//! ========================================================
//! |                  ****WARNING****                     |
//! | This file is auto-generated!  Do NOT edit this file. |
//! | Profile Version = ???                                |
//! | Build Date = ???                                     |
//! ========================================================
#![allow(missing_docs)]
#![allow(dead_code, unused)]
#![allow(
    clippy::unreadable_literal,
    clippy::enum_variant_names,
    clippy::upper_case_acronyms
)]
use crate::fit;
use std::fmt;

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum File {
    /// Read only, single file. Must be in root directory.
    Device,
    /// Read/write, single file. Directory=Settings
    Settings,
    /// Read/write, multiple files, file number = sport type. Directory=Sports
    Sport,
    /// Read/erase, multiple files. Directory=Activities
    Activity,
    /// Read/write/erase, multiple files. Directory=Workouts
    Workout,
    /// Read/write/erase, multiple files. Directory=Courses
    Course,
    /// Read/write, single file. Directory=Schedules
    Schedules,
    /// Read only, single file. Circular buffer. All message definitions at start of file. Directory=Weight
    Weight,
    /// Read only, single file. Directory=Totals
    Totals,
    /// Read/write, single file. Directory=Goals
    Goals,
    /// Read only. Directory=Blood Pressure
    BloodPressure,
    /// Read only. Directory=Monitoring. File number=sub type.
    MonitoringA,
    /// Read/erase, multiple files. Directory=Activities
    ActivitySummary,
    MonitoringDaily,
    /// Read only. Directory=Monitoring. File number=identifier
    MonitoringB,
    /// Read/write/erase. Multiple Files. Directory=Segments
    Segment,
    /// Read/write/erase. Single File. Directory=Segments
    SegmentList,
    /// Read/write/erase. Single File. Directory=Settings
    ExdConfiguration,
    /// 0xF7 - 0xFE reserved for manufacturer specific file types
    MfgRangeMin,
    /// 0xF7 - 0xFE reserved for manufacturer specific file types
    MfgRangeMax,
}
impl fmt::Display for File {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            File::Device => f.write_str("device"),
            File::Settings => f.write_str("settings"),
            File::Sport => f.write_str("sport"),
            File::Activity => f.write_str("activity"),
            File::Workout => f.write_str("workout"),
            File::Course => f.write_str("course"),
            File::Schedules => f.write_str("schedules"),
            File::Weight => f.write_str("weight"),
            File::Totals => f.write_str("totals"),
            File::Goals => f.write_str("goals"),
            File::BloodPressure => f.write_str("blood_pressure"),
            File::MonitoringA => f.write_str("monitoring_a"),
            File::ActivitySummary => f.write_str("activity_summary"),
            File::MonitoringDaily => f.write_str("monitoring_daily"),
            File::MonitoringB => f.write_str("monitoring_b"),
            File::Segment => f.write_str("segment"),
            File::SegmentList => f.write_str("segment_list"),
            File::ExdConfiguration => f.write_str("exd_configuration"),
            File::MfgRangeMin => f.write_str("mfg_range_min"),
            File::MfgRangeMax => f.write_str("mfg_range_max"),
        }
    }
}
impl File {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            File::Device => fit::Value::Enum(1),
            File::Settings => fit::Value::Enum(2),
            File::Sport => fit::Value::Enum(3),
            File::Activity => fit::Value::Enum(4),
            File::Workout => fit::Value::Enum(5),
            File::Course => fit::Value::Enum(6),
            File::Schedules => fit::Value::Enum(7),
            File::Weight => fit::Value::Enum(9),
            File::Totals => fit::Value::Enum(10),
            File::Goals => fit::Value::Enum(11),
            File::BloodPressure => fit::Value::Enum(14),
            File::MonitoringA => fit::Value::Enum(15),
            File::ActivitySummary => fit::Value::Enum(20),
            File::MonitoringDaily => fit::Value::Enum(28),
            File::MonitoringB => fit::Value::Enum(32),
            File::Segment => fit::Value::Enum(34),
            File::SegmentList => fit::Value::Enum(35),
            File::ExdConfiguration => fit::Value::Enum(40),
            File::MfgRangeMin => fit::Value::Enum(0xF7),
            File::MfgRangeMax => fit::Value::Enum(0xFE),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for File {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(1) => Ok(File::Device),
            fit::Value::Enum(2) => Ok(File::Settings),
            fit::Value::Enum(3) => Ok(File::Sport),
            fit::Value::Enum(4) => Ok(File::Activity),
            fit::Value::Enum(5) => Ok(File::Workout),
            fit::Value::Enum(6) => Ok(File::Course),
            fit::Value::Enum(7) => Ok(File::Schedules),
            fit::Value::Enum(9) => Ok(File::Weight),
            fit::Value::Enum(10) => Ok(File::Totals),
            fit::Value::Enum(11) => Ok(File::Goals),
            fit::Value::Enum(14) => Ok(File::BloodPressure),
            fit::Value::Enum(15) => Ok(File::MonitoringA),
            fit::Value::Enum(20) => Ok(File::ActivitySummary),
            fit::Value::Enum(28) => Ok(File::MonitoringDaily),
            fit::Value::Enum(32) => Ok(File::MonitoringB),
            fit::Value::Enum(34) => Ok(File::Segment),
            fit::Value::Enum(35) => Ok(File::SegmentList),
            fit::Value::Enum(40) => Ok(File::ExdConfiguration),
            fit::Value::Enum(0xF7) => Ok(File::MfgRangeMin),
            fit::Value::Enum(0xFE) => Ok(File::MfgRangeMax),
            _ => Err("No corresponding File exists"),
        }
    }
}
impl TryFrom<&str> for File {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "device" => Ok(File::Device),
            "settings" => Ok(File::Settings),
            "sport" => Ok(File::Sport),
            "activity" => Ok(File::Activity),
            "workout" => Ok(File::Workout),
            "course" => Ok(File::Course),
            "schedules" => Ok(File::Schedules),
            "weight" => Ok(File::Weight),
            "totals" => Ok(File::Totals),
            "goals" => Ok(File::Goals),
            "blood_pressure" => Ok(File::BloodPressure),
            "monitoring_a" => Ok(File::MonitoringA),
            "activity_summary" => Ok(File::ActivitySummary),
            "monitoring_daily" => Ok(File::MonitoringDaily),
            "monitoring_b" => Ok(File::MonitoringB),
            "segment" => Ok(File::Segment),
            "segment_list" => Ok(File::SegmentList),
            "exd_configuration" => Ok(File::ExdConfiguration),
            "mfg_range_min" => Ok(File::MfgRangeMin),
            "mfg_range_max" => Ok(File::MfgRangeMax),
            _ => Err("No corresponding File exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum MesgNum {
    FileId,
    Capabilities,
    DeviceSettings,
    UserProfile,
    HrmProfile,
    SdmProfile,
    BikeProfile,
    ZonesTarget,
    HrZone,
    PowerZone,
    MetZone,
    Sport,
    Goal,
    Session,
    Lap,
    Record,
    Event,
    DeviceInfo,
    Workout,
    WorkoutStep,
    Schedule,
    WeightScale,
    Course,
    CoursePoint,
    Totals,
    Activity,
    Software,
    FileCapabilities,
    MesgCapabilities,
    FieldCapabilities,
    FileCreator,
    BloodPressure,
    SpeedZone,
    Monitoring,
    TrainingFile,
    Hrv,
    AntRx,
    AntTx,
    AntChannelId,
    Length,
    MonitoringInfo,
    Pad,
    SlaveDevice,
    Connectivity,
    WeatherConditions,
    WeatherAlert,
    CadenceZone,
    Hr,
    SegmentLap,
    MemoGlob,
    SegmentId,
    SegmentLeaderboardEntry,
    SegmentPoint,
    SegmentFile,
    WorkoutSession,
    WatchfaceSettings,
    GpsMetadata,
    CameraEvent,
    TimestampCorrelation,
    GyroscopeData,
    AccelerometerData,
    ThreeDSensorCalibration,
    VideoFrame,
    ObdiiData,
    NmeaSentence,
    AviationAttitude,
    Video,
    VideoTitle,
    VideoDescription,
    VideoClip,
    OhrSettings,
    ExdScreenConfiguration,
    ExdDataFieldConfiguration,
    ExdDataConceptConfiguration,
    FieldDescription,
    DeveloperDataId,
    MagnetometerData,
    BarometerData,
    OneDSensorCalibration,
    MonitoringHrData,
    TimeInZone,
    Set,
    StressLevel,
    MaxMetData,
    DiveSettings,
    DiveGas,
    DiveAlarm,
    ExerciseTitle,
    DiveSummary,
    Spo2Data,
    SleepLevel,
    Jump,
    BeatIntervals,
    RespirationRate,
    Split,
    ClimbPro,
    TankUpdate,
    TankSummary,
    SleepAssessment,
    HrvStatusSummary,
    HrvValue,
    DeviceAuxBatteryInfo,
    DiveApneaAlarm,
    /// 0xFF00 - 0xFFFE reserved for manufacturer specific messages
    MfgRangeMin,
    /// 0xFF00 - 0xFFFE reserved for manufacturer specific messages
    MfgRangeMax,
}
impl fmt::Display for MesgNum {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            MesgNum::FileId => f.write_str("file_id"),
            MesgNum::Capabilities => f.write_str("capabilities"),
            MesgNum::DeviceSettings => f.write_str("device_settings"),
            MesgNum::UserProfile => f.write_str("user_profile"),
            MesgNum::HrmProfile => f.write_str("hrm_profile"),
            MesgNum::SdmProfile => f.write_str("sdm_profile"),
            MesgNum::BikeProfile => f.write_str("bike_profile"),
            MesgNum::ZonesTarget => f.write_str("zones_target"),
            MesgNum::HrZone => f.write_str("hr_zone"),
            MesgNum::PowerZone => f.write_str("power_zone"),
            MesgNum::MetZone => f.write_str("met_zone"),
            MesgNum::Sport => f.write_str("sport"),
            MesgNum::Goal => f.write_str("goal"),
            MesgNum::Session => f.write_str("session"),
            MesgNum::Lap => f.write_str("lap"),
            MesgNum::Record => f.write_str("record"),
            MesgNum::Event => f.write_str("event"),
            MesgNum::DeviceInfo => f.write_str("device_info"),
            MesgNum::Workout => f.write_str("workout"),
            MesgNum::WorkoutStep => f.write_str("workout_step"),
            MesgNum::Schedule => f.write_str("schedule"),
            MesgNum::WeightScale => f.write_str("weight_scale"),
            MesgNum::Course => f.write_str("course"),
            MesgNum::CoursePoint => f.write_str("course_point"),
            MesgNum::Totals => f.write_str("totals"),
            MesgNum::Activity => f.write_str("activity"),
            MesgNum::Software => f.write_str("software"),
            MesgNum::FileCapabilities => f.write_str("file_capabilities"),
            MesgNum::MesgCapabilities => f.write_str("mesg_capabilities"),
            MesgNum::FieldCapabilities => f.write_str("field_capabilities"),
            MesgNum::FileCreator => f.write_str("file_creator"),
            MesgNum::BloodPressure => f.write_str("blood_pressure"),
            MesgNum::SpeedZone => f.write_str("speed_zone"),
            MesgNum::Monitoring => f.write_str("monitoring"),
            MesgNum::TrainingFile => f.write_str("training_file"),
            MesgNum::Hrv => f.write_str("hrv"),
            MesgNum::AntRx => f.write_str("ant_rx"),
            MesgNum::AntTx => f.write_str("ant_tx"),
            MesgNum::AntChannelId => f.write_str("ant_channel_id"),
            MesgNum::Length => f.write_str("length"),
            MesgNum::MonitoringInfo => f.write_str("monitoring_info"),
            MesgNum::Pad => f.write_str("pad"),
            MesgNum::SlaveDevice => f.write_str("slave_device"),
            MesgNum::Connectivity => f.write_str("connectivity"),
            MesgNum::WeatherConditions => f.write_str("weather_conditions"),
            MesgNum::WeatherAlert => f.write_str("weather_alert"),
            MesgNum::CadenceZone => f.write_str("cadence_zone"),
            MesgNum::Hr => f.write_str("hr"),
            MesgNum::SegmentLap => f.write_str("segment_lap"),
            MesgNum::MemoGlob => f.write_str("memo_glob"),
            MesgNum::SegmentId => f.write_str("segment_id"),
            MesgNum::SegmentLeaderboardEntry => f.write_str("segment_leaderboard_entry"),
            MesgNum::SegmentPoint => f.write_str("segment_point"),
            MesgNum::SegmentFile => f.write_str("segment_file"),
            MesgNum::WorkoutSession => f.write_str("workout_session"),
            MesgNum::WatchfaceSettings => f.write_str("watchface_settings"),
            MesgNum::GpsMetadata => f.write_str("gps_metadata"),
            MesgNum::CameraEvent => f.write_str("camera_event"),
            MesgNum::TimestampCorrelation => f.write_str("timestamp_correlation"),
            MesgNum::GyroscopeData => f.write_str("gyroscope_data"),
            MesgNum::AccelerometerData => f.write_str("accelerometer_data"),
            MesgNum::ThreeDSensorCalibration => f.write_str("three_d_sensor_calibration"),
            MesgNum::VideoFrame => f.write_str("video_frame"),
            MesgNum::ObdiiData => f.write_str("obdii_data"),
            MesgNum::NmeaSentence => f.write_str("nmea_sentence"),
            MesgNum::AviationAttitude => f.write_str("aviation_attitude"),
            MesgNum::Video => f.write_str("video"),
            MesgNum::VideoTitle => f.write_str("video_title"),
            MesgNum::VideoDescription => f.write_str("video_description"),
            MesgNum::VideoClip => f.write_str("video_clip"),
            MesgNum::OhrSettings => f.write_str("ohr_settings"),
            MesgNum::ExdScreenConfiguration => f.write_str("exd_screen_configuration"),
            MesgNum::ExdDataFieldConfiguration => f.write_str("exd_data_field_configuration"),
            MesgNum::ExdDataConceptConfiguration => f.write_str("exd_data_concept_configuration"),
            MesgNum::FieldDescription => f.write_str("field_description"),
            MesgNum::DeveloperDataId => f.write_str("developer_data_id"),
            MesgNum::MagnetometerData => f.write_str("magnetometer_data"),
            MesgNum::BarometerData => f.write_str("barometer_data"),
            MesgNum::OneDSensorCalibration => f.write_str("one_d_sensor_calibration"),
            MesgNum::MonitoringHrData => f.write_str("monitoring_hr_data"),
            MesgNum::TimeInZone => f.write_str("time_in_zone"),
            MesgNum::Set => f.write_str("set"),
            MesgNum::StressLevel => f.write_str("stress_level"),
            MesgNum::MaxMetData => f.write_str("max_met_data"),
            MesgNum::DiveSettings => f.write_str("dive_settings"),
            MesgNum::DiveGas => f.write_str("dive_gas"),
            MesgNum::DiveAlarm => f.write_str("dive_alarm"),
            MesgNum::ExerciseTitle => f.write_str("exercise_title"),
            MesgNum::DiveSummary => f.write_str("dive_summary"),
            MesgNum::Spo2Data => f.write_str("spo2_data"),
            MesgNum::SleepLevel => f.write_str("sleep_level"),
            MesgNum::Jump => f.write_str("jump"),
            MesgNum::BeatIntervals => f.write_str("beat_intervals"),
            MesgNum::RespirationRate => f.write_str("respiration_rate"),
            MesgNum::Split => f.write_str("split"),
            MesgNum::ClimbPro => f.write_str("climb_pro"),
            MesgNum::TankUpdate => f.write_str("tank_update"),
            MesgNum::TankSummary => f.write_str("tank_summary"),
            MesgNum::SleepAssessment => f.write_str("sleep_assessment"),
            MesgNum::HrvStatusSummary => f.write_str("hrv_status_summary"),
            MesgNum::HrvValue => f.write_str("hrv_value"),
            MesgNum::DeviceAuxBatteryInfo => f.write_str("device_aux_battery_info"),
            MesgNum::DiveApneaAlarm => f.write_str("dive_apnea_alarm"),
            MesgNum::MfgRangeMin => f.write_str("mfg_range_min"),
            MesgNum::MfgRangeMax => f.write_str("mfg_range_max"),
        }
    }
}
impl MesgNum {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            MesgNum::FileId => fit::Value::UInt16(0),
            MesgNum::Capabilities => fit::Value::UInt16(1),
            MesgNum::DeviceSettings => fit::Value::UInt16(2),
            MesgNum::UserProfile => fit::Value::UInt16(3),
            MesgNum::HrmProfile => fit::Value::UInt16(4),
            MesgNum::SdmProfile => fit::Value::UInt16(5),
            MesgNum::BikeProfile => fit::Value::UInt16(6),
            MesgNum::ZonesTarget => fit::Value::UInt16(7),
            MesgNum::HrZone => fit::Value::UInt16(8),
            MesgNum::PowerZone => fit::Value::UInt16(9),
            MesgNum::MetZone => fit::Value::UInt16(10),
            MesgNum::Sport => fit::Value::UInt16(12),
            MesgNum::Goal => fit::Value::UInt16(15),
            MesgNum::Session => fit::Value::UInt16(18),
            MesgNum::Lap => fit::Value::UInt16(19),
            MesgNum::Record => fit::Value::UInt16(20),
            MesgNum::Event => fit::Value::UInt16(21),
            MesgNum::DeviceInfo => fit::Value::UInt16(23),
            MesgNum::Workout => fit::Value::UInt16(26),
            MesgNum::WorkoutStep => fit::Value::UInt16(27),
            MesgNum::Schedule => fit::Value::UInt16(28),
            MesgNum::WeightScale => fit::Value::UInt16(30),
            MesgNum::Course => fit::Value::UInt16(31),
            MesgNum::CoursePoint => fit::Value::UInt16(32),
            MesgNum::Totals => fit::Value::UInt16(33),
            MesgNum::Activity => fit::Value::UInt16(34),
            MesgNum::Software => fit::Value::UInt16(35),
            MesgNum::FileCapabilities => fit::Value::UInt16(37),
            MesgNum::MesgCapabilities => fit::Value::UInt16(38),
            MesgNum::FieldCapabilities => fit::Value::UInt16(39),
            MesgNum::FileCreator => fit::Value::UInt16(49),
            MesgNum::BloodPressure => fit::Value::UInt16(51),
            MesgNum::SpeedZone => fit::Value::UInt16(53),
            MesgNum::Monitoring => fit::Value::UInt16(55),
            MesgNum::TrainingFile => fit::Value::UInt16(72),
            MesgNum::Hrv => fit::Value::UInt16(78),
            MesgNum::AntRx => fit::Value::UInt16(80),
            MesgNum::AntTx => fit::Value::UInt16(81),
            MesgNum::AntChannelId => fit::Value::UInt16(82),
            MesgNum::Length => fit::Value::UInt16(101),
            MesgNum::MonitoringInfo => fit::Value::UInt16(103),
            MesgNum::Pad => fit::Value::UInt16(105),
            MesgNum::SlaveDevice => fit::Value::UInt16(106),
            MesgNum::Connectivity => fit::Value::UInt16(127),
            MesgNum::WeatherConditions => fit::Value::UInt16(128),
            MesgNum::WeatherAlert => fit::Value::UInt16(129),
            MesgNum::CadenceZone => fit::Value::UInt16(131),
            MesgNum::Hr => fit::Value::UInt16(132),
            MesgNum::SegmentLap => fit::Value::UInt16(142),
            MesgNum::MemoGlob => fit::Value::UInt16(145),
            MesgNum::SegmentId => fit::Value::UInt16(148),
            MesgNum::SegmentLeaderboardEntry => fit::Value::UInt16(149),
            MesgNum::SegmentPoint => fit::Value::UInt16(150),
            MesgNum::SegmentFile => fit::Value::UInt16(151),
            MesgNum::WorkoutSession => fit::Value::UInt16(158),
            MesgNum::WatchfaceSettings => fit::Value::UInt16(159),
            MesgNum::GpsMetadata => fit::Value::UInt16(160),
            MesgNum::CameraEvent => fit::Value::UInt16(161),
            MesgNum::TimestampCorrelation => fit::Value::UInt16(162),
            MesgNum::GyroscopeData => fit::Value::UInt16(164),
            MesgNum::AccelerometerData => fit::Value::UInt16(165),
            MesgNum::ThreeDSensorCalibration => fit::Value::UInt16(167),
            MesgNum::VideoFrame => fit::Value::UInt16(169),
            MesgNum::ObdiiData => fit::Value::UInt16(174),
            MesgNum::NmeaSentence => fit::Value::UInt16(177),
            MesgNum::AviationAttitude => fit::Value::UInt16(178),
            MesgNum::Video => fit::Value::UInt16(184),
            MesgNum::VideoTitle => fit::Value::UInt16(185),
            MesgNum::VideoDescription => fit::Value::UInt16(186),
            MesgNum::VideoClip => fit::Value::UInt16(187),
            MesgNum::OhrSettings => fit::Value::UInt16(188),
            MesgNum::ExdScreenConfiguration => fit::Value::UInt16(200),
            MesgNum::ExdDataFieldConfiguration => fit::Value::UInt16(201),
            MesgNum::ExdDataConceptConfiguration => fit::Value::UInt16(202),
            MesgNum::FieldDescription => fit::Value::UInt16(206),
            MesgNum::DeveloperDataId => fit::Value::UInt16(207),
            MesgNum::MagnetometerData => fit::Value::UInt16(208),
            MesgNum::BarometerData => fit::Value::UInt16(209),
            MesgNum::OneDSensorCalibration => fit::Value::UInt16(210),
            MesgNum::MonitoringHrData => fit::Value::UInt16(211),
            MesgNum::TimeInZone => fit::Value::UInt16(216),
            MesgNum::Set => fit::Value::UInt16(225),
            MesgNum::StressLevel => fit::Value::UInt16(227),
            MesgNum::MaxMetData => fit::Value::UInt16(229),
            MesgNum::DiveSettings => fit::Value::UInt16(258),
            MesgNum::DiveGas => fit::Value::UInt16(259),
            MesgNum::DiveAlarm => fit::Value::UInt16(262),
            MesgNum::ExerciseTitle => fit::Value::UInt16(264),
            MesgNum::DiveSummary => fit::Value::UInt16(268),
            MesgNum::Spo2Data => fit::Value::UInt16(269),
            MesgNum::SleepLevel => fit::Value::UInt16(275),
            MesgNum::Jump => fit::Value::UInt16(285),
            MesgNum::BeatIntervals => fit::Value::UInt16(290),
            MesgNum::RespirationRate => fit::Value::UInt16(297),
            MesgNum::Split => fit::Value::UInt16(312),
            MesgNum::ClimbPro => fit::Value::UInt16(317),
            MesgNum::TankUpdate => fit::Value::UInt16(319),
            MesgNum::TankSummary => fit::Value::UInt16(323),
            MesgNum::SleepAssessment => fit::Value::UInt16(346),
            MesgNum::HrvStatusSummary => fit::Value::UInt16(370),
            MesgNum::HrvValue => fit::Value::UInt16(371),
            MesgNum::DeviceAuxBatteryInfo => fit::Value::UInt16(375),
            MesgNum::DiveApneaAlarm => fit::Value::UInt16(393),
            MesgNum::MfgRangeMin => fit::Value::UInt16(0xFF00),
            MesgNum::MfgRangeMax => fit::Value::UInt16(0xFFFE),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for MesgNum {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(MesgNum::FileId),
            fit::Value::UInt16(1) => Ok(MesgNum::Capabilities),
            fit::Value::UInt16(2) => Ok(MesgNum::DeviceSettings),
            fit::Value::UInt16(3) => Ok(MesgNum::UserProfile),
            fit::Value::UInt16(4) => Ok(MesgNum::HrmProfile),
            fit::Value::UInt16(5) => Ok(MesgNum::SdmProfile),
            fit::Value::UInt16(6) => Ok(MesgNum::BikeProfile),
            fit::Value::UInt16(7) => Ok(MesgNum::ZonesTarget),
            fit::Value::UInt16(8) => Ok(MesgNum::HrZone),
            fit::Value::UInt16(9) => Ok(MesgNum::PowerZone),
            fit::Value::UInt16(10) => Ok(MesgNum::MetZone),
            fit::Value::UInt16(12) => Ok(MesgNum::Sport),
            fit::Value::UInt16(15) => Ok(MesgNum::Goal),
            fit::Value::UInt16(18) => Ok(MesgNum::Session),
            fit::Value::UInt16(19) => Ok(MesgNum::Lap),
            fit::Value::UInt16(20) => Ok(MesgNum::Record),
            fit::Value::UInt16(21) => Ok(MesgNum::Event),
            fit::Value::UInt16(23) => Ok(MesgNum::DeviceInfo),
            fit::Value::UInt16(26) => Ok(MesgNum::Workout),
            fit::Value::UInt16(27) => Ok(MesgNum::WorkoutStep),
            fit::Value::UInt16(28) => Ok(MesgNum::Schedule),
            fit::Value::UInt16(30) => Ok(MesgNum::WeightScale),
            fit::Value::UInt16(31) => Ok(MesgNum::Course),
            fit::Value::UInt16(32) => Ok(MesgNum::CoursePoint),
            fit::Value::UInt16(33) => Ok(MesgNum::Totals),
            fit::Value::UInt16(34) => Ok(MesgNum::Activity),
            fit::Value::UInt16(35) => Ok(MesgNum::Software),
            fit::Value::UInt16(37) => Ok(MesgNum::FileCapabilities),
            fit::Value::UInt16(38) => Ok(MesgNum::MesgCapabilities),
            fit::Value::UInt16(39) => Ok(MesgNum::FieldCapabilities),
            fit::Value::UInt16(49) => Ok(MesgNum::FileCreator),
            fit::Value::UInt16(51) => Ok(MesgNum::BloodPressure),
            fit::Value::UInt16(53) => Ok(MesgNum::SpeedZone),
            fit::Value::UInt16(55) => Ok(MesgNum::Monitoring),
            fit::Value::UInt16(72) => Ok(MesgNum::TrainingFile),
            fit::Value::UInt16(78) => Ok(MesgNum::Hrv),
            fit::Value::UInt16(80) => Ok(MesgNum::AntRx),
            fit::Value::UInt16(81) => Ok(MesgNum::AntTx),
            fit::Value::UInt16(82) => Ok(MesgNum::AntChannelId),
            fit::Value::UInt16(101) => Ok(MesgNum::Length),
            fit::Value::UInt16(103) => Ok(MesgNum::MonitoringInfo),
            fit::Value::UInt16(105) => Ok(MesgNum::Pad),
            fit::Value::UInt16(106) => Ok(MesgNum::SlaveDevice),
            fit::Value::UInt16(127) => Ok(MesgNum::Connectivity),
            fit::Value::UInt16(128) => Ok(MesgNum::WeatherConditions),
            fit::Value::UInt16(129) => Ok(MesgNum::WeatherAlert),
            fit::Value::UInt16(131) => Ok(MesgNum::CadenceZone),
            fit::Value::UInt16(132) => Ok(MesgNum::Hr),
            fit::Value::UInt16(142) => Ok(MesgNum::SegmentLap),
            fit::Value::UInt16(145) => Ok(MesgNum::MemoGlob),
            fit::Value::UInt16(148) => Ok(MesgNum::SegmentId),
            fit::Value::UInt16(149) => Ok(MesgNum::SegmentLeaderboardEntry),
            fit::Value::UInt16(150) => Ok(MesgNum::SegmentPoint),
            fit::Value::UInt16(151) => Ok(MesgNum::SegmentFile),
            fit::Value::UInt16(158) => Ok(MesgNum::WorkoutSession),
            fit::Value::UInt16(159) => Ok(MesgNum::WatchfaceSettings),
            fit::Value::UInt16(160) => Ok(MesgNum::GpsMetadata),
            fit::Value::UInt16(161) => Ok(MesgNum::CameraEvent),
            fit::Value::UInt16(162) => Ok(MesgNum::TimestampCorrelation),
            fit::Value::UInt16(164) => Ok(MesgNum::GyroscopeData),
            fit::Value::UInt16(165) => Ok(MesgNum::AccelerometerData),
            fit::Value::UInt16(167) => Ok(MesgNum::ThreeDSensorCalibration),
            fit::Value::UInt16(169) => Ok(MesgNum::VideoFrame),
            fit::Value::UInt16(174) => Ok(MesgNum::ObdiiData),
            fit::Value::UInt16(177) => Ok(MesgNum::NmeaSentence),
            fit::Value::UInt16(178) => Ok(MesgNum::AviationAttitude),
            fit::Value::UInt16(184) => Ok(MesgNum::Video),
            fit::Value::UInt16(185) => Ok(MesgNum::VideoTitle),
            fit::Value::UInt16(186) => Ok(MesgNum::VideoDescription),
            fit::Value::UInt16(187) => Ok(MesgNum::VideoClip),
            fit::Value::UInt16(188) => Ok(MesgNum::OhrSettings),
            fit::Value::UInt16(200) => Ok(MesgNum::ExdScreenConfiguration),
            fit::Value::UInt16(201) => Ok(MesgNum::ExdDataFieldConfiguration),
            fit::Value::UInt16(202) => Ok(MesgNum::ExdDataConceptConfiguration),
            fit::Value::UInt16(206) => Ok(MesgNum::FieldDescription),
            fit::Value::UInt16(207) => Ok(MesgNum::DeveloperDataId),
            fit::Value::UInt16(208) => Ok(MesgNum::MagnetometerData),
            fit::Value::UInt16(209) => Ok(MesgNum::BarometerData),
            fit::Value::UInt16(210) => Ok(MesgNum::OneDSensorCalibration),
            fit::Value::UInt16(211) => Ok(MesgNum::MonitoringHrData),
            fit::Value::UInt16(216) => Ok(MesgNum::TimeInZone),
            fit::Value::UInt16(225) => Ok(MesgNum::Set),
            fit::Value::UInt16(227) => Ok(MesgNum::StressLevel),
            fit::Value::UInt16(229) => Ok(MesgNum::MaxMetData),
            fit::Value::UInt16(258) => Ok(MesgNum::DiveSettings),
            fit::Value::UInt16(259) => Ok(MesgNum::DiveGas),
            fit::Value::UInt16(262) => Ok(MesgNum::DiveAlarm),
            fit::Value::UInt16(264) => Ok(MesgNum::ExerciseTitle),
            fit::Value::UInt16(268) => Ok(MesgNum::DiveSummary),
            fit::Value::UInt16(269) => Ok(MesgNum::Spo2Data),
            fit::Value::UInt16(275) => Ok(MesgNum::SleepLevel),
            fit::Value::UInt16(285) => Ok(MesgNum::Jump),
            fit::Value::UInt16(290) => Ok(MesgNum::BeatIntervals),
            fit::Value::UInt16(297) => Ok(MesgNum::RespirationRate),
            fit::Value::UInt16(312) => Ok(MesgNum::Split),
            fit::Value::UInt16(317) => Ok(MesgNum::ClimbPro),
            fit::Value::UInt16(319) => Ok(MesgNum::TankUpdate),
            fit::Value::UInt16(323) => Ok(MesgNum::TankSummary),
            fit::Value::UInt16(346) => Ok(MesgNum::SleepAssessment),
            fit::Value::UInt16(370) => Ok(MesgNum::HrvStatusSummary),
            fit::Value::UInt16(371) => Ok(MesgNum::HrvValue),
            fit::Value::UInt16(375) => Ok(MesgNum::DeviceAuxBatteryInfo),
            fit::Value::UInt16(393) => Ok(MesgNum::DiveApneaAlarm),
            fit::Value::UInt16(0xFF00) => Ok(MesgNum::MfgRangeMin),
            fit::Value::UInt16(0xFFFE) => Ok(MesgNum::MfgRangeMax),
            _ => Err("No corresponding MesgNum exists"),
        }
    }
}
impl TryFrom<&str> for MesgNum {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "file_id" => Ok(MesgNum::FileId),
            "capabilities" => Ok(MesgNum::Capabilities),
            "device_settings" => Ok(MesgNum::DeviceSettings),
            "user_profile" => Ok(MesgNum::UserProfile),
            "hrm_profile" => Ok(MesgNum::HrmProfile),
            "sdm_profile" => Ok(MesgNum::SdmProfile),
            "bike_profile" => Ok(MesgNum::BikeProfile),
            "zones_target" => Ok(MesgNum::ZonesTarget),
            "hr_zone" => Ok(MesgNum::HrZone),
            "power_zone" => Ok(MesgNum::PowerZone),
            "met_zone" => Ok(MesgNum::MetZone),
            "sport" => Ok(MesgNum::Sport),
            "goal" => Ok(MesgNum::Goal),
            "session" => Ok(MesgNum::Session),
            "lap" => Ok(MesgNum::Lap),
            "record" => Ok(MesgNum::Record),
            "event" => Ok(MesgNum::Event),
            "device_info" => Ok(MesgNum::DeviceInfo),
            "workout" => Ok(MesgNum::Workout),
            "workout_step" => Ok(MesgNum::WorkoutStep),
            "schedule" => Ok(MesgNum::Schedule),
            "weight_scale" => Ok(MesgNum::WeightScale),
            "course" => Ok(MesgNum::Course),
            "course_point" => Ok(MesgNum::CoursePoint),
            "totals" => Ok(MesgNum::Totals),
            "activity" => Ok(MesgNum::Activity),
            "software" => Ok(MesgNum::Software),
            "file_capabilities" => Ok(MesgNum::FileCapabilities),
            "mesg_capabilities" => Ok(MesgNum::MesgCapabilities),
            "field_capabilities" => Ok(MesgNum::FieldCapabilities),
            "file_creator" => Ok(MesgNum::FileCreator),
            "blood_pressure" => Ok(MesgNum::BloodPressure),
            "speed_zone" => Ok(MesgNum::SpeedZone),
            "monitoring" => Ok(MesgNum::Monitoring),
            "training_file" => Ok(MesgNum::TrainingFile),
            "hrv" => Ok(MesgNum::Hrv),
            "ant_rx" => Ok(MesgNum::AntRx),
            "ant_tx" => Ok(MesgNum::AntTx),
            "ant_channel_id" => Ok(MesgNum::AntChannelId),
            "length" => Ok(MesgNum::Length),
            "monitoring_info" => Ok(MesgNum::MonitoringInfo),
            "pad" => Ok(MesgNum::Pad),
            "slave_device" => Ok(MesgNum::SlaveDevice),
            "connectivity" => Ok(MesgNum::Connectivity),
            "weather_conditions" => Ok(MesgNum::WeatherConditions),
            "weather_alert" => Ok(MesgNum::WeatherAlert),
            "cadence_zone" => Ok(MesgNum::CadenceZone),
            "hr" => Ok(MesgNum::Hr),
            "segment_lap" => Ok(MesgNum::SegmentLap),
            "memo_glob" => Ok(MesgNum::MemoGlob),
            "segment_id" => Ok(MesgNum::SegmentId),
            "segment_leaderboard_entry" => Ok(MesgNum::SegmentLeaderboardEntry),
            "segment_point" => Ok(MesgNum::SegmentPoint),
            "segment_file" => Ok(MesgNum::SegmentFile),
            "workout_session" => Ok(MesgNum::WorkoutSession),
            "watchface_settings" => Ok(MesgNum::WatchfaceSettings),
            "gps_metadata" => Ok(MesgNum::GpsMetadata),
            "camera_event" => Ok(MesgNum::CameraEvent),
            "timestamp_correlation" => Ok(MesgNum::TimestampCorrelation),
            "gyroscope_data" => Ok(MesgNum::GyroscopeData),
            "accelerometer_data" => Ok(MesgNum::AccelerometerData),
            "three_d_sensor_calibration" => Ok(MesgNum::ThreeDSensorCalibration),
            "video_frame" => Ok(MesgNum::VideoFrame),
            "obdii_data" => Ok(MesgNum::ObdiiData),
            "nmea_sentence" => Ok(MesgNum::NmeaSentence),
            "aviation_attitude" => Ok(MesgNum::AviationAttitude),
            "video" => Ok(MesgNum::Video),
            "video_title" => Ok(MesgNum::VideoTitle),
            "video_description" => Ok(MesgNum::VideoDescription),
            "video_clip" => Ok(MesgNum::VideoClip),
            "ohr_settings" => Ok(MesgNum::OhrSettings),
            "exd_screen_configuration" => Ok(MesgNum::ExdScreenConfiguration),
            "exd_data_field_configuration" => Ok(MesgNum::ExdDataFieldConfiguration),
            "exd_data_concept_configuration" => Ok(MesgNum::ExdDataConceptConfiguration),
            "field_description" => Ok(MesgNum::FieldDescription),
            "developer_data_id" => Ok(MesgNum::DeveloperDataId),
            "magnetometer_data" => Ok(MesgNum::MagnetometerData),
            "barometer_data" => Ok(MesgNum::BarometerData),
            "one_d_sensor_calibration" => Ok(MesgNum::OneDSensorCalibration),
            "monitoring_hr_data" => Ok(MesgNum::MonitoringHrData),
            "time_in_zone" => Ok(MesgNum::TimeInZone),
            "set" => Ok(MesgNum::Set),
            "stress_level" => Ok(MesgNum::StressLevel),
            "max_met_data" => Ok(MesgNum::MaxMetData),
            "dive_settings" => Ok(MesgNum::DiveSettings),
            "dive_gas" => Ok(MesgNum::DiveGas),
            "dive_alarm" => Ok(MesgNum::DiveAlarm),
            "exercise_title" => Ok(MesgNum::ExerciseTitle),
            "dive_summary" => Ok(MesgNum::DiveSummary),
            "spo2_data" => Ok(MesgNum::Spo2Data),
            "sleep_level" => Ok(MesgNum::SleepLevel),
            "jump" => Ok(MesgNum::Jump),
            "beat_intervals" => Ok(MesgNum::BeatIntervals),
            "respiration_rate" => Ok(MesgNum::RespirationRate),
            "split" => Ok(MesgNum::Split),
            "climb_pro" => Ok(MesgNum::ClimbPro),
            "tank_update" => Ok(MesgNum::TankUpdate),
            "tank_summary" => Ok(MesgNum::TankSummary),
            "sleep_assessment" => Ok(MesgNum::SleepAssessment),
            "hrv_status_summary" => Ok(MesgNum::HrvStatusSummary),
            "hrv_value" => Ok(MesgNum::HrvValue),
            "device_aux_battery_info" => Ok(MesgNum::DeviceAuxBatteryInfo),
            "dive_apnea_alarm" => Ok(MesgNum::DiveApneaAlarm),
            "mfg_range_min" => Ok(MesgNum::MfgRangeMin),
            "mfg_range_max" => Ok(MesgNum::MfgRangeMax),
            _ => Err("No corresponding MesgNum exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Checksum {
    /// Allows clear of checksum for flash memory where can only write 1 to 0 without erasing sector.
    Clear,
    /// Set to mark checksum as valid if computes to invalid values 0 or 0xFF. Checksum can also be set to ok to save encoding computation time.
    Ok,
}
impl fmt::Display for Checksum {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Checksum::Clear => f.write_str("clear"),
            Checksum::Ok => f.write_str("ok"),
        }
    }
}
impl Checksum {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Checksum::Clear => fit::Value::UInt8(0),
            Checksum::Ok => fit::Value::UInt8(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for Checksum {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(0) => Ok(Checksum::Clear),
            fit::Value::UInt8(1) => Ok(Checksum::Ok),
            _ => Err("No corresponding Checksum exists"),
        }
    }
}
impl TryFrom<&str> for Checksum {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "clear" => Ok(Checksum::Clear),
            "ok" => Ok(Checksum::Ok),
            _ => Err("No corresponding Checksum exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum FileFlags {
    Read,
    Write,
    Erase,
}
impl fmt::Display for FileFlags {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FileFlags::Read => f.write_str("read"),
            FileFlags::Write => f.write_str("write"),
            FileFlags::Erase => f.write_str("erase"),
        }
    }
}
impl FileFlags {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            FileFlags::Read => fit::Value::UInt8z(0x02),
            FileFlags::Write => fit::Value::UInt8z(0x04),
            FileFlags::Erase => fit::Value::UInt8z(0x08),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for FileFlags {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x02) => Ok(FileFlags::Read),
            fit::Value::UInt8z(0x04) => Ok(FileFlags::Write),
            fit::Value::UInt8z(0x08) => Ok(FileFlags::Erase),
            _ => Err("No corresponding FileFlags exists"),
        }
    }
}
impl TryFrom<&str> for FileFlags {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "read" => Ok(FileFlags::Read),
            "write" => Ok(FileFlags::Write),
            "erase" => Ok(FileFlags::Erase),
            _ => Err("No corresponding FileFlags exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum MesgCount {
    NumPerFile,
    MaxPerFile,
    MaxPerFileType,
}
impl fmt::Display for MesgCount {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            MesgCount::NumPerFile => f.write_str("num_per_file"),
            MesgCount::MaxPerFile => f.write_str("max_per_file"),
            MesgCount::MaxPerFileType => f.write_str("max_per_file_type"),
        }
    }
}
impl MesgCount {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            MesgCount::NumPerFile => fit::Value::Enum(0),
            MesgCount::MaxPerFile => fit::Value::Enum(1),
            MesgCount::MaxPerFileType => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for MesgCount {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(MesgCount::NumPerFile),
            fit::Value::Enum(1) => Ok(MesgCount::MaxPerFile),
            fit::Value::Enum(2) => Ok(MesgCount::MaxPerFileType),
            _ => Err("No corresponding MesgCount exists"),
        }
    }
}
impl TryFrom<&str> for MesgCount {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "num_per_file" => Ok(MesgCount::NumPerFile),
            "max_per_file" => Ok(MesgCount::MaxPerFile),
            "max_per_file_type" => Ok(MesgCount::MaxPerFileType),
            _ => Err("No corresponding MesgCount exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DateTime {
    /// if date_time is < 0x10000000 then it is system time (seconds from device power on)
    Min,
}
impl fmt::Display for DateTime {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DateTime::Min => f.write_str("min"),
        }
    }
}
impl DateTime {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DateTime::Min => fit::Value::UInt32(0x10000000),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32"
    }
}
impl TryFrom<&fit::Value> for DateTime {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32(0x10000000) => Ok(DateTime::Min),
            _ => Err("No corresponding DateTime exists"),
        }
    }
}
impl TryFrom<&str> for DateTime {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "min" => Ok(DateTime::Min),
            _ => Err("No corresponding DateTime exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LocalDateTime {
    /// if date_time is < 0x10000000 then it is system time (seconds from device power on)
    Min,
}
impl fmt::Display for LocalDateTime {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LocalDateTime::Min => f.write_str("min"),
        }
    }
}
impl LocalDateTime {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LocalDateTime::Min => fit::Value::UInt32(0x10000000),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32"
    }
}
impl TryFrom<&fit::Value> for LocalDateTime {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32(0x10000000) => Ok(LocalDateTime::Min),
            _ => Err("No corresponding LocalDateTime exists"),
        }
    }
}
impl TryFrom<&str> for LocalDateTime {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "min" => Ok(LocalDateTime::Min),
            _ => Err("No corresponding LocalDateTime exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum MessageIndex {
    /// message is selected if set
    Selected,
    /// reserved (default 0)
    Reserved,
    /// index
    Mask,
}
impl fmt::Display for MessageIndex {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            MessageIndex::Selected => f.write_str("selected"),
            MessageIndex::Reserved => f.write_str("reserved"),
            MessageIndex::Mask => f.write_str("mask"),
        }
    }
}
impl MessageIndex {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            MessageIndex::Selected => fit::Value::UInt16(0x8000),
            MessageIndex::Reserved => fit::Value::UInt16(0x7000),
            MessageIndex::Mask => fit::Value::UInt16(0x0FFF),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for MessageIndex {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0x8000) => Ok(MessageIndex::Selected),
            fit::Value::UInt16(0x7000) => Ok(MessageIndex::Reserved),
            fit::Value::UInt16(0x0FFF) => Ok(MessageIndex::Mask),
            _ => Err("No corresponding MessageIndex exists"),
        }
    }
}
impl TryFrom<&str> for MessageIndex {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "selected" => Ok(MessageIndex::Selected),
            "reserved" => Ok(MessageIndex::Reserved),
            "mask" => Ok(MessageIndex::Mask),
            _ => Err("No corresponding MessageIndex exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DeviceIndex {
    /// Creator of the file is always device index 0.
    Creator,
}
impl fmt::Display for DeviceIndex {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DeviceIndex::Creator => f.write_str("creator"),
        }
    }
}
impl DeviceIndex {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DeviceIndex::Creator => fit::Value::UInt8(0),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for DeviceIndex {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(0) => Ok(DeviceIndex::Creator),
            _ => Err("No corresponding DeviceIndex exists"),
        }
    }
}
impl TryFrom<&str> for DeviceIndex {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "creator" => Ok(DeviceIndex::Creator),
            _ => Err("No corresponding DeviceIndex exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Gender {
    Female,
    Male,
}
impl fmt::Display for Gender {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Gender::Female => f.write_str("female"),
            Gender::Male => f.write_str("male"),
        }
    }
}
impl Gender {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Gender::Female => fit::Value::Enum(0),
            Gender::Male => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Gender {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Gender::Female),
            fit::Value::Enum(1) => Ok(Gender::Male),
            _ => Err("No corresponding Gender exists"),
        }
    }
}
impl TryFrom<&str> for Gender {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "female" => Ok(Gender::Female),
            "male" => Ok(Gender::Male),
            _ => Err("No corresponding Gender exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Language {
    English,
    French,
    Italian,
    German,
    Spanish,
    Croatian,
    Czech,
    Danish,
    Dutch,
    Finnish,
    Greek,
    Hungarian,
    Norwegian,
    Polish,
    Portuguese,
    Slovakian,
    Slovenian,
    Swedish,
    Russian,
    Turkish,
    Latvian,
    Ukrainian,
    Arabic,
    Farsi,
    Bulgarian,
    Romanian,
    Chinese,
    Japanese,
    Korean,
    Taiwanese,
    Thai,
    Hebrew,
    BrazilianPortuguese,
    Indonesian,
    Malaysian,
    Vietnamese,
    Burmese,
    Mongolian,
    Custom,
}
impl fmt::Display for Language {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Language::English => f.write_str("english"),
            Language::French => f.write_str("french"),
            Language::Italian => f.write_str("italian"),
            Language::German => f.write_str("german"),
            Language::Spanish => f.write_str("spanish"),
            Language::Croatian => f.write_str("croatian"),
            Language::Czech => f.write_str("czech"),
            Language::Danish => f.write_str("danish"),
            Language::Dutch => f.write_str("dutch"),
            Language::Finnish => f.write_str("finnish"),
            Language::Greek => f.write_str("greek"),
            Language::Hungarian => f.write_str("hungarian"),
            Language::Norwegian => f.write_str("norwegian"),
            Language::Polish => f.write_str("polish"),
            Language::Portuguese => f.write_str("portuguese"),
            Language::Slovakian => f.write_str("slovakian"),
            Language::Slovenian => f.write_str("slovenian"),
            Language::Swedish => f.write_str("swedish"),
            Language::Russian => f.write_str("russian"),
            Language::Turkish => f.write_str("turkish"),
            Language::Latvian => f.write_str("latvian"),
            Language::Ukrainian => f.write_str("ukrainian"),
            Language::Arabic => f.write_str("arabic"),
            Language::Farsi => f.write_str("farsi"),
            Language::Bulgarian => f.write_str("bulgarian"),
            Language::Romanian => f.write_str("romanian"),
            Language::Chinese => f.write_str("chinese"),
            Language::Japanese => f.write_str("japanese"),
            Language::Korean => f.write_str("korean"),
            Language::Taiwanese => f.write_str("taiwanese"),
            Language::Thai => f.write_str("thai"),
            Language::Hebrew => f.write_str("hebrew"),
            Language::BrazilianPortuguese => f.write_str("brazilian_portuguese"),
            Language::Indonesian => f.write_str("indonesian"),
            Language::Malaysian => f.write_str("malaysian"),
            Language::Vietnamese => f.write_str("vietnamese"),
            Language::Burmese => f.write_str("burmese"),
            Language::Mongolian => f.write_str("mongolian"),
            Language::Custom => f.write_str("custom"),
        }
    }
}
impl Language {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Language::English => fit::Value::Enum(0),
            Language::French => fit::Value::Enum(1),
            Language::Italian => fit::Value::Enum(2),
            Language::German => fit::Value::Enum(3),
            Language::Spanish => fit::Value::Enum(4),
            Language::Croatian => fit::Value::Enum(5),
            Language::Czech => fit::Value::Enum(6),
            Language::Danish => fit::Value::Enum(7),
            Language::Dutch => fit::Value::Enum(8),
            Language::Finnish => fit::Value::Enum(9),
            Language::Greek => fit::Value::Enum(10),
            Language::Hungarian => fit::Value::Enum(11),
            Language::Norwegian => fit::Value::Enum(12),
            Language::Polish => fit::Value::Enum(13),
            Language::Portuguese => fit::Value::Enum(14),
            Language::Slovakian => fit::Value::Enum(15),
            Language::Slovenian => fit::Value::Enum(16),
            Language::Swedish => fit::Value::Enum(17),
            Language::Russian => fit::Value::Enum(18),
            Language::Turkish => fit::Value::Enum(19),
            Language::Latvian => fit::Value::Enum(20),
            Language::Ukrainian => fit::Value::Enum(21),
            Language::Arabic => fit::Value::Enum(22),
            Language::Farsi => fit::Value::Enum(23),
            Language::Bulgarian => fit::Value::Enum(24),
            Language::Romanian => fit::Value::Enum(25),
            Language::Chinese => fit::Value::Enum(26),
            Language::Japanese => fit::Value::Enum(27),
            Language::Korean => fit::Value::Enum(28),
            Language::Taiwanese => fit::Value::Enum(29),
            Language::Thai => fit::Value::Enum(30),
            Language::Hebrew => fit::Value::Enum(31),
            Language::BrazilianPortuguese => fit::Value::Enum(32),
            Language::Indonesian => fit::Value::Enum(33),
            Language::Malaysian => fit::Value::Enum(34),
            Language::Vietnamese => fit::Value::Enum(35),
            Language::Burmese => fit::Value::Enum(36),
            Language::Mongolian => fit::Value::Enum(37),
            Language::Custom => fit::Value::Enum(254),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Language {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Language::English),
            fit::Value::Enum(1) => Ok(Language::French),
            fit::Value::Enum(2) => Ok(Language::Italian),
            fit::Value::Enum(3) => Ok(Language::German),
            fit::Value::Enum(4) => Ok(Language::Spanish),
            fit::Value::Enum(5) => Ok(Language::Croatian),
            fit::Value::Enum(6) => Ok(Language::Czech),
            fit::Value::Enum(7) => Ok(Language::Danish),
            fit::Value::Enum(8) => Ok(Language::Dutch),
            fit::Value::Enum(9) => Ok(Language::Finnish),
            fit::Value::Enum(10) => Ok(Language::Greek),
            fit::Value::Enum(11) => Ok(Language::Hungarian),
            fit::Value::Enum(12) => Ok(Language::Norwegian),
            fit::Value::Enum(13) => Ok(Language::Polish),
            fit::Value::Enum(14) => Ok(Language::Portuguese),
            fit::Value::Enum(15) => Ok(Language::Slovakian),
            fit::Value::Enum(16) => Ok(Language::Slovenian),
            fit::Value::Enum(17) => Ok(Language::Swedish),
            fit::Value::Enum(18) => Ok(Language::Russian),
            fit::Value::Enum(19) => Ok(Language::Turkish),
            fit::Value::Enum(20) => Ok(Language::Latvian),
            fit::Value::Enum(21) => Ok(Language::Ukrainian),
            fit::Value::Enum(22) => Ok(Language::Arabic),
            fit::Value::Enum(23) => Ok(Language::Farsi),
            fit::Value::Enum(24) => Ok(Language::Bulgarian),
            fit::Value::Enum(25) => Ok(Language::Romanian),
            fit::Value::Enum(26) => Ok(Language::Chinese),
            fit::Value::Enum(27) => Ok(Language::Japanese),
            fit::Value::Enum(28) => Ok(Language::Korean),
            fit::Value::Enum(29) => Ok(Language::Taiwanese),
            fit::Value::Enum(30) => Ok(Language::Thai),
            fit::Value::Enum(31) => Ok(Language::Hebrew),
            fit::Value::Enum(32) => Ok(Language::BrazilianPortuguese),
            fit::Value::Enum(33) => Ok(Language::Indonesian),
            fit::Value::Enum(34) => Ok(Language::Malaysian),
            fit::Value::Enum(35) => Ok(Language::Vietnamese),
            fit::Value::Enum(36) => Ok(Language::Burmese),
            fit::Value::Enum(37) => Ok(Language::Mongolian),
            fit::Value::Enum(254) => Ok(Language::Custom),
            _ => Err("No corresponding Language exists"),
        }
    }
}
impl TryFrom<&str> for Language {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "english" => Ok(Language::English),
            "french" => Ok(Language::French),
            "italian" => Ok(Language::Italian),
            "german" => Ok(Language::German),
            "spanish" => Ok(Language::Spanish),
            "croatian" => Ok(Language::Croatian),
            "czech" => Ok(Language::Czech),
            "danish" => Ok(Language::Danish),
            "dutch" => Ok(Language::Dutch),
            "finnish" => Ok(Language::Finnish),
            "greek" => Ok(Language::Greek),
            "hungarian" => Ok(Language::Hungarian),
            "norwegian" => Ok(Language::Norwegian),
            "polish" => Ok(Language::Polish),
            "portuguese" => Ok(Language::Portuguese),
            "slovakian" => Ok(Language::Slovakian),
            "slovenian" => Ok(Language::Slovenian),
            "swedish" => Ok(Language::Swedish),
            "russian" => Ok(Language::Russian),
            "turkish" => Ok(Language::Turkish),
            "latvian" => Ok(Language::Latvian),
            "ukrainian" => Ok(Language::Ukrainian),
            "arabic" => Ok(Language::Arabic),
            "farsi" => Ok(Language::Farsi),
            "bulgarian" => Ok(Language::Bulgarian),
            "romanian" => Ok(Language::Romanian),
            "chinese" => Ok(Language::Chinese),
            "japanese" => Ok(Language::Japanese),
            "korean" => Ok(Language::Korean),
            "taiwanese" => Ok(Language::Taiwanese),
            "thai" => Ok(Language::Thai),
            "hebrew" => Ok(Language::Hebrew),
            "brazilian_portuguese" => Ok(Language::BrazilianPortuguese),
            "indonesian" => Ok(Language::Indonesian),
            "malaysian" => Ok(Language::Malaysian),
            "vietnamese" => Ok(Language::Vietnamese),
            "burmese" => Ok(Language::Burmese),
            "mongolian" => Ok(Language::Mongolian),
            "custom" => Ok(Language::Custom),
            _ => Err("No corresponding Language exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LanguageBits0 {
    English,
    French,
    Italian,
    German,
    Spanish,
    Croatian,
    Czech,
    Danish,
}
impl fmt::Display for LanguageBits0 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LanguageBits0::English => f.write_str("english"),
            LanguageBits0::French => f.write_str("french"),
            LanguageBits0::Italian => f.write_str("italian"),
            LanguageBits0::German => f.write_str("german"),
            LanguageBits0::Spanish => f.write_str("spanish"),
            LanguageBits0::Croatian => f.write_str("croatian"),
            LanguageBits0::Czech => f.write_str("czech"),
            LanguageBits0::Danish => f.write_str("danish"),
        }
    }
}
impl LanguageBits0 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LanguageBits0::English => fit::Value::UInt8z(0x01),
            LanguageBits0::French => fit::Value::UInt8z(0x02),
            LanguageBits0::Italian => fit::Value::UInt8z(0x04),
            LanguageBits0::German => fit::Value::UInt8z(0x08),
            LanguageBits0::Spanish => fit::Value::UInt8z(0x10),
            LanguageBits0::Croatian => fit::Value::UInt8z(0x20),
            LanguageBits0::Czech => fit::Value::UInt8z(0x40),
            LanguageBits0::Danish => fit::Value::UInt8z(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for LanguageBits0 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(LanguageBits0::English),
            fit::Value::UInt8z(0x02) => Ok(LanguageBits0::French),
            fit::Value::UInt8z(0x04) => Ok(LanguageBits0::Italian),
            fit::Value::UInt8z(0x08) => Ok(LanguageBits0::German),
            fit::Value::UInt8z(0x10) => Ok(LanguageBits0::Spanish),
            fit::Value::UInt8z(0x20) => Ok(LanguageBits0::Croatian),
            fit::Value::UInt8z(0x40) => Ok(LanguageBits0::Czech),
            fit::Value::UInt8z(0x80) => Ok(LanguageBits0::Danish),
            _ => Err("No corresponding LanguageBits0 exists"),
        }
    }
}
impl TryFrom<&str> for LanguageBits0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "english" => Ok(LanguageBits0::English),
            "french" => Ok(LanguageBits0::French),
            "italian" => Ok(LanguageBits0::Italian),
            "german" => Ok(LanguageBits0::German),
            "spanish" => Ok(LanguageBits0::Spanish),
            "croatian" => Ok(LanguageBits0::Croatian),
            "czech" => Ok(LanguageBits0::Czech),
            "danish" => Ok(LanguageBits0::Danish),
            _ => Err("No corresponding LanguageBits0 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LanguageBits1 {
    Dutch,
    Finnish,
    Greek,
    Hungarian,
    Norwegian,
    Polish,
    Portuguese,
    Slovakian,
}
impl fmt::Display for LanguageBits1 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LanguageBits1::Dutch => f.write_str("dutch"),
            LanguageBits1::Finnish => f.write_str("finnish"),
            LanguageBits1::Greek => f.write_str("greek"),
            LanguageBits1::Hungarian => f.write_str("hungarian"),
            LanguageBits1::Norwegian => f.write_str("norwegian"),
            LanguageBits1::Polish => f.write_str("polish"),
            LanguageBits1::Portuguese => f.write_str("portuguese"),
            LanguageBits1::Slovakian => f.write_str("slovakian"),
        }
    }
}
impl LanguageBits1 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LanguageBits1::Dutch => fit::Value::UInt8z(0x01),
            LanguageBits1::Finnish => fit::Value::UInt8z(0x02),
            LanguageBits1::Greek => fit::Value::UInt8z(0x04),
            LanguageBits1::Hungarian => fit::Value::UInt8z(0x08),
            LanguageBits1::Norwegian => fit::Value::UInt8z(0x10),
            LanguageBits1::Polish => fit::Value::UInt8z(0x20),
            LanguageBits1::Portuguese => fit::Value::UInt8z(0x40),
            LanguageBits1::Slovakian => fit::Value::UInt8z(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for LanguageBits1 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(LanguageBits1::Dutch),
            fit::Value::UInt8z(0x02) => Ok(LanguageBits1::Finnish),
            fit::Value::UInt8z(0x04) => Ok(LanguageBits1::Greek),
            fit::Value::UInt8z(0x08) => Ok(LanguageBits1::Hungarian),
            fit::Value::UInt8z(0x10) => Ok(LanguageBits1::Norwegian),
            fit::Value::UInt8z(0x20) => Ok(LanguageBits1::Polish),
            fit::Value::UInt8z(0x40) => Ok(LanguageBits1::Portuguese),
            fit::Value::UInt8z(0x80) => Ok(LanguageBits1::Slovakian),
            _ => Err("No corresponding LanguageBits1 exists"),
        }
    }
}
impl TryFrom<&str> for LanguageBits1 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "dutch" => Ok(LanguageBits1::Dutch),
            "finnish" => Ok(LanguageBits1::Finnish),
            "greek" => Ok(LanguageBits1::Greek),
            "hungarian" => Ok(LanguageBits1::Hungarian),
            "norwegian" => Ok(LanguageBits1::Norwegian),
            "polish" => Ok(LanguageBits1::Polish),
            "portuguese" => Ok(LanguageBits1::Portuguese),
            "slovakian" => Ok(LanguageBits1::Slovakian),
            _ => Err("No corresponding LanguageBits1 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LanguageBits2 {
    Slovenian,
    Swedish,
    Russian,
    Turkish,
    Latvian,
    Ukrainian,
    Arabic,
    Farsi,
}
impl fmt::Display for LanguageBits2 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LanguageBits2::Slovenian => f.write_str("slovenian"),
            LanguageBits2::Swedish => f.write_str("swedish"),
            LanguageBits2::Russian => f.write_str("russian"),
            LanguageBits2::Turkish => f.write_str("turkish"),
            LanguageBits2::Latvian => f.write_str("latvian"),
            LanguageBits2::Ukrainian => f.write_str("ukrainian"),
            LanguageBits2::Arabic => f.write_str("arabic"),
            LanguageBits2::Farsi => f.write_str("farsi"),
        }
    }
}
impl LanguageBits2 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LanguageBits2::Slovenian => fit::Value::UInt8z(0x01),
            LanguageBits2::Swedish => fit::Value::UInt8z(0x02),
            LanguageBits2::Russian => fit::Value::UInt8z(0x04),
            LanguageBits2::Turkish => fit::Value::UInt8z(0x08),
            LanguageBits2::Latvian => fit::Value::UInt8z(0x10),
            LanguageBits2::Ukrainian => fit::Value::UInt8z(0x20),
            LanguageBits2::Arabic => fit::Value::UInt8z(0x40),
            LanguageBits2::Farsi => fit::Value::UInt8z(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for LanguageBits2 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(LanguageBits2::Slovenian),
            fit::Value::UInt8z(0x02) => Ok(LanguageBits2::Swedish),
            fit::Value::UInt8z(0x04) => Ok(LanguageBits2::Russian),
            fit::Value::UInt8z(0x08) => Ok(LanguageBits2::Turkish),
            fit::Value::UInt8z(0x10) => Ok(LanguageBits2::Latvian),
            fit::Value::UInt8z(0x20) => Ok(LanguageBits2::Ukrainian),
            fit::Value::UInt8z(0x40) => Ok(LanguageBits2::Arabic),
            fit::Value::UInt8z(0x80) => Ok(LanguageBits2::Farsi),
            _ => Err("No corresponding LanguageBits2 exists"),
        }
    }
}
impl TryFrom<&str> for LanguageBits2 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "slovenian" => Ok(LanguageBits2::Slovenian),
            "swedish" => Ok(LanguageBits2::Swedish),
            "russian" => Ok(LanguageBits2::Russian),
            "turkish" => Ok(LanguageBits2::Turkish),
            "latvian" => Ok(LanguageBits2::Latvian),
            "ukrainian" => Ok(LanguageBits2::Ukrainian),
            "arabic" => Ok(LanguageBits2::Arabic),
            "farsi" => Ok(LanguageBits2::Farsi),
            _ => Err("No corresponding LanguageBits2 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LanguageBits3 {
    Bulgarian,
    Romanian,
    Chinese,
    Japanese,
    Korean,
    Taiwanese,
    Thai,
    Hebrew,
}
impl fmt::Display for LanguageBits3 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LanguageBits3::Bulgarian => f.write_str("bulgarian"),
            LanguageBits3::Romanian => f.write_str("romanian"),
            LanguageBits3::Chinese => f.write_str("chinese"),
            LanguageBits3::Japanese => f.write_str("japanese"),
            LanguageBits3::Korean => f.write_str("korean"),
            LanguageBits3::Taiwanese => f.write_str("taiwanese"),
            LanguageBits3::Thai => f.write_str("thai"),
            LanguageBits3::Hebrew => f.write_str("hebrew"),
        }
    }
}
impl LanguageBits3 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LanguageBits3::Bulgarian => fit::Value::UInt8z(0x01),
            LanguageBits3::Romanian => fit::Value::UInt8z(0x02),
            LanguageBits3::Chinese => fit::Value::UInt8z(0x04),
            LanguageBits3::Japanese => fit::Value::UInt8z(0x08),
            LanguageBits3::Korean => fit::Value::UInt8z(0x10),
            LanguageBits3::Taiwanese => fit::Value::UInt8z(0x20),
            LanguageBits3::Thai => fit::Value::UInt8z(0x40),
            LanguageBits3::Hebrew => fit::Value::UInt8z(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for LanguageBits3 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(LanguageBits3::Bulgarian),
            fit::Value::UInt8z(0x02) => Ok(LanguageBits3::Romanian),
            fit::Value::UInt8z(0x04) => Ok(LanguageBits3::Chinese),
            fit::Value::UInt8z(0x08) => Ok(LanguageBits3::Japanese),
            fit::Value::UInt8z(0x10) => Ok(LanguageBits3::Korean),
            fit::Value::UInt8z(0x20) => Ok(LanguageBits3::Taiwanese),
            fit::Value::UInt8z(0x40) => Ok(LanguageBits3::Thai),
            fit::Value::UInt8z(0x80) => Ok(LanguageBits3::Hebrew),
            _ => Err("No corresponding LanguageBits3 exists"),
        }
    }
}
impl TryFrom<&str> for LanguageBits3 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "bulgarian" => Ok(LanguageBits3::Bulgarian),
            "romanian" => Ok(LanguageBits3::Romanian),
            "chinese" => Ok(LanguageBits3::Chinese),
            "japanese" => Ok(LanguageBits3::Japanese),
            "korean" => Ok(LanguageBits3::Korean),
            "taiwanese" => Ok(LanguageBits3::Taiwanese),
            "thai" => Ok(LanguageBits3::Thai),
            "hebrew" => Ok(LanguageBits3::Hebrew),
            _ => Err("No corresponding LanguageBits3 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LanguageBits4 {
    BrazilianPortuguese,
    Indonesian,
    Malaysian,
    Vietnamese,
    Burmese,
    Mongolian,
}
impl fmt::Display for LanguageBits4 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LanguageBits4::BrazilianPortuguese => f.write_str("brazilian_portuguese"),
            LanguageBits4::Indonesian => f.write_str("indonesian"),
            LanguageBits4::Malaysian => f.write_str("malaysian"),
            LanguageBits4::Vietnamese => f.write_str("vietnamese"),
            LanguageBits4::Burmese => f.write_str("burmese"),
            LanguageBits4::Mongolian => f.write_str("mongolian"),
        }
    }
}
impl LanguageBits4 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LanguageBits4::BrazilianPortuguese => fit::Value::UInt8z(0x01),
            LanguageBits4::Indonesian => fit::Value::UInt8z(0x02),
            LanguageBits4::Malaysian => fit::Value::UInt8z(0x04),
            LanguageBits4::Vietnamese => fit::Value::UInt8z(0x08),
            LanguageBits4::Burmese => fit::Value::UInt8z(0x10),
            LanguageBits4::Mongolian => fit::Value::UInt8z(0x20),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for LanguageBits4 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(LanguageBits4::BrazilianPortuguese),
            fit::Value::UInt8z(0x02) => Ok(LanguageBits4::Indonesian),
            fit::Value::UInt8z(0x04) => Ok(LanguageBits4::Malaysian),
            fit::Value::UInt8z(0x08) => Ok(LanguageBits4::Vietnamese),
            fit::Value::UInt8z(0x10) => Ok(LanguageBits4::Burmese),
            fit::Value::UInt8z(0x20) => Ok(LanguageBits4::Mongolian),
            _ => Err("No corresponding LanguageBits4 exists"),
        }
    }
}
impl TryFrom<&str> for LanguageBits4 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "brazilian_portuguese" => Ok(LanguageBits4::BrazilianPortuguese),
            "indonesian" => Ok(LanguageBits4::Indonesian),
            "malaysian" => Ok(LanguageBits4::Malaysian),
            "vietnamese" => Ok(LanguageBits4::Vietnamese),
            "burmese" => Ok(LanguageBits4::Burmese),
            "mongolian" => Ok(LanguageBits4::Mongolian),
            _ => Err("No corresponding LanguageBits4 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum TimeZone {
    Almaty,
    Bangkok,
    Bombay,
    Brasilia,
    Cairo,
    CapeVerdeIs,
    Darwin,
    Eniwetok,
    Fiji,
    HongKong,
    Islamabad,
    Kabul,
    Magadan,
    MidAtlantic,
    Moscow,
    Muscat,
    Newfoundland,
    Samoa,
    Sydney,
    Tehran,
    Tokyo,
    UsAlaska,
    UsAtlantic,
    UsCentral,
    UsEastern,
    UsHawaii,
    UsMountain,
    UsPacific,
    Other,
    Auckland,
    Kathmandu,
    EuropeWesternWet,
    EuropeCentralCet,
    EuropeEasternEet,
    Jakarta,
    Perth,
    Adelaide,
    Brisbane,
    Tasmania,
    Iceland,
    Amsterdam,
    Athens,
    Barcelona,
    Berlin,
    Brussels,
    Budapest,
    Copenhagen,
    Dublin,
    Helsinki,
    Lisbon,
    London,
    Madrid,
    Munich,
    Oslo,
    Paris,
    Prague,
    Reykjavik,
    Rome,
    Stockholm,
    Vienna,
    Warsaw,
    Zurich,
    Quebec,
    Ontario,
    Manitoba,
    Saskatchewan,
    Alberta,
    BritishColumbia,
    Boise,
    Boston,
    Chicago,
    Dallas,
    Denver,
    KansasCity,
    LasVegas,
    LosAngeles,
    Miami,
    Minneapolis,
    NewYork,
    NewOrleans,
    Phoenix,
    SantaFe,
    Seattle,
    WashingtonDc,
    UsArizona,
    Chita,
    Ekaterinburg,
    Irkutsk,
    Kaliningrad,
    Krasnoyarsk,
    Novosibirsk,
    PetropavlovskKamchatskiy,
    Samara,
    Vladivostok,
    MexicoCentral,
    MexicoMountain,
    MexicoPacific,
    CapeTown,
    Winkhoek,
    Lagos,
    Riyahd,
    Venezuela,
    AustraliaLh,
    Santiago,
    Manual,
    Automatic,
}
impl fmt::Display for TimeZone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TimeZone::Almaty => f.write_str("almaty"),
            TimeZone::Bangkok => f.write_str("bangkok"),
            TimeZone::Bombay => f.write_str("bombay"),
            TimeZone::Brasilia => f.write_str("brasilia"),
            TimeZone::Cairo => f.write_str("cairo"),
            TimeZone::CapeVerdeIs => f.write_str("cape_verde_is"),
            TimeZone::Darwin => f.write_str("darwin"),
            TimeZone::Eniwetok => f.write_str("eniwetok"),
            TimeZone::Fiji => f.write_str("fiji"),
            TimeZone::HongKong => f.write_str("hong_kong"),
            TimeZone::Islamabad => f.write_str("islamabad"),
            TimeZone::Kabul => f.write_str("kabul"),
            TimeZone::Magadan => f.write_str("magadan"),
            TimeZone::MidAtlantic => f.write_str("mid_atlantic"),
            TimeZone::Moscow => f.write_str("moscow"),
            TimeZone::Muscat => f.write_str("muscat"),
            TimeZone::Newfoundland => f.write_str("newfoundland"),
            TimeZone::Samoa => f.write_str("samoa"),
            TimeZone::Sydney => f.write_str("sydney"),
            TimeZone::Tehran => f.write_str("tehran"),
            TimeZone::Tokyo => f.write_str("tokyo"),
            TimeZone::UsAlaska => f.write_str("us_alaska"),
            TimeZone::UsAtlantic => f.write_str("us_atlantic"),
            TimeZone::UsCentral => f.write_str("us_central"),
            TimeZone::UsEastern => f.write_str("us_eastern"),
            TimeZone::UsHawaii => f.write_str("us_hawaii"),
            TimeZone::UsMountain => f.write_str("us_mountain"),
            TimeZone::UsPacific => f.write_str("us_pacific"),
            TimeZone::Other => f.write_str("other"),
            TimeZone::Auckland => f.write_str("auckland"),
            TimeZone::Kathmandu => f.write_str("kathmandu"),
            TimeZone::EuropeWesternWet => f.write_str("europe_western_wet"),
            TimeZone::EuropeCentralCet => f.write_str("europe_central_cet"),
            TimeZone::EuropeEasternEet => f.write_str("europe_eastern_eet"),
            TimeZone::Jakarta => f.write_str("jakarta"),
            TimeZone::Perth => f.write_str("perth"),
            TimeZone::Adelaide => f.write_str("adelaide"),
            TimeZone::Brisbane => f.write_str("brisbane"),
            TimeZone::Tasmania => f.write_str("tasmania"),
            TimeZone::Iceland => f.write_str("iceland"),
            TimeZone::Amsterdam => f.write_str("amsterdam"),
            TimeZone::Athens => f.write_str("athens"),
            TimeZone::Barcelona => f.write_str("barcelona"),
            TimeZone::Berlin => f.write_str("berlin"),
            TimeZone::Brussels => f.write_str("brussels"),
            TimeZone::Budapest => f.write_str("budapest"),
            TimeZone::Copenhagen => f.write_str("copenhagen"),
            TimeZone::Dublin => f.write_str("dublin"),
            TimeZone::Helsinki => f.write_str("helsinki"),
            TimeZone::Lisbon => f.write_str("lisbon"),
            TimeZone::London => f.write_str("london"),
            TimeZone::Madrid => f.write_str("madrid"),
            TimeZone::Munich => f.write_str("munich"),
            TimeZone::Oslo => f.write_str("oslo"),
            TimeZone::Paris => f.write_str("paris"),
            TimeZone::Prague => f.write_str("prague"),
            TimeZone::Reykjavik => f.write_str("reykjavik"),
            TimeZone::Rome => f.write_str("rome"),
            TimeZone::Stockholm => f.write_str("stockholm"),
            TimeZone::Vienna => f.write_str("vienna"),
            TimeZone::Warsaw => f.write_str("warsaw"),
            TimeZone::Zurich => f.write_str("zurich"),
            TimeZone::Quebec => f.write_str("quebec"),
            TimeZone::Ontario => f.write_str("ontario"),
            TimeZone::Manitoba => f.write_str("manitoba"),
            TimeZone::Saskatchewan => f.write_str("saskatchewan"),
            TimeZone::Alberta => f.write_str("alberta"),
            TimeZone::BritishColumbia => f.write_str("british_columbia"),
            TimeZone::Boise => f.write_str("boise"),
            TimeZone::Boston => f.write_str("boston"),
            TimeZone::Chicago => f.write_str("chicago"),
            TimeZone::Dallas => f.write_str("dallas"),
            TimeZone::Denver => f.write_str("denver"),
            TimeZone::KansasCity => f.write_str("kansas_city"),
            TimeZone::LasVegas => f.write_str("las_vegas"),
            TimeZone::LosAngeles => f.write_str("los_angeles"),
            TimeZone::Miami => f.write_str("miami"),
            TimeZone::Minneapolis => f.write_str("minneapolis"),
            TimeZone::NewYork => f.write_str("new_york"),
            TimeZone::NewOrleans => f.write_str("new_orleans"),
            TimeZone::Phoenix => f.write_str("phoenix"),
            TimeZone::SantaFe => f.write_str("santa_fe"),
            TimeZone::Seattle => f.write_str("seattle"),
            TimeZone::WashingtonDc => f.write_str("washington_dc"),
            TimeZone::UsArizona => f.write_str("us_arizona"),
            TimeZone::Chita => f.write_str("chita"),
            TimeZone::Ekaterinburg => f.write_str("ekaterinburg"),
            TimeZone::Irkutsk => f.write_str("irkutsk"),
            TimeZone::Kaliningrad => f.write_str("kaliningrad"),
            TimeZone::Krasnoyarsk => f.write_str("krasnoyarsk"),
            TimeZone::Novosibirsk => f.write_str("novosibirsk"),
            TimeZone::PetropavlovskKamchatskiy => f.write_str("petropavlovsk_kamchatskiy"),
            TimeZone::Samara => f.write_str("samara"),
            TimeZone::Vladivostok => f.write_str("vladivostok"),
            TimeZone::MexicoCentral => f.write_str("mexico_central"),
            TimeZone::MexicoMountain => f.write_str("mexico_mountain"),
            TimeZone::MexicoPacific => f.write_str("mexico_pacific"),
            TimeZone::CapeTown => f.write_str("cape_town"),
            TimeZone::Winkhoek => f.write_str("winkhoek"),
            TimeZone::Lagos => f.write_str("lagos"),
            TimeZone::Riyahd => f.write_str("riyahd"),
            TimeZone::Venezuela => f.write_str("venezuela"),
            TimeZone::AustraliaLh => f.write_str("australia_lh"),
            TimeZone::Santiago => f.write_str("santiago"),
            TimeZone::Manual => f.write_str("manual"),
            TimeZone::Automatic => f.write_str("automatic"),
        }
    }
}
impl TimeZone {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            TimeZone::Almaty => fit::Value::Enum(0),
            TimeZone::Bangkok => fit::Value::Enum(1),
            TimeZone::Bombay => fit::Value::Enum(2),
            TimeZone::Brasilia => fit::Value::Enum(3),
            TimeZone::Cairo => fit::Value::Enum(4),
            TimeZone::CapeVerdeIs => fit::Value::Enum(5),
            TimeZone::Darwin => fit::Value::Enum(6),
            TimeZone::Eniwetok => fit::Value::Enum(7),
            TimeZone::Fiji => fit::Value::Enum(8),
            TimeZone::HongKong => fit::Value::Enum(9),
            TimeZone::Islamabad => fit::Value::Enum(10),
            TimeZone::Kabul => fit::Value::Enum(11),
            TimeZone::Magadan => fit::Value::Enum(12),
            TimeZone::MidAtlantic => fit::Value::Enum(13),
            TimeZone::Moscow => fit::Value::Enum(14),
            TimeZone::Muscat => fit::Value::Enum(15),
            TimeZone::Newfoundland => fit::Value::Enum(16),
            TimeZone::Samoa => fit::Value::Enum(17),
            TimeZone::Sydney => fit::Value::Enum(18),
            TimeZone::Tehran => fit::Value::Enum(19),
            TimeZone::Tokyo => fit::Value::Enum(20),
            TimeZone::UsAlaska => fit::Value::Enum(21),
            TimeZone::UsAtlantic => fit::Value::Enum(22),
            TimeZone::UsCentral => fit::Value::Enum(23),
            TimeZone::UsEastern => fit::Value::Enum(24),
            TimeZone::UsHawaii => fit::Value::Enum(25),
            TimeZone::UsMountain => fit::Value::Enum(26),
            TimeZone::UsPacific => fit::Value::Enum(27),
            TimeZone::Other => fit::Value::Enum(28),
            TimeZone::Auckland => fit::Value::Enum(29),
            TimeZone::Kathmandu => fit::Value::Enum(30),
            TimeZone::EuropeWesternWet => fit::Value::Enum(31),
            TimeZone::EuropeCentralCet => fit::Value::Enum(32),
            TimeZone::EuropeEasternEet => fit::Value::Enum(33),
            TimeZone::Jakarta => fit::Value::Enum(34),
            TimeZone::Perth => fit::Value::Enum(35),
            TimeZone::Adelaide => fit::Value::Enum(36),
            TimeZone::Brisbane => fit::Value::Enum(37),
            TimeZone::Tasmania => fit::Value::Enum(38),
            TimeZone::Iceland => fit::Value::Enum(39),
            TimeZone::Amsterdam => fit::Value::Enum(40),
            TimeZone::Athens => fit::Value::Enum(41),
            TimeZone::Barcelona => fit::Value::Enum(42),
            TimeZone::Berlin => fit::Value::Enum(43),
            TimeZone::Brussels => fit::Value::Enum(44),
            TimeZone::Budapest => fit::Value::Enum(45),
            TimeZone::Copenhagen => fit::Value::Enum(46),
            TimeZone::Dublin => fit::Value::Enum(47),
            TimeZone::Helsinki => fit::Value::Enum(48),
            TimeZone::Lisbon => fit::Value::Enum(49),
            TimeZone::London => fit::Value::Enum(50),
            TimeZone::Madrid => fit::Value::Enum(51),
            TimeZone::Munich => fit::Value::Enum(52),
            TimeZone::Oslo => fit::Value::Enum(53),
            TimeZone::Paris => fit::Value::Enum(54),
            TimeZone::Prague => fit::Value::Enum(55),
            TimeZone::Reykjavik => fit::Value::Enum(56),
            TimeZone::Rome => fit::Value::Enum(57),
            TimeZone::Stockholm => fit::Value::Enum(58),
            TimeZone::Vienna => fit::Value::Enum(59),
            TimeZone::Warsaw => fit::Value::Enum(60),
            TimeZone::Zurich => fit::Value::Enum(61),
            TimeZone::Quebec => fit::Value::Enum(62),
            TimeZone::Ontario => fit::Value::Enum(63),
            TimeZone::Manitoba => fit::Value::Enum(64),
            TimeZone::Saskatchewan => fit::Value::Enum(65),
            TimeZone::Alberta => fit::Value::Enum(66),
            TimeZone::BritishColumbia => fit::Value::Enum(67),
            TimeZone::Boise => fit::Value::Enum(68),
            TimeZone::Boston => fit::Value::Enum(69),
            TimeZone::Chicago => fit::Value::Enum(70),
            TimeZone::Dallas => fit::Value::Enum(71),
            TimeZone::Denver => fit::Value::Enum(72),
            TimeZone::KansasCity => fit::Value::Enum(73),
            TimeZone::LasVegas => fit::Value::Enum(74),
            TimeZone::LosAngeles => fit::Value::Enum(75),
            TimeZone::Miami => fit::Value::Enum(76),
            TimeZone::Minneapolis => fit::Value::Enum(77),
            TimeZone::NewYork => fit::Value::Enum(78),
            TimeZone::NewOrleans => fit::Value::Enum(79),
            TimeZone::Phoenix => fit::Value::Enum(80),
            TimeZone::SantaFe => fit::Value::Enum(81),
            TimeZone::Seattle => fit::Value::Enum(82),
            TimeZone::WashingtonDc => fit::Value::Enum(83),
            TimeZone::UsArizona => fit::Value::Enum(84),
            TimeZone::Chita => fit::Value::Enum(85),
            TimeZone::Ekaterinburg => fit::Value::Enum(86),
            TimeZone::Irkutsk => fit::Value::Enum(87),
            TimeZone::Kaliningrad => fit::Value::Enum(88),
            TimeZone::Krasnoyarsk => fit::Value::Enum(89),
            TimeZone::Novosibirsk => fit::Value::Enum(90),
            TimeZone::PetropavlovskKamchatskiy => fit::Value::Enum(91),
            TimeZone::Samara => fit::Value::Enum(92),
            TimeZone::Vladivostok => fit::Value::Enum(93),
            TimeZone::MexicoCentral => fit::Value::Enum(94),
            TimeZone::MexicoMountain => fit::Value::Enum(95),
            TimeZone::MexicoPacific => fit::Value::Enum(96),
            TimeZone::CapeTown => fit::Value::Enum(97),
            TimeZone::Winkhoek => fit::Value::Enum(98),
            TimeZone::Lagos => fit::Value::Enum(99),
            TimeZone::Riyahd => fit::Value::Enum(100),
            TimeZone::Venezuela => fit::Value::Enum(101),
            TimeZone::AustraliaLh => fit::Value::Enum(102),
            TimeZone::Santiago => fit::Value::Enum(103),
            TimeZone::Manual => fit::Value::Enum(253),
            TimeZone::Automatic => fit::Value::Enum(254),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for TimeZone {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(TimeZone::Almaty),
            fit::Value::Enum(1) => Ok(TimeZone::Bangkok),
            fit::Value::Enum(2) => Ok(TimeZone::Bombay),
            fit::Value::Enum(3) => Ok(TimeZone::Brasilia),
            fit::Value::Enum(4) => Ok(TimeZone::Cairo),
            fit::Value::Enum(5) => Ok(TimeZone::CapeVerdeIs),
            fit::Value::Enum(6) => Ok(TimeZone::Darwin),
            fit::Value::Enum(7) => Ok(TimeZone::Eniwetok),
            fit::Value::Enum(8) => Ok(TimeZone::Fiji),
            fit::Value::Enum(9) => Ok(TimeZone::HongKong),
            fit::Value::Enum(10) => Ok(TimeZone::Islamabad),
            fit::Value::Enum(11) => Ok(TimeZone::Kabul),
            fit::Value::Enum(12) => Ok(TimeZone::Magadan),
            fit::Value::Enum(13) => Ok(TimeZone::MidAtlantic),
            fit::Value::Enum(14) => Ok(TimeZone::Moscow),
            fit::Value::Enum(15) => Ok(TimeZone::Muscat),
            fit::Value::Enum(16) => Ok(TimeZone::Newfoundland),
            fit::Value::Enum(17) => Ok(TimeZone::Samoa),
            fit::Value::Enum(18) => Ok(TimeZone::Sydney),
            fit::Value::Enum(19) => Ok(TimeZone::Tehran),
            fit::Value::Enum(20) => Ok(TimeZone::Tokyo),
            fit::Value::Enum(21) => Ok(TimeZone::UsAlaska),
            fit::Value::Enum(22) => Ok(TimeZone::UsAtlantic),
            fit::Value::Enum(23) => Ok(TimeZone::UsCentral),
            fit::Value::Enum(24) => Ok(TimeZone::UsEastern),
            fit::Value::Enum(25) => Ok(TimeZone::UsHawaii),
            fit::Value::Enum(26) => Ok(TimeZone::UsMountain),
            fit::Value::Enum(27) => Ok(TimeZone::UsPacific),
            fit::Value::Enum(28) => Ok(TimeZone::Other),
            fit::Value::Enum(29) => Ok(TimeZone::Auckland),
            fit::Value::Enum(30) => Ok(TimeZone::Kathmandu),
            fit::Value::Enum(31) => Ok(TimeZone::EuropeWesternWet),
            fit::Value::Enum(32) => Ok(TimeZone::EuropeCentralCet),
            fit::Value::Enum(33) => Ok(TimeZone::EuropeEasternEet),
            fit::Value::Enum(34) => Ok(TimeZone::Jakarta),
            fit::Value::Enum(35) => Ok(TimeZone::Perth),
            fit::Value::Enum(36) => Ok(TimeZone::Adelaide),
            fit::Value::Enum(37) => Ok(TimeZone::Brisbane),
            fit::Value::Enum(38) => Ok(TimeZone::Tasmania),
            fit::Value::Enum(39) => Ok(TimeZone::Iceland),
            fit::Value::Enum(40) => Ok(TimeZone::Amsterdam),
            fit::Value::Enum(41) => Ok(TimeZone::Athens),
            fit::Value::Enum(42) => Ok(TimeZone::Barcelona),
            fit::Value::Enum(43) => Ok(TimeZone::Berlin),
            fit::Value::Enum(44) => Ok(TimeZone::Brussels),
            fit::Value::Enum(45) => Ok(TimeZone::Budapest),
            fit::Value::Enum(46) => Ok(TimeZone::Copenhagen),
            fit::Value::Enum(47) => Ok(TimeZone::Dublin),
            fit::Value::Enum(48) => Ok(TimeZone::Helsinki),
            fit::Value::Enum(49) => Ok(TimeZone::Lisbon),
            fit::Value::Enum(50) => Ok(TimeZone::London),
            fit::Value::Enum(51) => Ok(TimeZone::Madrid),
            fit::Value::Enum(52) => Ok(TimeZone::Munich),
            fit::Value::Enum(53) => Ok(TimeZone::Oslo),
            fit::Value::Enum(54) => Ok(TimeZone::Paris),
            fit::Value::Enum(55) => Ok(TimeZone::Prague),
            fit::Value::Enum(56) => Ok(TimeZone::Reykjavik),
            fit::Value::Enum(57) => Ok(TimeZone::Rome),
            fit::Value::Enum(58) => Ok(TimeZone::Stockholm),
            fit::Value::Enum(59) => Ok(TimeZone::Vienna),
            fit::Value::Enum(60) => Ok(TimeZone::Warsaw),
            fit::Value::Enum(61) => Ok(TimeZone::Zurich),
            fit::Value::Enum(62) => Ok(TimeZone::Quebec),
            fit::Value::Enum(63) => Ok(TimeZone::Ontario),
            fit::Value::Enum(64) => Ok(TimeZone::Manitoba),
            fit::Value::Enum(65) => Ok(TimeZone::Saskatchewan),
            fit::Value::Enum(66) => Ok(TimeZone::Alberta),
            fit::Value::Enum(67) => Ok(TimeZone::BritishColumbia),
            fit::Value::Enum(68) => Ok(TimeZone::Boise),
            fit::Value::Enum(69) => Ok(TimeZone::Boston),
            fit::Value::Enum(70) => Ok(TimeZone::Chicago),
            fit::Value::Enum(71) => Ok(TimeZone::Dallas),
            fit::Value::Enum(72) => Ok(TimeZone::Denver),
            fit::Value::Enum(73) => Ok(TimeZone::KansasCity),
            fit::Value::Enum(74) => Ok(TimeZone::LasVegas),
            fit::Value::Enum(75) => Ok(TimeZone::LosAngeles),
            fit::Value::Enum(76) => Ok(TimeZone::Miami),
            fit::Value::Enum(77) => Ok(TimeZone::Minneapolis),
            fit::Value::Enum(78) => Ok(TimeZone::NewYork),
            fit::Value::Enum(79) => Ok(TimeZone::NewOrleans),
            fit::Value::Enum(80) => Ok(TimeZone::Phoenix),
            fit::Value::Enum(81) => Ok(TimeZone::SantaFe),
            fit::Value::Enum(82) => Ok(TimeZone::Seattle),
            fit::Value::Enum(83) => Ok(TimeZone::WashingtonDc),
            fit::Value::Enum(84) => Ok(TimeZone::UsArizona),
            fit::Value::Enum(85) => Ok(TimeZone::Chita),
            fit::Value::Enum(86) => Ok(TimeZone::Ekaterinburg),
            fit::Value::Enum(87) => Ok(TimeZone::Irkutsk),
            fit::Value::Enum(88) => Ok(TimeZone::Kaliningrad),
            fit::Value::Enum(89) => Ok(TimeZone::Krasnoyarsk),
            fit::Value::Enum(90) => Ok(TimeZone::Novosibirsk),
            fit::Value::Enum(91) => Ok(TimeZone::PetropavlovskKamchatskiy),
            fit::Value::Enum(92) => Ok(TimeZone::Samara),
            fit::Value::Enum(93) => Ok(TimeZone::Vladivostok),
            fit::Value::Enum(94) => Ok(TimeZone::MexicoCentral),
            fit::Value::Enum(95) => Ok(TimeZone::MexicoMountain),
            fit::Value::Enum(96) => Ok(TimeZone::MexicoPacific),
            fit::Value::Enum(97) => Ok(TimeZone::CapeTown),
            fit::Value::Enum(98) => Ok(TimeZone::Winkhoek),
            fit::Value::Enum(99) => Ok(TimeZone::Lagos),
            fit::Value::Enum(100) => Ok(TimeZone::Riyahd),
            fit::Value::Enum(101) => Ok(TimeZone::Venezuela),
            fit::Value::Enum(102) => Ok(TimeZone::AustraliaLh),
            fit::Value::Enum(103) => Ok(TimeZone::Santiago),
            fit::Value::Enum(253) => Ok(TimeZone::Manual),
            fit::Value::Enum(254) => Ok(TimeZone::Automatic),
            _ => Err("No corresponding TimeZone exists"),
        }
    }
}
impl TryFrom<&str> for TimeZone {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "almaty" => Ok(TimeZone::Almaty),
            "bangkok" => Ok(TimeZone::Bangkok),
            "bombay" => Ok(TimeZone::Bombay),
            "brasilia" => Ok(TimeZone::Brasilia),
            "cairo" => Ok(TimeZone::Cairo),
            "cape_verde_is" => Ok(TimeZone::CapeVerdeIs),
            "darwin" => Ok(TimeZone::Darwin),
            "eniwetok" => Ok(TimeZone::Eniwetok),
            "fiji" => Ok(TimeZone::Fiji),
            "hong_kong" => Ok(TimeZone::HongKong),
            "islamabad" => Ok(TimeZone::Islamabad),
            "kabul" => Ok(TimeZone::Kabul),
            "magadan" => Ok(TimeZone::Magadan),
            "mid_atlantic" => Ok(TimeZone::MidAtlantic),
            "moscow" => Ok(TimeZone::Moscow),
            "muscat" => Ok(TimeZone::Muscat),
            "newfoundland" => Ok(TimeZone::Newfoundland),
            "samoa" => Ok(TimeZone::Samoa),
            "sydney" => Ok(TimeZone::Sydney),
            "tehran" => Ok(TimeZone::Tehran),
            "tokyo" => Ok(TimeZone::Tokyo),
            "us_alaska" => Ok(TimeZone::UsAlaska),
            "us_atlantic" => Ok(TimeZone::UsAtlantic),
            "us_central" => Ok(TimeZone::UsCentral),
            "us_eastern" => Ok(TimeZone::UsEastern),
            "us_hawaii" => Ok(TimeZone::UsHawaii),
            "us_mountain" => Ok(TimeZone::UsMountain),
            "us_pacific" => Ok(TimeZone::UsPacific),
            "other" => Ok(TimeZone::Other),
            "auckland" => Ok(TimeZone::Auckland),
            "kathmandu" => Ok(TimeZone::Kathmandu),
            "europe_western_wet" => Ok(TimeZone::EuropeWesternWet),
            "europe_central_cet" => Ok(TimeZone::EuropeCentralCet),
            "europe_eastern_eet" => Ok(TimeZone::EuropeEasternEet),
            "jakarta" => Ok(TimeZone::Jakarta),
            "perth" => Ok(TimeZone::Perth),
            "adelaide" => Ok(TimeZone::Adelaide),
            "brisbane" => Ok(TimeZone::Brisbane),
            "tasmania" => Ok(TimeZone::Tasmania),
            "iceland" => Ok(TimeZone::Iceland),
            "amsterdam" => Ok(TimeZone::Amsterdam),
            "athens" => Ok(TimeZone::Athens),
            "barcelona" => Ok(TimeZone::Barcelona),
            "berlin" => Ok(TimeZone::Berlin),
            "brussels" => Ok(TimeZone::Brussels),
            "budapest" => Ok(TimeZone::Budapest),
            "copenhagen" => Ok(TimeZone::Copenhagen),
            "dublin" => Ok(TimeZone::Dublin),
            "helsinki" => Ok(TimeZone::Helsinki),
            "lisbon" => Ok(TimeZone::Lisbon),
            "london" => Ok(TimeZone::London),
            "madrid" => Ok(TimeZone::Madrid),
            "munich" => Ok(TimeZone::Munich),
            "oslo" => Ok(TimeZone::Oslo),
            "paris" => Ok(TimeZone::Paris),
            "prague" => Ok(TimeZone::Prague),
            "reykjavik" => Ok(TimeZone::Reykjavik),
            "rome" => Ok(TimeZone::Rome),
            "stockholm" => Ok(TimeZone::Stockholm),
            "vienna" => Ok(TimeZone::Vienna),
            "warsaw" => Ok(TimeZone::Warsaw),
            "zurich" => Ok(TimeZone::Zurich),
            "quebec" => Ok(TimeZone::Quebec),
            "ontario" => Ok(TimeZone::Ontario),
            "manitoba" => Ok(TimeZone::Manitoba),
            "saskatchewan" => Ok(TimeZone::Saskatchewan),
            "alberta" => Ok(TimeZone::Alberta),
            "british_columbia" => Ok(TimeZone::BritishColumbia),
            "boise" => Ok(TimeZone::Boise),
            "boston" => Ok(TimeZone::Boston),
            "chicago" => Ok(TimeZone::Chicago),
            "dallas" => Ok(TimeZone::Dallas),
            "denver" => Ok(TimeZone::Denver),
            "kansas_city" => Ok(TimeZone::KansasCity),
            "las_vegas" => Ok(TimeZone::LasVegas),
            "los_angeles" => Ok(TimeZone::LosAngeles),
            "miami" => Ok(TimeZone::Miami),
            "minneapolis" => Ok(TimeZone::Minneapolis),
            "new_york" => Ok(TimeZone::NewYork),
            "new_orleans" => Ok(TimeZone::NewOrleans),
            "phoenix" => Ok(TimeZone::Phoenix),
            "santa_fe" => Ok(TimeZone::SantaFe),
            "seattle" => Ok(TimeZone::Seattle),
            "washington_dc" => Ok(TimeZone::WashingtonDc),
            "us_arizona" => Ok(TimeZone::UsArizona),
            "chita" => Ok(TimeZone::Chita),
            "ekaterinburg" => Ok(TimeZone::Ekaterinburg),
            "irkutsk" => Ok(TimeZone::Irkutsk),
            "kaliningrad" => Ok(TimeZone::Kaliningrad),
            "krasnoyarsk" => Ok(TimeZone::Krasnoyarsk),
            "novosibirsk" => Ok(TimeZone::Novosibirsk),
            "petropavlovsk_kamchatskiy" => Ok(TimeZone::PetropavlovskKamchatskiy),
            "samara" => Ok(TimeZone::Samara),
            "vladivostok" => Ok(TimeZone::Vladivostok),
            "mexico_central" => Ok(TimeZone::MexicoCentral),
            "mexico_mountain" => Ok(TimeZone::MexicoMountain),
            "mexico_pacific" => Ok(TimeZone::MexicoPacific),
            "cape_town" => Ok(TimeZone::CapeTown),
            "winkhoek" => Ok(TimeZone::Winkhoek),
            "lagos" => Ok(TimeZone::Lagos),
            "riyahd" => Ok(TimeZone::Riyahd),
            "venezuela" => Ok(TimeZone::Venezuela),
            "australia_lh" => Ok(TimeZone::AustraliaLh),
            "santiago" => Ok(TimeZone::Santiago),
            "manual" => Ok(TimeZone::Manual),
            "automatic" => Ok(TimeZone::Automatic),
            _ => Err("No corresponding TimeZone exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DisplayMeasure {
    Metric,
    Statute,
    Nautical,
}
impl fmt::Display for DisplayMeasure {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DisplayMeasure::Metric => f.write_str("metric"),
            DisplayMeasure::Statute => f.write_str("statute"),
            DisplayMeasure::Nautical => f.write_str("nautical"),
        }
    }
}
impl DisplayMeasure {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DisplayMeasure::Metric => fit::Value::Enum(0),
            DisplayMeasure::Statute => fit::Value::Enum(1),
            DisplayMeasure::Nautical => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DisplayMeasure {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DisplayMeasure::Metric),
            fit::Value::Enum(1) => Ok(DisplayMeasure::Statute),
            fit::Value::Enum(2) => Ok(DisplayMeasure::Nautical),
            _ => Err("No corresponding DisplayMeasure exists"),
        }
    }
}
impl TryFrom<&str> for DisplayMeasure {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "metric" => Ok(DisplayMeasure::Metric),
            "statute" => Ok(DisplayMeasure::Statute),
            "nautical" => Ok(DisplayMeasure::Nautical),
            _ => Err("No corresponding DisplayMeasure exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DisplayHeart {
    Bpm,
    Max,
    Reserve,
}
impl fmt::Display for DisplayHeart {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DisplayHeart::Bpm => f.write_str("bpm"),
            DisplayHeart::Max => f.write_str("max"),
            DisplayHeart::Reserve => f.write_str("reserve"),
        }
    }
}
impl DisplayHeart {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DisplayHeart::Bpm => fit::Value::Enum(0),
            DisplayHeart::Max => fit::Value::Enum(1),
            DisplayHeart::Reserve => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DisplayHeart {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DisplayHeart::Bpm),
            fit::Value::Enum(1) => Ok(DisplayHeart::Max),
            fit::Value::Enum(2) => Ok(DisplayHeart::Reserve),
            _ => Err("No corresponding DisplayHeart exists"),
        }
    }
}
impl TryFrom<&str> for DisplayHeart {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "bpm" => Ok(DisplayHeart::Bpm),
            "max" => Ok(DisplayHeart::Max),
            "reserve" => Ok(DisplayHeart::Reserve),
            _ => Err("No corresponding DisplayHeart exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DisplayPower {
    Watts,
    PercentFtp,
}
impl fmt::Display for DisplayPower {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DisplayPower::Watts => f.write_str("watts"),
            DisplayPower::PercentFtp => f.write_str("percent_ftp"),
        }
    }
}
impl DisplayPower {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DisplayPower::Watts => fit::Value::Enum(0),
            DisplayPower::PercentFtp => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DisplayPower {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DisplayPower::Watts),
            fit::Value::Enum(1) => Ok(DisplayPower::PercentFtp),
            _ => Err("No corresponding DisplayPower exists"),
        }
    }
}
impl TryFrom<&str> for DisplayPower {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "watts" => Ok(DisplayPower::Watts),
            "percent_ftp" => Ok(DisplayPower::PercentFtp),
            _ => Err("No corresponding DisplayPower exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DisplayPosition {
    /// dd.dddddd
    Degree,
    /// dddmm.mmm
    DegreeMinute,
    /// dddmmss
    DegreeMinuteSecond,
    /// Austrian Grid (BMN)
    AustrianGrid,
    /// British National Grid
    BritishGrid,
    /// Dutch grid system
    DutchGrid,
    /// Hungarian grid system
    HungarianGrid,
    /// Finnish grid system Zone3 KKJ27
    FinnishGrid,
    /// Gausss Krueger (German)
    GermanGrid,
    /// Icelandic Grid
    IcelandicGrid,
    /// Indonesian Equatorial LCO
    IndonesianEquatorial,
    /// Indonesian Irian LCO
    IndonesianIrian,
    /// Indonesian Southern LCO
    IndonesianSouthern,
    /// India zone 0
    IndiaZone0,
    /// India zone IA
    IndiaZoneIA,
    /// India zone IB
    IndiaZoneIB,
    /// India zone IIA
    IndiaZoneIIA,
    /// India zone IIB
    IndiaZoneIIB,
    /// India zone IIIA
    IndiaZoneIIIA,
    /// India zone IIIB
    IndiaZoneIIIB,
    /// India zone IVA
    IndiaZoneIVA,
    /// India zone IVB
    IndiaZoneIVB,
    /// Irish Transverse Mercator
    IrishTransverse,
    /// Irish Grid
    IrishGrid,
    /// Loran TD
    Loran,
    /// Maidenhead grid system
    MaidenheadGrid,
    /// MGRS grid system
    MgrsGrid,
    /// New Zealand grid system
    NewZealandGrid,
    /// New Zealand Transverse Mercator
    NewZealandTransverse,
    /// Qatar National Grid
    QatarGrid,
    /// Modified RT-90 (Sweden)
    ModifiedSwedishGrid,
    /// RT-90 (Sweden)
    SwedishGrid,
    /// South African Grid
    SouthAfricanGrid,
    /// Swiss CH-1903 grid
    SwissGrid,
    /// Taiwan Grid
    TaiwanGrid,
    /// United States National Grid
    UnitedStatesGrid,
    /// UTM/UPS grid system
    UtmUpsGrid,
    /// West Malayan RSO
    WestMalayan,
    /// Borneo RSO
    BorneoRso,
    /// Estonian grid system
    EstonianGrid,
    /// Latvian Transverse Mercator
    LatvianGrid,
    /// Reference Grid 99 TM (Swedish)
    SwedishRef99Grid,
}
impl fmt::Display for DisplayPosition {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DisplayPosition::Degree => f.write_str("degree"),
            DisplayPosition::DegreeMinute => f.write_str("degree_minute"),
            DisplayPosition::DegreeMinuteSecond => f.write_str("degree_minute_second"),
            DisplayPosition::AustrianGrid => f.write_str("austrian_grid"),
            DisplayPosition::BritishGrid => f.write_str("british_grid"),
            DisplayPosition::DutchGrid => f.write_str("dutch_grid"),
            DisplayPosition::HungarianGrid => f.write_str("hungarian_grid"),
            DisplayPosition::FinnishGrid => f.write_str("finnish_grid"),
            DisplayPosition::GermanGrid => f.write_str("german_grid"),
            DisplayPosition::IcelandicGrid => f.write_str("icelandic_grid"),
            DisplayPosition::IndonesianEquatorial => f.write_str("indonesian_equatorial"),
            DisplayPosition::IndonesianIrian => f.write_str("indonesian_irian"),
            DisplayPosition::IndonesianSouthern => f.write_str("indonesian_southern"),
            DisplayPosition::IndiaZone0 => f.write_str("india_zone_0"),
            DisplayPosition::IndiaZoneIA => f.write_str("india_zone_IA"),
            DisplayPosition::IndiaZoneIB => f.write_str("india_zone_IB"),
            DisplayPosition::IndiaZoneIIA => f.write_str("india_zone_IIA"),
            DisplayPosition::IndiaZoneIIB => f.write_str("india_zone_IIB"),
            DisplayPosition::IndiaZoneIIIA => f.write_str("india_zone_IIIA"),
            DisplayPosition::IndiaZoneIIIB => f.write_str("india_zone_IIIB"),
            DisplayPosition::IndiaZoneIVA => f.write_str("india_zone_IVA"),
            DisplayPosition::IndiaZoneIVB => f.write_str("india_zone_IVB"),
            DisplayPosition::IrishTransverse => f.write_str("irish_transverse"),
            DisplayPosition::IrishGrid => f.write_str("irish_grid"),
            DisplayPosition::Loran => f.write_str("loran"),
            DisplayPosition::MaidenheadGrid => f.write_str("maidenhead_grid"),
            DisplayPosition::MgrsGrid => f.write_str("mgrs_grid"),
            DisplayPosition::NewZealandGrid => f.write_str("new_zealand_grid"),
            DisplayPosition::NewZealandTransverse => f.write_str("new_zealand_transverse"),
            DisplayPosition::QatarGrid => f.write_str("qatar_grid"),
            DisplayPosition::ModifiedSwedishGrid => f.write_str("modified_swedish_grid"),
            DisplayPosition::SwedishGrid => f.write_str("swedish_grid"),
            DisplayPosition::SouthAfricanGrid => f.write_str("south_african_grid"),
            DisplayPosition::SwissGrid => f.write_str("swiss_grid"),
            DisplayPosition::TaiwanGrid => f.write_str("taiwan_grid"),
            DisplayPosition::UnitedStatesGrid => f.write_str("united_states_grid"),
            DisplayPosition::UtmUpsGrid => f.write_str("utm_ups_grid"),
            DisplayPosition::WestMalayan => f.write_str("west_malayan"),
            DisplayPosition::BorneoRso => f.write_str("borneo_rso"),
            DisplayPosition::EstonianGrid => f.write_str("estonian_grid"),
            DisplayPosition::LatvianGrid => f.write_str("latvian_grid"),
            DisplayPosition::SwedishRef99Grid => f.write_str("swedish_ref_99_grid"),
        }
    }
}
impl DisplayPosition {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DisplayPosition::Degree => fit::Value::Enum(0),
            DisplayPosition::DegreeMinute => fit::Value::Enum(1),
            DisplayPosition::DegreeMinuteSecond => fit::Value::Enum(2),
            DisplayPosition::AustrianGrid => fit::Value::Enum(3),
            DisplayPosition::BritishGrid => fit::Value::Enum(4),
            DisplayPosition::DutchGrid => fit::Value::Enum(5),
            DisplayPosition::HungarianGrid => fit::Value::Enum(6),
            DisplayPosition::FinnishGrid => fit::Value::Enum(7),
            DisplayPosition::GermanGrid => fit::Value::Enum(8),
            DisplayPosition::IcelandicGrid => fit::Value::Enum(9),
            DisplayPosition::IndonesianEquatorial => fit::Value::Enum(10),
            DisplayPosition::IndonesianIrian => fit::Value::Enum(11),
            DisplayPosition::IndonesianSouthern => fit::Value::Enum(12),
            DisplayPosition::IndiaZone0 => fit::Value::Enum(13),
            DisplayPosition::IndiaZoneIA => fit::Value::Enum(14),
            DisplayPosition::IndiaZoneIB => fit::Value::Enum(15),
            DisplayPosition::IndiaZoneIIA => fit::Value::Enum(16),
            DisplayPosition::IndiaZoneIIB => fit::Value::Enum(17),
            DisplayPosition::IndiaZoneIIIA => fit::Value::Enum(18),
            DisplayPosition::IndiaZoneIIIB => fit::Value::Enum(19),
            DisplayPosition::IndiaZoneIVA => fit::Value::Enum(20),
            DisplayPosition::IndiaZoneIVB => fit::Value::Enum(21),
            DisplayPosition::IrishTransverse => fit::Value::Enum(22),
            DisplayPosition::IrishGrid => fit::Value::Enum(23),
            DisplayPosition::Loran => fit::Value::Enum(24),
            DisplayPosition::MaidenheadGrid => fit::Value::Enum(25),
            DisplayPosition::MgrsGrid => fit::Value::Enum(26),
            DisplayPosition::NewZealandGrid => fit::Value::Enum(27),
            DisplayPosition::NewZealandTransverse => fit::Value::Enum(28),
            DisplayPosition::QatarGrid => fit::Value::Enum(29),
            DisplayPosition::ModifiedSwedishGrid => fit::Value::Enum(30),
            DisplayPosition::SwedishGrid => fit::Value::Enum(31),
            DisplayPosition::SouthAfricanGrid => fit::Value::Enum(32),
            DisplayPosition::SwissGrid => fit::Value::Enum(33),
            DisplayPosition::TaiwanGrid => fit::Value::Enum(34),
            DisplayPosition::UnitedStatesGrid => fit::Value::Enum(35),
            DisplayPosition::UtmUpsGrid => fit::Value::Enum(36),
            DisplayPosition::WestMalayan => fit::Value::Enum(37),
            DisplayPosition::BorneoRso => fit::Value::Enum(38),
            DisplayPosition::EstonianGrid => fit::Value::Enum(39),
            DisplayPosition::LatvianGrid => fit::Value::Enum(40),
            DisplayPosition::SwedishRef99Grid => fit::Value::Enum(41),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DisplayPosition {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DisplayPosition::Degree),
            fit::Value::Enum(1) => Ok(DisplayPosition::DegreeMinute),
            fit::Value::Enum(2) => Ok(DisplayPosition::DegreeMinuteSecond),
            fit::Value::Enum(3) => Ok(DisplayPosition::AustrianGrid),
            fit::Value::Enum(4) => Ok(DisplayPosition::BritishGrid),
            fit::Value::Enum(5) => Ok(DisplayPosition::DutchGrid),
            fit::Value::Enum(6) => Ok(DisplayPosition::HungarianGrid),
            fit::Value::Enum(7) => Ok(DisplayPosition::FinnishGrid),
            fit::Value::Enum(8) => Ok(DisplayPosition::GermanGrid),
            fit::Value::Enum(9) => Ok(DisplayPosition::IcelandicGrid),
            fit::Value::Enum(10) => Ok(DisplayPosition::IndonesianEquatorial),
            fit::Value::Enum(11) => Ok(DisplayPosition::IndonesianIrian),
            fit::Value::Enum(12) => Ok(DisplayPosition::IndonesianSouthern),
            fit::Value::Enum(13) => Ok(DisplayPosition::IndiaZone0),
            fit::Value::Enum(14) => Ok(DisplayPosition::IndiaZoneIA),
            fit::Value::Enum(15) => Ok(DisplayPosition::IndiaZoneIB),
            fit::Value::Enum(16) => Ok(DisplayPosition::IndiaZoneIIA),
            fit::Value::Enum(17) => Ok(DisplayPosition::IndiaZoneIIB),
            fit::Value::Enum(18) => Ok(DisplayPosition::IndiaZoneIIIA),
            fit::Value::Enum(19) => Ok(DisplayPosition::IndiaZoneIIIB),
            fit::Value::Enum(20) => Ok(DisplayPosition::IndiaZoneIVA),
            fit::Value::Enum(21) => Ok(DisplayPosition::IndiaZoneIVB),
            fit::Value::Enum(22) => Ok(DisplayPosition::IrishTransverse),
            fit::Value::Enum(23) => Ok(DisplayPosition::IrishGrid),
            fit::Value::Enum(24) => Ok(DisplayPosition::Loran),
            fit::Value::Enum(25) => Ok(DisplayPosition::MaidenheadGrid),
            fit::Value::Enum(26) => Ok(DisplayPosition::MgrsGrid),
            fit::Value::Enum(27) => Ok(DisplayPosition::NewZealandGrid),
            fit::Value::Enum(28) => Ok(DisplayPosition::NewZealandTransverse),
            fit::Value::Enum(29) => Ok(DisplayPosition::QatarGrid),
            fit::Value::Enum(30) => Ok(DisplayPosition::ModifiedSwedishGrid),
            fit::Value::Enum(31) => Ok(DisplayPosition::SwedishGrid),
            fit::Value::Enum(32) => Ok(DisplayPosition::SouthAfricanGrid),
            fit::Value::Enum(33) => Ok(DisplayPosition::SwissGrid),
            fit::Value::Enum(34) => Ok(DisplayPosition::TaiwanGrid),
            fit::Value::Enum(35) => Ok(DisplayPosition::UnitedStatesGrid),
            fit::Value::Enum(36) => Ok(DisplayPosition::UtmUpsGrid),
            fit::Value::Enum(37) => Ok(DisplayPosition::WestMalayan),
            fit::Value::Enum(38) => Ok(DisplayPosition::BorneoRso),
            fit::Value::Enum(39) => Ok(DisplayPosition::EstonianGrid),
            fit::Value::Enum(40) => Ok(DisplayPosition::LatvianGrid),
            fit::Value::Enum(41) => Ok(DisplayPosition::SwedishRef99Grid),
            _ => Err("No corresponding DisplayPosition exists"),
        }
    }
}
impl TryFrom<&str> for DisplayPosition {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "degree" => Ok(DisplayPosition::Degree),
            "degree_minute" => Ok(DisplayPosition::DegreeMinute),
            "degree_minute_second" => Ok(DisplayPosition::DegreeMinuteSecond),
            "austrian_grid" => Ok(DisplayPosition::AustrianGrid),
            "british_grid" => Ok(DisplayPosition::BritishGrid),
            "dutch_grid" => Ok(DisplayPosition::DutchGrid),
            "hungarian_grid" => Ok(DisplayPosition::HungarianGrid),
            "finnish_grid" => Ok(DisplayPosition::FinnishGrid),
            "german_grid" => Ok(DisplayPosition::GermanGrid),
            "icelandic_grid" => Ok(DisplayPosition::IcelandicGrid),
            "indonesian_equatorial" => Ok(DisplayPosition::IndonesianEquatorial),
            "indonesian_irian" => Ok(DisplayPosition::IndonesianIrian),
            "indonesian_southern" => Ok(DisplayPosition::IndonesianSouthern),
            "india_zone_0" => Ok(DisplayPosition::IndiaZone0),
            "india_zone_IA" => Ok(DisplayPosition::IndiaZoneIA),
            "india_zone_IB" => Ok(DisplayPosition::IndiaZoneIB),
            "india_zone_IIA" => Ok(DisplayPosition::IndiaZoneIIA),
            "india_zone_IIB" => Ok(DisplayPosition::IndiaZoneIIB),
            "india_zone_IIIA" => Ok(DisplayPosition::IndiaZoneIIIA),
            "india_zone_IIIB" => Ok(DisplayPosition::IndiaZoneIIIB),
            "india_zone_IVA" => Ok(DisplayPosition::IndiaZoneIVA),
            "india_zone_IVB" => Ok(DisplayPosition::IndiaZoneIVB),
            "irish_transverse" => Ok(DisplayPosition::IrishTransverse),
            "irish_grid" => Ok(DisplayPosition::IrishGrid),
            "loran" => Ok(DisplayPosition::Loran),
            "maidenhead_grid" => Ok(DisplayPosition::MaidenheadGrid),
            "mgrs_grid" => Ok(DisplayPosition::MgrsGrid),
            "new_zealand_grid" => Ok(DisplayPosition::NewZealandGrid),
            "new_zealand_transverse" => Ok(DisplayPosition::NewZealandTransverse),
            "qatar_grid" => Ok(DisplayPosition::QatarGrid),
            "modified_swedish_grid" => Ok(DisplayPosition::ModifiedSwedishGrid),
            "swedish_grid" => Ok(DisplayPosition::SwedishGrid),
            "south_african_grid" => Ok(DisplayPosition::SouthAfricanGrid),
            "swiss_grid" => Ok(DisplayPosition::SwissGrid),
            "taiwan_grid" => Ok(DisplayPosition::TaiwanGrid),
            "united_states_grid" => Ok(DisplayPosition::UnitedStatesGrid),
            "utm_ups_grid" => Ok(DisplayPosition::UtmUpsGrid),
            "west_malayan" => Ok(DisplayPosition::WestMalayan),
            "borneo_rso" => Ok(DisplayPosition::BorneoRso),
            "estonian_grid" => Ok(DisplayPosition::EstonianGrid),
            "latvian_grid" => Ok(DisplayPosition::LatvianGrid),
            "swedish_ref_99_grid" => Ok(DisplayPosition::SwedishRef99Grid),
            _ => Err("No corresponding DisplayPosition exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Switch {
    Off,
    On,
    Auto,
}
impl fmt::Display for Switch {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Switch::Off => f.write_str("off"),
            Switch::On => f.write_str("on"),
            Switch::Auto => f.write_str("auto"),
        }
    }
}
impl Switch {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Switch::Off => fit::Value::Enum(0),
            Switch::On => fit::Value::Enum(1),
            Switch::Auto => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Switch {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Switch::Off),
            fit::Value::Enum(1) => Ok(Switch::On),
            fit::Value::Enum(2) => Ok(Switch::Auto),
            _ => Err("No corresponding Switch exists"),
        }
    }
}
impl TryFrom<&str> for Switch {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "off" => Ok(Switch::Off),
            "on" => Ok(Switch::On),
            "auto" => Ok(Switch::Auto),
            _ => Err("No corresponding Switch exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Sport {
    Generic,
    Running,
    Cycling,
    /// Mulitsport transition
    Transition,
    FitnessEquipment,
    Swimming,
    Basketball,
    Soccer,
    Tennis,
    AmericanFootball,
    Training,
    Walking,
    CrossCountrySkiing,
    AlpineSkiing,
    Snowboarding,
    Rowing,
    Mountaineering,
    Hiking,
    Multisport,
    Paddling,
    Flying,
    EBiking,
    Motorcycling,
    Boating,
    Driving,
    Golf,
    HangGliding,
    HorsebackRiding,
    Hunting,
    Fishing,
    InlineSkating,
    RockClimbing,
    Sailing,
    IceSkating,
    SkyDiving,
    Snowshoeing,
    Snowmobiling,
    StandUpPaddleboarding,
    Surfing,
    Wakeboarding,
    WaterSkiing,
    Kayaking,
    Rafting,
    Windsurfing,
    Kitesurfing,
    Tactical,
    Jumpmaster,
    Boxing,
    FloorClimbing,
    Diving,
    Hiit,
    Racket,
    WaterTubing,
    Wakesurfing,
    /// All is for goals only to include all sports.
    All,
}
impl fmt::Display for Sport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Sport::Generic => f.write_str("generic"),
            Sport::Running => f.write_str("running"),
            Sport::Cycling => f.write_str("cycling"),
            Sport::Transition => f.write_str("transition"),
            Sport::FitnessEquipment => f.write_str("fitness_equipment"),
            Sport::Swimming => f.write_str("swimming"),
            Sport::Basketball => f.write_str("basketball"),
            Sport::Soccer => f.write_str("soccer"),
            Sport::Tennis => f.write_str("tennis"),
            Sport::AmericanFootball => f.write_str("american_football"),
            Sport::Training => f.write_str("training"),
            Sport::Walking => f.write_str("walking"),
            Sport::CrossCountrySkiing => f.write_str("cross_country_skiing"),
            Sport::AlpineSkiing => f.write_str("alpine_skiing"),
            Sport::Snowboarding => f.write_str("snowboarding"),
            Sport::Rowing => f.write_str("rowing"),
            Sport::Mountaineering => f.write_str("mountaineering"),
            Sport::Hiking => f.write_str("hiking"),
            Sport::Multisport => f.write_str("multisport"),
            Sport::Paddling => f.write_str("paddling"),
            Sport::Flying => f.write_str("flying"),
            Sport::EBiking => f.write_str("e_biking"),
            Sport::Motorcycling => f.write_str("motorcycling"),
            Sport::Boating => f.write_str("boating"),
            Sport::Driving => f.write_str("driving"),
            Sport::Golf => f.write_str("golf"),
            Sport::HangGliding => f.write_str("hang_gliding"),
            Sport::HorsebackRiding => f.write_str("horseback_riding"),
            Sport::Hunting => f.write_str("hunting"),
            Sport::Fishing => f.write_str("fishing"),
            Sport::InlineSkating => f.write_str("inline_skating"),
            Sport::RockClimbing => f.write_str("rock_climbing"),
            Sport::Sailing => f.write_str("sailing"),
            Sport::IceSkating => f.write_str("ice_skating"),
            Sport::SkyDiving => f.write_str("sky_diving"),
            Sport::Snowshoeing => f.write_str("snowshoeing"),
            Sport::Snowmobiling => f.write_str("snowmobiling"),
            Sport::StandUpPaddleboarding => f.write_str("stand_up_paddleboarding"),
            Sport::Surfing => f.write_str("surfing"),
            Sport::Wakeboarding => f.write_str("wakeboarding"),
            Sport::WaterSkiing => f.write_str("water_skiing"),
            Sport::Kayaking => f.write_str("kayaking"),
            Sport::Rafting => f.write_str("rafting"),
            Sport::Windsurfing => f.write_str("windsurfing"),
            Sport::Kitesurfing => f.write_str("kitesurfing"),
            Sport::Tactical => f.write_str("tactical"),
            Sport::Jumpmaster => f.write_str("jumpmaster"),
            Sport::Boxing => f.write_str("boxing"),
            Sport::FloorClimbing => f.write_str("floor_climbing"),
            Sport::Diving => f.write_str("diving"),
            Sport::Hiit => f.write_str("hiit"),
            Sport::Racket => f.write_str("racket"),
            Sport::WaterTubing => f.write_str("water_tubing"),
            Sport::Wakesurfing => f.write_str("wakesurfing"),
            Sport::All => f.write_str("all"),
        }
    }
}
impl Sport {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Sport::Generic => fit::Value::Enum(0),
            Sport::Running => fit::Value::Enum(1),
            Sport::Cycling => fit::Value::Enum(2),
            Sport::Transition => fit::Value::Enum(3),
            Sport::FitnessEquipment => fit::Value::Enum(4),
            Sport::Swimming => fit::Value::Enum(5),
            Sport::Basketball => fit::Value::Enum(6),
            Sport::Soccer => fit::Value::Enum(7),
            Sport::Tennis => fit::Value::Enum(8),
            Sport::AmericanFootball => fit::Value::Enum(9),
            Sport::Training => fit::Value::Enum(10),
            Sport::Walking => fit::Value::Enum(11),
            Sport::CrossCountrySkiing => fit::Value::Enum(12),
            Sport::AlpineSkiing => fit::Value::Enum(13),
            Sport::Snowboarding => fit::Value::Enum(14),
            Sport::Rowing => fit::Value::Enum(15),
            Sport::Mountaineering => fit::Value::Enum(16),
            Sport::Hiking => fit::Value::Enum(17),
            Sport::Multisport => fit::Value::Enum(18),
            Sport::Paddling => fit::Value::Enum(19),
            Sport::Flying => fit::Value::Enum(20),
            Sport::EBiking => fit::Value::Enum(21),
            Sport::Motorcycling => fit::Value::Enum(22),
            Sport::Boating => fit::Value::Enum(23),
            Sport::Driving => fit::Value::Enum(24),
            Sport::Golf => fit::Value::Enum(25),
            Sport::HangGliding => fit::Value::Enum(26),
            Sport::HorsebackRiding => fit::Value::Enum(27),
            Sport::Hunting => fit::Value::Enum(28),
            Sport::Fishing => fit::Value::Enum(29),
            Sport::InlineSkating => fit::Value::Enum(30),
            Sport::RockClimbing => fit::Value::Enum(31),
            Sport::Sailing => fit::Value::Enum(32),
            Sport::IceSkating => fit::Value::Enum(33),
            Sport::SkyDiving => fit::Value::Enum(34),
            Sport::Snowshoeing => fit::Value::Enum(35),
            Sport::Snowmobiling => fit::Value::Enum(36),
            Sport::StandUpPaddleboarding => fit::Value::Enum(37),
            Sport::Surfing => fit::Value::Enum(38),
            Sport::Wakeboarding => fit::Value::Enum(39),
            Sport::WaterSkiing => fit::Value::Enum(40),
            Sport::Kayaking => fit::Value::Enum(41),
            Sport::Rafting => fit::Value::Enum(42),
            Sport::Windsurfing => fit::Value::Enum(43),
            Sport::Kitesurfing => fit::Value::Enum(44),
            Sport::Tactical => fit::Value::Enum(45),
            Sport::Jumpmaster => fit::Value::Enum(46),
            Sport::Boxing => fit::Value::Enum(47),
            Sport::FloorClimbing => fit::Value::Enum(48),
            Sport::Diving => fit::Value::Enum(53),
            Sport::Hiit => fit::Value::Enum(62),
            Sport::Racket => fit::Value::Enum(64),
            Sport::WaterTubing => fit::Value::Enum(76),
            Sport::Wakesurfing => fit::Value::Enum(77),
            Sport::All => fit::Value::Enum(254),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Sport {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Sport::Generic),
            fit::Value::Enum(1) => Ok(Sport::Running),
            fit::Value::Enum(2) => Ok(Sport::Cycling),
            fit::Value::Enum(3) => Ok(Sport::Transition),
            fit::Value::Enum(4) => Ok(Sport::FitnessEquipment),
            fit::Value::Enum(5) => Ok(Sport::Swimming),
            fit::Value::Enum(6) => Ok(Sport::Basketball),
            fit::Value::Enum(7) => Ok(Sport::Soccer),
            fit::Value::Enum(8) => Ok(Sport::Tennis),
            fit::Value::Enum(9) => Ok(Sport::AmericanFootball),
            fit::Value::Enum(10) => Ok(Sport::Training),
            fit::Value::Enum(11) => Ok(Sport::Walking),
            fit::Value::Enum(12) => Ok(Sport::CrossCountrySkiing),
            fit::Value::Enum(13) => Ok(Sport::AlpineSkiing),
            fit::Value::Enum(14) => Ok(Sport::Snowboarding),
            fit::Value::Enum(15) => Ok(Sport::Rowing),
            fit::Value::Enum(16) => Ok(Sport::Mountaineering),
            fit::Value::Enum(17) => Ok(Sport::Hiking),
            fit::Value::Enum(18) => Ok(Sport::Multisport),
            fit::Value::Enum(19) => Ok(Sport::Paddling),
            fit::Value::Enum(20) => Ok(Sport::Flying),
            fit::Value::Enum(21) => Ok(Sport::EBiking),
            fit::Value::Enum(22) => Ok(Sport::Motorcycling),
            fit::Value::Enum(23) => Ok(Sport::Boating),
            fit::Value::Enum(24) => Ok(Sport::Driving),
            fit::Value::Enum(25) => Ok(Sport::Golf),
            fit::Value::Enum(26) => Ok(Sport::HangGliding),
            fit::Value::Enum(27) => Ok(Sport::HorsebackRiding),
            fit::Value::Enum(28) => Ok(Sport::Hunting),
            fit::Value::Enum(29) => Ok(Sport::Fishing),
            fit::Value::Enum(30) => Ok(Sport::InlineSkating),
            fit::Value::Enum(31) => Ok(Sport::RockClimbing),
            fit::Value::Enum(32) => Ok(Sport::Sailing),
            fit::Value::Enum(33) => Ok(Sport::IceSkating),
            fit::Value::Enum(34) => Ok(Sport::SkyDiving),
            fit::Value::Enum(35) => Ok(Sport::Snowshoeing),
            fit::Value::Enum(36) => Ok(Sport::Snowmobiling),
            fit::Value::Enum(37) => Ok(Sport::StandUpPaddleboarding),
            fit::Value::Enum(38) => Ok(Sport::Surfing),
            fit::Value::Enum(39) => Ok(Sport::Wakeboarding),
            fit::Value::Enum(40) => Ok(Sport::WaterSkiing),
            fit::Value::Enum(41) => Ok(Sport::Kayaking),
            fit::Value::Enum(42) => Ok(Sport::Rafting),
            fit::Value::Enum(43) => Ok(Sport::Windsurfing),
            fit::Value::Enum(44) => Ok(Sport::Kitesurfing),
            fit::Value::Enum(45) => Ok(Sport::Tactical),
            fit::Value::Enum(46) => Ok(Sport::Jumpmaster),
            fit::Value::Enum(47) => Ok(Sport::Boxing),
            fit::Value::Enum(48) => Ok(Sport::FloorClimbing),
            fit::Value::Enum(53) => Ok(Sport::Diving),
            fit::Value::Enum(62) => Ok(Sport::Hiit),
            fit::Value::Enum(64) => Ok(Sport::Racket),
            fit::Value::Enum(76) => Ok(Sport::WaterTubing),
            fit::Value::Enum(77) => Ok(Sport::Wakesurfing),
            fit::Value::Enum(254) => Ok(Sport::All),
            _ => Err("No corresponding Sport exists"),
        }
    }
}
impl TryFrom<&str> for Sport {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "generic" => Ok(Sport::Generic),
            "running" => Ok(Sport::Running),
            "cycling" => Ok(Sport::Cycling),
            "transition" => Ok(Sport::Transition),
            "fitness_equipment" => Ok(Sport::FitnessEquipment),
            "swimming" => Ok(Sport::Swimming),
            "basketball" => Ok(Sport::Basketball),
            "soccer" => Ok(Sport::Soccer),
            "tennis" => Ok(Sport::Tennis),
            "american_football" => Ok(Sport::AmericanFootball),
            "training" => Ok(Sport::Training),
            "walking" => Ok(Sport::Walking),
            "cross_country_skiing" => Ok(Sport::CrossCountrySkiing),
            "alpine_skiing" => Ok(Sport::AlpineSkiing),
            "snowboarding" => Ok(Sport::Snowboarding),
            "rowing" => Ok(Sport::Rowing),
            "mountaineering" => Ok(Sport::Mountaineering),
            "hiking" => Ok(Sport::Hiking),
            "multisport" => Ok(Sport::Multisport),
            "paddling" => Ok(Sport::Paddling),
            "flying" => Ok(Sport::Flying),
            "e_biking" => Ok(Sport::EBiking),
            "motorcycling" => Ok(Sport::Motorcycling),
            "boating" => Ok(Sport::Boating),
            "driving" => Ok(Sport::Driving),
            "golf" => Ok(Sport::Golf),
            "hang_gliding" => Ok(Sport::HangGliding),
            "horseback_riding" => Ok(Sport::HorsebackRiding),
            "hunting" => Ok(Sport::Hunting),
            "fishing" => Ok(Sport::Fishing),
            "inline_skating" => Ok(Sport::InlineSkating),
            "rock_climbing" => Ok(Sport::RockClimbing),
            "sailing" => Ok(Sport::Sailing),
            "ice_skating" => Ok(Sport::IceSkating),
            "sky_diving" => Ok(Sport::SkyDiving),
            "snowshoeing" => Ok(Sport::Snowshoeing),
            "snowmobiling" => Ok(Sport::Snowmobiling),
            "stand_up_paddleboarding" => Ok(Sport::StandUpPaddleboarding),
            "surfing" => Ok(Sport::Surfing),
            "wakeboarding" => Ok(Sport::Wakeboarding),
            "water_skiing" => Ok(Sport::WaterSkiing),
            "kayaking" => Ok(Sport::Kayaking),
            "rafting" => Ok(Sport::Rafting),
            "windsurfing" => Ok(Sport::Windsurfing),
            "kitesurfing" => Ok(Sport::Kitesurfing),
            "tactical" => Ok(Sport::Tactical),
            "jumpmaster" => Ok(Sport::Jumpmaster),
            "boxing" => Ok(Sport::Boxing),
            "floor_climbing" => Ok(Sport::FloorClimbing),
            "diving" => Ok(Sport::Diving),
            "hiit" => Ok(Sport::Hiit),
            "racket" => Ok(Sport::Racket),
            "water_tubing" => Ok(Sport::WaterTubing),
            "wakesurfing" => Ok(Sport::Wakesurfing),
            "all" => Ok(Sport::All),
            _ => Err("No corresponding Sport exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SportBits0 {
    Generic,
    Running,
    Cycling,
    /// Mulitsport transition
    Transition,
    FitnessEquipment,
    Swimming,
    Basketball,
    Soccer,
}
impl fmt::Display for SportBits0 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SportBits0::Generic => f.write_str("generic"),
            SportBits0::Running => f.write_str("running"),
            SportBits0::Cycling => f.write_str("cycling"),
            SportBits0::Transition => f.write_str("transition"),
            SportBits0::FitnessEquipment => f.write_str("fitness_equipment"),
            SportBits0::Swimming => f.write_str("swimming"),
            SportBits0::Basketball => f.write_str("basketball"),
            SportBits0::Soccer => f.write_str("soccer"),
        }
    }
}
impl SportBits0 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SportBits0::Generic => fit::Value::UInt8z(0x01),
            SportBits0::Running => fit::Value::UInt8z(0x02),
            SportBits0::Cycling => fit::Value::UInt8z(0x04),
            SportBits0::Transition => fit::Value::UInt8z(0x08),
            SportBits0::FitnessEquipment => fit::Value::UInt8z(0x10),
            SportBits0::Swimming => fit::Value::UInt8z(0x20),
            SportBits0::Basketball => fit::Value::UInt8z(0x40),
            SportBits0::Soccer => fit::Value::UInt8z(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for SportBits0 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(SportBits0::Generic),
            fit::Value::UInt8z(0x02) => Ok(SportBits0::Running),
            fit::Value::UInt8z(0x04) => Ok(SportBits0::Cycling),
            fit::Value::UInt8z(0x08) => Ok(SportBits0::Transition),
            fit::Value::UInt8z(0x10) => Ok(SportBits0::FitnessEquipment),
            fit::Value::UInt8z(0x20) => Ok(SportBits0::Swimming),
            fit::Value::UInt8z(0x40) => Ok(SportBits0::Basketball),
            fit::Value::UInt8z(0x80) => Ok(SportBits0::Soccer),
            _ => Err("No corresponding SportBits0 exists"),
        }
    }
}
impl TryFrom<&str> for SportBits0 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "generic" => Ok(SportBits0::Generic),
            "running" => Ok(SportBits0::Running),
            "cycling" => Ok(SportBits0::Cycling),
            "transition" => Ok(SportBits0::Transition),
            "fitness_equipment" => Ok(SportBits0::FitnessEquipment),
            "swimming" => Ok(SportBits0::Swimming),
            "basketball" => Ok(SportBits0::Basketball),
            "soccer" => Ok(SportBits0::Soccer),
            _ => Err("No corresponding SportBits0 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SportBits1 {
    Tennis,
    AmericanFootball,
    Training,
    Walking,
    CrossCountrySkiing,
    AlpineSkiing,
    Snowboarding,
    Rowing,
}
impl fmt::Display for SportBits1 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SportBits1::Tennis => f.write_str("tennis"),
            SportBits1::AmericanFootball => f.write_str("american_football"),
            SportBits1::Training => f.write_str("training"),
            SportBits1::Walking => f.write_str("walking"),
            SportBits1::CrossCountrySkiing => f.write_str("cross_country_skiing"),
            SportBits1::AlpineSkiing => f.write_str("alpine_skiing"),
            SportBits1::Snowboarding => f.write_str("snowboarding"),
            SportBits1::Rowing => f.write_str("rowing"),
        }
    }
}
impl SportBits1 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SportBits1::Tennis => fit::Value::UInt8z(0x01),
            SportBits1::AmericanFootball => fit::Value::UInt8z(0x02),
            SportBits1::Training => fit::Value::UInt8z(0x04),
            SportBits1::Walking => fit::Value::UInt8z(0x08),
            SportBits1::CrossCountrySkiing => fit::Value::UInt8z(0x10),
            SportBits1::AlpineSkiing => fit::Value::UInt8z(0x20),
            SportBits1::Snowboarding => fit::Value::UInt8z(0x40),
            SportBits1::Rowing => fit::Value::UInt8z(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for SportBits1 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(SportBits1::Tennis),
            fit::Value::UInt8z(0x02) => Ok(SportBits1::AmericanFootball),
            fit::Value::UInt8z(0x04) => Ok(SportBits1::Training),
            fit::Value::UInt8z(0x08) => Ok(SportBits1::Walking),
            fit::Value::UInt8z(0x10) => Ok(SportBits1::CrossCountrySkiing),
            fit::Value::UInt8z(0x20) => Ok(SportBits1::AlpineSkiing),
            fit::Value::UInt8z(0x40) => Ok(SportBits1::Snowboarding),
            fit::Value::UInt8z(0x80) => Ok(SportBits1::Rowing),
            _ => Err("No corresponding SportBits1 exists"),
        }
    }
}
impl TryFrom<&str> for SportBits1 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "tennis" => Ok(SportBits1::Tennis),
            "american_football" => Ok(SportBits1::AmericanFootball),
            "training" => Ok(SportBits1::Training),
            "walking" => Ok(SportBits1::Walking),
            "cross_country_skiing" => Ok(SportBits1::CrossCountrySkiing),
            "alpine_skiing" => Ok(SportBits1::AlpineSkiing),
            "snowboarding" => Ok(SportBits1::Snowboarding),
            "rowing" => Ok(SportBits1::Rowing),
            _ => Err("No corresponding SportBits1 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SportBits2 {
    Mountaineering,
    Hiking,
    Multisport,
    Paddling,
    Flying,
    EBiking,
    Motorcycling,
    Boating,
}
impl fmt::Display for SportBits2 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SportBits2::Mountaineering => f.write_str("mountaineering"),
            SportBits2::Hiking => f.write_str("hiking"),
            SportBits2::Multisport => f.write_str("multisport"),
            SportBits2::Paddling => f.write_str("paddling"),
            SportBits2::Flying => f.write_str("flying"),
            SportBits2::EBiking => f.write_str("e_biking"),
            SportBits2::Motorcycling => f.write_str("motorcycling"),
            SportBits2::Boating => f.write_str("boating"),
        }
    }
}
impl SportBits2 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SportBits2::Mountaineering => fit::Value::UInt8z(0x01),
            SportBits2::Hiking => fit::Value::UInt8z(0x02),
            SportBits2::Multisport => fit::Value::UInt8z(0x04),
            SportBits2::Paddling => fit::Value::UInt8z(0x08),
            SportBits2::Flying => fit::Value::UInt8z(0x10),
            SportBits2::EBiking => fit::Value::UInt8z(0x20),
            SportBits2::Motorcycling => fit::Value::UInt8z(0x40),
            SportBits2::Boating => fit::Value::UInt8z(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for SportBits2 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(SportBits2::Mountaineering),
            fit::Value::UInt8z(0x02) => Ok(SportBits2::Hiking),
            fit::Value::UInt8z(0x04) => Ok(SportBits2::Multisport),
            fit::Value::UInt8z(0x08) => Ok(SportBits2::Paddling),
            fit::Value::UInt8z(0x10) => Ok(SportBits2::Flying),
            fit::Value::UInt8z(0x20) => Ok(SportBits2::EBiking),
            fit::Value::UInt8z(0x40) => Ok(SportBits2::Motorcycling),
            fit::Value::UInt8z(0x80) => Ok(SportBits2::Boating),
            _ => Err("No corresponding SportBits2 exists"),
        }
    }
}
impl TryFrom<&str> for SportBits2 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "mountaineering" => Ok(SportBits2::Mountaineering),
            "hiking" => Ok(SportBits2::Hiking),
            "multisport" => Ok(SportBits2::Multisport),
            "paddling" => Ok(SportBits2::Paddling),
            "flying" => Ok(SportBits2::Flying),
            "e_biking" => Ok(SportBits2::EBiking),
            "motorcycling" => Ok(SportBits2::Motorcycling),
            "boating" => Ok(SportBits2::Boating),
            _ => Err("No corresponding SportBits2 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SportBits3 {
    Driving,
    Golf,
    HangGliding,
    HorsebackRiding,
    Hunting,
    Fishing,
    InlineSkating,
    RockClimbing,
}
impl fmt::Display for SportBits3 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SportBits3::Driving => f.write_str("driving"),
            SportBits3::Golf => f.write_str("golf"),
            SportBits3::HangGliding => f.write_str("hang_gliding"),
            SportBits3::HorsebackRiding => f.write_str("horseback_riding"),
            SportBits3::Hunting => f.write_str("hunting"),
            SportBits3::Fishing => f.write_str("fishing"),
            SportBits3::InlineSkating => f.write_str("inline_skating"),
            SportBits3::RockClimbing => f.write_str("rock_climbing"),
        }
    }
}
impl SportBits3 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SportBits3::Driving => fit::Value::UInt8z(0x01),
            SportBits3::Golf => fit::Value::UInt8z(0x02),
            SportBits3::HangGliding => fit::Value::UInt8z(0x04),
            SportBits3::HorsebackRiding => fit::Value::UInt8z(0x08),
            SportBits3::Hunting => fit::Value::UInt8z(0x10),
            SportBits3::Fishing => fit::Value::UInt8z(0x20),
            SportBits3::InlineSkating => fit::Value::UInt8z(0x40),
            SportBits3::RockClimbing => fit::Value::UInt8z(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for SportBits3 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(SportBits3::Driving),
            fit::Value::UInt8z(0x02) => Ok(SportBits3::Golf),
            fit::Value::UInt8z(0x04) => Ok(SportBits3::HangGliding),
            fit::Value::UInt8z(0x08) => Ok(SportBits3::HorsebackRiding),
            fit::Value::UInt8z(0x10) => Ok(SportBits3::Hunting),
            fit::Value::UInt8z(0x20) => Ok(SportBits3::Fishing),
            fit::Value::UInt8z(0x40) => Ok(SportBits3::InlineSkating),
            fit::Value::UInt8z(0x80) => Ok(SportBits3::RockClimbing),
            _ => Err("No corresponding SportBits3 exists"),
        }
    }
}
impl TryFrom<&str> for SportBits3 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "driving" => Ok(SportBits3::Driving),
            "golf" => Ok(SportBits3::Golf),
            "hang_gliding" => Ok(SportBits3::HangGliding),
            "horseback_riding" => Ok(SportBits3::HorsebackRiding),
            "hunting" => Ok(SportBits3::Hunting),
            "fishing" => Ok(SportBits3::Fishing),
            "inline_skating" => Ok(SportBits3::InlineSkating),
            "rock_climbing" => Ok(SportBits3::RockClimbing),
            _ => Err("No corresponding SportBits3 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SportBits4 {
    Sailing,
    IceSkating,
    SkyDiving,
    Snowshoeing,
    Snowmobiling,
    StandUpPaddleboarding,
    Surfing,
    Wakeboarding,
}
impl fmt::Display for SportBits4 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SportBits4::Sailing => f.write_str("sailing"),
            SportBits4::IceSkating => f.write_str("ice_skating"),
            SportBits4::SkyDiving => f.write_str("sky_diving"),
            SportBits4::Snowshoeing => f.write_str("snowshoeing"),
            SportBits4::Snowmobiling => f.write_str("snowmobiling"),
            SportBits4::StandUpPaddleboarding => f.write_str("stand_up_paddleboarding"),
            SportBits4::Surfing => f.write_str("surfing"),
            SportBits4::Wakeboarding => f.write_str("wakeboarding"),
        }
    }
}
impl SportBits4 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SportBits4::Sailing => fit::Value::UInt8z(0x01),
            SportBits4::IceSkating => fit::Value::UInt8z(0x02),
            SportBits4::SkyDiving => fit::Value::UInt8z(0x04),
            SportBits4::Snowshoeing => fit::Value::UInt8z(0x08),
            SportBits4::Snowmobiling => fit::Value::UInt8z(0x10),
            SportBits4::StandUpPaddleboarding => fit::Value::UInt8z(0x20),
            SportBits4::Surfing => fit::Value::UInt8z(0x40),
            SportBits4::Wakeboarding => fit::Value::UInt8z(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for SportBits4 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(SportBits4::Sailing),
            fit::Value::UInt8z(0x02) => Ok(SportBits4::IceSkating),
            fit::Value::UInt8z(0x04) => Ok(SportBits4::SkyDiving),
            fit::Value::UInt8z(0x08) => Ok(SportBits4::Snowshoeing),
            fit::Value::UInt8z(0x10) => Ok(SportBits4::Snowmobiling),
            fit::Value::UInt8z(0x20) => Ok(SportBits4::StandUpPaddleboarding),
            fit::Value::UInt8z(0x40) => Ok(SportBits4::Surfing),
            fit::Value::UInt8z(0x80) => Ok(SportBits4::Wakeboarding),
            _ => Err("No corresponding SportBits4 exists"),
        }
    }
}
impl TryFrom<&str> for SportBits4 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "sailing" => Ok(SportBits4::Sailing),
            "ice_skating" => Ok(SportBits4::IceSkating),
            "sky_diving" => Ok(SportBits4::SkyDiving),
            "snowshoeing" => Ok(SportBits4::Snowshoeing),
            "snowmobiling" => Ok(SportBits4::Snowmobiling),
            "stand_up_paddleboarding" => Ok(SportBits4::StandUpPaddleboarding),
            "surfing" => Ok(SportBits4::Surfing),
            "wakeboarding" => Ok(SportBits4::Wakeboarding),
            _ => Err("No corresponding SportBits4 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SportBits5 {
    WaterSkiing,
    Kayaking,
    Rafting,
    Windsurfing,
    Kitesurfing,
    Tactical,
    Jumpmaster,
    Boxing,
}
impl fmt::Display for SportBits5 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SportBits5::WaterSkiing => f.write_str("water_skiing"),
            SportBits5::Kayaking => f.write_str("kayaking"),
            SportBits5::Rafting => f.write_str("rafting"),
            SportBits5::Windsurfing => f.write_str("windsurfing"),
            SportBits5::Kitesurfing => f.write_str("kitesurfing"),
            SportBits5::Tactical => f.write_str("tactical"),
            SportBits5::Jumpmaster => f.write_str("jumpmaster"),
            SportBits5::Boxing => f.write_str("boxing"),
        }
    }
}
impl SportBits5 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SportBits5::WaterSkiing => fit::Value::UInt8z(0x01),
            SportBits5::Kayaking => fit::Value::UInt8z(0x02),
            SportBits5::Rafting => fit::Value::UInt8z(0x04),
            SportBits5::Windsurfing => fit::Value::UInt8z(0x08),
            SportBits5::Kitesurfing => fit::Value::UInt8z(0x10),
            SportBits5::Tactical => fit::Value::UInt8z(0x20),
            SportBits5::Jumpmaster => fit::Value::UInt8z(0x40),
            SportBits5::Boxing => fit::Value::UInt8z(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for SportBits5 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(SportBits5::WaterSkiing),
            fit::Value::UInt8z(0x02) => Ok(SportBits5::Kayaking),
            fit::Value::UInt8z(0x04) => Ok(SportBits5::Rafting),
            fit::Value::UInt8z(0x08) => Ok(SportBits5::Windsurfing),
            fit::Value::UInt8z(0x10) => Ok(SportBits5::Kitesurfing),
            fit::Value::UInt8z(0x20) => Ok(SportBits5::Tactical),
            fit::Value::UInt8z(0x40) => Ok(SportBits5::Jumpmaster),
            fit::Value::UInt8z(0x80) => Ok(SportBits5::Boxing),
            _ => Err("No corresponding SportBits5 exists"),
        }
    }
}
impl TryFrom<&str> for SportBits5 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "water_skiing" => Ok(SportBits5::WaterSkiing),
            "kayaking" => Ok(SportBits5::Kayaking),
            "rafting" => Ok(SportBits5::Rafting),
            "windsurfing" => Ok(SportBits5::Windsurfing),
            "kitesurfing" => Ok(SportBits5::Kitesurfing),
            "tactical" => Ok(SportBits5::Tactical),
            "jumpmaster" => Ok(SportBits5::Jumpmaster),
            "boxing" => Ok(SportBits5::Boxing),
            _ => Err("No corresponding SportBits5 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SportBits6 {
    FloorClimbing,
}
impl fmt::Display for SportBits6 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SportBits6::FloorClimbing => f.write_str("floor_climbing"),
        }
    }
}
impl SportBits6 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SportBits6::FloorClimbing => fit::Value::UInt8z(0x01),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8z"
    }
}
impl TryFrom<&fit::Value> for SportBits6 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8z(0x01) => Ok(SportBits6::FloorClimbing),
            _ => Err("No corresponding SportBits6 exists"),
        }
    }
}
impl TryFrom<&str> for SportBits6 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "floor_climbing" => Ok(SportBits6::FloorClimbing),
            _ => Err("No corresponding SportBits6 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SubSport {
    Generic,
    /// Run/Fitness Equipment
    Treadmill,
    /// Run
    Street,
    /// Run
    Trail,
    /// Run
    Track,
    /// Cycling
    Spin,
    /// Cycling/Fitness Equipment
    IndoorCycling,
    /// Cycling
    Road,
    /// Cycling
    Mountain,
    /// Cycling
    Downhill,
    /// Cycling
    Recumbent,
    /// Cycling
    Cyclocross,
    /// Cycling
    HandCycling,
    /// Cycling
    TrackCycling,
    /// Fitness Equipment
    IndoorRowing,
    /// Fitness Equipment
    Elliptical,
    /// Fitness Equipment
    StairClimbing,
    /// Swimming
    LapSwimming,
    /// Swimming
    OpenWater,
    /// Training
    FlexibilityTraining,
    /// Training
    StrengthTraining,
    /// Tennis
    WarmUp,
    /// Tennis
    Match,
    /// Tennis
    Exercise,
    Challenge,
    /// Fitness Equipment
    IndoorSkiing,
    /// Training
    CardioTraining,
    /// Walking/Fitness Equipment
    IndoorWalking,
    /// E-Biking
    EBikeFitness,
    /// Cycling
    Bmx,
    /// Walking
    CasualWalking,
    /// Walking
    SpeedWalking,
    /// Transition
    BikeToRunTransition,
    /// Transition
    RunToBikeTransition,
    /// Transition
    SwimToBikeTransition,
    /// Motorcycling
    Atv,
    /// Motorcycling
    Motocross,
    /// Alpine Skiing/Snowboarding
    Backcountry,
    /// Alpine Skiing/Snowboarding
    Resort,
    /// Flying
    RcDrone,
    /// Flying
    Wingsuit,
    /// Kayaking/Rafting
    Whitewater,
    /// Cross Country Skiing
    SkateSkiing,
    /// Training
    Yoga,
    /// Fitness Equipment
    Pilates,
    /// Run
    IndoorRunning,
    /// Cycling
    GravelCycling,
    /// Cycling
    EBikeMountain,
    /// Cycling
    Commuting,
    /// Cycling
    MixedSurface,
    Navigate,
    TrackMe,
    Map,
    /// Diving
    SingleGasDiving,
    /// Diving
    MultiGasDiving,
    /// Diving
    GaugeDiving,
    /// Diving
    ApneaDiving,
    /// Diving
    ApneaHunting,
    VirtualActivity,
    /// Used for events where participants run, crawl through mud, climb over walls, etc.
    Obstacle,
    Breathing,
    /// Sailing
    SailRace,
    /// Ultramarathon
    Ultra,
    /// Climbing
    IndoorClimbing,
    /// Climbing
    Bouldering,
    /// High Intensity Interval Training
    Hiit,
    /// HIIT
    Amrap,
    /// HIIT
    Emom,
    /// HIIT
    Tabata,
    /// Racket
    Pickleball,
    /// Racket
    Padel,
    /// Flying
    FlyCanopy,
    /// Flying
    FlyParaglide,
    /// Flying
    FlyParamotor,
    /// Flying
    FlyPressurized,
    /// Flying
    FlyNavigate,
    /// Flying
    FlyTimer,
    /// Flying
    FlyAltimeter,
    /// Flying
    FlyWx,
    /// Flying
    FlyVfr,
    /// Flying
    FlyIfr,
    All,
}
impl fmt::Display for SubSport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SubSport::Generic => f.write_str("generic"),
            SubSport::Treadmill => f.write_str("treadmill"),
            SubSport::Street => f.write_str("street"),
            SubSport::Trail => f.write_str("trail"),
            SubSport::Track => f.write_str("track"),
            SubSport::Spin => f.write_str("spin"),
            SubSport::IndoorCycling => f.write_str("indoor_cycling"),
            SubSport::Road => f.write_str("road"),
            SubSport::Mountain => f.write_str("mountain"),
            SubSport::Downhill => f.write_str("downhill"),
            SubSport::Recumbent => f.write_str("recumbent"),
            SubSport::Cyclocross => f.write_str("cyclocross"),
            SubSport::HandCycling => f.write_str("hand_cycling"),
            SubSport::TrackCycling => f.write_str("track_cycling"),
            SubSport::IndoorRowing => f.write_str("indoor_rowing"),
            SubSport::Elliptical => f.write_str("elliptical"),
            SubSport::StairClimbing => f.write_str("stair_climbing"),
            SubSport::LapSwimming => f.write_str("lap_swimming"),
            SubSport::OpenWater => f.write_str("open_water"),
            SubSport::FlexibilityTraining => f.write_str("flexibility_training"),
            SubSport::StrengthTraining => f.write_str("strength_training"),
            SubSport::WarmUp => f.write_str("warm_up"),
            SubSport::Match => f.write_str("match"),
            SubSport::Exercise => f.write_str("exercise"),
            SubSport::Challenge => f.write_str("challenge"),
            SubSport::IndoorSkiing => f.write_str("indoor_skiing"),
            SubSport::CardioTraining => f.write_str("cardio_training"),
            SubSport::IndoorWalking => f.write_str("indoor_walking"),
            SubSport::EBikeFitness => f.write_str("e_bike_fitness"),
            SubSport::Bmx => f.write_str("bmx"),
            SubSport::CasualWalking => f.write_str("casual_walking"),
            SubSport::SpeedWalking => f.write_str("speed_walking"),
            SubSport::BikeToRunTransition => f.write_str("bike_to_run_transition"),
            SubSport::RunToBikeTransition => f.write_str("run_to_bike_transition"),
            SubSport::SwimToBikeTransition => f.write_str("swim_to_bike_transition"),
            SubSport::Atv => f.write_str("atv"),
            SubSport::Motocross => f.write_str("motocross"),
            SubSport::Backcountry => f.write_str("backcountry"),
            SubSport::Resort => f.write_str("resort"),
            SubSport::RcDrone => f.write_str("rc_drone"),
            SubSport::Wingsuit => f.write_str("wingsuit"),
            SubSport::Whitewater => f.write_str("whitewater"),
            SubSport::SkateSkiing => f.write_str("skate_skiing"),
            SubSport::Yoga => f.write_str("yoga"),
            SubSport::Pilates => f.write_str("pilates"),
            SubSport::IndoorRunning => f.write_str("indoor_running"),
            SubSport::GravelCycling => f.write_str("gravel_cycling"),
            SubSport::EBikeMountain => f.write_str("e_bike_mountain"),
            SubSport::Commuting => f.write_str("commuting"),
            SubSport::MixedSurface => f.write_str("mixed_surface"),
            SubSport::Navigate => f.write_str("navigate"),
            SubSport::TrackMe => f.write_str("track_me"),
            SubSport::Map => f.write_str("map"),
            SubSport::SingleGasDiving => f.write_str("single_gas_diving"),
            SubSport::MultiGasDiving => f.write_str("multi_gas_diving"),
            SubSport::GaugeDiving => f.write_str("gauge_diving"),
            SubSport::ApneaDiving => f.write_str("apnea_diving"),
            SubSport::ApneaHunting => f.write_str("apnea_hunting"),
            SubSport::VirtualActivity => f.write_str("virtual_activity"),
            SubSport::Obstacle => f.write_str("obstacle"),
            SubSport::Breathing => f.write_str("breathing"),
            SubSport::SailRace => f.write_str("sail_race"),
            SubSport::Ultra => f.write_str("ultra"),
            SubSport::IndoorClimbing => f.write_str("indoor_climbing"),
            SubSport::Bouldering => f.write_str("bouldering"),
            SubSport::Hiit => f.write_str("hiit"),
            SubSport::Amrap => f.write_str("amrap"),
            SubSport::Emom => f.write_str("emom"),
            SubSport::Tabata => f.write_str("tabata"),
            SubSport::Pickleball => f.write_str("pickleball"),
            SubSport::Padel => f.write_str("padel"),
            SubSport::FlyCanopy => f.write_str("fly_canopy"),
            SubSport::FlyParaglide => f.write_str("fly_paraglide"),
            SubSport::FlyParamotor => f.write_str("fly_paramotor"),
            SubSport::FlyPressurized => f.write_str("fly_pressurized"),
            SubSport::FlyNavigate => f.write_str("fly_navigate"),
            SubSport::FlyTimer => f.write_str("fly_timer"),
            SubSport::FlyAltimeter => f.write_str("fly_altimeter"),
            SubSport::FlyWx => f.write_str("fly_wx"),
            SubSport::FlyVfr => f.write_str("fly_vfr"),
            SubSport::FlyIfr => f.write_str("fly_ifr"),
            SubSport::All => f.write_str("all"),
        }
    }
}
impl SubSport {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SubSport::Generic => fit::Value::Enum(0),
            SubSport::Treadmill => fit::Value::Enum(1),
            SubSport::Street => fit::Value::Enum(2),
            SubSport::Trail => fit::Value::Enum(3),
            SubSport::Track => fit::Value::Enum(4),
            SubSport::Spin => fit::Value::Enum(5),
            SubSport::IndoorCycling => fit::Value::Enum(6),
            SubSport::Road => fit::Value::Enum(7),
            SubSport::Mountain => fit::Value::Enum(8),
            SubSport::Downhill => fit::Value::Enum(9),
            SubSport::Recumbent => fit::Value::Enum(10),
            SubSport::Cyclocross => fit::Value::Enum(11),
            SubSport::HandCycling => fit::Value::Enum(12),
            SubSport::TrackCycling => fit::Value::Enum(13),
            SubSport::IndoorRowing => fit::Value::Enum(14),
            SubSport::Elliptical => fit::Value::Enum(15),
            SubSport::StairClimbing => fit::Value::Enum(16),
            SubSport::LapSwimming => fit::Value::Enum(17),
            SubSport::OpenWater => fit::Value::Enum(18),
            SubSport::FlexibilityTraining => fit::Value::Enum(19),
            SubSport::StrengthTraining => fit::Value::Enum(20),
            SubSport::WarmUp => fit::Value::Enum(21),
            SubSport::Match => fit::Value::Enum(22),
            SubSport::Exercise => fit::Value::Enum(23),
            SubSport::Challenge => fit::Value::Enum(24),
            SubSport::IndoorSkiing => fit::Value::Enum(25),
            SubSport::CardioTraining => fit::Value::Enum(26),
            SubSport::IndoorWalking => fit::Value::Enum(27),
            SubSport::EBikeFitness => fit::Value::Enum(28),
            SubSport::Bmx => fit::Value::Enum(29),
            SubSport::CasualWalking => fit::Value::Enum(30),
            SubSport::SpeedWalking => fit::Value::Enum(31),
            SubSport::BikeToRunTransition => fit::Value::Enum(32),
            SubSport::RunToBikeTransition => fit::Value::Enum(33),
            SubSport::SwimToBikeTransition => fit::Value::Enum(34),
            SubSport::Atv => fit::Value::Enum(35),
            SubSport::Motocross => fit::Value::Enum(36),
            SubSport::Backcountry => fit::Value::Enum(37),
            SubSport::Resort => fit::Value::Enum(38),
            SubSport::RcDrone => fit::Value::Enum(39),
            SubSport::Wingsuit => fit::Value::Enum(40),
            SubSport::Whitewater => fit::Value::Enum(41),
            SubSport::SkateSkiing => fit::Value::Enum(42),
            SubSport::Yoga => fit::Value::Enum(43),
            SubSport::Pilates => fit::Value::Enum(44),
            SubSport::IndoorRunning => fit::Value::Enum(45),
            SubSport::GravelCycling => fit::Value::Enum(46),
            SubSport::EBikeMountain => fit::Value::Enum(47),
            SubSport::Commuting => fit::Value::Enum(48),
            SubSport::MixedSurface => fit::Value::Enum(49),
            SubSport::Navigate => fit::Value::Enum(50),
            SubSport::TrackMe => fit::Value::Enum(51),
            SubSport::Map => fit::Value::Enum(52),
            SubSport::SingleGasDiving => fit::Value::Enum(53),
            SubSport::MultiGasDiving => fit::Value::Enum(54),
            SubSport::GaugeDiving => fit::Value::Enum(55),
            SubSport::ApneaDiving => fit::Value::Enum(56),
            SubSport::ApneaHunting => fit::Value::Enum(57),
            SubSport::VirtualActivity => fit::Value::Enum(58),
            SubSport::Obstacle => fit::Value::Enum(59),
            SubSport::Breathing => fit::Value::Enum(62),
            SubSport::SailRace => fit::Value::Enum(65),
            SubSport::Ultra => fit::Value::Enum(67),
            SubSport::IndoorClimbing => fit::Value::Enum(68),
            SubSport::Bouldering => fit::Value::Enum(69),
            SubSport::Hiit => fit::Value::Enum(70),
            SubSport::Amrap => fit::Value::Enum(73),
            SubSport::Emom => fit::Value::Enum(74),
            SubSport::Tabata => fit::Value::Enum(75),
            SubSport::Pickleball => fit::Value::Enum(84),
            SubSport::Padel => fit::Value::Enum(85),
            SubSport::FlyCanopy => fit::Value::Enum(110),
            SubSport::FlyParaglide => fit::Value::Enum(111),
            SubSport::FlyParamotor => fit::Value::Enum(112),
            SubSport::FlyPressurized => fit::Value::Enum(113),
            SubSport::FlyNavigate => fit::Value::Enum(114),
            SubSport::FlyTimer => fit::Value::Enum(115),
            SubSport::FlyAltimeter => fit::Value::Enum(116),
            SubSport::FlyWx => fit::Value::Enum(117),
            SubSport::FlyVfr => fit::Value::Enum(118),
            SubSport::FlyIfr => fit::Value::Enum(119),
            SubSport::All => fit::Value::Enum(254),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SubSport {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SubSport::Generic),
            fit::Value::Enum(1) => Ok(SubSport::Treadmill),
            fit::Value::Enum(2) => Ok(SubSport::Street),
            fit::Value::Enum(3) => Ok(SubSport::Trail),
            fit::Value::Enum(4) => Ok(SubSport::Track),
            fit::Value::Enum(5) => Ok(SubSport::Spin),
            fit::Value::Enum(6) => Ok(SubSport::IndoorCycling),
            fit::Value::Enum(7) => Ok(SubSport::Road),
            fit::Value::Enum(8) => Ok(SubSport::Mountain),
            fit::Value::Enum(9) => Ok(SubSport::Downhill),
            fit::Value::Enum(10) => Ok(SubSport::Recumbent),
            fit::Value::Enum(11) => Ok(SubSport::Cyclocross),
            fit::Value::Enum(12) => Ok(SubSport::HandCycling),
            fit::Value::Enum(13) => Ok(SubSport::TrackCycling),
            fit::Value::Enum(14) => Ok(SubSport::IndoorRowing),
            fit::Value::Enum(15) => Ok(SubSport::Elliptical),
            fit::Value::Enum(16) => Ok(SubSport::StairClimbing),
            fit::Value::Enum(17) => Ok(SubSport::LapSwimming),
            fit::Value::Enum(18) => Ok(SubSport::OpenWater),
            fit::Value::Enum(19) => Ok(SubSport::FlexibilityTraining),
            fit::Value::Enum(20) => Ok(SubSport::StrengthTraining),
            fit::Value::Enum(21) => Ok(SubSport::WarmUp),
            fit::Value::Enum(22) => Ok(SubSport::Match),
            fit::Value::Enum(23) => Ok(SubSport::Exercise),
            fit::Value::Enum(24) => Ok(SubSport::Challenge),
            fit::Value::Enum(25) => Ok(SubSport::IndoorSkiing),
            fit::Value::Enum(26) => Ok(SubSport::CardioTraining),
            fit::Value::Enum(27) => Ok(SubSport::IndoorWalking),
            fit::Value::Enum(28) => Ok(SubSport::EBikeFitness),
            fit::Value::Enum(29) => Ok(SubSport::Bmx),
            fit::Value::Enum(30) => Ok(SubSport::CasualWalking),
            fit::Value::Enum(31) => Ok(SubSport::SpeedWalking),
            fit::Value::Enum(32) => Ok(SubSport::BikeToRunTransition),
            fit::Value::Enum(33) => Ok(SubSport::RunToBikeTransition),
            fit::Value::Enum(34) => Ok(SubSport::SwimToBikeTransition),
            fit::Value::Enum(35) => Ok(SubSport::Atv),
            fit::Value::Enum(36) => Ok(SubSport::Motocross),
            fit::Value::Enum(37) => Ok(SubSport::Backcountry),
            fit::Value::Enum(38) => Ok(SubSport::Resort),
            fit::Value::Enum(39) => Ok(SubSport::RcDrone),
            fit::Value::Enum(40) => Ok(SubSport::Wingsuit),
            fit::Value::Enum(41) => Ok(SubSport::Whitewater),
            fit::Value::Enum(42) => Ok(SubSport::SkateSkiing),
            fit::Value::Enum(43) => Ok(SubSport::Yoga),
            fit::Value::Enum(44) => Ok(SubSport::Pilates),
            fit::Value::Enum(45) => Ok(SubSport::IndoorRunning),
            fit::Value::Enum(46) => Ok(SubSport::GravelCycling),
            fit::Value::Enum(47) => Ok(SubSport::EBikeMountain),
            fit::Value::Enum(48) => Ok(SubSport::Commuting),
            fit::Value::Enum(49) => Ok(SubSport::MixedSurface),
            fit::Value::Enum(50) => Ok(SubSport::Navigate),
            fit::Value::Enum(51) => Ok(SubSport::TrackMe),
            fit::Value::Enum(52) => Ok(SubSport::Map),
            fit::Value::Enum(53) => Ok(SubSport::SingleGasDiving),
            fit::Value::Enum(54) => Ok(SubSport::MultiGasDiving),
            fit::Value::Enum(55) => Ok(SubSport::GaugeDiving),
            fit::Value::Enum(56) => Ok(SubSport::ApneaDiving),
            fit::Value::Enum(57) => Ok(SubSport::ApneaHunting),
            fit::Value::Enum(58) => Ok(SubSport::VirtualActivity),
            fit::Value::Enum(59) => Ok(SubSport::Obstacle),
            fit::Value::Enum(62) => Ok(SubSport::Breathing),
            fit::Value::Enum(65) => Ok(SubSport::SailRace),
            fit::Value::Enum(67) => Ok(SubSport::Ultra),
            fit::Value::Enum(68) => Ok(SubSport::IndoorClimbing),
            fit::Value::Enum(69) => Ok(SubSport::Bouldering),
            fit::Value::Enum(70) => Ok(SubSport::Hiit),
            fit::Value::Enum(73) => Ok(SubSport::Amrap),
            fit::Value::Enum(74) => Ok(SubSport::Emom),
            fit::Value::Enum(75) => Ok(SubSport::Tabata),
            fit::Value::Enum(84) => Ok(SubSport::Pickleball),
            fit::Value::Enum(85) => Ok(SubSport::Padel),
            fit::Value::Enum(110) => Ok(SubSport::FlyCanopy),
            fit::Value::Enum(111) => Ok(SubSport::FlyParaglide),
            fit::Value::Enum(112) => Ok(SubSport::FlyParamotor),
            fit::Value::Enum(113) => Ok(SubSport::FlyPressurized),
            fit::Value::Enum(114) => Ok(SubSport::FlyNavigate),
            fit::Value::Enum(115) => Ok(SubSport::FlyTimer),
            fit::Value::Enum(116) => Ok(SubSport::FlyAltimeter),
            fit::Value::Enum(117) => Ok(SubSport::FlyWx),
            fit::Value::Enum(118) => Ok(SubSport::FlyVfr),
            fit::Value::Enum(119) => Ok(SubSport::FlyIfr),
            fit::Value::Enum(254) => Ok(SubSport::All),
            _ => Err("No corresponding SubSport exists"),
        }
    }
}
impl TryFrom<&str> for SubSport {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "generic" => Ok(SubSport::Generic),
            "treadmill" => Ok(SubSport::Treadmill),
            "street" => Ok(SubSport::Street),
            "trail" => Ok(SubSport::Trail),
            "track" => Ok(SubSport::Track),
            "spin" => Ok(SubSport::Spin),
            "indoor_cycling" => Ok(SubSport::IndoorCycling),
            "road" => Ok(SubSport::Road),
            "mountain" => Ok(SubSport::Mountain),
            "downhill" => Ok(SubSport::Downhill),
            "recumbent" => Ok(SubSport::Recumbent),
            "cyclocross" => Ok(SubSport::Cyclocross),
            "hand_cycling" => Ok(SubSport::HandCycling),
            "track_cycling" => Ok(SubSport::TrackCycling),
            "indoor_rowing" => Ok(SubSport::IndoorRowing),
            "elliptical" => Ok(SubSport::Elliptical),
            "stair_climbing" => Ok(SubSport::StairClimbing),
            "lap_swimming" => Ok(SubSport::LapSwimming),
            "open_water" => Ok(SubSport::OpenWater),
            "flexibility_training" => Ok(SubSport::FlexibilityTraining),
            "strength_training" => Ok(SubSport::StrengthTraining),
            "warm_up" => Ok(SubSport::WarmUp),
            "match" => Ok(SubSport::Match),
            "exercise" => Ok(SubSport::Exercise),
            "challenge" => Ok(SubSport::Challenge),
            "indoor_skiing" => Ok(SubSport::IndoorSkiing),
            "cardio_training" => Ok(SubSport::CardioTraining),
            "indoor_walking" => Ok(SubSport::IndoorWalking),
            "e_bike_fitness" => Ok(SubSport::EBikeFitness),
            "bmx" => Ok(SubSport::Bmx),
            "casual_walking" => Ok(SubSport::CasualWalking),
            "speed_walking" => Ok(SubSport::SpeedWalking),
            "bike_to_run_transition" => Ok(SubSport::BikeToRunTransition),
            "run_to_bike_transition" => Ok(SubSport::RunToBikeTransition),
            "swim_to_bike_transition" => Ok(SubSport::SwimToBikeTransition),
            "atv" => Ok(SubSport::Atv),
            "motocross" => Ok(SubSport::Motocross),
            "backcountry" => Ok(SubSport::Backcountry),
            "resort" => Ok(SubSport::Resort),
            "rc_drone" => Ok(SubSport::RcDrone),
            "wingsuit" => Ok(SubSport::Wingsuit),
            "whitewater" => Ok(SubSport::Whitewater),
            "skate_skiing" => Ok(SubSport::SkateSkiing),
            "yoga" => Ok(SubSport::Yoga),
            "pilates" => Ok(SubSport::Pilates),
            "indoor_running" => Ok(SubSport::IndoorRunning),
            "gravel_cycling" => Ok(SubSport::GravelCycling),
            "e_bike_mountain" => Ok(SubSport::EBikeMountain),
            "commuting" => Ok(SubSport::Commuting),
            "mixed_surface" => Ok(SubSport::MixedSurface),
            "navigate" => Ok(SubSport::Navigate),
            "track_me" => Ok(SubSport::TrackMe),
            "map" => Ok(SubSport::Map),
            "single_gas_diving" => Ok(SubSport::SingleGasDiving),
            "multi_gas_diving" => Ok(SubSport::MultiGasDiving),
            "gauge_diving" => Ok(SubSport::GaugeDiving),
            "apnea_diving" => Ok(SubSport::ApneaDiving),
            "apnea_hunting" => Ok(SubSport::ApneaHunting),
            "virtual_activity" => Ok(SubSport::VirtualActivity),
            "obstacle" => Ok(SubSport::Obstacle),
            "breathing" => Ok(SubSport::Breathing),
            "sail_race" => Ok(SubSport::SailRace),
            "ultra" => Ok(SubSport::Ultra),
            "indoor_climbing" => Ok(SubSport::IndoorClimbing),
            "bouldering" => Ok(SubSport::Bouldering),
            "hiit" => Ok(SubSport::Hiit),
            "amrap" => Ok(SubSport::Amrap),
            "emom" => Ok(SubSport::Emom),
            "tabata" => Ok(SubSport::Tabata),
            "pickleball" => Ok(SubSport::Pickleball),
            "padel" => Ok(SubSport::Padel),
            "fly_canopy" => Ok(SubSport::FlyCanopy),
            "fly_paraglide" => Ok(SubSport::FlyParaglide),
            "fly_paramotor" => Ok(SubSport::FlyParamotor),
            "fly_pressurized" => Ok(SubSport::FlyPressurized),
            "fly_navigate" => Ok(SubSport::FlyNavigate),
            "fly_timer" => Ok(SubSport::FlyTimer),
            "fly_altimeter" => Ok(SubSport::FlyAltimeter),
            "fly_wx" => Ok(SubSport::FlyWx),
            "fly_vfr" => Ok(SubSport::FlyVfr),
            "fly_ifr" => Ok(SubSport::FlyIfr),
            "all" => Ok(SubSport::All),
            _ => Err("No corresponding SubSport exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SportEvent {
    Uncategorized,
    Geocaching,
    Fitness,
    Recreation,
    Race,
    SpecialEvent,
    Training,
    Transportation,
    Touring,
}
impl fmt::Display for SportEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SportEvent::Uncategorized => f.write_str("uncategorized"),
            SportEvent::Geocaching => f.write_str("geocaching"),
            SportEvent::Fitness => f.write_str("fitness"),
            SportEvent::Recreation => f.write_str("recreation"),
            SportEvent::Race => f.write_str("race"),
            SportEvent::SpecialEvent => f.write_str("special_event"),
            SportEvent::Training => f.write_str("training"),
            SportEvent::Transportation => f.write_str("transportation"),
            SportEvent::Touring => f.write_str("touring"),
        }
    }
}
impl SportEvent {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SportEvent::Uncategorized => fit::Value::Enum(0),
            SportEvent::Geocaching => fit::Value::Enum(1),
            SportEvent::Fitness => fit::Value::Enum(2),
            SportEvent::Recreation => fit::Value::Enum(3),
            SportEvent::Race => fit::Value::Enum(4),
            SportEvent::SpecialEvent => fit::Value::Enum(5),
            SportEvent::Training => fit::Value::Enum(6),
            SportEvent::Transportation => fit::Value::Enum(7),
            SportEvent::Touring => fit::Value::Enum(8),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SportEvent {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SportEvent::Uncategorized),
            fit::Value::Enum(1) => Ok(SportEvent::Geocaching),
            fit::Value::Enum(2) => Ok(SportEvent::Fitness),
            fit::Value::Enum(3) => Ok(SportEvent::Recreation),
            fit::Value::Enum(4) => Ok(SportEvent::Race),
            fit::Value::Enum(5) => Ok(SportEvent::SpecialEvent),
            fit::Value::Enum(6) => Ok(SportEvent::Training),
            fit::Value::Enum(7) => Ok(SportEvent::Transportation),
            fit::Value::Enum(8) => Ok(SportEvent::Touring),
            _ => Err("No corresponding SportEvent exists"),
        }
    }
}
impl TryFrom<&str> for SportEvent {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "uncategorized" => Ok(SportEvent::Uncategorized),
            "geocaching" => Ok(SportEvent::Geocaching),
            "fitness" => Ok(SportEvent::Fitness),
            "recreation" => Ok(SportEvent::Recreation),
            "race" => Ok(SportEvent::Race),
            "special_event" => Ok(SportEvent::SpecialEvent),
            "training" => Ok(SportEvent::Training),
            "transportation" => Ok(SportEvent::Transportation),
            "touring" => Ok(SportEvent::Touring),
            _ => Err("No corresponding SportEvent exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Activity {
    Manual,
    AutoMultiSport,
}
impl fmt::Display for Activity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Activity::Manual => f.write_str("manual"),
            Activity::AutoMultiSport => f.write_str("auto_multi_sport"),
        }
    }
}
impl Activity {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Activity::Manual => fit::Value::Enum(0),
            Activity::AutoMultiSport => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Activity {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Activity::Manual),
            fit::Value::Enum(1) => Ok(Activity::AutoMultiSport),
            _ => Err("No corresponding Activity exists"),
        }
    }
}
impl TryFrom<&str> for Activity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "manual" => Ok(Activity::Manual),
            "auto_multi_sport" => Ok(Activity::AutoMultiSport),
            _ => Err("No corresponding Activity exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Intensity {
    Active,
    Rest,
    Warmup,
    Cooldown,
    Recovery,
    Interval,
    Other,
}
impl fmt::Display for Intensity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Intensity::Active => f.write_str("active"),
            Intensity::Rest => f.write_str("rest"),
            Intensity::Warmup => f.write_str("warmup"),
            Intensity::Cooldown => f.write_str("cooldown"),
            Intensity::Recovery => f.write_str("recovery"),
            Intensity::Interval => f.write_str("interval"),
            Intensity::Other => f.write_str("other"),
        }
    }
}
impl Intensity {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Intensity::Active => fit::Value::Enum(0),
            Intensity::Rest => fit::Value::Enum(1),
            Intensity::Warmup => fit::Value::Enum(2),
            Intensity::Cooldown => fit::Value::Enum(3),
            Intensity::Recovery => fit::Value::Enum(4),
            Intensity::Interval => fit::Value::Enum(5),
            Intensity::Other => fit::Value::Enum(6),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Intensity {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Intensity::Active),
            fit::Value::Enum(1) => Ok(Intensity::Rest),
            fit::Value::Enum(2) => Ok(Intensity::Warmup),
            fit::Value::Enum(3) => Ok(Intensity::Cooldown),
            fit::Value::Enum(4) => Ok(Intensity::Recovery),
            fit::Value::Enum(5) => Ok(Intensity::Interval),
            fit::Value::Enum(6) => Ok(Intensity::Other),
            _ => Err("No corresponding Intensity exists"),
        }
    }
}
impl TryFrom<&str> for Intensity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "active" => Ok(Intensity::Active),
            "rest" => Ok(Intensity::Rest),
            "warmup" => Ok(Intensity::Warmup),
            "cooldown" => Ok(Intensity::Cooldown),
            "recovery" => Ok(Intensity::Recovery),
            "interval" => Ok(Intensity::Interval),
            "other" => Ok(Intensity::Other),
            _ => Err("No corresponding Intensity exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SessionTrigger {
    ActivityEnd,
    /// User changed sport.
    Manual,
    /// Auto multi-sport feature is enabled and user pressed lap button to advance session.
    AutoMultiSport,
    /// Auto sport change caused by user linking to fitness equipment.
    FitnessEquipment,
}
impl fmt::Display for SessionTrigger {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SessionTrigger::ActivityEnd => f.write_str("activity_end"),
            SessionTrigger::Manual => f.write_str("manual"),
            SessionTrigger::AutoMultiSport => f.write_str("auto_multi_sport"),
            SessionTrigger::FitnessEquipment => f.write_str("fitness_equipment"),
        }
    }
}
impl SessionTrigger {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SessionTrigger::ActivityEnd => fit::Value::Enum(0),
            SessionTrigger::Manual => fit::Value::Enum(1),
            SessionTrigger::AutoMultiSport => fit::Value::Enum(2),
            SessionTrigger::FitnessEquipment => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SessionTrigger {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SessionTrigger::ActivityEnd),
            fit::Value::Enum(1) => Ok(SessionTrigger::Manual),
            fit::Value::Enum(2) => Ok(SessionTrigger::AutoMultiSport),
            fit::Value::Enum(3) => Ok(SessionTrigger::FitnessEquipment),
            _ => Err("No corresponding SessionTrigger exists"),
        }
    }
}
impl TryFrom<&str> for SessionTrigger {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "activity_end" => Ok(SessionTrigger::ActivityEnd),
            "manual" => Ok(SessionTrigger::Manual),
            "auto_multi_sport" => Ok(SessionTrigger::AutoMultiSport),
            "fitness_equipment" => Ok(SessionTrigger::FitnessEquipment),
            _ => Err("No corresponding SessionTrigger exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum AutolapTrigger {
    Time,
    Distance,
    PositionStart,
    PositionLap,
    PositionWaypoint,
    PositionMarked,
    Off,
}
impl fmt::Display for AutolapTrigger {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AutolapTrigger::Time => f.write_str("time"),
            AutolapTrigger::Distance => f.write_str("distance"),
            AutolapTrigger::PositionStart => f.write_str("position_start"),
            AutolapTrigger::PositionLap => f.write_str("position_lap"),
            AutolapTrigger::PositionWaypoint => f.write_str("position_waypoint"),
            AutolapTrigger::PositionMarked => f.write_str("position_marked"),
            AutolapTrigger::Off => f.write_str("off"),
        }
    }
}
impl AutolapTrigger {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            AutolapTrigger::Time => fit::Value::Enum(0),
            AutolapTrigger::Distance => fit::Value::Enum(1),
            AutolapTrigger::PositionStart => fit::Value::Enum(2),
            AutolapTrigger::PositionLap => fit::Value::Enum(3),
            AutolapTrigger::PositionWaypoint => fit::Value::Enum(4),
            AutolapTrigger::PositionMarked => fit::Value::Enum(5),
            AutolapTrigger::Off => fit::Value::Enum(6),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for AutolapTrigger {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(AutolapTrigger::Time),
            fit::Value::Enum(1) => Ok(AutolapTrigger::Distance),
            fit::Value::Enum(2) => Ok(AutolapTrigger::PositionStart),
            fit::Value::Enum(3) => Ok(AutolapTrigger::PositionLap),
            fit::Value::Enum(4) => Ok(AutolapTrigger::PositionWaypoint),
            fit::Value::Enum(5) => Ok(AutolapTrigger::PositionMarked),
            fit::Value::Enum(6) => Ok(AutolapTrigger::Off),
            _ => Err("No corresponding AutolapTrigger exists"),
        }
    }
}
impl TryFrom<&str> for AutolapTrigger {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "time" => Ok(AutolapTrigger::Time),
            "distance" => Ok(AutolapTrigger::Distance),
            "position_start" => Ok(AutolapTrigger::PositionStart),
            "position_lap" => Ok(AutolapTrigger::PositionLap),
            "position_waypoint" => Ok(AutolapTrigger::PositionWaypoint),
            "position_marked" => Ok(AutolapTrigger::PositionMarked),
            "off" => Ok(AutolapTrigger::Off),
            _ => Err("No corresponding AutolapTrigger exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LapTrigger {
    Manual,
    Time,
    Distance,
    PositionStart,
    PositionLap,
    PositionWaypoint,
    PositionMarked,
    SessionEnd,
    FitnessEquipment,
}
impl fmt::Display for LapTrigger {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LapTrigger::Manual => f.write_str("manual"),
            LapTrigger::Time => f.write_str("time"),
            LapTrigger::Distance => f.write_str("distance"),
            LapTrigger::PositionStart => f.write_str("position_start"),
            LapTrigger::PositionLap => f.write_str("position_lap"),
            LapTrigger::PositionWaypoint => f.write_str("position_waypoint"),
            LapTrigger::PositionMarked => f.write_str("position_marked"),
            LapTrigger::SessionEnd => f.write_str("session_end"),
            LapTrigger::FitnessEquipment => f.write_str("fitness_equipment"),
        }
    }
}
impl LapTrigger {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LapTrigger::Manual => fit::Value::Enum(0),
            LapTrigger::Time => fit::Value::Enum(1),
            LapTrigger::Distance => fit::Value::Enum(2),
            LapTrigger::PositionStart => fit::Value::Enum(3),
            LapTrigger::PositionLap => fit::Value::Enum(4),
            LapTrigger::PositionWaypoint => fit::Value::Enum(5),
            LapTrigger::PositionMarked => fit::Value::Enum(6),
            LapTrigger::SessionEnd => fit::Value::Enum(7),
            LapTrigger::FitnessEquipment => fit::Value::Enum(8),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for LapTrigger {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(LapTrigger::Manual),
            fit::Value::Enum(1) => Ok(LapTrigger::Time),
            fit::Value::Enum(2) => Ok(LapTrigger::Distance),
            fit::Value::Enum(3) => Ok(LapTrigger::PositionStart),
            fit::Value::Enum(4) => Ok(LapTrigger::PositionLap),
            fit::Value::Enum(5) => Ok(LapTrigger::PositionWaypoint),
            fit::Value::Enum(6) => Ok(LapTrigger::PositionMarked),
            fit::Value::Enum(7) => Ok(LapTrigger::SessionEnd),
            fit::Value::Enum(8) => Ok(LapTrigger::FitnessEquipment),
            _ => Err("No corresponding LapTrigger exists"),
        }
    }
}
impl TryFrom<&str> for LapTrigger {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "manual" => Ok(LapTrigger::Manual),
            "time" => Ok(LapTrigger::Time),
            "distance" => Ok(LapTrigger::Distance),
            "position_start" => Ok(LapTrigger::PositionStart),
            "position_lap" => Ok(LapTrigger::PositionLap),
            "position_waypoint" => Ok(LapTrigger::PositionWaypoint),
            "position_marked" => Ok(LapTrigger::PositionMarked),
            "session_end" => Ok(LapTrigger::SessionEnd),
            "fitness_equipment" => Ok(LapTrigger::FitnessEquipment),
            _ => Err("No corresponding LapTrigger exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum TimeMode {
    Hour12,
    /// Does not use a leading zero and has a colon
    Hour24,
    /// Uses a leading zero and does not have a colon
    Military,
    Hour12WithSeconds,
    Hour24WithSeconds,
    Utc,
}
impl fmt::Display for TimeMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TimeMode::Hour12 => f.write_str("hour12"),
            TimeMode::Hour24 => f.write_str("hour24"),
            TimeMode::Military => f.write_str("military"),
            TimeMode::Hour12WithSeconds => f.write_str("hour_12_with_seconds"),
            TimeMode::Hour24WithSeconds => f.write_str("hour_24_with_seconds"),
            TimeMode::Utc => f.write_str("utc"),
        }
    }
}
impl TimeMode {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            TimeMode::Hour12 => fit::Value::Enum(0),
            TimeMode::Hour24 => fit::Value::Enum(1),
            TimeMode::Military => fit::Value::Enum(2),
            TimeMode::Hour12WithSeconds => fit::Value::Enum(3),
            TimeMode::Hour24WithSeconds => fit::Value::Enum(4),
            TimeMode::Utc => fit::Value::Enum(5),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for TimeMode {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(TimeMode::Hour12),
            fit::Value::Enum(1) => Ok(TimeMode::Hour24),
            fit::Value::Enum(2) => Ok(TimeMode::Military),
            fit::Value::Enum(3) => Ok(TimeMode::Hour12WithSeconds),
            fit::Value::Enum(4) => Ok(TimeMode::Hour24WithSeconds),
            fit::Value::Enum(5) => Ok(TimeMode::Utc),
            _ => Err("No corresponding TimeMode exists"),
        }
    }
}
impl TryFrom<&str> for TimeMode {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "hour12" => Ok(TimeMode::Hour12),
            "hour24" => Ok(TimeMode::Hour24),
            "military" => Ok(TimeMode::Military),
            "hour_12_with_seconds" => Ok(TimeMode::Hour12WithSeconds),
            "hour_24_with_seconds" => Ok(TimeMode::Hour24WithSeconds),
            "utc" => Ok(TimeMode::Utc),
            _ => Err("No corresponding TimeMode exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum BacklightMode {
    Off,
    Manual,
    KeyAndMessages,
    AutoBrightness,
    SmartNotifications,
    KeyAndMessagesNight,
    KeyAndMessagesAndSmartNotifications,
}
impl fmt::Display for BacklightMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BacklightMode::Off => f.write_str("off"),
            BacklightMode::Manual => f.write_str("manual"),
            BacklightMode::KeyAndMessages => f.write_str("key_and_messages"),
            BacklightMode::AutoBrightness => f.write_str("auto_brightness"),
            BacklightMode::SmartNotifications => f.write_str("smart_notifications"),
            BacklightMode::KeyAndMessagesNight => f.write_str("key_and_messages_night"),
            BacklightMode::KeyAndMessagesAndSmartNotifications => {
                f.write_str("key_and_messages_and_smart_notifications")
            }
        }
    }
}
impl BacklightMode {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            BacklightMode::Off => fit::Value::Enum(0),
            BacklightMode::Manual => fit::Value::Enum(1),
            BacklightMode::KeyAndMessages => fit::Value::Enum(2),
            BacklightMode::AutoBrightness => fit::Value::Enum(3),
            BacklightMode::SmartNotifications => fit::Value::Enum(4),
            BacklightMode::KeyAndMessagesNight => fit::Value::Enum(5),
            BacklightMode::KeyAndMessagesAndSmartNotifications => fit::Value::Enum(6),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for BacklightMode {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(BacklightMode::Off),
            fit::Value::Enum(1) => Ok(BacklightMode::Manual),
            fit::Value::Enum(2) => Ok(BacklightMode::KeyAndMessages),
            fit::Value::Enum(3) => Ok(BacklightMode::AutoBrightness),
            fit::Value::Enum(4) => Ok(BacklightMode::SmartNotifications),
            fit::Value::Enum(5) => Ok(BacklightMode::KeyAndMessagesNight),
            fit::Value::Enum(6) => Ok(BacklightMode::KeyAndMessagesAndSmartNotifications),
            _ => Err("No corresponding BacklightMode exists"),
        }
    }
}
impl TryFrom<&str> for BacklightMode {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "off" => Ok(BacklightMode::Off),
            "manual" => Ok(BacklightMode::Manual),
            "key_and_messages" => Ok(BacklightMode::KeyAndMessages),
            "auto_brightness" => Ok(BacklightMode::AutoBrightness),
            "smart_notifications" => Ok(BacklightMode::SmartNotifications),
            "key_and_messages_night" => Ok(BacklightMode::KeyAndMessagesNight),
            "key_and_messages_and_smart_notifications" => {
                Ok(BacklightMode::KeyAndMessagesAndSmartNotifications)
            }
            _ => Err("No corresponding BacklightMode exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DateMode {
    DayMonth,
    MonthDay,
}
impl fmt::Display for DateMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DateMode::DayMonth => f.write_str("day_month"),
            DateMode::MonthDay => f.write_str("month_day"),
        }
    }
}
impl DateMode {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DateMode::DayMonth => fit::Value::Enum(0),
            DateMode::MonthDay => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DateMode {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DateMode::DayMonth),
            fit::Value::Enum(1) => Ok(DateMode::MonthDay),
            _ => Err("No corresponding DateMode exists"),
        }
    }
}
impl TryFrom<&str> for DateMode {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "day_month" => Ok(DateMode::DayMonth),
            "month_day" => Ok(DateMode::MonthDay),
            _ => Err("No corresponding DateMode exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum BacklightTimeout {
    /// Backlight stays on forever.
    Infinite,
}
impl fmt::Display for BacklightTimeout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BacklightTimeout::Infinite => f.write_str("infinite"),
        }
    }
}
impl BacklightTimeout {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            BacklightTimeout::Infinite => fit::Value::UInt8(0),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for BacklightTimeout {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(0) => Ok(BacklightTimeout::Infinite),
            _ => Err("No corresponding BacklightTimeout exists"),
        }
    }
}
impl TryFrom<&str> for BacklightTimeout {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "infinite" => Ok(BacklightTimeout::Infinite),
            _ => Err("No corresponding BacklightTimeout exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Event {
    /// Group 0. Start / stop_all
    Timer,
    /// start / stop
    Workout,
    /// Start at beginning of workout. Stop at end of each step.
    WorkoutStep,
    /// stop_all group 0
    PowerDown,
    /// stop_all group 0
    PowerUp,
    /// start / stop group 0
    OffCourse,
    /// Stop at end of each session.
    Session,
    /// Stop at end of each lap.
    Lap,
    /// marker
    CoursePoint,
    /// marker
    Battery,
    /// Group 1. Start at beginning of activity if VP enabled, when VP pace is changed during activity or VP enabled mid activity. stop_disable when VP disabled.
    VirtualPartnerPace,
    /// Group 0. Start / stop when in alert condition.
    HrHighAlert,
    /// Group 0. Start / stop when in alert condition.
    HrLowAlert,
    /// Group 0. Start / stop when in alert condition.
    SpeedHighAlert,
    /// Group 0. Start / stop when in alert condition.
    SpeedLowAlert,
    /// Group 0. Start / stop when in alert condition.
    CadHighAlert,
    /// Group 0. Start / stop when in alert condition.
    CadLowAlert,
    /// Group 0. Start / stop when in alert condition.
    PowerHighAlert,
    /// Group 0. Start / stop when in alert condition.
    PowerLowAlert,
    /// marker
    RecoveryHr,
    /// marker
    BatteryLow,
    /// Group 1. Start if enabled mid activity (not required at start of activity). Stop when duration is reached. stop_disable if disabled.
    TimeDurationAlert,
    /// Group 1. Start if enabled mid activity (not required at start of activity). Stop when duration is reached. stop_disable if disabled.
    DistanceDurationAlert,
    /// Group 1. Start if enabled mid activity (not required at start of activity). Stop when duration is reached. stop_disable if disabled.
    CalorieDurationAlert,
    /// Group 1.. Stop at end of activity.
    Activity,
    /// marker
    FitnessEquipment,
    /// Stop at end of each length.
    Length,
    /// marker
    UserMarker,
    /// marker
    SportPoint,
    /// start/stop/marker
    Calibration,
    /// marker
    FrontGearChange,
    /// marker
    RearGearChange,
    /// marker
    RiderPositionChange,
    /// Group 0. Start / stop when in alert condition.
    ElevHighAlert,
    /// Group 0. Start / stop when in alert condition.
    ElevLowAlert,
    /// marker
    CommTimeout,
    /// marker
    AutoActivityDetect,
    /// marker
    DiveAlert,
    /// marker
    DiveGasSwitched,
    /// marker
    TankPressureReserve,
    /// marker
    TankPressureCritical,
    /// marker
    TankLost,
    /// start/stop/marker
    RadarThreatAlert,
    /// marker
    TankBatteryLow,
    /// marker - tank pod has connected
    TankPodConnected,
    /// marker - tank pod has lost connection
    TankPodDisconnected,
}
impl fmt::Display for Event {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Event::Timer => f.write_str("timer"),
            Event::Workout => f.write_str("workout"),
            Event::WorkoutStep => f.write_str("workout_step"),
            Event::PowerDown => f.write_str("power_down"),
            Event::PowerUp => f.write_str("power_up"),
            Event::OffCourse => f.write_str("off_course"),
            Event::Session => f.write_str("session"),
            Event::Lap => f.write_str("lap"),
            Event::CoursePoint => f.write_str("course_point"),
            Event::Battery => f.write_str("battery"),
            Event::VirtualPartnerPace => f.write_str("virtual_partner_pace"),
            Event::HrHighAlert => f.write_str("hr_high_alert"),
            Event::HrLowAlert => f.write_str("hr_low_alert"),
            Event::SpeedHighAlert => f.write_str("speed_high_alert"),
            Event::SpeedLowAlert => f.write_str("speed_low_alert"),
            Event::CadHighAlert => f.write_str("cad_high_alert"),
            Event::CadLowAlert => f.write_str("cad_low_alert"),
            Event::PowerHighAlert => f.write_str("power_high_alert"),
            Event::PowerLowAlert => f.write_str("power_low_alert"),
            Event::RecoveryHr => f.write_str("recovery_hr"),
            Event::BatteryLow => f.write_str("battery_low"),
            Event::TimeDurationAlert => f.write_str("time_duration_alert"),
            Event::DistanceDurationAlert => f.write_str("distance_duration_alert"),
            Event::CalorieDurationAlert => f.write_str("calorie_duration_alert"),
            Event::Activity => f.write_str("activity"),
            Event::FitnessEquipment => f.write_str("fitness_equipment"),
            Event::Length => f.write_str("length"),
            Event::UserMarker => f.write_str("user_marker"),
            Event::SportPoint => f.write_str("sport_point"),
            Event::Calibration => f.write_str("calibration"),
            Event::FrontGearChange => f.write_str("front_gear_change"),
            Event::RearGearChange => f.write_str("rear_gear_change"),
            Event::RiderPositionChange => f.write_str("rider_position_change"),
            Event::ElevHighAlert => f.write_str("elev_high_alert"),
            Event::ElevLowAlert => f.write_str("elev_low_alert"),
            Event::CommTimeout => f.write_str("comm_timeout"),
            Event::AutoActivityDetect => f.write_str("auto_activity_detect"),
            Event::DiveAlert => f.write_str("dive_alert"),
            Event::DiveGasSwitched => f.write_str("dive_gas_switched"),
            Event::TankPressureReserve => f.write_str("tank_pressure_reserve"),
            Event::TankPressureCritical => f.write_str("tank_pressure_critical"),
            Event::TankLost => f.write_str("tank_lost"),
            Event::RadarThreatAlert => f.write_str("radar_threat_alert"),
            Event::TankBatteryLow => f.write_str("tank_battery_low"),
            Event::TankPodConnected => f.write_str("tank_pod_connected"),
            Event::TankPodDisconnected => f.write_str("tank_pod_disconnected"),
        }
    }
}
impl Event {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Event::Timer => fit::Value::Enum(0),
            Event::Workout => fit::Value::Enum(3),
            Event::WorkoutStep => fit::Value::Enum(4),
            Event::PowerDown => fit::Value::Enum(5),
            Event::PowerUp => fit::Value::Enum(6),
            Event::OffCourse => fit::Value::Enum(7),
            Event::Session => fit::Value::Enum(8),
            Event::Lap => fit::Value::Enum(9),
            Event::CoursePoint => fit::Value::Enum(10),
            Event::Battery => fit::Value::Enum(11),
            Event::VirtualPartnerPace => fit::Value::Enum(12),
            Event::HrHighAlert => fit::Value::Enum(13),
            Event::HrLowAlert => fit::Value::Enum(14),
            Event::SpeedHighAlert => fit::Value::Enum(15),
            Event::SpeedLowAlert => fit::Value::Enum(16),
            Event::CadHighAlert => fit::Value::Enum(17),
            Event::CadLowAlert => fit::Value::Enum(18),
            Event::PowerHighAlert => fit::Value::Enum(19),
            Event::PowerLowAlert => fit::Value::Enum(20),
            Event::RecoveryHr => fit::Value::Enum(21),
            Event::BatteryLow => fit::Value::Enum(22),
            Event::TimeDurationAlert => fit::Value::Enum(23),
            Event::DistanceDurationAlert => fit::Value::Enum(24),
            Event::CalorieDurationAlert => fit::Value::Enum(25),
            Event::Activity => fit::Value::Enum(26),
            Event::FitnessEquipment => fit::Value::Enum(27),
            Event::Length => fit::Value::Enum(28),
            Event::UserMarker => fit::Value::Enum(32),
            Event::SportPoint => fit::Value::Enum(33),
            Event::Calibration => fit::Value::Enum(36),
            Event::FrontGearChange => fit::Value::Enum(42),
            Event::RearGearChange => fit::Value::Enum(43),
            Event::RiderPositionChange => fit::Value::Enum(44),
            Event::ElevHighAlert => fit::Value::Enum(45),
            Event::ElevLowAlert => fit::Value::Enum(46),
            Event::CommTimeout => fit::Value::Enum(47),
            Event::AutoActivityDetect => fit::Value::Enum(54),
            Event::DiveAlert => fit::Value::Enum(56),
            Event::DiveGasSwitched => fit::Value::Enum(57),
            Event::TankPressureReserve => fit::Value::Enum(71),
            Event::TankPressureCritical => fit::Value::Enum(72),
            Event::TankLost => fit::Value::Enum(73),
            Event::RadarThreatAlert => fit::Value::Enum(75),
            Event::TankBatteryLow => fit::Value::Enum(76),
            Event::TankPodConnected => fit::Value::Enum(81),
            Event::TankPodDisconnected => fit::Value::Enum(82),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Event {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Event::Timer),
            fit::Value::Enum(3) => Ok(Event::Workout),
            fit::Value::Enum(4) => Ok(Event::WorkoutStep),
            fit::Value::Enum(5) => Ok(Event::PowerDown),
            fit::Value::Enum(6) => Ok(Event::PowerUp),
            fit::Value::Enum(7) => Ok(Event::OffCourse),
            fit::Value::Enum(8) => Ok(Event::Session),
            fit::Value::Enum(9) => Ok(Event::Lap),
            fit::Value::Enum(10) => Ok(Event::CoursePoint),
            fit::Value::Enum(11) => Ok(Event::Battery),
            fit::Value::Enum(12) => Ok(Event::VirtualPartnerPace),
            fit::Value::Enum(13) => Ok(Event::HrHighAlert),
            fit::Value::Enum(14) => Ok(Event::HrLowAlert),
            fit::Value::Enum(15) => Ok(Event::SpeedHighAlert),
            fit::Value::Enum(16) => Ok(Event::SpeedLowAlert),
            fit::Value::Enum(17) => Ok(Event::CadHighAlert),
            fit::Value::Enum(18) => Ok(Event::CadLowAlert),
            fit::Value::Enum(19) => Ok(Event::PowerHighAlert),
            fit::Value::Enum(20) => Ok(Event::PowerLowAlert),
            fit::Value::Enum(21) => Ok(Event::RecoveryHr),
            fit::Value::Enum(22) => Ok(Event::BatteryLow),
            fit::Value::Enum(23) => Ok(Event::TimeDurationAlert),
            fit::Value::Enum(24) => Ok(Event::DistanceDurationAlert),
            fit::Value::Enum(25) => Ok(Event::CalorieDurationAlert),
            fit::Value::Enum(26) => Ok(Event::Activity),
            fit::Value::Enum(27) => Ok(Event::FitnessEquipment),
            fit::Value::Enum(28) => Ok(Event::Length),
            fit::Value::Enum(32) => Ok(Event::UserMarker),
            fit::Value::Enum(33) => Ok(Event::SportPoint),
            fit::Value::Enum(36) => Ok(Event::Calibration),
            fit::Value::Enum(42) => Ok(Event::FrontGearChange),
            fit::Value::Enum(43) => Ok(Event::RearGearChange),
            fit::Value::Enum(44) => Ok(Event::RiderPositionChange),
            fit::Value::Enum(45) => Ok(Event::ElevHighAlert),
            fit::Value::Enum(46) => Ok(Event::ElevLowAlert),
            fit::Value::Enum(47) => Ok(Event::CommTimeout),
            fit::Value::Enum(54) => Ok(Event::AutoActivityDetect),
            fit::Value::Enum(56) => Ok(Event::DiveAlert),
            fit::Value::Enum(57) => Ok(Event::DiveGasSwitched),
            fit::Value::Enum(71) => Ok(Event::TankPressureReserve),
            fit::Value::Enum(72) => Ok(Event::TankPressureCritical),
            fit::Value::Enum(73) => Ok(Event::TankLost),
            fit::Value::Enum(75) => Ok(Event::RadarThreatAlert),
            fit::Value::Enum(76) => Ok(Event::TankBatteryLow),
            fit::Value::Enum(81) => Ok(Event::TankPodConnected),
            fit::Value::Enum(82) => Ok(Event::TankPodDisconnected),
            _ => Err("No corresponding Event exists"),
        }
    }
}
impl TryFrom<&str> for Event {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "timer" => Ok(Event::Timer),
            "workout" => Ok(Event::Workout),
            "workout_step" => Ok(Event::WorkoutStep),
            "power_down" => Ok(Event::PowerDown),
            "power_up" => Ok(Event::PowerUp),
            "off_course" => Ok(Event::OffCourse),
            "session" => Ok(Event::Session),
            "lap" => Ok(Event::Lap),
            "course_point" => Ok(Event::CoursePoint),
            "battery" => Ok(Event::Battery),
            "virtual_partner_pace" => Ok(Event::VirtualPartnerPace),
            "hr_high_alert" => Ok(Event::HrHighAlert),
            "hr_low_alert" => Ok(Event::HrLowAlert),
            "speed_high_alert" => Ok(Event::SpeedHighAlert),
            "speed_low_alert" => Ok(Event::SpeedLowAlert),
            "cad_high_alert" => Ok(Event::CadHighAlert),
            "cad_low_alert" => Ok(Event::CadLowAlert),
            "power_high_alert" => Ok(Event::PowerHighAlert),
            "power_low_alert" => Ok(Event::PowerLowAlert),
            "recovery_hr" => Ok(Event::RecoveryHr),
            "battery_low" => Ok(Event::BatteryLow),
            "time_duration_alert" => Ok(Event::TimeDurationAlert),
            "distance_duration_alert" => Ok(Event::DistanceDurationAlert),
            "calorie_duration_alert" => Ok(Event::CalorieDurationAlert),
            "activity" => Ok(Event::Activity),
            "fitness_equipment" => Ok(Event::FitnessEquipment),
            "length" => Ok(Event::Length),
            "user_marker" => Ok(Event::UserMarker),
            "sport_point" => Ok(Event::SportPoint),
            "calibration" => Ok(Event::Calibration),
            "front_gear_change" => Ok(Event::FrontGearChange),
            "rear_gear_change" => Ok(Event::RearGearChange),
            "rider_position_change" => Ok(Event::RiderPositionChange),
            "elev_high_alert" => Ok(Event::ElevHighAlert),
            "elev_low_alert" => Ok(Event::ElevLowAlert),
            "comm_timeout" => Ok(Event::CommTimeout),
            "auto_activity_detect" => Ok(Event::AutoActivityDetect),
            "dive_alert" => Ok(Event::DiveAlert),
            "dive_gas_switched" => Ok(Event::DiveGasSwitched),
            "tank_pressure_reserve" => Ok(Event::TankPressureReserve),
            "tank_pressure_critical" => Ok(Event::TankPressureCritical),
            "tank_lost" => Ok(Event::TankLost),
            "radar_threat_alert" => Ok(Event::RadarThreatAlert),
            "tank_battery_low" => Ok(Event::TankBatteryLow),
            "tank_pod_connected" => Ok(Event::TankPodConnected),
            "tank_pod_disconnected" => Ok(Event::TankPodDisconnected),
            _ => Err("No corresponding Event exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum EventType {
    Start,
    Stop,
    ConsecutiveDepreciated,
    Marker,
    StopAll,
    BeginDepreciated,
    EndDepreciated,
    EndAllDepreciated,
    StopDisable,
    StopDisableAll,
}
impl fmt::Display for EventType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            EventType::Start => f.write_str("start"),
            EventType::Stop => f.write_str("stop"),
            EventType::ConsecutiveDepreciated => f.write_str("consecutive_depreciated"),
            EventType::Marker => f.write_str("marker"),
            EventType::StopAll => f.write_str("stop_all"),
            EventType::BeginDepreciated => f.write_str("begin_depreciated"),
            EventType::EndDepreciated => f.write_str("end_depreciated"),
            EventType::EndAllDepreciated => f.write_str("end_all_depreciated"),
            EventType::StopDisable => f.write_str("stop_disable"),
            EventType::StopDisableAll => f.write_str("stop_disable_all"),
        }
    }
}
impl EventType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            EventType::Start => fit::Value::Enum(0),
            EventType::Stop => fit::Value::Enum(1),
            EventType::ConsecutiveDepreciated => fit::Value::Enum(2),
            EventType::Marker => fit::Value::Enum(3),
            EventType::StopAll => fit::Value::Enum(4),
            EventType::BeginDepreciated => fit::Value::Enum(5),
            EventType::EndDepreciated => fit::Value::Enum(6),
            EventType::EndAllDepreciated => fit::Value::Enum(7),
            EventType::StopDisable => fit::Value::Enum(8),
            EventType::StopDisableAll => fit::Value::Enum(9),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for EventType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(EventType::Start),
            fit::Value::Enum(1) => Ok(EventType::Stop),
            fit::Value::Enum(2) => Ok(EventType::ConsecutiveDepreciated),
            fit::Value::Enum(3) => Ok(EventType::Marker),
            fit::Value::Enum(4) => Ok(EventType::StopAll),
            fit::Value::Enum(5) => Ok(EventType::BeginDepreciated),
            fit::Value::Enum(6) => Ok(EventType::EndDepreciated),
            fit::Value::Enum(7) => Ok(EventType::EndAllDepreciated),
            fit::Value::Enum(8) => Ok(EventType::StopDisable),
            fit::Value::Enum(9) => Ok(EventType::StopDisableAll),
            _ => Err("No corresponding EventType exists"),
        }
    }
}
impl TryFrom<&str> for EventType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "start" => Ok(EventType::Start),
            "stop" => Ok(EventType::Stop),
            "consecutive_depreciated" => Ok(EventType::ConsecutiveDepreciated),
            "marker" => Ok(EventType::Marker),
            "stop_all" => Ok(EventType::StopAll),
            "begin_depreciated" => Ok(EventType::BeginDepreciated),
            "end_depreciated" => Ok(EventType::EndDepreciated),
            "end_all_depreciated" => Ok(EventType::EndAllDepreciated),
            "stop_disable" => Ok(EventType::StopDisable),
            "stop_disable_all" => Ok(EventType::StopDisableAll),
            _ => Err("No corresponding EventType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum TimerTrigger {
    Manual,
    Auto,
    FitnessEquipment,
}
impl fmt::Display for TimerTrigger {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TimerTrigger::Manual => f.write_str("manual"),
            TimerTrigger::Auto => f.write_str("auto"),
            TimerTrigger::FitnessEquipment => f.write_str("fitness_equipment"),
        }
    }
}
impl TimerTrigger {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            TimerTrigger::Manual => fit::Value::Enum(0),
            TimerTrigger::Auto => fit::Value::Enum(1),
            TimerTrigger::FitnessEquipment => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for TimerTrigger {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(TimerTrigger::Manual),
            fit::Value::Enum(1) => Ok(TimerTrigger::Auto),
            fit::Value::Enum(2) => Ok(TimerTrigger::FitnessEquipment),
            _ => Err("No corresponding TimerTrigger exists"),
        }
    }
}
impl TryFrom<&str> for TimerTrigger {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "manual" => Ok(TimerTrigger::Manual),
            "auto" => Ok(TimerTrigger::Auto),
            "fitness_equipment" => Ok(TimerTrigger::FitnessEquipment),
            _ => Err("No corresponding TimerTrigger exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum FitnessEquipmentState {
    Ready,
    InUse,
    Paused,
    /// lost connection to fitness equipment
    Unknown,
}
impl fmt::Display for FitnessEquipmentState {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitnessEquipmentState::Ready => f.write_str("ready"),
            FitnessEquipmentState::InUse => f.write_str("in_use"),
            FitnessEquipmentState::Paused => f.write_str("paused"),
            FitnessEquipmentState::Unknown => f.write_str("unknown"),
        }
    }
}
impl FitnessEquipmentState {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            FitnessEquipmentState::Ready => fit::Value::Enum(0),
            FitnessEquipmentState::InUse => fit::Value::Enum(1),
            FitnessEquipmentState::Paused => fit::Value::Enum(2),
            FitnessEquipmentState::Unknown => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for FitnessEquipmentState {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(FitnessEquipmentState::Ready),
            fit::Value::Enum(1) => Ok(FitnessEquipmentState::InUse),
            fit::Value::Enum(2) => Ok(FitnessEquipmentState::Paused),
            fit::Value::Enum(3) => Ok(FitnessEquipmentState::Unknown),
            _ => Err("No corresponding FitnessEquipmentState exists"),
        }
    }
}
impl TryFrom<&str> for FitnessEquipmentState {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "ready" => Ok(FitnessEquipmentState::Ready),
            "in_use" => Ok(FitnessEquipmentState::InUse),
            "paused" => Ok(FitnessEquipmentState::Paused),
            "unknown" => Ok(FitnessEquipmentState::Unknown),
            _ => Err("No corresponding FitnessEquipmentState exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Tone {
    Off,
    Tone,
    Vibrate,
    ToneAndVibrate,
}
impl fmt::Display for Tone {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Tone::Off => f.write_str("off"),
            Tone::Tone => f.write_str("tone"),
            Tone::Vibrate => f.write_str("vibrate"),
            Tone::ToneAndVibrate => f.write_str("tone_and_vibrate"),
        }
    }
}
impl Tone {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Tone::Off => fit::Value::Enum(0),
            Tone::Tone => fit::Value::Enum(1),
            Tone::Vibrate => fit::Value::Enum(2),
            Tone::ToneAndVibrate => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Tone {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Tone::Off),
            fit::Value::Enum(1) => Ok(Tone::Tone),
            fit::Value::Enum(2) => Ok(Tone::Vibrate),
            fit::Value::Enum(3) => Ok(Tone::ToneAndVibrate),
            _ => Err("No corresponding Tone exists"),
        }
    }
}
impl TryFrom<&str> for Tone {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "off" => Ok(Tone::Off),
            "tone" => Ok(Tone::Tone),
            "vibrate" => Ok(Tone::Vibrate),
            "tone_and_vibrate" => Ok(Tone::ToneAndVibrate),
            _ => Err("No corresponding Tone exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Autoscroll {
    None,
    Slow,
    Medium,
    Fast,
}
impl fmt::Display for Autoscroll {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Autoscroll::None => f.write_str("none"),
            Autoscroll::Slow => f.write_str("slow"),
            Autoscroll::Medium => f.write_str("medium"),
            Autoscroll::Fast => f.write_str("fast"),
        }
    }
}
impl Autoscroll {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Autoscroll::None => fit::Value::Enum(0),
            Autoscroll::Slow => fit::Value::Enum(1),
            Autoscroll::Medium => fit::Value::Enum(2),
            Autoscroll::Fast => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Autoscroll {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Autoscroll::None),
            fit::Value::Enum(1) => Ok(Autoscroll::Slow),
            fit::Value::Enum(2) => Ok(Autoscroll::Medium),
            fit::Value::Enum(3) => Ok(Autoscroll::Fast),
            _ => Err("No corresponding Autoscroll exists"),
        }
    }
}
impl TryFrom<&str> for Autoscroll {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "none" => Ok(Autoscroll::None),
            "slow" => Ok(Autoscroll::Slow),
            "medium" => Ok(Autoscroll::Medium),
            "fast" => Ok(Autoscroll::Fast),
            _ => Err("No corresponding Autoscroll exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ActivityClass {
    /// 0 to 100
    Level,
    LevelMax,
    Athlete,
}
impl fmt::Display for ActivityClass {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ActivityClass::Level => f.write_str("level"),
            ActivityClass::LevelMax => f.write_str("level_max"),
            ActivityClass::Athlete => f.write_str("athlete"),
        }
    }
}
impl ActivityClass {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ActivityClass::Level => fit::Value::Enum(0x7F),
            ActivityClass::LevelMax => fit::Value::Enum(100),
            ActivityClass::Athlete => fit::Value::Enum(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for ActivityClass {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0x7F) => Ok(ActivityClass::Level),
            fit::Value::Enum(100) => Ok(ActivityClass::LevelMax),
            fit::Value::Enum(0x80) => Ok(ActivityClass::Athlete),
            _ => Err("No corresponding ActivityClass exists"),
        }
    }
}
impl TryFrom<&str> for ActivityClass {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "level" => Ok(ActivityClass::Level),
            "level_max" => Ok(ActivityClass::LevelMax),
            "athlete" => Ok(ActivityClass::Athlete),
            _ => Err("No corresponding ActivityClass exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum HrZoneCalc {
    Custom,
    PercentMaxHr,
    PercentHrr,
    PercentLthr,
}
impl fmt::Display for HrZoneCalc {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            HrZoneCalc::Custom => f.write_str("custom"),
            HrZoneCalc::PercentMaxHr => f.write_str("percent_max_hr"),
            HrZoneCalc::PercentHrr => f.write_str("percent_hrr"),
            HrZoneCalc::PercentLthr => f.write_str("percent_lthr"),
        }
    }
}
impl HrZoneCalc {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            HrZoneCalc::Custom => fit::Value::Enum(0),
            HrZoneCalc::PercentMaxHr => fit::Value::Enum(1),
            HrZoneCalc::PercentHrr => fit::Value::Enum(2),
            HrZoneCalc::PercentLthr => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for HrZoneCalc {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(HrZoneCalc::Custom),
            fit::Value::Enum(1) => Ok(HrZoneCalc::PercentMaxHr),
            fit::Value::Enum(2) => Ok(HrZoneCalc::PercentHrr),
            fit::Value::Enum(3) => Ok(HrZoneCalc::PercentLthr),
            _ => Err("No corresponding HrZoneCalc exists"),
        }
    }
}
impl TryFrom<&str> for HrZoneCalc {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "custom" => Ok(HrZoneCalc::Custom),
            "percent_max_hr" => Ok(HrZoneCalc::PercentMaxHr),
            "percent_hrr" => Ok(HrZoneCalc::PercentHrr),
            "percent_lthr" => Ok(HrZoneCalc::PercentLthr),
            _ => Err("No corresponding HrZoneCalc exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum PwrZoneCalc {
    Custom,
    PercentFtp,
}
impl fmt::Display for PwrZoneCalc {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PwrZoneCalc::Custom => f.write_str("custom"),
            PwrZoneCalc::PercentFtp => f.write_str("percent_ftp"),
        }
    }
}
impl PwrZoneCalc {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            PwrZoneCalc::Custom => fit::Value::Enum(0),
            PwrZoneCalc::PercentFtp => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for PwrZoneCalc {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(PwrZoneCalc::Custom),
            fit::Value::Enum(1) => Ok(PwrZoneCalc::PercentFtp),
            _ => Err("No corresponding PwrZoneCalc exists"),
        }
    }
}
impl TryFrom<&str> for PwrZoneCalc {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "custom" => Ok(PwrZoneCalc::Custom),
            "percent_ftp" => Ok(PwrZoneCalc::PercentFtp),
            _ => Err("No corresponding PwrZoneCalc exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WktStepDuration {
    Time,
    Distance,
    HrLessThan,
    HrGreaterThan,
    Calories,
    Open,
    RepeatUntilStepsCmplt,
    RepeatUntilTime,
    RepeatUntilDistance,
    RepeatUntilCalories,
    RepeatUntilHrLessThan,
    RepeatUntilHrGreaterThan,
    RepeatUntilPowerLessThan,
    RepeatUntilPowerGreaterThan,
    PowerLessThan,
    PowerGreaterThan,
    TrainingPeaksTss,
    RepeatUntilPowerLastLapLessThan,
    RepeatUntilMaxPowerLastLapLessThan,
    Power3sLessThan,
    Power10sLessThan,
    Power30sLessThan,
    Power3sGreaterThan,
    Power10sGreaterThan,
    Power30sGreaterThan,
    PowerLapLessThan,
    PowerLapGreaterThan,
    RepeatUntilTrainingPeaksTss,
    RepetitionTime,
    Reps,
    TimeOnly,
}
impl fmt::Display for WktStepDuration {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WktStepDuration::Time => f.write_str("time"),
            WktStepDuration::Distance => f.write_str("distance"),
            WktStepDuration::HrLessThan => f.write_str("hr_less_than"),
            WktStepDuration::HrGreaterThan => f.write_str("hr_greater_than"),
            WktStepDuration::Calories => f.write_str("calories"),
            WktStepDuration::Open => f.write_str("open"),
            WktStepDuration::RepeatUntilStepsCmplt => f.write_str("repeat_until_steps_cmplt"),
            WktStepDuration::RepeatUntilTime => f.write_str("repeat_until_time"),
            WktStepDuration::RepeatUntilDistance => f.write_str("repeat_until_distance"),
            WktStepDuration::RepeatUntilCalories => f.write_str("repeat_until_calories"),
            WktStepDuration::RepeatUntilHrLessThan => f.write_str("repeat_until_hr_less_than"),
            WktStepDuration::RepeatUntilHrGreaterThan => {
                f.write_str("repeat_until_hr_greater_than")
            }
            WktStepDuration::RepeatUntilPowerLessThan => {
                f.write_str("repeat_until_power_less_than")
            }
            WktStepDuration::RepeatUntilPowerGreaterThan => {
                f.write_str("repeat_until_power_greater_than")
            }
            WktStepDuration::PowerLessThan => f.write_str("power_less_than"),
            WktStepDuration::PowerGreaterThan => f.write_str("power_greater_than"),
            WktStepDuration::TrainingPeaksTss => f.write_str("training_peaks_tss"),
            WktStepDuration::RepeatUntilPowerLastLapLessThan => {
                f.write_str("repeat_until_power_last_lap_less_than")
            }
            WktStepDuration::RepeatUntilMaxPowerLastLapLessThan => {
                f.write_str("repeat_until_max_power_last_lap_less_than")
            }
            WktStepDuration::Power3sLessThan => f.write_str("power_3s_less_than"),
            WktStepDuration::Power10sLessThan => f.write_str("power_10s_less_than"),
            WktStepDuration::Power30sLessThan => f.write_str("power_30s_less_than"),
            WktStepDuration::Power3sGreaterThan => f.write_str("power_3s_greater_than"),
            WktStepDuration::Power10sGreaterThan => f.write_str("power_10s_greater_than"),
            WktStepDuration::Power30sGreaterThan => f.write_str("power_30s_greater_than"),
            WktStepDuration::PowerLapLessThan => f.write_str("power_lap_less_than"),
            WktStepDuration::PowerLapGreaterThan => f.write_str("power_lap_greater_than"),
            WktStepDuration::RepeatUntilTrainingPeaksTss => {
                f.write_str("repeat_until_training_peaks_tss")
            }
            WktStepDuration::RepetitionTime => f.write_str("repetition_time"),
            WktStepDuration::Reps => f.write_str("reps"),
            WktStepDuration::TimeOnly => f.write_str("time_only"),
        }
    }
}
impl WktStepDuration {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WktStepDuration::Time => fit::Value::Enum(0),
            WktStepDuration::Distance => fit::Value::Enum(1),
            WktStepDuration::HrLessThan => fit::Value::Enum(2),
            WktStepDuration::HrGreaterThan => fit::Value::Enum(3),
            WktStepDuration::Calories => fit::Value::Enum(4),
            WktStepDuration::Open => fit::Value::Enum(5),
            WktStepDuration::RepeatUntilStepsCmplt => fit::Value::Enum(6),
            WktStepDuration::RepeatUntilTime => fit::Value::Enum(7),
            WktStepDuration::RepeatUntilDistance => fit::Value::Enum(8),
            WktStepDuration::RepeatUntilCalories => fit::Value::Enum(9),
            WktStepDuration::RepeatUntilHrLessThan => fit::Value::Enum(10),
            WktStepDuration::RepeatUntilHrGreaterThan => fit::Value::Enum(11),
            WktStepDuration::RepeatUntilPowerLessThan => fit::Value::Enum(12),
            WktStepDuration::RepeatUntilPowerGreaterThan => fit::Value::Enum(13),
            WktStepDuration::PowerLessThan => fit::Value::Enum(14),
            WktStepDuration::PowerGreaterThan => fit::Value::Enum(15),
            WktStepDuration::TrainingPeaksTss => fit::Value::Enum(16),
            WktStepDuration::RepeatUntilPowerLastLapLessThan => fit::Value::Enum(17),
            WktStepDuration::RepeatUntilMaxPowerLastLapLessThan => fit::Value::Enum(18),
            WktStepDuration::Power3sLessThan => fit::Value::Enum(19),
            WktStepDuration::Power10sLessThan => fit::Value::Enum(20),
            WktStepDuration::Power30sLessThan => fit::Value::Enum(21),
            WktStepDuration::Power3sGreaterThan => fit::Value::Enum(22),
            WktStepDuration::Power10sGreaterThan => fit::Value::Enum(23),
            WktStepDuration::Power30sGreaterThan => fit::Value::Enum(24),
            WktStepDuration::PowerLapLessThan => fit::Value::Enum(25),
            WktStepDuration::PowerLapGreaterThan => fit::Value::Enum(26),
            WktStepDuration::RepeatUntilTrainingPeaksTss => fit::Value::Enum(27),
            WktStepDuration::RepetitionTime => fit::Value::Enum(28),
            WktStepDuration::Reps => fit::Value::Enum(29),
            WktStepDuration::TimeOnly => fit::Value::Enum(31),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for WktStepDuration {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(WktStepDuration::Time),
            fit::Value::Enum(1) => Ok(WktStepDuration::Distance),
            fit::Value::Enum(2) => Ok(WktStepDuration::HrLessThan),
            fit::Value::Enum(3) => Ok(WktStepDuration::HrGreaterThan),
            fit::Value::Enum(4) => Ok(WktStepDuration::Calories),
            fit::Value::Enum(5) => Ok(WktStepDuration::Open),
            fit::Value::Enum(6) => Ok(WktStepDuration::RepeatUntilStepsCmplt),
            fit::Value::Enum(7) => Ok(WktStepDuration::RepeatUntilTime),
            fit::Value::Enum(8) => Ok(WktStepDuration::RepeatUntilDistance),
            fit::Value::Enum(9) => Ok(WktStepDuration::RepeatUntilCalories),
            fit::Value::Enum(10) => Ok(WktStepDuration::RepeatUntilHrLessThan),
            fit::Value::Enum(11) => Ok(WktStepDuration::RepeatUntilHrGreaterThan),
            fit::Value::Enum(12) => Ok(WktStepDuration::RepeatUntilPowerLessThan),
            fit::Value::Enum(13) => Ok(WktStepDuration::RepeatUntilPowerGreaterThan),
            fit::Value::Enum(14) => Ok(WktStepDuration::PowerLessThan),
            fit::Value::Enum(15) => Ok(WktStepDuration::PowerGreaterThan),
            fit::Value::Enum(16) => Ok(WktStepDuration::TrainingPeaksTss),
            fit::Value::Enum(17) => Ok(WktStepDuration::RepeatUntilPowerLastLapLessThan),
            fit::Value::Enum(18) => Ok(WktStepDuration::RepeatUntilMaxPowerLastLapLessThan),
            fit::Value::Enum(19) => Ok(WktStepDuration::Power3sLessThan),
            fit::Value::Enum(20) => Ok(WktStepDuration::Power10sLessThan),
            fit::Value::Enum(21) => Ok(WktStepDuration::Power30sLessThan),
            fit::Value::Enum(22) => Ok(WktStepDuration::Power3sGreaterThan),
            fit::Value::Enum(23) => Ok(WktStepDuration::Power10sGreaterThan),
            fit::Value::Enum(24) => Ok(WktStepDuration::Power30sGreaterThan),
            fit::Value::Enum(25) => Ok(WktStepDuration::PowerLapLessThan),
            fit::Value::Enum(26) => Ok(WktStepDuration::PowerLapGreaterThan),
            fit::Value::Enum(27) => Ok(WktStepDuration::RepeatUntilTrainingPeaksTss),
            fit::Value::Enum(28) => Ok(WktStepDuration::RepetitionTime),
            fit::Value::Enum(29) => Ok(WktStepDuration::Reps),
            fit::Value::Enum(31) => Ok(WktStepDuration::TimeOnly),
            _ => Err("No corresponding WktStepDuration exists"),
        }
    }
}
impl TryFrom<&str> for WktStepDuration {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "time" => Ok(WktStepDuration::Time),
            "distance" => Ok(WktStepDuration::Distance),
            "hr_less_than" => Ok(WktStepDuration::HrLessThan),
            "hr_greater_than" => Ok(WktStepDuration::HrGreaterThan),
            "calories" => Ok(WktStepDuration::Calories),
            "open" => Ok(WktStepDuration::Open),
            "repeat_until_steps_cmplt" => Ok(WktStepDuration::RepeatUntilStepsCmplt),
            "repeat_until_time" => Ok(WktStepDuration::RepeatUntilTime),
            "repeat_until_distance" => Ok(WktStepDuration::RepeatUntilDistance),
            "repeat_until_calories" => Ok(WktStepDuration::RepeatUntilCalories),
            "repeat_until_hr_less_than" => Ok(WktStepDuration::RepeatUntilHrLessThan),
            "repeat_until_hr_greater_than" => Ok(WktStepDuration::RepeatUntilHrGreaterThan),
            "repeat_until_power_less_than" => Ok(WktStepDuration::RepeatUntilPowerLessThan),
            "repeat_until_power_greater_than" => Ok(WktStepDuration::RepeatUntilPowerGreaterThan),
            "power_less_than" => Ok(WktStepDuration::PowerLessThan),
            "power_greater_than" => Ok(WktStepDuration::PowerGreaterThan),
            "training_peaks_tss" => Ok(WktStepDuration::TrainingPeaksTss),
            "repeat_until_power_last_lap_less_than" => {
                Ok(WktStepDuration::RepeatUntilPowerLastLapLessThan)
            }
            "repeat_until_max_power_last_lap_less_than" => {
                Ok(WktStepDuration::RepeatUntilMaxPowerLastLapLessThan)
            }
            "power_3s_less_than" => Ok(WktStepDuration::Power3sLessThan),
            "power_10s_less_than" => Ok(WktStepDuration::Power10sLessThan),
            "power_30s_less_than" => Ok(WktStepDuration::Power30sLessThan),
            "power_3s_greater_than" => Ok(WktStepDuration::Power3sGreaterThan),
            "power_10s_greater_than" => Ok(WktStepDuration::Power10sGreaterThan),
            "power_30s_greater_than" => Ok(WktStepDuration::Power30sGreaterThan),
            "power_lap_less_than" => Ok(WktStepDuration::PowerLapLessThan),
            "power_lap_greater_than" => Ok(WktStepDuration::PowerLapGreaterThan),
            "repeat_until_training_peaks_tss" => Ok(WktStepDuration::RepeatUntilTrainingPeaksTss),
            "repetition_time" => Ok(WktStepDuration::RepetitionTime),
            "reps" => Ok(WktStepDuration::Reps),
            "time_only" => Ok(WktStepDuration::TimeOnly),
            _ => Err("No corresponding WktStepDuration exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WktStepTarget {
    Speed,
    HeartRate,
    Open,
    Cadence,
    Power,
    Grade,
    Resistance,
    Power3s,
    Power10s,
    Power30s,
    PowerLap,
    SwimStroke,
    SpeedLap,
    HeartRateLap,
}
impl fmt::Display for WktStepTarget {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WktStepTarget::Speed => f.write_str("speed"),
            WktStepTarget::HeartRate => f.write_str("heart_rate"),
            WktStepTarget::Open => f.write_str("open"),
            WktStepTarget::Cadence => f.write_str("cadence"),
            WktStepTarget::Power => f.write_str("power"),
            WktStepTarget::Grade => f.write_str("grade"),
            WktStepTarget::Resistance => f.write_str("resistance"),
            WktStepTarget::Power3s => f.write_str("power_3s"),
            WktStepTarget::Power10s => f.write_str("power_10s"),
            WktStepTarget::Power30s => f.write_str("power_30s"),
            WktStepTarget::PowerLap => f.write_str("power_lap"),
            WktStepTarget::SwimStroke => f.write_str("swim_stroke"),
            WktStepTarget::SpeedLap => f.write_str("speed_lap"),
            WktStepTarget::HeartRateLap => f.write_str("heart_rate_lap"),
        }
    }
}
impl WktStepTarget {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WktStepTarget::Speed => fit::Value::Enum(0),
            WktStepTarget::HeartRate => fit::Value::Enum(1),
            WktStepTarget::Open => fit::Value::Enum(2),
            WktStepTarget::Cadence => fit::Value::Enum(3),
            WktStepTarget::Power => fit::Value::Enum(4),
            WktStepTarget::Grade => fit::Value::Enum(5),
            WktStepTarget::Resistance => fit::Value::Enum(6),
            WktStepTarget::Power3s => fit::Value::Enum(7),
            WktStepTarget::Power10s => fit::Value::Enum(8),
            WktStepTarget::Power30s => fit::Value::Enum(9),
            WktStepTarget::PowerLap => fit::Value::Enum(10),
            WktStepTarget::SwimStroke => fit::Value::Enum(11),
            WktStepTarget::SpeedLap => fit::Value::Enum(12),
            WktStepTarget::HeartRateLap => fit::Value::Enum(13),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for WktStepTarget {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(WktStepTarget::Speed),
            fit::Value::Enum(1) => Ok(WktStepTarget::HeartRate),
            fit::Value::Enum(2) => Ok(WktStepTarget::Open),
            fit::Value::Enum(3) => Ok(WktStepTarget::Cadence),
            fit::Value::Enum(4) => Ok(WktStepTarget::Power),
            fit::Value::Enum(5) => Ok(WktStepTarget::Grade),
            fit::Value::Enum(6) => Ok(WktStepTarget::Resistance),
            fit::Value::Enum(7) => Ok(WktStepTarget::Power3s),
            fit::Value::Enum(8) => Ok(WktStepTarget::Power10s),
            fit::Value::Enum(9) => Ok(WktStepTarget::Power30s),
            fit::Value::Enum(10) => Ok(WktStepTarget::PowerLap),
            fit::Value::Enum(11) => Ok(WktStepTarget::SwimStroke),
            fit::Value::Enum(12) => Ok(WktStepTarget::SpeedLap),
            fit::Value::Enum(13) => Ok(WktStepTarget::HeartRateLap),
            _ => Err("No corresponding WktStepTarget exists"),
        }
    }
}
impl TryFrom<&str> for WktStepTarget {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "speed" => Ok(WktStepTarget::Speed),
            "heart_rate" => Ok(WktStepTarget::HeartRate),
            "open" => Ok(WktStepTarget::Open),
            "cadence" => Ok(WktStepTarget::Cadence),
            "power" => Ok(WktStepTarget::Power),
            "grade" => Ok(WktStepTarget::Grade),
            "resistance" => Ok(WktStepTarget::Resistance),
            "power_3s" => Ok(WktStepTarget::Power3s),
            "power_10s" => Ok(WktStepTarget::Power10s),
            "power_30s" => Ok(WktStepTarget::Power30s),
            "power_lap" => Ok(WktStepTarget::PowerLap),
            "swim_stroke" => Ok(WktStepTarget::SwimStroke),
            "speed_lap" => Ok(WktStepTarget::SpeedLap),
            "heart_rate_lap" => Ok(WktStepTarget::HeartRateLap),
            _ => Err("No corresponding WktStepTarget exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Goal {
    Time,
    Distance,
    Calories,
    Frequency,
    Steps,
    Ascent,
    ActiveMinutes,
}
impl fmt::Display for Goal {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Goal::Time => f.write_str("time"),
            Goal::Distance => f.write_str("distance"),
            Goal::Calories => f.write_str("calories"),
            Goal::Frequency => f.write_str("frequency"),
            Goal::Steps => f.write_str("steps"),
            Goal::Ascent => f.write_str("ascent"),
            Goal::ActiveMinutes => f.write_str("active_minutes"),
        }
    }
}
impl Goal {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Goal::Time => fit::Value::Enum(0),
            Goal::Distance => fit::Value::Enum(1),
            Goal::Calories => fit::Value::Enum(2),
            Goal::Frequency => fit::Value::Enum(3),
            Goal::Steps => fit::Value::Enum(4),
            Goal::Ascent => fit::Value::Enum(5),
            Goal::ActiveMinutes => fit::Value::Enum(6),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Goal {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Goal::Time),
            fit::Value::Enum(1) => Ok(Goal::Distance),
            fit::Value::Enum(2) => Ok(Goal::Calories),
            fit::Value::Enum(3) => Ok(Goal::Frequency),
            fit::Value::Enum(4) => Ok(Goal::Steps),
            fit::Value::Enum(5) => Ok(Goal::Ascent),
            fit::Value::Enum(6) => Ok(Goal::ActiveMinutes),
            _ => Err("No corresponding Goal exists"),
        }
    }
}
impl TryFrom<&str> for Goal {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "time" => Ok(Goal::Time),
            "distance" => Ok(Goal::Distance),
            "calories" => Ok(Goal::Calories),
            "frequency" => Ok(Goal::Frequency),
            "steps" => Ok(Goal::Steps),
            "ascent" => Ok(Goal::Ascent),
            "active_minutes" => Ok(Goal::ActiveMinutes),
            _ => Err("No corresponding Goal exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum GoalRecurrence {
    Off,
    Daily,
    Weekly,
    Monthly,
    Yearly,
    Custom,
}
impl fmt::Display for GoalRecurrence {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            GoalRecurrence::Off => f.write_str("off"),
            GoalRecurrence::Daily => f.write_str("daily"),
            GoalRecurrence::Weekly => f.write_str("weekly"),
            GoalRecurrence::Monthly => f.write_str("monthly"),
            GoalRecurrence::Yearly => f.write_str("yearly"),
            GoalRecurrence::Custom => f.write_str("custom"),
        }
    }
}
impl GoalRecurrence {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            GoalRecurrence::Off => fit::Value::Enum(0),
            GoalRecurrence::Daily => fit::Value::Enum(1),
            GoalRecurrence::Weekly => fit::Value::Enum(2),
            GoalRecurrence::Monthly => fit::Value::Enum(3),
            GoalRecurrence::Yearly => fit::Value::Enum(4),
            GoalRecurrence::Custom => fit::Value::Enum(5),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for GoalRecurrence {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(GoalRecurrence::Off),
            fit::Value::Enum(1) => Ok(GoalRecurrence::Daily),
            fit::Value::Enum(2) => Ok(GoalRecurrence::Weekly),
            fit::Value::Enum(3) => Ok(GoalRecurrence::Monthly),
            fit::Value::Enum(4) => Ok(GoalRecurrence::Yearly),
            fit::Value::Enum(5) => Ok(GoalRecurrence::Custom),
            _ => Err("No corresponding GoalRecurrence exists"),
        }
    }
}
impl TryFrom<&str> for GoalRecurrence {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "off" => Ok(GoalRecurrence::Off),
            "daily" => Ok(GoalRecurrence::Daily),
            "weekly" => Ok(GoalRecurrence::Weekly),
            "monthly" => Ok(GoalRecurrence::Monthly),
            "yearly" => Ok(GoalRecurrence::Yearly),
            "custom" => Ok(GoalRecurrence::Custom),
            _ => Err("No corresponding GoalRecurrence exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum GoalSource {
    /// Device generated
    Auto,
    /// Social network sourced goal
    Community,
    /// Manually generated
    User,
}
impl fmt::Display for GoalSource {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            GoalSource::Auto => f.write_str("auto"),
            GoalSource::Community => f.write_str("community"),
            GoalSource::User => f.write_str("user"),
        }
    }
}
impl GoalSource {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            GoalSource::Auto => fit::Value::Enum(0),
            GoalSource::Community => fit::Value::Enum(1),
            GoalSource::User => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for GoalSource {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(GoalSource::Auto),
            fit::Value::Enum(1) => Ok(GoalSource::Community),
            fit::Value::Enum(2) => Ok(GoalSource::User),
            _ => Err("No corresponding GoalSource exists"),
        }
    }
}
impl TryFrom<&str> for GoalSource {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "auto" => Ok(GoalSource::Auto),
            "community" => Ok(GoalSource::Community),
            "user" => Ok(GoalSource::User),
            _ => Err("No corresponding GoalSource exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Schedule {
    Workout,
    Course,
}
impl fmt::Display for Schedule {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Schedule::Workout => f.write_str("workout"),
            Schedule::Course => f.write_str("course"),
        }
    }
}
impl Schedule {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Schedule::Workout => fit::Value::Enum(0),
            Schedule::Course => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Schedule {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Schedule::Workout),
            fit::Value::Enum(1) => Ok(Schedule::Course),
            _ => Err("No corresponding Schedule exists"),
        }
    }
}
impl TryFrom<&str> for Schedule {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "workout" => Ok(Schedule::Workout),
            "course" => Ok(Schedule::Course),
            _ => Err("No corresponding Schedule exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CoursePoint {
    Generic,
    Summit,
    Valley,
    Water,
    Food,
    Danger,
    Left,
    Right,
    Straight,
    FirstAid,
    FourthCategory,
    ThirdCategory,
    SecondCategory,
    FirstCategory,
    HorsCategory,
    Sprint,
    LeftFork,
    RightFork,
    MiddleFork,
    SlightLeft,
    SharpLeft,
    SlightRight,
    SharpRight,
    UTurn,
    SegmentStart,
    SegmentEnd,
    Campsite,
    AidStation,
    RestArea,
    /// Used with UpAhead
    GeneralDistance,
    Service,
    EnergyGel,
    SportsDrink,
    MileMarker,
    Checkpoint,
    Shelter,
    MeetingSpot,
    Overlook,
    Toilet,
    Shower,
    Gear,
    SharpCurve,
    SteepIncline,
    Tunnel,
    Bridge,
    Obstacle,
    Crossing,
    Store,
    Transition,
    Navaid,
    Transport,
    Alert,
    Info,
}
impl fmt::Display for CoursePoint {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CoursePoint::Generic => f.write_str("generic"),
            CoursePoint::Summit => f.write_str("summit"),
            CoursePoint::Valley => f.write_str("valley"),
            CoursePoint::Water => f.write_str("water"),
            CoursePoint::Food => f.write_str("food"),
            CoursePoint::Danger => f.write_str("danger"),
            CoursePoint::Left => f.write_str("left"),
            CoursePoint::Right => f.write_str("right"),
            CoursePoint::Straight => f.write_str("straight"),
            CoursePoint::FirstAid => f.write_str("first_aid"),
            CoursePoint::FourthCategory => f.write_str("fourth_category"),
            CoursePoint::ThirdCategory => f.write_str("third_category"),
            CoursePoint::SecondCategory => f.write_str("second_category"),
            CoursePoint::FirstCategory => f.write_str("first_category"),
            CoursePoint::HorsCategory => f.write_str("hors_category"),
            CoursePoint::Sprint => f.write_str("sprint"),
            CoursePoint::LeftFork => f.write_str("left_fork"),
            CoursePoint::RightFork => f.write_str("right_fork"),
            CoursePoint::MiddleFork => f.write_str("middle_fork"),
            CoursePoint::SlightLeft => f.write_str("slight_left"),
            CoursePoint::SharpLeft => f.write_str("sharp_left"),
            CoursePoint::SlightRight => f.write_str("slight_right"),
            CoursePoint::SharpRight => f.write_str("sharp_right"),
            CoursePoint::UTurn => f.write_str("u_turn"),
            CoursePoint::SegmentStart => f.write_str("segment_start"),
            CoursePoint::SegmentEnd => f.write_str("segment_end"),
            CoursePoint::Campsite => f.write_str("campsite"),
            CoursePoint::AidStation => f.write_str("aid_station"),
            CoursePoint::RestArea => f.write_str("rest_area"),
            CoursePoint::GeneralDistance => f.write_str("general_distance"),
            CoursePoint::Service => f.write_str("service"),
            CoursePoint::EnergyGel => f.write_str("energy_gel"),
            CoursePoint::SportsDrink => f.write_str("sports_drink"),
            CoursePoint::MileMarker => f.write_str("mile_marker"),
            CoursePoint::Checkpoint => f.write_str("checkpoint"),
            CoursePoint::Shelter => f.write_str("shelter"),
            CoursePoint::MeetingSpot => f.write_str("meeting_spot"),
            CoursePoint::Overlook => f.write_str("overlook"),
            CoursePoint::Toilet => f.write_str("toilet"),
            CoursePoint::Shower => f.write_str("shower"),
            CoursePoint::Gear => f.write_str("gear"),
            CoursePoint::SharpCurve => f.write_str("sharp_curve"),
            CoursePoint::SteepIncline => f.write_str("steep_incline"),
            CoursePoint::Tunnel => f.write_str("tunnel"),
            CoursePoint::Bridge => f.write_str("bridge"),
            CoursePoint::Obstacle => f.write_str("obstacle"),
            CoursePoint::Crossing => f.write_str("crossing"),
            CoursePoint::Store => f.write_str("store"),
            CoursePoint::Transition => f.write_str("transition"),
            CoursePoint::Navaid => f.write_str("navaid"),
            CoursePoint::Transport => f.write_str("transport"),
            CoursePoint::Alert => f.write_str("alert"),
            CoursePoint::Info => f.write_str("info"),
        }
    }
}
impl CoursePoint {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CoursePoint::Generic => fit::Value::Enum(0),
            CoursePoint::Summit => fit::Value::Enum(1),
            CoursePoint::Valley => fit::Value::Enum(2),
            CoursePoint::Water => fit::Value::Enum(3),
            CoursePoint::Food => fit::Value::Enum(4),
            CoursePoint::Danger => fit::Value::Enum(5),
            CoursePoint::Left => fit::Value::Enum(6),
            CoursePoint::Right => fit::Value::Enum(7),
            CoursePoint::Straight => fit::Value::Enum(8),
            CoursePoint::FirstAid => fit::Value::Enum(9),
            CoursePoint::FourthCategory => fit::Value::Enum(10),
            CoursePoint::ThirdCategory => fit::Value::Enum(11),
            CoursePoint::SecondCategory => fit::Value::Enum(12),
            CoursePoint::FirstCategory => fit::Value::Enum(13),
            CoursePoint::HorsCategory => fit::Value::Enum(14),
            CoursePoint::Sprint => fit::Value::Enum(15),
            CoursePoint::LeftFork => fit::Value::Enum(16),
            CoursePoint::RightFork => fit::Value::Enum(17),
            CoursePoint::MiddleFork => fit::Value::Enum(18),
            CoursePoint::SlightLeft => fit::Value::Enum(19),
            CoursePoint::SharpLeft => fit::Value::Enum(20),
            CoursePoint::SlightRight => fit::Value::Enum(21),
            CoursePoint::SharpRight => fit::Value::Enum(22),
            CoursePoint::UTurn => fit::Value::Enum(23),
            CoursePoint::SegmentStart => fit::Value::Enum(24),
            CoursePoint::SegmentEnd => fit::Value::Enum(25),
            CoursePoint::Campsite => fit::Value::Enum(27),
            CoursePoint::AidStation => fit::Value::Enum(28),
            CoursePoint::RestArea => fit::Value::Enum(29),
            CoursePoint::GeneralDistance => fit::Value::Enum(30),
            CoursePoint::Service => fit::Value::Enum(31),
            CoursePoint::EnergyGel => fit::Value::Enum(32),
            CoursePoint::SportsDrink => fit::Value::Enum(33),
            CoursePoint::MileMarker => fit::Value::Enum(34),
            CoursePoint::Checkpoint => fit::Value::Enum(35),
            CoursePoint::Shelter => fit::Value::Enum(36),
            CoursePoint::MeetingSpot => fit::Value::Enum(37),
            CoursePoint::Overlook => fit::Value::Enum(38),
            CoursePoint::Toilet => fit::Value::Enum(39),
            CoursePoint::Shower => fit::Value::Enum(40),
            CoursePoint::Gear => fit::Value::Enum(41),
            CoursePoint::SharpCurve => fit::Value::Enum(42),
            CoursePoint::SteepIncline => fit::Value::Enum(43),
            CoursePoint::Tunnel => fit::Value::Enum(44),
            CoursePoint::Bridge => fit::Value::Enum(45),
            CoursePoint::Obstacle => fit::Value::Enum(46),
            CoursePoint::Crossing => fit::Value::Enum(47),
            CoursePoint::Store => fit::Value::Enum(48),
            CoursePoint::Transition => fit::Value::Enum(49),
            CoursePoint::Navaid => fit::Value::Enum(50),
            CoursePoint::Transport => fit::Value::Enum(51),
            CoursePoint::Alert => fit::Value::Enum(52),
            CoursePoint::Info => fit::Value::Enum(53),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for CoursePoint {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(CoursePoint::Generic),
            fit::Value::Enum(1) => Ok(CoursePoint::Summit),
            fit::Value::Enum(2) => Ok(CoursePoint::Valley),
            fit::Value::Enum(3) => Ok(CoursePoint::Water),
            fit::Value::Enum(4) => Ok(CoursePoint::Food),
            fit::Value::Enum(5) => Ok(CoursePoint::Danger),
            fit::Value::Enum(6) => Ok(CoursePoint::Left),
            fit::Value::Enum(7) => Ok(CoursePoint::Right),
            fit::Value::Enum(8) => Ok(CoursePoint::Straight),
            fit::Value::Enum(9) => Ok(CoursePoint::FirstAid),
            fit::Value::Enum(10) => Ok(CoursePoint::FourthCategory),
            fit::Value::Enum(11) => Ok(CoursePoint::ThirdCategory),
            fit::Value::Enum(12) => Ok(CoursePoint::SecondCategory),
            fit::Value::Enum(13) => Ok(CoursePoint::FirstCategory),
            fit::Value::Enum(14) => Ok(CoursePoint::HorsCategory),
            fit::Value::Enum(15) => Ok(CoursePoint::Sprint),
            fit::Value::Enum(16) => Ok(CoursePoint::LeftFork),
            fit::Value::Enum(17) => Ok(CoursePoint::RightFork),
            fit::Value::Enum(18) => Ok(CoursePoint::MiddleFork),
            fit::Value::Enum(19) => Ok(CoursePoint::SlightLeft),
            fit::Value::Enum(20) => Ok(CoursePoint::SharpLeft),
            fit::Value::Enum(21) => Ok(CoursePoint::SlightRight),
            fit::Value::Enum(22) => Ok(CoursePoint::SharpRight),
            fit::Value::Enum(23) => Ok(CoursePoint::UTurn),
            fit::Value::Enum(24) => Ok(CoursePoint::SegmentStart),
            fit::Value::Enum(25) => Ok(CoursePoint::SegmentEnd),
            fit::Value::Enum(27) => Ok(CoursePoint::Campsite),
            fit::Value::Enum(28) => Ok(CoursePoint::AidStation),
            fit::Value::Enum(29) => Ok(CoursePoint::RestArea),
            fit::Value::Enum(30) => Ok(CoursePoint::GeneralDistance),
            fit::Value::Enum(31) => Ok(CoursePoint::Service),
            fit::Value::Enum(32) => Ok(CoursePoint::EnergyGel),
            fit::Value::Enum(33) => Ok(CoursePoint::SportsDrink),
            fit::Value::Enum(34) => Ok(CoursePoint::MileMarker),
            fit::Value::Enum(35) => Ok(CoursePoint::Checkpoint),
            fit::Value::Enum(36) => Ok(CoursePoint::Shelter),
            fit::Value::Enum(37) => Ok(CoursePoint::MeetingSpot),
            fit::Value::Enum(38) => Ok(CoursePoint::Overlook),
            fit::Value::Enum(39) => Ok(CoursePoint::Toilet),
            fit::Value::Enum(40) => Ok(CoursePoint::Shower),
            fit::Value::Enum(41) => Ok(CoursePoint::Gear),
            fit::Value::Enum(42) => Ok(CoursePoint::SharpCurve),
            fit::Value::Enum(43) => Ok(CoursePoint::SteepIncline),
            fit::Value::Enum(44) => Ok(CoursePoint::Tunnel),
            fit::Value::Enum(45) => Ok(CoursePoint::Bridge),
            fit::Value::Enum(46) => Ok(CoursePoint::Obstacle),
            fit::Value::Enum(47) => Ok(CoursePoint::Crossing),
            fit::Value::Enum(48) => Ok(CoursePoint::Store),
            fit::Value::Enum(49) => Ok(CoursePoint::Transition),
            fit::Value::Enum(50) => Ok(CoursePoint::Navaid),
            fit::Value::Enum(51) => Ok(CoursePoint::Transport),
            fit::Value::Enum(52) => Ok(CoursePoint::Alert),
            fit::Value::Enum(53) => Ok(CoursePoint::Info),
            _ => Err("No corresponding CoursePoint exists"),
        }
    }
}
impl TryFrom<&str> for CoursePoint {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "generic" => Ok(CoursePoint::Generic),
            "summit" => Ok(CoursePoint::Summit),
            "valley" => Ok(CoursePoint::Valley),
            "water" => Ok(CoursePoint::Water),
            "food" => Ok(CoursePoint::Food),
            "danger" => Ok(CoursePoint::Danger),
            "left" => Ok(CoursePoint::Left),
            "right" => Ok(CoursePoint::Right),
            "straight" => Ok(CoursePoint::Straight),
            "first_aid" => Ok(CoursePoint::FirstAid),
            "fourth_category" => Ok(CoursePoint::FourthCategory),
            "third_category" => Ok(CoursePoint::ThirdCategory),
            "second_category" => Ok(CoursePoint::SecondCategory),
            "first_category" => Ok(CoursePoint::FirstCategory),
            "hors_category" => Ok(CoursePoint::HorsCategory),
            "sprint" => Ok(CoursePoint::Sprint),
            "left_fork" => Ok(CoursePoint::LeftFork),
            "right_fork" => Ok(CoursePoint::RightFork),
            "middle_fork" => Ok(CoursePoint::MiddleFork),
            "slight_left" => Ok(CoursePoint::SlightLeft),
            "sharp_left" => Ok(CoursePoint::SharpLeft),
            "slight_right" => Ok(CoursePoint::SlightRight),
            "sharp_right" => Ok(CoursePoint::SharpRight),
            "u_turn" => Ok(CoursePoint::UTurn),
            "segment_start" => Ok(CoursePoint::SegmentStart),
            "segment_end" => Ok(CoursePoint::SegmentEnd),
            "campsite" => Ok(CoursePoint::Campsite),
            "aid_station" => Ok(CoursePoint::AidStation),
            "rest_area" => Ok(CoursePoint::RestArea),
            "general_distance" => Ok(CoursePoint::GeneralDistance),
            "service" => Ok(CoursePoint::Service),
            "energy_gel" => Ok(CoursePoint::EnergyGel),
            "sports_drink" => Ok(CoursePoint::SportsDrink),
            "mile_marker" => Ok(CoursePoint::MileMarker),
            "checkpoint" => Ok(CoursePoint::Checkpoint),
            "shelter" => Ok(CoursePoint::Shelter),
            "meeting_spot" => Ok(CoursePoint::MeetingSpot),
            "overlook" => Ok(CoursePoint::Overlook),
            "toilet" => Ok(CoursePoint::Toilet),
            "shower" => Ok(CoursePoint::Shower),
            "gear" => Ok(CoursePoint::Gear),
            "sharp_curve" => Ok(CoursePoint::SharpCurve),
            "steep_incline" => Ok(CoursePoint::SteepIncline),
            "tunnel" => Ok(CoursePoint::Tunnel),
            "bridge" => Ok(CoursePoint::Bridge),
            "obstacle" => Ok(CoursePoint::Obstacle),
            "crossing" => Ok(CoursePoint::Crossing),
            "store" => Ok(CoursePoint::Store),
            "transition" => Ok(CoursePoint::Transition),
            "navaid" => Ok(CoursePoint::Navaid),
            "transport" => Ok(CoursePoint::Transport),
            "alert" => Ok(CoursePoint::Alert),
            "info" => Ok(CoursePoint::Info),
            _ => Err("No corresponding CoursePoint exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Manufacturer {
    Garmin,
    /// Do not use. Used by FR405 for ANTFS man id.
    GarminFr405Antfs,
    Zephyr,
    Dayton,
    Idt,
    Srm,
    Quarq,
    Ibike,
    Saris,
    SparkHk,
    Tanita,
    Echowell,
    DynastreamOem,
    Nautilus,
    Dynastream,
    Timex,
    Metrigear,
    Xelic,
    Beurer,
    Cardiosport,
    AAndD,
    Hmm,
    Suunto,
    ThitaElektronik,
    Gpulse,
    CleanMobile,
    PedalBrain,
    Peaksware,
    Saxonar,
    LemondFitness,
    Dexcom,
    WahooFitness,
    OctaneFitness,
    Archinoetics,
    TheHurtBox,
    CitizenSystems,
    Magellan,
    Osynce,
    Holux,
    Concept2,
    Shimano,
    OneGiantLeap,
    AceSensor,
    BrimBrothers,
    Xplova,
    PerceptionDigital,
    Bf1systems,
    Pioneer,
    Spantec,
    Metalogics,
    N4iiiis,
    SeikoEpson,
    SeikoEpsonOem,
    IforPowell,
    MaxwellGuider,
    StarTrac,
    Breakaway,
    AlatechTechnologyLtd,
    MioTechnologyEurope,
    Rotor,
    Geonaute,
    IdBike,
    Specialized,
    Wtek,
    PhysicalEnterprises,
    NorthPoleEngineering,
    Bkool,
    Cateye,
    StagesCycling,
    Sigmasport,
    Tomtom,
    Peripedal,
    Wattbike,
    Moxy,
    Ciclosport,
    Powerbahn,
    AcornProjectsAps,
    Lifebeam,
    Bontrager,
    Wellgo,
    Scosche,
    Magura,
    Woodway,
    Elite,
    NielsenKellerman,
    DkCity,
    Tacx,
    DirectionTechnology,
    Magtonic,
    N1partcarbon,
    InsideRideTechnologies,
    SoundOfMotion,
    Stryd,
    /// Indoorcycling Group
    Icg,
    MiPulse,
    BsxAthletics,
    Look,
    CampagnoloSrl,
    BodyBikeSmart,
    Praxisworks,
    /// Limits Technology Ltd.
    LimitsTechnology,
    /// TopAction Technology Inc.
    TopactionTechnology,
    Cosinuss,
    Fitcare,
    Magene,
    GiantManufacturingCo,
    /// Tigrasport
    Tigrasport,
    Salutron,
    Technogym,
    BrytonSensors,
    LatitudeLimited,
    SoaringTechnology,
    Igpsport,
    Thinkrider,
    GopherSport,
    Waterrower,
    Orangetheory,
    Inpeak,
    Kinetic,
    JohnsonHealthTech,
    PolarElectro,
    Seesense,
    NciTechnology,
    Iqsquare,
    Leomo,
    IfitCom,
    CorosByte,
    VersaDesign,
    Chileaf,
    Cycplus,
    GravaaByte,
    Sigeyi,
    Coospo,
    Geoid,
    Bosch,
    Kyto,
    KineticSports,
    DecathlonByte,
    TqSystems,
    TagHeuer,
    KeiserFitness,
    ZwiftByte,
    PorscheEp,
    Blackbird,
    MeilanByte,
    Ezon,
    Development,
    Healthandlife,
    Lezyne,
    ScribeLabs,
    Zwift,
    Watteam,
    Recon,
    FaveroElectronics,
    Dynovelo,
    Strava,
    /// Amer Sports
    Precor,
    Bryton,
    Sram,
    /// MiTAC Global Corporation (Mio Technology)
    Navman,
    /// COBI GmbH
    Cobi,
    Spivi,
    MioMagellan,
    Evesports,
    SensitivusGauge,
    Podoon,
    LifeTimeFitness,
    /// Falco eMotors Inc.
    FalcoEMotors,
    Minoura,
    Cycliq,
    Luxottica,
    TrainerRoad,
    TheSufferfest,
    Fullspeedahead,
    Virtualtraining,
    Feedbacksports,
    Omata,
    Vdo,
    Magneticdays,
    Hammerhead,
    KineticByKurt,
    Shapelog,
    Dabuziduo,
    Jetblack,
    Coros,
    Virtugo,
    Velosense,
    Cycligentinc,
    Trailforks,
    MahleEbikemotion,
    Nurvv,
    Microprogram,
    Zone5cloud,
    Greenteg,
    YamahaMotors,
    Whoop,
    Gravaa,
    Onelap,
    MonarkExercise,
    Form,
    Decathlon,
    Syncros,
    Heatup,
    Cannondale,
    TrueFitness,
    RGTCycling,
    Vasa,
    RaceRepublic,
    Fazua,
    OrekaTraining,
    /// Lishun Electric & Communication
    Lsec,
    LululemonStudio,
    Shanyue,
    SpinningMda,
    Hilldating,
    Actigraphcorp,
}
impl fmt::Display for Manufacturer {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Manufacturer::Garmin => f.write_str("garmin"),
            Manufacturer::GarminFr405Antfs => f.write_str("garmin_fr405_antfs"),
            Manufacturer::Zephyr => f.write_str("zephyr"),
            Manufacturer::Dayton => f.write_str("dayton"),
            Manufacturer::Idt => f.write_str("idt"),
            Manufacturer::Srm => f.write_str("srm"),
            Manufacturer::Quarq => f.write_str("quarq"),
            Manufacturer::Ibike => f.write_str("ibike"),
            Manufacturer::Saris => f.write_str("saris"),
            Manufacturer::SparkHk => f.write_str("spark_hk"),
            Manufacturer::Tanita => f.write_str("tanita"),
            Manufacturer::Echowell => f.write_str("echowell"),
            Manufacturer::DynastreamOem => f.write_str("dynastream_oem"),
            Manufacturer::Nautilus => f.write_str("nautilus"),
            Manufacturer::Dynastream => f.write_str("dynastream"),
            Manufacturer::Timex => f.write_str("timex"),
            Manufacturer::Metrigear => f.write_str("metrigear"),
            Manufacturer::Xelic => f.write_str("xelic"),
            Manufacturer::Beurer => f.write_str("beurer"),
            Manufacturer::Cardiosport => f.write_str("cardiosport"),
            Manufacturer::AAndD => f.write_str("a_and_d"),
            Manufacturer::Hmm => f.write_str("hmm"),
            Manufacturer::Suunto => f.write_str("suunto"),
            Manufacturer::ThitaElektronik => f.write_str("thita_elektronik"),
            Manufacturer::Gpulse => f.write_str("gpulse"),
            Manufacturer::CleanMobile => f.write_str("clean_mobile"),
            Manufacturer::PedalBrain => f.write_str("pedal_brain"),
            Manufacturer::Peaksware => f.write_str("peaksware"),
            Manufacturer::Saxonar => f.write_str("saxonar"),
            Manufacturer::LemondFitness => f.write_str("lemond_fitness"),
            Manufacturer::Dexcom => f.write_str("dexcom"),
            Manufacturer::WahooFitness => f.write_str("wahoo_fitness"),
            Manufacturer::OctaneFitness => f.write_str("octane_fitness"),
            Manufacturer::Archinoetics => f.write_str("archinoetics"),
            Manufacturer::TheHurtBox => f.write_str("the_hurt_box"),
            Manufacturer::CitizenSystems => f.write_str("citizen_systems"),
            Manufacturer::Magellan => f.write_str("magellan"),
            Manufacturer::Osynce => f.write_str("osynce"),
            Manufacturer::Holux => f.write_str("holux"),
            Manufacturer::Concept2 => f.write_str("concept2"),
            Manufacturer::Shimano => f.write_str("shimano"),
            Manufacturer::OneGiantLeap => f.write_str("one_giant_leap"),
            Manufacturer::AceSensor => f.write_str("ace_sensor"),
            Manufacturer::BrimBrothers => f.write_str("brim_brothers"),
            Manufacturer::Xplova => f.write_str("xplova"),
            Manufacturer::PerceptionDigital => f.write_str("perception_digital"),
            Manufacturer::Bf1systems => f.write_str("bf1systems"),
            Manufacturer::Pioneer => f.write_str("pioneer"),
            Manufacturer::Spantec => f.write_str("spantec"),
            Manufacturer::Metalogics => f.write_str("metalogics"),
            Manufacturer::N4iiiis => f.write_str("4iiiis"),
            Manufacturer::SeikoEpson => f.write_str("seiko_epson"),
            Manufacturer::SeikoEpsonOem => f.write_str("seiko_epson_oem"),
            Manufacturer::IforPowell => f.write_str("ifor_powell"),
            Manufacturer::MaxwellGuider => f.write_str("maxwell_guider"),
            Manufacturer::StarTrac => f.write_str("star_trac"),
            Manufacturer::Breakaway => f.write_str("breakaway"),
            Manufacturer::AlatechTechnologyLtd => f.write_str("alatech_technology_ltd"),
            Manufacturer::MioTechnologyEurope => f.write_str("mio_technology_europe"),
            Manufacturer::Rotor => f.write_str("rotor"),
            Manufacturer::Geonaute => f.write_str("geonaute"),
            Manufacturer::IdBike => f.write_str("id_bike"),
            Manufacturer::Specialized => f.write_str("specialized"),
            Manufacturer::Wtek => f.write_str("wtek"),
            Manufacturer::PhysicalEnterprises => f.write_str("physical_enterprises"),
            Manufacturer::NorthPoleEngineering => f.write_str("north_pole_engineering"),
            Manufacturer::Bkool => f.write_str("bkool"),
            Manufacturer::Cateye => f.write_str("cateye"),
            Manufacturer::StagesCycling => f.write_str("stages_cycling"),
            Manufacturer::Sigmasport => f.write_str("sigmasport"),
            Manufacturer::Tomtom => f.write_str("tomtom"),
            Manufacturer::Peripedal => f.write_str("peripedal"),
            Manufacturer::Wattbike => f.write_str("wattbike"),
            Manufacturer::Moxy => f.write_str("moxy"),
            Manufacturer::Ciclosport => f.write_str("ciclosport"),
            Manufacturer::Powerbahn => f.write_str("powerbahn"),
            Manufacturer::AcornProjectsAps => f.write_str("acorn_projects_aps"),
            Manufacturer::Lifebeam => f.write_str("lifebeam"),
            Manufacturer::Bontrager => f.write_str("bontrager"),
            Manufacturer::Wellgo => f.write_str("wellgo"),
            Manufacturer::Scosche => f.write_str("scosche"),
            Manufacturer::Magura => f.write_str("magura"),
            Manufacturer::Woodway => f.write_str("woodway"),
            Manufacturer::Elite => f.write_str("elite"),
            Manufacturer::NielsenKellerman => f.write_str("nielsen_kellerman"),
            Manufacturer::DkCity => f.write_str("dk_city"),
            Manufacturer::Tacx => f.write_str("tacx"),
            Manufacturer::DirectionTechnology => f.write_str("direction_technology"),
            Manufacturer::Magtonic => f.write_str("magtonic"),
            Manufacturer::N1partcarbon => f.write_str("1partcarbon"),
            Manufacturer::InsideRideTechnologies => f.write_str("inside_ride_technologies"),
            Manufacturer::SoundOfMotion => f.write_str("sound_of_motion"),
            Manufacturer::Stryd => f.write_str("stryd"),
            Manufacturer::Icg => f.write_str("icg"),
            Manufacturer::MiPulse => f.write_str("MiPulse"),
            Manufacturer::BsxAthletics => f.write_str("bsx_athletics"),
            Manufacturer::Look => f.write_str("look"),
            Manufacturer::CampagnoloSrl => f.write_str("campagnolo_srl"),
            Manufacturer::BodyBikeSmart => f.write_str("body_bike_smart"),
            Manufacturer::Praxisworks => f.write_str("praxisworks"),
            Manufacturer::LimitsTechnology => f.write_str("limits_technology"),
            Manufacturer::TopactionTechnology => f.write_str("topaction_technology"),
            Manufacturer::Cosinuss => f.write_str("cosinuss"),
            Manufacturer::Fitcare => f.write_str("fitcare"),
            Manufacturer::Magene => f.write_str("magene"),
            Manufacturer::GiantManufacturingCo => f.write_str("giant_manufacturing_co"),
            Manufacturer::Tigrasport => f.write_str("tigrasport"),
            Manufacturer::Salutron => f.write_str("salutron"),
            Manufacturer::Technogym => f.write_str("technogym"),
            Manufacturer::BrytonSensors => f.write_str("bryton_sensors"),
            Manufacturer::LatitudeLimited => f.write_str("latitude_limited"),
            Manufacturer::SoaringTechnology => f.write_str("soaring_technology"),
            Manufacturer::Igpsport => f.write_str("igpsport"),
            Manufacturer::Thinkrider => f.write_str("thinkrider"),
            Manufacturer::GopherSport => f.write_str("gopher_sport"),
            Manufacturer::Waterrower => f.write_str("waterrower"),
            Manufacturer::Orangetheory => f.write_str("orangetheory"),
            Manufacturer::Inpeak => f.write_str("inpeak"),
            Manufacturer::Kinetic => f.write_str("kinetic"),
            Manufacturer::JohnsonHealthTech => f.write_str("johnson_health_tech"),
            Manufacturer::PolarElectro => f.write_str("polar_electro"),
            Manufacturer::Seesense => f.write_str("seesense"),
            Manufacturer::NciTechnology => f.write_str("nci_technology"),
            Manufacturer::Iqsquare => f.write_str("iqsquare"),
            Manufacturer::Leomo => f.write_str("leomo"),
            Manufacturer::IfitCom => f.write_str("ifit_com"),
            Manufacturer::CorosByte => f.write_str("coros_byte"),
            Manufacturer::VersaDesign => f.write_str("versa_design"),
            Manufacturer::Chileaf => f.write_str("chileaf"),
            Manufacturer::Cycplus => f.write_str("cycplus"),
            Manufacturer::GravaaByte => f.write_str("gravaa_byte"),
            Manufacturer::Sigeyi => f.write_str("sigeyi"),
            Manufacturer::Coospo => f.write_str("coospo"),
            Manufacturer::Geoid => f.write_str("geoid"),
            Manufacturer::Bosch => f.write_str("bosch"),
            Manufacturer::Kyto => f.write_str("kyto"),
            Manufacturer::KineticSports => f.write_str("kinetic_sports"),
            Manufacturer::DecathlonByte => f.write_str("decathlon_byte"),
            Manufacturer::TqSystems => f.write_str("tq_systems"),
            Manufacturer::TagHeuer => f.write_str("tag_heuer"),
            Manufacturer::KeiserFitness => f.write_str("keiser_fitness"),
            Manufacturer::ZwiftByte => f.write_str("zwift_byte"),
            Manufacturer::PorscheEp => f.write_str("porsche_ep"),
            Manufacturer::Blackbird => f.write_str("blackbird"),
            Manufacturer::MeilanByte => f.write_str("meilan_byte"),
            Manufacturer::Ezon => f.write_str("ezon"),
            Manufacturer::Development => f.write_str("development"),
            Manufacturer::Healthandlife => f.write_str("healthandlife"),
            Manufacturer::Lezyne => f.write_str("lezyne"),
            Manufacturer::ScribeLabs => f.write_str("scribe_labs"),
            Manufacturer::Zwift => f.write_str("zwift"),
            Manufacturer::Watteam => f.write_str("watteam"),
            Manufacturer::Recon => f.write_str("recon"),
            Manufacturer::FaveroElectronics => f.write_str("favero_electronics"),
            Manufacturer::Dynovelo => f.write_str("dynovelo"),
            Manufacturer::Strava => f.write_str("strava"),
            Manufacturer::Precor => f.write_str("precor"),
            Manufacturer::Bryton => f.write_str("bryton"),
            Manufacturer::Sram => f.write_str("sram"),
            Manufacturer::Navman => f.write_str("navman"),
            Manufacturer::Cobi => f.write_str("cobi"),
            Manufacturer::Spivi => f.write_str("spivi"),
            Manufacturer::MioMagellan => f.write_str("mio_magellan"),
            Manufacturer::Evesports => f.write_str("evesports"),
            Manufacturer::SensitivusGauge => f.write_str("sensitivus_gauge"),
            Manufacturer::Podoon => f.write_str("podoon"),
            Manufacturer::LifeTimeFitness => f.write_str("life_time_fitness"),
            Manufacturer::FalcoEMotors => f.write_str("falco_e_motors"),
            Manufacturer::Minoura => f.write_str("minoura"),
            Manufacturer::Cycliq => f.write_str("cycliq"),
            Manufacturer::Luxottica => f.write_str("luxottica"),
            Manufacturer::TrainerRoad => f.write_str("trainer_road"),
            Manufacturer::TheSufferfest => f.write_str("the_sufferfest"),
            Manufacturer::Fullspeedahead => f.write_str("fullspeedahead"),
            Manufacturer::Virtualtraining => f.write_str("virtualtraining"),
            Manufacturer::Feedbacksports => f.write_str("feedbacksports"),
            Manufacturer::Omata => f.write_str("omata"),
            Manufacturer::Vdo => f.write_str("vdo"),
            Manufacturer::Magneticdays => f.write_str("magneticdays"),
            Manufacturer::Hammerhead => f.write_str("hammerhead"),
            Manufacturer::KineticByKurt => f.write_str("kinetic_by_kurt"),
            Manufacturer::Shapelog => f.write_str("shapelog"),
            Manufacturer::Dabuziduo => f.write_str("dabuziduo"),
            Manufacturer::Jetblack => f.write_str("jetblack"),
            Manufacturer::Coros => f.write_str("coros"),
            Manufacturer::Virtugo => f.write_str("virtugo"),
            Manufacturer::Velosense => f.write_str("velosense"),
            Manufacturer::Cycligentinc => f.write_str("cycligentinc"),
            Manufacturer::Trailforks => f.write_str("trailforks"),
            Manufacturer::MahleEbikemotion => f.write_str("mahle_ebikemotion"),
            Manufacturer::Nurvv => f.write_str("nurvv"),
            Manufacturer::Microprogram => f.write_str("microprogram"),
            Manufacturer::Zone5cloud => f.write_str("zone5cloud"),
            Manufacturer::Greenteg => f.write_str("greenteg"),
            Manufacturer::YamahaMotors => f.write_str("yamaha_motors"),
            Manufacturer::Whoop => f.write_str("whoop"),
            Manufacturer::Gravaa => f.write_str("gravaa"),
            Manufacturer::Onelap => f.write_str("onelap"),
            Manufacturer::MonarkExercise => f.write_str("monark_exercise"),
            Manufacturer::Form => f.write_str("form"),
            Manufacturer::Decathlon => f.write_str("decathlon"),
            Manufacturer::Syncros => f.write_str("syncros"),
            Manufacturer::Heatup => f.write_str("heatup"),
            Manufacturer::Cannondale => f.write_str("cannondale"),
            Manufacturer::TrueFitness => f.write_str("true_fitness"),
            Manufacturer::RGTCycling => f.write_str("RGT_cycling"),
            Manufacturer::Vasa => f.write_str("vasa"),
            Manufacturer::RaceRepublic => f.write_str("race_republic"),
            Manufacturer::Fazua => f.write_str("fazua"),
            Manufacturer::OrekaTraining => f.write_str("oreka_training"),
            Manufacturer::Lsec => f.write_str("lsec"),
            Manufacturer::LululemonStudio => f.write_str("lululemon_studio"),
            Manufacturer::Shanyue => f.write_str("shanyue"),
            Manufacturer::SpinningMda => f.write_str("spinning_mda"),
            Manufacturer::Hilldating => f.write_str("hilldating"),
            Manufacturer::Actigraphcorp => f.write_str("actigraphcorp"),
        }
    }
}
impl Manufacturer {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Manufacturer::Garmin => fit::Value::UInt16(1),
            Manufacturer::GarminFr405Antfs => fit::Value::UInt16(2),
            Manufacturer::Zephyr => fit::Value::UInt16(3),
            Manufacturer::Dayton => fit::Value::UInt16(4),
            Manufacturer::Idt => fit::Value::UInt16(5),
            Manufacturer::Srm => fit::Value::UInt16(6),
            Manufacturer::Quarq => fit::Value::UInt16(7),
            Manufacturer::Ibike => fit::Value::UInt16(8),
            Manufacturer::Saris => fit::Value::UInt16(9),
            Manufacturer::SparkHk => fit::Value::UInt16(10),
            Manufacturer::Tanita => fit::Value::UInt16(11),
            Manufacturer::Echowell => fit::Value::UInt16(12),
            Manufacturer::DynastreamOem => fit::Value::UInt16(13),
            Manufacturer::Nautilus => fit::Value::UInt16(14),
            Manufacturer::Dynastream => fit::Value::UInt16(15),
            Manufacturer::Timex => fit::Value::UInt16(16),
            Manufacturer::Metrigear => fit::Value::UInt16(17),
            Manufacturer::Xelic => fit::Value::UInt16(18),
            Manufacturer::Beurer => fit::Value::UInt16(19),
            Manufacturer::Cardiosport => fit::Value::UInt16(20),
            Manufacturer::AAndD => fit::Value::UInt16(21),
            Manufacturer::Hmm => fit::Value::UInt16(22),
            Manufacturer::Suunto => fit::Value::UInt16(23),
            Manufacturer::ThitaElektronik => fit::Value::UInt16(24),
            Manufacturer::Gpulse => fit::Value::UInt16(25),
            Manufacturer::CleanMobile => fit::Value::UInt16(26),
            Manufacturer::PedalBrain => fit::Value::UInt16(27),
            Manufacturer::Peaksware => fit::Value::UInt16(28),
            Manufacturer::Saxonar => fit::Value::UInt16(29),
            Manufacturer::LemondFitness => fit::Value::UInt16(30),
            Manufacturer::Dexcom => fit::Value::UInt16(31),
            Manufacturer::WahooFitness => fit::Value::UInt16(32),
            Manufacturer::OctaneFitness => fit::Value::UInt16(33),
            Manufacturer::Archinoetics => fit::Value::UInt16(34),
            Manufacturer::TheHurtBox => fit::Value::UInt16(35),
            Manufacturer::CitizenSystems => fit::Value::UInt16(36),
            Manufacturer::Magellan => fit::Value::UInt16(37),
            Manufacturer::Osynce => fit::Value::UInt16(38),
            Manufacturer::Holux => fit::Value::UInt16(39),
            Manufacturer::Concept2 => fit::Value::UInt16(40),
            Manufacturer::Shimano => fit::Value::UInt16(41),
            Manufacturer::OneGiantLeap => fit::Value::UInt16(42),
            Manufacturer::AceSensor => fit::Value::UInt16(43),
            Manufacturer::BrimBrothers => fit::Value::UInt16(44),
            Manufacturer::Xplova => fit::Value::UInt16(45),
            Manufacturer::PerceptionDigital => fit::Value::UInt16(46),
            Manufacturer::Bf1systems => fit::Value::UInt16(47),
            Manufacturer::Pioneer => fit::Value::UInt16(48),
            Manufacturer::Spantec => fit::Value::UInt16(49),
            Manufacturer::Metalogics => fit::Value::UInt16(50),
            Manufacturer::N4iiiis => fit::Value::UInt16(51),
            Manufacturer::SeikoEpson => fit::Value::UInt16(52),
            Manufacturer::SeikoEpsonOem => fit::Value::UInt16(53),
            Manufacturer::IforPowell => fit::Value::UInt16(54),
            Manufacturer::MaxwellGuider => fit::Value::UInt16(55),
            Manufacturer::StarTrac => fit::Value::UInt16(56),
            Manufacturer::Breakaway => fit::Value::UInt16(57),
            Manufacturer::AlatechTechnologyLtd => fit::Value::UInt16(58),
            Manufacturer::MioTechnologyEurope => fit::Value::UInt16(59),
            Manufacturer::Rotor => fit::Value::UInt16(60),
            Manufacturer::Geonaute => fit::Value::UInt16(61),
            Manufacturer::IdBike => fit::Value::UInt16(62),
            Manufacturer::Specialized => fit::Value::UInt16(63),
            Manufacturer::Wtek => fit::Value::UInt16(64),
            Manufacturer::PhysicalEnterprises => fit::Value::UInt16(65),
            Manufacturer::NorthPoleEngineering => fit::Value::UInt16(66),
            Manufacturer::Bkool => fit::Value::UInt16(67),
            Manufacturer::Cateye => fit::Value::UInt16(68),
            Manufacturer::StagesCycling => fit::Value::UInt16(69),
            Manufacturer::Sigmasport => fit::Value::UInt16(70),
            Manufacturer::Tomtom => fit::Value::UInt16(71),
            Manufacturer::Peripedal => fit::Value::UInt16(72),
            Manufacturer::Wattbike => fit::Value::UInt16(73),
            Manufacturer::Moxy => fit::Value::UInt16(76),
            Manufacturer::Ciclosport => fit::Value::UInt16(77),
            Manufacturer::Powerbahn => fit::Value::UInt16(78),
            Manufacturer::AcornProjectsAps => fit::Value::UInt16(79),
            Manufacturer::Lifebeam => fit::Value::UInt16(80),
            Manufacturer::Bontrager => fit::Value::UInt16(81),
            Manufacturer::Wellgo => fit::Value::UInt16(82),
            Manufacturer::Scosche => fit::Value::UInt16(83),
            Manufacturer::Magura => fit::Value::UInt16(84),
            Manufacturer::Woodway => fit::Value::UInt16(85),
            Manufacturer::Elite => fit::Value::UInt16(86),
            Manufacturer::NielsenKellerman => fit::Value::UInt16(87),
            Manufacturer::DkCity => fit::Value::UInt16(88),
            Manufacturer::Tacx => fit::Value::UInt16(89),
            Manufacturer::DirectionTechnology => fit::Value::UInt16(90),
            Manufacturer::Magtonic => fit::Value::UInt16(91),
            Manufacturer::N1partcarbon => fit::Value::UInt16(92),
            Manufacturer::InsideRideTechnologies => fit::Value::UInt16(93),
            Manufacturer::SoundOfMotion => fit::Value::UInt16(94),
            Manufacturer::Stryd => fit::Value::UInt16(95),
            Manufacturer::Icg => fit::Value::UInt16(96),
            Manufacturer::MiPulse => fit::Value::UInt16(97),
            Manufacturer::BsxAthletics => fit::Value::UInt16(98),
            Manufacturer::Look => fit::Value::UInt16(99),
            Manufacturer::CampagnoloSrl => fit::Value::UInt16(100),
            Manufacturer::BodyBikeSmart => fit::Value::UInt16(101),
            Manufacturer::Praxisworks => fit::Value::UInt16(102),
            Manufacturer::LimitsTechnology => fit::Value::UInt16(103),
            Manufacturer::TopactionTechnology => fit::Value::UInt16(104),
            Manufacturer::Cosinuss => fit::Value::UInt16(105),
            Manufacturer::Fitcare => fit::Value::UInt16(106),
            Manufacturer::Magene => fit::Value::UInt16(107),
            Manufacturer::GiantManufacturingCo => fit::Value::UInt16(108),
            Manufacturer::Tigrasport => fit::Value::UInt16(109),
            Manufacturer::Salutron => fit::Value::UInt16(110),
            Manufacturer::Technogym => fit::Value::UInt16(111),
            Manufacturer::BrytonSensors => fit::Value::UInt16(112),
            Manufacturer::LatitudeLimited => fit::Value::UInt16(113),
            Manufacturer::SoaringTechnology => fit::Value::UInt16(114),
            Manufacturer::Igpsport => fit::Value::UInt16(115),
            Manufacturer::Thinkrider => fit::Value::UInt16(116),
            Manufacturer::GopherSport => fit::Value::UInt16(117),
            Manufacturer::Waterrower => fit::Value::UInt16(118),
            Manufacturer::Orangetheory => fit::Value::UInt16(119),
            Manufacturer::Inpeak => fit::Value::UInt16(120),
            Manufacturer::Kinetic => fit::Value::UInt16(121),
            Manufacturer::JohnsonHealthTech => fit::Value::UInt16(122),
            Manufacturer::PolarElectro => fit::Value::UInt16(123),
            Manufacturer::Seesense => fit::Value::UInt16(124),
            Manufacturer::NciTechnology => fit::Value::UInt16(125),
            Manufacturer::Iqsquare => fit::Value::UInt16(126),
            Manufacturer::Leomo => fit::Value::UInt16(127),
            Manufacturer::IfitCom => fit::Value::UInt16(128),
            Manufacturer::CorosByte => fit::Value::UInt16(129),
            Manufacturer::VersaDesign => fit::Value::UInt16(130),
            Manufacturer::Chileaf => fit::Value::UInt16(131),
            Manufacturer::Cycplus => fit::Value::UInt16(132),
            Manufacturer::GravaaByte => fit::Value::UInt16(133),
            Manufacturer::Sigeyi => fit::Value::UInt16(134),
            Manufacturer::Coospo => fit::Value::UInt16(135),
            Manufacturer::Geoid => fit::Value::UInt16(136),
            Manufacturer::Bosch => fit::Value::UInt16(137),
            Manufacturer::Kyto => fit::Value::UInt16(138),
            Manufacturer::KineticSports => fit::Value::UInt16(139),
            Manufacturer::DecathlonByte => fit::Value::UInt16(140),
            Manufacturer::TqSystems => fit::Value::UInt16(141),
            Manufacturer::TagHeuer => fit::Value::UInt16(142),
            Manufacturer::KeiserFitness => fit::Value::UInt16(143),
            Manufacturer::ZwiftByte => fit::Value::UInt16(144),
            Manufacturer::PorscheEp => fit::Value::UInt16(145),
            Manufacturer::Blackbird => fit::Value::UInt16(146),
            Manufacturer::MeilanByte => fit::Value::UInt16(147),
            Manufacturer::Ezon => fit::Value::UInt16(148),
            Manufacturer::Development => fit::Value::UInt16(255),
            Manufacturer::Healthandlife => fit::Value::UInt16(257),
            Manufacturer::Lezyne => fit::Value::UInt16(258),
            Manufacturer::ScribeLabs => fit::Value::UInt16(259),
            Manufacturer::Zwift => fit::Value::UInt16(260),
            Manufacturer::Watteam => fit::Value::UInt16(261),
            Manufacturer::Recon => fit::Value::UInt16(262),
            Manufacturer::FaveroElectronics => fit::Value::UInt16(263),
            Manufacturer::Dynovelo => fit::Value::UInt16(264),
            Manufacturer::Strava => fit::Value::UInt16(265),
            Manufacturer::Precor => fit::Value::UInt16(266),
            Manufacturer::Bryton => fit::Value::UInt16(267),
            Manufacturer::Sram => fit::Value::UInt16(268),
            Manufacturer::Navman => fit::Value::UInt16(269),
            Manufacturer::Cobi => fit::Value::UInt16(270),
            Manufacturer::Spivi => fit::Value::UInt16(271),
            Manufacturer::MioMagellan => fit::Value::UInt16(272),
            Manufacturer::Evesports => fit::Value::UInt16(273),
            Manufacturer::SensitivusGauge => fit::Value::UInt16(274),
            Manufacturer::Podoon => fit::Value::UInt16(275),
            Manufacturer::LifeTimeFitness => fit::Value::UInt16(276),
            Manufacturer::FalcoEMotors => fit::Value::UInt16(277),
            Manufacturer::Minoura => fit::Value::UInt16(278),
            Manufacturer::Cycliq => fit::Value::UInt16(279),
            Manufacturer::Luxottica => fit::Value::UInt16(280),
            Manufacturer::TrainerRoad => fit::Value::UInt16(281),
            Manufacturer::TheSufferfest => fit::Value::UInt16(282),
            Manufacturer::Fullspeedahead => fit::Value::UInt16(283),
            Manufacturer::Virtualtraining => fit::Value::UInt16(284),
            Manufacturer::Feedbacksports => fit::Value::UInt16(285),
            Manufacturer::Omata => fit::Value::UInt16(286),
            Manufacturer::Vdo => fit::Value::UInt16(287),
            Manufacturer::Magneticdays => fit::Value::UInt16(288),
            Manufacturer::Hammerhead => fit::Value::UInt16(289),
            Manufacturer::KineticByKurt => fit::Value::UInt16(290),
            Manufacturer::Shapelog => fit::Value::UInt16(291),
            Manufacturer::Dabuziduo => fit::Value::UInt16(292),
            Manufacturer::Jetblack => fit::Value::UInt16(293),
            Manufacturer::Coros => fit::Value::UInt16(294),
            Manufacturer::Virtugo => fit::Value::UInt16(295),
            Manufacturer::Velosense => fit::Value::UInt16(296),
            Manufacturer::Cycligentinc => fit::Value::UInt16(297),
            Manufacturer::Trailforks => fit::Value::UInt16(298),
            Manufacturer::MahleEbikemotion => fit::Value::UInt16(299),
            Manufacturer::Nurvv => fit::Value::UInt16(300),
            Manufacturer::Microprogram => fit::Value::UInt16(301),
            Manufacturer::Zone5cloud => fit::Value::UInt16(302),
            Manufacturer::Greenteg => fit::Value::UInt16(303),
            Manufacturer::YamahaMotors => fit::Value::UInt16(304),
            Manufacturer::Whoop => fit::Value::UInt16(305),
            Manufacturer::Gravaa => fit::Value::UInt16(306),
            Manufacturer::Onelap => fit::Value::UInt16(307),
            Manufacturer::MonarkExercise => fit::Value::UInt16(308),
            Manufacturer::Form => fit::Value::UInt16(309),
            Manufacturer::Decathlon => fit::Value::UInt16(310),
            Manufacturer::Syncros => fit::Value::UInt16(311),
            Manufacturer::Heatup => fit::Value::UInt16(312),
            Manufacturer::Cannondale => fit::Value::UInt16(313),
            Manufacturer::TrueFitness => fit::Value::UInt16(314),
            Manufacturer::RGTCycling => fit::Value::UInt16(315),
            Manufacturer::Vasa => fit::Value::UInt16(316),
            Manufacturer::RaceRepublic => fit::Value::UInt16(317),
            Manufacturer::Fazua => fit::Value::UInt16(318),
            Manufacturer::OrekaTraining => fit::Value::UInt16(319),
            Manufacturer::Lsec => fit::Value::UInt16(320),
            Manufacturer::LululemonStudio => fit::Value::UInt16(321),
            Manufacturer::Shanyue => fit::Value::UInt16(322),
            Manufacturer::SpinningMda => fit::Value::UInt16(323),
            Manufacturer::Hilldating => fit::Value::UInt16(324),
            Manufacturer::Actigraphcorp => fit::Value::UInt16(5759),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for Manufacturer {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(1) => Ok(Manufacturer::Garmin),
            fit::Value::UInt16(2) => Ok(Manufacturer::GarminFr405Antfs),
            fit::Value::UInt16(3) => Ok(Manufacturer::Zephyr),
            fit::Value::UInt16(4) => Ok(Manufacturer::Dayton),
            fit::Value::UInt16(5) => Ok(Manufacturer::Idt),
            fit::Value::UInt16(6) => Ok(Manufacturer::Srm),
            fit::Value::UInt16(7) => Ok(Manufacturer::Quarq),
            fit::Value::UInt16(8) => Ok(Manufacturer::Ibike),
            fit::Value::UInt16(9) => Ok(Manufacturer::Saris),
            fit::Value::UInt16(10) => Ok(Manufacturer::SparkHk),
            fit::Value::UInt16(11) => Ok(Manufacturer::Tanita),
            fit::Value::UInt16(12) => Ok(Manufacturer::Echowell),
            fit::Value::UInt16(13) => Ok(Manufacturer::DynastreamOem),
            fit::Value::UInt16(14) => Ok(Manufacturer::Nautilus),
            fit::Value::UInt16(15) => Ok(Manufacturer::Dynastream),
            fit::Value::UInt16(16) => Ok(Manufacturer::Timex),
            fit::Value::UInt16(17) => Ok(Manufacturer::Metrigear),
            fit::Value::UInt16(18) => Ok(Manufacturer::Xelic),
            fit::Value::UInt16(19) => Ok(Manufacturer::Beurer),
            fit::Value::UInt16(20) => Ok(Manufacturer::Cardiosport),
            fit::Value::UInt16(21) => Ok(Manufacturer::AAndD),
            fit::Value::UInt16(22) => Ok(Manufacturer::Hmm),
            fit::Value::UInt16(23) => Ok(Manufacturer::Suunto),
            fit::Value::UInt16(24) => Ok(Manufacturer::ThitaElektronik),
            fit::Value::UInt16(25) => Ok(Manufacturer::Gpulse),
            fit::Value::UInt16(26) => Ok(Manufacturer::CleanMobile),
            fit::Value::UInt16(27) => Ok(Manufacturer::PedalBrain),
            fit::Value::UInt16(28) => Ok(Manufacturer::Peaksware),
            fit::Value::UInt16(29) => Ok(Manufacturer::Saxonar),
            fit::Value::UInt16(30) => Ok(Manufacturer::LemondFitness),
            fit::Value::UInt16(31) => Ok(Manufacturer::Dexcom),
            fit::Value::UInt16(32) => Ok(Manufacturer::WahooFitness),
            fit::Value::UInt16(33) => Ok(Manufacturer::OctaneFitness),
            fit::Value::UInt16(34) => Ok(Manufacturer::Archinoetics),
            fit::Value::UInt16(35) => Ok(Manufacturer::TheHurtBox),
            fit::Value::UInt16(36) => Ok(Manufacturer::CitizenSystems),
            fit::Value::UInt16(37) => Ok(Manufacturer::Magellan),
            fit::Value::UInt16(38) => Ok(Manufacturer::Osynce),
            fit::Value::UInt16(39) => Ok(Manufacturer::Holux),
            fit::Value::UInt16(40) => Ok(Manufacturer::Concept2),
            fit::Value::UInt16(41) => Ok(Manufacturer::Shimano),
            fit::Value::UInt16(42) => Ok(Manufacturer::OneGiantLeap),
            fit::Value::UInt16(43) => Ok(Manufacturer::AceSensor),
            fit::Value::UInt16(44) => Ok(Manufacturer::BrimBrothers),
            fit::Value::UInt16(45) => Ok(Manufacturer::Xplova),
            fit::Value::UInt16(46) => Ok(Manufacturer::PerceptionDigital),
            fit::Value::UInt16(47) => Ok(Manufacturer::Bf1systems),
            fit::Value::UInt16(48) => Ok(Manufacturer::Pioneer),
            fit::Value::UInt16(49) => Ok(Manufacturer::Spantec),
            fit::Value::UInt16(50) => Ok(Manufacturer::Metalogics),
            fit::Value::UInt16(51) => Ok(Manufacturer::N4iiiis),
            fit::Value::UInt16(52) => Ok(Manufacturer::SeikoEpson),
            fit::Value::UInt16(53) => Ok(Manufacturer::SeikoEpsonOem),
            fit::Value::UInt16(54) => Ok(Manufacturer::IforPowell),
            fit::Value::UInt16(55) => Ok(Manufacturer::MaxwellGuider),
            fit::Value::UInt16(56) => Ok(Manufacturer::StarTrac),
            fit::Value::UInt16(57) => Ok(Manufacturer::Breakaway),
            fit::Value::UInt16(58) => Ok(Manufacturer::AlatechTechnologyLtd),
            fit::Value::UInt16(59) => Ok(Manufacturer::MioTechnologyEurope),
            fit::Value::UInt16(60) => Ok(Manufacturer::Rotor),
            fit::Value::UInt16(61) => Ok(Manufacturer::Geonaute),
            fit::Value::UInt16(62) => Ok(Manufacturer::IdBike),
            fit::Value::UInt16(63) => Ok(Manufacturer::Specialized),
            fit::Value::UInt16(64) => Ok(Manufacturer::Wtek),
            fit::Value::UInt16(65) => Ok(Manufacturer::PhysicalEnterprises),
            fit::Value::UInt16(66) => Ok(Manufacturer::NorthPoleEngineering),
            fit::Value::UInt16(67) => Ok(Manufacturer::Bkool),
            fit::Value::UInt16(68) => Ok(Manufacturer::Cateye),
            fit::Value::UInt16(69) => Ok(Manufacturer::StagesCycling),
            fit::Value::UInt16(70) => Ok(Manufacturer::Sigmasport),
            fit::Value::UInt16(71) => Ok(Manufacturer::Tomtom),
            fit::Value::UInt16(72) => Ok(Manufacturer::Peripedal),
            fit::Value::UInt16(73) => Ok(Manufacturer::Wattbike),
            fit::Value::UInt16(76) => Ok(Manufacturer::Moxy),
            fit::Value::UInt16(77) => Ok(Manufacturer::Ciclosport),
            fit::Value::UInt16(78) => Ok(Manufacturer::Powerbahn),
            fit::Value::UInt16(79) => Ok(Manufacturer::AcornProjectsAps),
            fit::Value::UInt16(80) => Ok(Manufacturer::Lifebeam),
            fit::Value::UInt16(81) => Ok(Manufacturer::Bontrager),
            fit::Value::UInt16(82) => Ok(Manufacturer::Wellgo),
            fit::Value::UInt16(83) => Ok(Manufacturer::Scosche),
            fit::Value::UInt16(84) => Ok(Manufacturer::Magura),
            fit::Value::UInt16(85) => Ok(Manufacturer::Woodway),
            fit::Value::UInt16(86) => Ok(Manufacturer::Elite),
            fit::Value::UInt16(87) => Ok(Manufacturer::NielsenKellerman),
            fit::Value::UInt16(88) => Ok(Manufacturer::DkCity),
            fit::Value::UInt16(89) => Ok(Manufacturer::Tacx),
            fit::Value::UInt16(90) => Ok(Manufacturer::DirectionTechnology),
            fit::Value::UInt16(91) => Ok(Manufacturer::Magtonic),
            fit::Value::UInt16(92) => Ok(Manufacturer::N1partcarbon),
            fit::Value::UInt16(93) => Ok(Manufacturer::InsideRideTechnologies),
            fit::Value::UInt16(94) => Ok(Manufacturer::SoundOfMotion),
            fit::Value::UInt16(95) => Ok(Manufacturer::Stryd),
            fit::Value::UInt16(96) => Ok(Manufacturer::Icg),
            fit::Value::UInt16(97) => Ok(Manufacturer::MiPulse),
            fit::Value::UInt16(98) => Ok(Manufacturer::BsxAthletics),
            fit::Value::UInt16(99) => Ok(Manufacturer::Look),
            fit::Value::UInt16(100) => Ok(Manufacturer::CampagnoloSrl),
            fit::Value::UInt16(101) => Ok(Manufacturer::BodyBikeSmart),
            fit::Value::UInt16(102) => Ok(Manufacturer::Praxisworks),
            fit::Value::UInt16(103) => Ok(Manufacturer::LimitsTechnology),
            fit::Value::UInt16(104) => Ok(Manufacturer::TopactionTechnology),
            fit::Value::UInt16(105) => Ok(Manufacturer::Cosinuss),
            fit::Value::UInt16(106) => Ok(Manufacturer::Fitcare),
            fit::Value::UInt16(107) => Ok(Manufacturer::Magene),
            fit::Value::UInt16(108) => Ok(Manufacturer::GiantManufacturingCo),
            fit::Value::UInt16(109) => Ok(Manufacturer::Tigrasport),
            fit::Value::UInt16(110) => Ok(Manufacturer::Salutron),
            fit::Value::UInt16(111) => Ok(Manufacturer::Technogym),
            fit::Value::UInt16(112) => Ok(Manufacturer::BrytonSensors),
            fit::Value::UInt16(113) => Ok(Manufacturer::LatitudeLimited),
            fit::Value::UInt16(114) => Ok(Manufacturer::SoaringTechnology),
            fit::Value::UInt16(115) => Ok(Manufacturer::Igpsport),
            fit::Value::UInt16(116) => Ok(Manufacturer::Thinkrider),
            fit::Value::UInt16(117) => Ok(Manufacturer::GopherSport),
            fit::Value::UInt16(118) => Ok(Manufacturer::Waterrower),
            fit::Value::UInt16(119) => Ok(Manufacturer::Orangetheory),
            fit::Value::UInt16(120) => Ok(Manufacturer::Inpeak),
            fit::Value::UInt16(121) => Ok(Manufacturer::Kinetic),
            fit::Value::UInt16(122) => Ok(Manufacturer::JohnsonHealthTech),
            fit::Value::UInt16(123) => Ok(Manufacturer::PolarElectro),
            fit::Value::UInt16(124) => Ok(Manufacturer::Seesense),
            fit::Value::UInt16(125) => Ok(Manufacturer::NciTechnology),
            fit::Value::UInt16(126) => Ok(Manufacturer::Iqsquare),
            fit::Value::UInt16(127) => Ok(Manufacturer::Leomo),
            fit::Value::UInt16(128) => Ok(Manufacturer::IfitCom),
            fit::Value::UInt16(129) => Ok(Manufacturer::CorosByte),
            fit::Value::UInt16(130) => Ok(Manufacturer::VersaDesign),
            fit::Value::UInt16(131) => Ok(Manufacturer::Chileaf),
            fit::Value::UInt16(132) => Ok(Manufacturer::Cycplus),
            fit::Value::UInt16(133) => Ok(Manufacturer::GravaaByte),
            fit::Value::UInt16(134) => Ok(Manufacturer::Sigeyi),
            fit::Value::UInt16(135) => Ok(Manufacturer::Coospo),
            fit::Value::UInt16(136) => Ok(Manufacturer::Geoid),
            fit::Value::UInt16(137) => Ok(Manufacturer::Bosch),
            fit::Value::UInt16(138) => Ok(Manufacturer::Kyto),
            fit::Value::UInt16(139) => Ok(Manufacturer::KineticSports),
            fit::Value::UInt16(140) => Ok(Manufacturer::DecathlonByte),
            fit::Value::UInt16(141) => Ok(Manufacturer::TqSystems),
            fit::Value::UInt16(142) => Ok(Manufacturer::TagHeuer),
            fit::Value::UInt16(143) => Ok(Manufacturer::KeiserFitness),
            fit::Value::UInt16(144) => Ok(Manufacturer::ZwiftByte),
            fit::Value::UInt16(145) => Ok(Manufacturer::PorscheEp),
            fit::Value::UInt16(146) => Ok(Manufacturer::Blackbird),
            fit::Value::UInt16(147) => Ok(Manufacturer::MeilanByte),
            fit::Value::UInt16(148) => Ok(Manufacturer::Ezon),
            fit::Value::UInt16(255) => Ok(Manufacturer::Development),
            fit::Value::UInt16(257) => Ok(Manufacturer::Healthandlife),
            fit::Value::UInt16(258) => Ok(Manufacturer::Lezyne),
            fit::Value::UInt16(259) => Ok(Manufacturer::ScribeLabs),
            fit::Value::UInt16(260) => Ok(Manufacturer::Zwift),
            fit::Value::UInt16(261) => Ok(Manufacturer::Watteam),
            fit::Value::UInt16(262) => Ok(Manufacturer::Recon),
            fit::Value::UInt16(263) => Ok(Manufacturer::FaveroElectronics),
            fit::Value::UInt16(264) => Ok(Manufacturer::Dynovelo),
            fit::Value::UInt16(265) => Ok(Manufacturer::Strava),
            fit::Value::UInt16(266) => Ok(Manufacturer::Precor),
            fit::Value::UInt16(267) => Ok(Manufacturer::Bryton),
            fit::Value::UInt16(268) => Ok(Manufacturer::Sram),
            fit::Value::UInt16(269) => Ok(Manufacturer::Navman),
            fit::Value::UInt16(270) => Ok(Manufacturer::Cobi),
            fit::Value::UInt16(271) => Ok(Manufacturer::Spivi),
            fit::Value::UInt16(272) => Ok(Manufacturer::MioMagellan),
            fit::Value::UInt16(273) => Ok(Manufacturer::Evesports),
            fit::Value::UInt16(274) => Ok(Manufacturer::SensitivusGauge),
            fit::Value::UInt16(275) => Ok(Manufacturer::Podoon),
            fit::Value::UInt16(276) => Ok(Manufacturer::LifeTimeFitness),
            fit::Value::UInt16(277) => Ok(Manufacturer::FalcoEMotors),
            fit::Value::UInt16(278) => Ok(Manufacturer::Minoura),
            fit::Value::UInt16(279) => Ok(Manufacturer::Cycliq),
            fit::Value::UInt16(280) => Ok(Manufacturer::Luxottica),
            fit::Value::UInt16(281) => Ok(Manufacturer::TrainerRoad),
            fit::Value::UInt16(282) => Ok(Manufacturer::TheSufferfest),
            fit::Value::UInt16(283) => Ok(Manufacturer::Fullspeedahead),
            fit::Value::UInt16(284) => Ok(Manufacturer::Virtualtraining),
            fit::Value::UInt16(285) => Ok(Manufacturer::Feedbacksports),
            fit::Value::UInt16(286) => Ok(Manufacturer::Omata),
            fit::Value::UInt16(287) => Ok(Manufacturer::Vdo),
            fit::Value::UInt16(288) => Ok(Manufacturer::Magneticdays),
            fit::Value::UInt16(289) => Ok(Manufacturer::Hammerhead),
            fit::Value::UInt16(290) => Ok(Manufacturer::KineticByKurt),
            fit::Value::UInt16(291) => Ok(Manufacturer::Shapelog),
            fit::Value::UInt16(292) => Ok(Manufacturer::Dabuziduo),
            fit::Value::UInt16(293) => Ok(Manufacturer::Jetblack),
            fit::Value::UInt16(294) => Ok(Manufacturer::Coros),
            fit::Value::UInt16(295) => Ok(Manufacturer::Virtugo),
            fit::Value::UInt16(296) => Ok(Manufacturer::Velosense),
            fit::Value::UInt16(297) => Ok(Manufacturer::Cycligentinc),
            fit::Value::UInt16(298) => Ok(Manufacturer::Trailforks),
            fit::Value::UInt16(299) => Ok(Manufacturer::MahleEbikemotion),
            fit::Value::UInt16(300) => Ok(Manufacturer::Nurvv),
            fit::Value::UInt16(301) => Ok(Manufacturer::Microprogram),
            fit::Value::UInt16(302) => Ok(Manufacturer::Zone5cloud),
            fit::Value::UInt16(303) => Ok(Manufacturer::Greenteg),
            fit::Value::UInt16(304) => Ok(Manufacturer::YamahaMotors),
            fit::Value::UInt16(305) => Ok(Manufacturer::Whoop),
            fit::Value::UInt16(306) => Ok(Manufacturer::Gravaa),
            fit::Value::UInt16(307) => Ok(Manufacturer::Onelap),
            fit::Value::UInt16(308) => Ok(Manufacturer::MonarkExercise),
            fit::Value::UInt16(309) => Ok(Manufacturer::Form),
            fit::Value::UInt16(310) => Ok(Manufacturer::Decathlon),
            fit::Value::UInt16(311) => Ok(Manufacturer::Syncros),
            fit::Value::UInt16(312) => Ok(Manufacturer::Heatup),
            fit::Value::UInt16(313) => Ok(Manufacturer::Cannondale),
            fit::Value::UInt16(314) => Ok(Manufacturer::TrueFitness),
            fit::Value::UInt16(315) => Ok(Manufacturer::RGTCycling),
            fit::Value::UInt16(316) => Ok(Manufacturer::Vasa),
            fit::Value::UInt16(317) => Ok(Manufacturer::RaceRepublic),
            fit::Value::UInt16(318) => Ok(Manufacturer::Fazua),
            fit::Value::UInt16(319) => Ok(Manufacturer::OrekaTraining),
            fit::Value::UInt16(320) => Ok(Manufacturer::Lsec),
            fit::Value::UInt16(321) => Ok(Manufacturer::LululemonStudio),
            fit::Value::UInt16(322) => Ok(Manufacturer::Shanyue),
            fit::Value::UInt16(323) => Ok(Manufacturer::SpinningMda),
            fit::Value::UInt16(324) => Ok(Manufacturer::Hilldating),
            fit::Value::UInt16(5759) => Ok(Manufacturer::Actigraphcorp),
            _ => Err("No corresponding Manufacturer exists"),
        }
    }
}
impl TryFrom<&str> for Manufacturer {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "garmin" => Ok(Manufacturer::Garmin),
            "garmin_fr405_antfs" => Ok(Manufacturer::GarminFr405Antfs),
            "zephyr" => Ok(Manufacturer::Zephyr),
            "dayton" => Ok(Manufacturer::Dayton),
            "idt" => Ok(Manufacturer::Idt),
            "srm" => Ok(Manufacturer::Srm),
            "quarq" => Ok(Manufacturer::Quarq),
            "ibike" => Ok(Manufacturer::Ibike),
            "saris" => Ok(Manufacturer::Saris),
            "spark_hk" => Ok(Manufacturer::SparkHk),
            "tanita" => Ok(Manufacturer::Tanita),
            "echowell" => Ok(Manufacturer::Echowell),
            "dynastream_oem" => Ok(Manufacturer::DynastreamOem),
            "nautilus" => Ok(Manufacturer::Nautilus),
            "dynastream" => Ok(Manufacturer::Dynastream),
            "timex" => Ok(Manufacturer::Timex),
            "metrigear" => Ok(Manufacturer::Metrigear),
            "xelic" => Ok(Manufacturer::Xelic),
            "beurer" => Ok(Manufacturer::Beurer),
            "cardiosport" => Ok(Manufacturer::Cardiosport),
            "a_and_d" => Ok(Manufacturer::AAndD),
            "hmm" => Ok(Manufacturer::Hmm),
            "suunto" => Ok(Manufacturer::Suunto),
            "thita_elektronik" => Ok(Manufacturer::ThitaElektronik),
            "gpulse" => Ok(Manufacturer::Gpulse),
            "clean_mobile" => Ok(Manufacturer::CleanMobile),
            "pedal_brain" => Ok(Manufacturer::PedalBrain),
            "peaksware" => Ok(Manufacturer::Peaksware),
            "saxonar" => Ok(Manufacturer::Saxonar),
            "lemond_fitness" => Ok(Manufacturer::LemondFitness),
            "dexcom" => Ok(Manufacturer::Dexcom),
            "wahoo_fitness" => Ok(Manufacturer::WahooFitness),
            "octane_fitness" => Ok(Manufacturer::OctaneFitness),
            "archinoetics" => Ok(Manufacturer::Archinoetics),
            "the_hurt_box" => Ok(Manufacturer::TheHurtBox),
            "citizen_systems" => Ok(Manufacturer::CitizenSystems),
            "magellan" => Ok(Manufacturer::Magellan),
            "osynce" => Ok(Manufacturer::Osynce),
            "holux" => Ok(Manufacturer::Holux),
            "concept2" => Ok(Manufacturer::Concept2),
            "shimano" => Ok(Manufacturer::Shimano),
            "one_giant_leap" => Ok(Manufacturer::OneGiantLeap),
            "ace_sensor" => Ok(Manufacturer::AceSensor),
            "brim_brothers" => Ok(Manufacturer::BrimBrothers),
            "xplova" => Ok(Manufacturer::Xplova),
            "perception_digital" => Ok(Manufacturer::PerceptionDigital),
            "bf1systems" => Ok(Manufacturer::Bf1systems),
            "pioneer" => Ok(Manufacturer::Pioneer),
            "spantec" => Ok(Manufacturer::Spantec),
            "metalogics" => Ok(Manufacturer::Metalogics),
            "4iiiis" => Ok(Manufacturer::N4iiiis),
            "seiko_epson" => Ok(Manufacturer::SeikoEpson),
            "seiko_epson_oem" => Ok(Manufacturer::SeikoEpsonOem),
            "ifor_powell" => Ok(Manufacturer::IforPowell),
            "maxwell_guider" => Ok(Manufacturer::MaxwellGuider),
            "star_trac" => Ok(Manufacturer::StarTrac),
            "breakaway" => Ok(Manufacturer::Breakaway),
            "alatech_technology_ltd" => Ok(Manufacturer::AlatechTechnologyLtd),
            "mio_technology_europe" => Ok(Manufacturer::MioTechnologyEurope),
            "rotor" => Ok(Manufacturer::Rotor),
            "geonaute" => Ok(Manufacturer::Geonaute),
            "id_bike" => Ok(Manufacturer::IdBike),
            "specialized" => Ok(Manufacturer::Specialized),
            "wtek" => Ok(Manufacturer::Wtek),
            "physical_enterprises" => Ok(Manufacturer::PhysicalEnterprises),
            "north_pole_engineering" => Ok(Manufacturer::NorthPoleEngineering),
            "bkool" => Ok(Manufacturer::Bkool),
            "cateye" => Ok(Manufacturer::Cateye),
            "stages_cycling" => Ok(Manufacturer::StagesCycling),
            "sigmasport" => Ok(Manufacturer::Sigmasport),
            "tomtom" => Ok(Manufacturer::Tomtom),
            "peripedal" => Ok(Manufacturer::Peripedal),
            "wattbike" => Ok(Manufacturer::Wattbike),
            "moxy" => Ok(Manufacturer::Moxy),
            "ciclosport" => Ok(Manufacturer::Ciclosport),
            "powerbahn" => Ok(Manufacturer::Powerbahn),
            "acorn_projects_aps" => Ok(Manufacturer::AcornProjectsAps),
            "lifebeam" => Ok(Manufacturer::Lifebeam),
            "bontrager" => Ok(Manufacturer::Bontrager),
            "wellgo" => Ok(Manufacturer::Wellgo),
            "scosche" => Ok(Manufacturer::Scosche),
            "magura" => Ok(Manufacturer::Magura),
            "woodway" => Ok(Manufacturer::Woodway),
            "elite" => Ok(Manufacturer::Elite),
            "nielsen_kellerman" => Ok(Manufacturer::NielsenKellerman),
            "dk_city" => Ok(Manufacturer::DkCity),
            "tacx" => Ok(Manufacturer::Tacx),
            "direction_technology" => Ok(Manufacturer::DirectionTechnology),
            "magtonic" => Ok(Manufacturer::Magtonic),
            "1partcarbon" => Ok(Manufacturer::N1partcarbon),
            "inside_ride_technologies" => Ok(Manufacturer::InsideRideTechnologies),
            "sound_of_motion" => Ok(Manufacturer::SoundOfMotion),
            "stryd" => Ok(Manufacturer::Stryd),
            "icg" => Ok(Manufacturer::Icg),
            "MiPulse" => Ok(Manufacturer::MiPulse),
            "bsx_athletics" => Ok(Manufacturer::BsxAthletics),
            "look" => Ok(Manufacturer::Look),
            "campagnolo_srl" => Ok(Manufacturer::CampagnoloSrl),
            "body_bike_smart" => Ok(Manufacturer::BodyBikeSmart),
            "praxisworks" => Ok(Manufacturer::Praxisworks),
            "limits_technology" => Ok(Manufacturer::LimitsTechnology),
            "topaction_technology" => Ok(Manufacturer::TopactionTechnology),
            "cosinuss" => Ok(Manufacturer::Cosinuss),
            "fitcare" => Ok(Manufacturer::Fitcare),
            "magene" => Ok(Manufacturer::Magene),
            "giant_manufacturing_co" => Ok(Manufacturer::GiantManufacturingCo),
            "tigrasport" => Ok(Manufacturer::Tigrasport),
            "salutron" => Ok(Manufacturer::Salutron),
            "technogym" => Ok(Manufacturer::Technogym),
            "bryton_sensors" => Ok(Manufacturer::BrytonSensors),
            "latitude_limited" => Ok(Manufacturer::LatitudeLimited),
            "soaring_technology" => Ok(Manufacturer::SoaringTechnology),
            "igpsport" => Ok(Manufacturer::Igpsport),
            "thinkrider" => Ok(Manufacturer::Thinkrider),
            "gopher_sport" => Ok(Manufacturer::GopherSport),
            "waterrower" => Ok(Manufacturer::Waterrower),
            "orangetheory" => Ok(Manufacturer::Orangetheory),
            "inpeak" => Ok(Manufacturer::Inpeak),
            "kinetic" => Ok(Manufacturer::Kinetic),
            "johnson_health_tech" => Ok(Manufacturer::JohnsonHealthTech),
            "polar_electro" => Ok(Manufacturer::PolarElectro),
            "seesense" => Ok(Manufacturer::Seesense),
            "nci_technology" => Ok(Manufacturer::NciTechnology),
            "iqsquare" => Ok(Manufacturer::Iqsquare),
            "leomo" => Ok(Manufacturer::Leomo),
            "ifit_com" => Ok(Manufacturer::IfitCom),
            "coros_byte" => Ok(Manufacturer::CorosByte),
            "versa_design" => Ok(Manufacturer::VersaDesign),
            "chileaf" => Ok(Manufacturer::Chileaf),
            "cycplus" => Ok(Manufacturer::Cycplus),
            "gravaa_byte" => Ok(Manufacturer::GravaaByte),
            "sigeyi" => Ok(Manufacturer::Sigeyi),
            "coospo" => Ok(Manufacturer::Coospo),
            "geoid" => Ok(Manufacturer::Geoid),
            "bosch" => Ok(Manufacturer::Bosch),
            "kyto" => Ok(Manufacturer::Kyto),
            "kinetic_sports" => Ok(Manufacturer::KineticSports),
            "decathlon_byte" => Ok(Manufacturer::DecathlonByte),
            "tq_systems" => Ok(Manufacturer::TqSystems),
            "tag_heuer" => Ok(Manufacturer::TagHeuer),
            "keiser_fitness" => Ok(Manufacturer::KeiserFitness),
            "zwift_byte" => Ok(Manufacturer::ZwiftByte),
            "porsche_ep" => Ok(Manufacturer::PorscheEp),
            "blackbird" => Ok(Manufacturer::Blackbird),
            "meilan_byte" => Ok(Manufacturer::MeilanByte),
            "ezon" => Ok(Manufacturer::Ezon),
            "development" => Ok(Manufacturer::Development),
            "healthandlife" => Ok(Manufacturer::Healthandlife),
            "lezyne" => Ok(Manufacturer::Lezyne),
            "scribe_labs" => Ok(Manufacturer::ScribeLabs),
            "zwift" => Ok(Manufacturer::Zwift),
            "watteam" => Ok(Manufacturer::Watteam),
            "recon" => Ok(Manufacturer::Recon),
            "favero_electronics" => Ok(Manufacturer::FaveroElectronics),
            "dynovelo" => Ok(Manufacturer::Dynovelo),
            "strava" => Ok(Manufacturer::Strava),
            "precor" => Ok(Manufacturer::Precor),
            "bryton" => Ok(Manufacturer::Bryton),
            "sram" => Ok(Manufacturer::Sram),
            "navman" => Ok(Manufacturer::Navman),
            "cobi" => Ok(Manufacturer::Cobi),
            "spivi" => Ok(Manufacturer::Spivi),
            "mio_magellan" => Ok(Manufacturer::MioMagellan),
            "evesports" => Ok(Manufacturer::Evesports),
            "sensitivus_gauge" => Ok(Manufacturer::SensitivusGauge),
            "podoon" => Ok(Manufacturer::Podoon),
            "life_time_fitness" => Ok(Manufacturer::LifeTimeFitness),
            "falco_e_motors" => Ok(Manufacturer::FalcoEMotors),
            "minoura" => Ok(Manufacturer::Minoura),
            "cycliq" => Ok(Manufacturer::Cycliq),
            "luxottica" => Ok(Manufacturer::Luxottica),
            "trainer_road" => Ok(Manufacturer::TrainerRoad),
            "the_sufferfest" => Ok(Manufacturer::TheSufferfest),
            "fullspeedahead" => Ok(Manufacturer::Fullspeedahead),
            "virtualtraining" => Ok(Manufacturer::Virtualtraining),
            "feedbacksports" => Ok(Manufacturer::Feedbacksports),
            "omata" => Ok(Manufacturer::Omata),
            "vdo" => Ok(Manufacturer::Vdo),
            "magneticdays" => Ok(Manufacturer::Magneticdays),
            "hammerhead" => Ok(Manufacturer::Hammerhead),
            "kinetic_by_kurt" => Ok(Manufacturer::KineticByKurt),
            "shapelog" => Ok(Manufacturer::Shapelog),
            "dabuziduo" => Ok(Manufacturer::Dabuziduo),
            "jetblack" => Ok(Manufacturer::Jetblack),
            "coros" => Ok(Manufacturer::Coros),
            "virtugo" => Ok(Manufacturer::Virtugo),
            "velosense" => Ok(Manufacturer::Velosense),
            "cycligentinc" => Ok(Manufacturer::Cycligentinc),
            "trailforks" => Ok(Manufacturer::Trailforks),
            "mahle_ebikemotion" => Ok(Manufacturer::MahleEbikemotion),
            "nurvv" => Ok(Manufacturer::Nurvv),
            "microprogram" => Ok(Manufacturer::Microprogram),
            "zone5cloud" => Ok(Manufacturer::Zone5cloud),
            "greenteg" => Ok(Manufacturer::Greenteg),
            "yamaha_motors" => Ok(Manufacturer::YamahaMotors),
            "whoop" => Ok(Manufacturer::Whoop),
            "gravaa" => Ok(Manufacturer::Gravaa),
            "onelap" => Ok(Manufacturer::Onelap),
            "monark_exercise" => Ok(Manufacturer::MonarkExercise),
            "form" => Ok(Manufacturer::Form),
            "decathlon" => Ok(Manufacturer::Decathlon),
            "syncros" => Ok(Manufacturer::Syncros),
            "heatup" => Ok(Manufacturer::Heatup),
            "cannondale" => Ok(Manufacturer::Cannondale),
            "true_fitness" => Ok(Manufacturer::TrueFitness),
            "RGT_cycling" => Ok(Manufacturer::RGTCycling),
            "vasa" => Ok(Manufacturer::Vasa),
            "race_republic" => Ok(Manufacturer::RaceRepublic),
            "fazua" => Ok(Manufacturer::Fazua),
            "oreka_training" => Ok(Manufacturer::OrekaTraining),
            "lsec" => Ok(Manufacturer::Lsec),
            "lululemon_studio" => Ok(Manufacturer::LululemonStudio),
            "shanyue" => Ok(Manufacturer::Shanyue),
            "spinning_mda" => Ok(Manufacturer::SpinningMda),
            "hilldating" => Ok(Manufacturer::Hilldating),
            "actigraphcorp" => Ok(Manufacturer::Actigraphcorp),
            _ => Err("No corresponding Manufacturer exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum GarminProduct {
    Hrm1,
    /// AXH01 HRM chipset
    Axh01,
    Axb01,
    Axb02,
    Hrm2ss,
    DsiAlf02,
    Hrm3ss,
    /// hrm_run model for HRM ANT+ messaging
    HrmRunSingleByteProductId,
    /// BSM model for ANT+ messaging
    Bsm,
    /// BCM model for ANT+ messaging
    Bcm,
    /// AXS01 HRM Bike Chipset model for ANT+ messaging
    Axs01,
    /// hrm_tri model for HRM ANT+ messaging
    HrmTriSingleByteProductId,
    /// hrm4 run model for HRM ANT+ messaging
    Hrm4RunSingleByteProductId,
    /// fr225 model for HRM ANT+ messaging
    Fr225SingleByteProductId,
    /// gen3_bsm model for Bike Speed ANT+ messaging
    Gen3BsmSingleByteProductId,
    /// gen3_bcm model for Bike Cadence ANT+ messaging
    Gen3BcmSingleByteProductId,
    /// Garmin Wearable Optical Heart Rate Sensor for ANT+ HR Profile Broadcasting
    OHR,
    Fr301China,
    Fr301Japan,
    Fr301Korea,
    Fr301Taiwan,
    /// Forerunner 405
    Fr405,
    /// Forerunner 50
    Fr50,
    Fr405Japan,
    /// Forerunner 60
    Fr60,
    DsiAlf01,
    /// Forerunner 310
    Fr310xt,
    Edge500,
    /// Forerunner 110
    Fr110,
    Edge800,
    Edge500Taiwan,
    Edge500Japan,
    Chirp,
    Fr110Japan,
    Edge200,
    Fr910xt,
    Edge800Taiwan,
    Edge800Japan,
    Alf04,
    Fr610,
    Fr210Japan,
    VectorSs,
    VectorCp,
    Edge800China,
    Edge500China,
    ApproachG10,
    Fr610Japan,
    Edge500Korea,
    Fr70,
    Fr310xt4t,
    Amx,
    Fr10,
    Edge800Korea,
    Swim,
    Fr910xtChina,
    Fenix,
    Edge200Taiwan,
    Edge510,
    Edge810,
    Tempe,
    Fr910xtJapan,
    Fr620,
    Fr220,
    Fr910xtKorea,
    Fr10Japan,
    Edge810Japan,
    VirbElite,
    /// Also Edge Touring Plus
    EdgeTouring,
    Edge510Japan,
    /// Also HRM-Swim
    HrmTri,
    HrmRun,
    Fr920xt,
    Edge510Asia,
    Edge810China,
    Edge810Taiwan,
    Edge1000,
    VivoFit,
    VirbRemote,
    VivoKi,
    Fr15,
    VivoActive,
    Edge510Korea,
    Fr620Japan,
    Fr620China,
    Fr220Japan,
    Fr220China,
    ApproachS6,
    VivoSmart,
    Fenix2,
    Epix,
    Fenix3,
    Edge1000Taiwan,
    Edge1000Japan,
    Fr15Japan,
    Edge520,
    Edge1000China,
    Fr620Russia,
    Fr220Russia,
    VectorS,
    Edge1000Korea,
    Fr920xtTaiwan,
    Fr920xtChina,
    Fr920xtJapan,
    Virbx,
    VivoSmartApac,
    EtrexTouch,
    Edge25,
    Fr25,
    VivoFit2,
    Fr225,
    Fr630,
    Fr230,
    Fr735xt,
    VivoActiveApac,
    Vector2,
    Vector2s,
    Virbxe,
    Fr620Taiwan,
    Fr220Taiwan,
    Truswing,
    D2airvenu,
    Fenix3China,
    Fenix3Twn,
    VariaHeadlight,
    VariaTaillightOld,
    EdgeExplore1000,
    Fr225Asia,
    VariaRadarTaillight,
    VariaRadarDisplay,
    Edge20,
    Edge520Asia,
    Edge520Japan,
    D2Bravo,
    ApproachS20,
    VivoSmart2,
    Edge1000Thai,
    VariaRemote,
    Edge25Asia,
    Edge25Jpn,
    Edge20Asia,
    ApproachX40,
    Fenix3Japan,
    VivoSmartEmea,
    Fr630Asia,
    Fr630Jpn,
    Fr230Jpn,
    Hrm4Run,
    EpixJapan,
    VivoActiveHr,
    VivoSmartGpsHr,
    VivoSmartHr,
    VivoSmartHrAsia,
    VivoSmartGpsHrAsia,
    VivoMove,
    VariaTaillight,
    Fr235Asia,
    Fr235Japan,
    VariaVision,
    VivoFit3,
    Fenix3Korea,
    Fenix3Sea,
    Fenix3Hr,
    VirbUltra30,
    IndexSmartScale,
    Fr235,
    Fenix3Chronos,
    Oregon7xx,
    Rino7xx,
    EpixKorea,
    Fenix3HrChn,
    Fenix3HrTwn,
    Fenix3HrJpn,
    Fenix3HrSea,
    Fenix3HrKor,
    Nautix,
    VivoActiveHrApac,
    Fr35,
    Oregon7xxWw,
    Edge820,
    EdgeExplore820,
    Fr735xtApac,
    Fr735xtJapan,
    Fenix5s,
    D2BravoTitanium,
    /// Varia UT 800 SW
    VariaUt800,
    RunningDynamicsPod,
    Edge820China,
    Edge820Japan,
    Fenix5x,
    VivoFitJr,
    VivoSmart3,
    VivoSport,
    Edge820Taiwan,
    Edge820Korea,
    Edge820Sea,
    Fr35Hebrew,
    ApproachS60,
    Fr35Apac,
    Fr35Japan,
    Fenix3ChronosAsia,
    Virb360,
    Fr935,
    Fenix5,
    Vivoactive3,
    Fr235ChinaNfc,
    Foretrex601701,
    VivoMoveHr,
    Edge1030,
    Fr35Sea,
    Vector3,
    Fenix5Asia,
    Fenix5sAsia,
    Fenix5xAsia,
    ApproachZ80,
    Fr35Korea,
    D2charlie,
    VivoSmart3Apac,
    VivoSportApac,
    Fr935Asia,
    Descent,
    VivoFit4,
    Fr645,
    Fr645m,
    Fr30,
    Fenix5sPlus,
    Edge130,
    Edge1030Asia,
    Vivosmart4,
    VivoMoveHrAsia,
    ApproachX10,
    Fr30Asia,
    Vivoactive3mW,
    Fr645Asia,
    Fr645mAsia,
    EdgeExplore,
    Gpsmap66,
    ApproachS10,
    Vivoactive3mL,
    ApproachG80,
    Edge130Asia,
    Edge1030Bontrager,
    Fenix5Plus,
    Fenix5xPlus,
    Edge520Plus,
    Fr945,
    Edge530,
    Edge830,
    InstinctEsports,
    Fenix5sPlusApac,
    Fenix5xPlusApac,
    Edge520PlusApac,
    DescentT1,
    Fr235lAsia,
    Fr245Asia,
    VivoActive3mApac,
    /// gen3 bike speed sensor
    Gen3Bsm,
    /// gen3 bike cadence sensor
    Gen3Bcm,
    VivoSmart4Asia,
    Vivoactive4Small,
    Vivoactive4Large,
    Venu,
    MarqDriver,
    MarqAviator,
    MarqCaptain,
    MarqCommander,
    MarqExpedition,
    MarqAthlete,
    DescentMk2,
    Gpsmap66i,
    Fenix6SSport,
    Fenix6S,
    Fenix6Sport,
    Fenix6,
    Fenix6x,
    /// HRM-Dual
    HrmDual,
    /// HRM-Pro
    HrmPro,
    VivoMove3Premium,
    ApproachS40,
    Fr245mAsia,
    Edge530Apac,
    Edge830Apac,
    VivoMove3,
    VivoActive4SmallAsia,
    VivoActive4LargeAsia,
    VivoActive4OledAsia,
    Swim2,
    MarqDriverAsia,
    MarqAviatorAsia,
    VivoMove3Asia,
    Fr945Asia,
    VivoActive3tChn,
    MarqCaptainAsia,
    MarqCommanderAsia,
    MarqExpeditionAsia,
    MarqAthleteAsia,
    InstinctSolar,
    Fr45Asia,
    Vivoactive3Daimler,
    LegacyRey,
    LegacyDarthVader,
    LegacyCaptainMarvel,
    LegacyFirstAvenger,
    Fenix6sSportAsia,
    Fenix6sAsia,
    Fenix6SportAsia,
    Fenix6Asia,
    Fenix6xAsia,
    LegacyCaptainMarvelAsia,
    LegacyFirstAvengerAsia,
    LegacyReyAsia,
    LegacyDarthVaderAsia,
    DescentMk2s,
    Edge130Plus,
    Edge1030Plus,
    /// Rally 100/200 Power Meter Series
    Rally200,
    Fr745,
    Venusq,
    Lily,
    MarqAdventurer,
    Enduro,
    Swim2Apac,
    MarqAdventurerAsia,
    Fr945Lte,
    /// Mk2 and Mk2i
    DescentMk2Asia,
    Venu2,
    Venu2s,
    VenuDaimlerAsia,
    MarqGolfer,
    VenuDaimler,
    Fr745Asia,
    LilyAsia,
    Edge1030PlusAsia,
    Edge130PlusAsia,
    ApproachS12,
    EnduroAsia,
    VenusqAsia,
    Edge1040,
    MarqGolferAsia,
    Venu2Plus,
    Gnss,
    Fr55,
    Instinct2,
    Fenix7s,
    Fenix7,
    Fenix7x,
    Fenix7sApac,
    Fenix7Apac,
    Fenix7xApac,
    ApproachG12,
    DescentMk2sAsia,
    ApproachS42,
    EpixGen2,
    EpixGen2Apac,
    Venu2sAsia,
    Venu2Asia,
    Fr945LteAsia,
    VivoMoveSport,
    VivomoveTrend,
    ApproachS12Asia,
    Fr255Music,
    Fr255SmallMusic,
    Fr255,
    Fr255Small,
    ApproachG12Asia,
    ApproachS42Asia,
    DescentG1,
    Venu2PlusAsia,
    Fr955,
    Fr55Asia,
    Edge540,
    Edge840,
    Vivosmart5,
    Instinct2Asia,
    /// Adventurer, Athlete, Captain, Golfer
    MarqGen2,
    Venusq2,
    Venusq2music,
    MarqGen2Aviator,
    D2AirX10,
    HrmProPlus,
    DescentG1Asia,
    Tactix7,
    InstinctCrossover,
    EdgeExplore2,
    ApproachS70,
    Fr265Large,
    Fr265Small,
    /// Neo Smart, Tacx
    TacxNeoSmart,
    /// Neo 2 Smart, Tacx
    TacxNeo2Smart,
    /// Neo 2T Smart, Tacx
    TacxNeo2TSmart,
    /// Neo Smart Bike, Tacx
    TacxNeoSmartBike,
    /// Satori Smart, Tacx
    TacxSatoriSmart,
    /// Flow Smart, Tacx
    TacxFlowSmart,
    /// Vortex Smart, Tacx
    TacxVortexSmart,
    /// Bushido Smart, Tacx
    TacxBushidoSmart,
    /// Genius Smart, Tacx
    TacxGeniusSmart,
    /// Flux/Flux S Smart, Tacx
    TacxFluxFluxSSmart,
    /// Flux 2 Smart, Tacx
    TacxFlux2Smart,
    /// Magnum, Tacx
    TacxMagnum,
    Edge1040Asia,
    EpixGen2Pro42,
    EpixGen2Pro47,
    EpixGen2Pro51,
    Fr965,
    Enduro2,
    Fenix7ProSolar,
    Instinct2x,
    DescentT2,
    /// SDM4 footpod
    Sdm4,
    EdgeRemote,
    TacxTrainingAppWin,
    TacxTrainingAppMac,
    TacxTrainingAppMacCatalyst,
    TrainingCenter,
    TacxTrainingAppAndroid,
    TacxTrainingAppIos,
    TacxTrainingAppLegacy,
    ConnectiqSimulator,
    AndroidAntplusPlugin,
    /// Garmin Connect website
    Connect,
}
impl fmt::Display for GarminProduct {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            GarminProduct::Hrm1 => f.write_str("hrm1"),
            GarminProduct::Axh01 => f.write_str("axh01"),
            GarminProduct::Axb01 => f.write_str("axb01"),
            GarminProduct::Axb02 => f.write_str("axb02"),
            GarminProduct::Hrm2ss => f.write_str("hrm2ss"),
            GarminProduct::DsiAlf02 => f.write_str("dsi_alf02"),
            GarminProduct::Hrm3ss => f.write_str("hrm3ss"),
            GarminProduct::HrmRunSingleByteProductId => {
                f.write_str("hrm_run_single_byte_product_id")
            }
            GarminProduct::Bsm => f.write_str("bsm"),
            GarminProduct::Bcm => f.write_str("bcm"),
            GarminProduct::Axs01 => f.write_str("axs01"),
            GarminProduct::HrmTriSingleByteProductId => {
                f.write_str("hrm_tri_single_byte_product_id")
            }
            GarminProduct::Hrm4RunSingleByteProductId => {
                f.write_str("hrm4_run_single_byte_product_id")
            }
            GarminProduct::Fr225SingleByteProductId => f.write_str("fr225_single_byte_product_id"),
            GarminProduct::Gen3BsmSingleByteProductId => {
                f.write_str("gen3_bsm_single_byte_product_id")
            }
            GarminProduct::Gen3BcmSingleByteProductId => {
                f.write_str("gen3_bcm_single_byte_product_id")
            }
            GarminProduct::OHR => f.write_str("OHR"),
            GarminProduct::Fr301China => f.write_str("fr301_china"),
            GarminProduct::Fr301Japan => f.write_str("fr301_japan"),
            GarminProduct::Fr301Korea => f.write_str("fr301_korea"),
            GarminProduct::Fr301Taiwan => f.write_str("fr301_taiwan"),
            GarminProduct::Fr405 => f.write_str("fr405"),
            GarminProduct::Fr50 => f.write_str("fr50"),
            GarminProduct::Fr405Japan => f.write_str("fr405_japan"),
            GarminProduct::Fr60 => f.write_str("fr60"),
            GarminProduct::DsiAlf01 => f.write_str("dsi_alf01"),
            GarminProduct::Fr310xt => f.write_str("fr310xt"),
            GarminProduct::Edge500 => f.write_str("edge500"),
            GarminProduct::Fr110 => f.write_str("fr110"),
            GarminProduct::Edge800 => f.write_str("edge800"),
            GarminProduct::Edge500Taiwan => f.write_str("edge500_taiwan"),
            GarminProduct::Edge500Japan => f.write_str("edge500_japan"),
            GarminProduct::Chirp => f.write_str("chirp"),
            GarminProduct::Fr110Japan => f.write_str("fr110_japan"),
            GarminProduct::Edge200 => f.write_str("edge200"),
            GarminProduct::Fr910xt => f.write_str("fr910xt"),
            GarminProduct::Edge800Taiwan => f.write_str("edge800_taiwan"),
            GarminProduct::Edge800Japan => f.write_str("edge800_japan"),
            GarminProduct::Alf04 => f.write_str("alf04"),
            GarminProduct::Fr610 => f.write_str("fr610"),
            GarminProduct::Fr210Japan => f.write_str("fr210_japan"),
            GarminProduct::VectorSs => f.write_str("vector_ss"),
            GarminProduct::VectorCp => f.write_str("vector_cp"),
            GarminProduct::Edge800China => f.write_str("edge800_china"),
            GarminProduct::Edge500China => f.write_str("edge500_china"),
            GarminProduct::ApproachG10 => f.write_str("approach_g10"),
            GarminProduct::Fr610Japan => f.write_str("fr610_japan"),
            GarminProduct::Edge500Korea => f.write_str("edge500_korea"),
            GarminProduct::Fr70 => f.write_str("fr70"),
            GarminProduct::Fr310xt4t => f.write_str("fr310xt_4t"),
            GarminProduct::Amx => f.write_str("amx"),
            GarminProduct::Fr10 => f.write_str("fr10"),
            GarminProduct::Edge800Korea => f.write_str("edge800_korea"),
            GarminProduct::Swim => f.write_str("swim"),
            GarminProduct::Fr910xtChina => f.write_str("fr910xt_china"),
            GarminProduct::Fenix => f.write_str("fenix"),
            GarminProduct::Edge200Taiwan => f.write_str("edge200_taiwan"),
            GarminProduct::Edge510 => f.write_str("edge510"),
            GarminProduct::Edge810 => f.write_str("edge810"),
            GarminProduct::Tempe => f.write_str("tempe"),
            GarminProduct::Fr910xtJapan => f.write_str("fr910xt_japan"),
            GarminProduct::Fr620 => f.write_str("fr620"),
            GarminProduct::Fr220 => f.write_str("fr220"),
            GarminProduct::Fr910xtKorea => f.write_str("fr910xt_korea"),
            GarminProduct::Fr10Japan => f.write_str("fr10_japan"),
            GarminProduct::Edge810Japan => f.write_str("edge810_japan"),
            GarminProduct::VirbElite => f.write_str("virb_elite"),
            GarminProduct::EdgeTouring => f.write_str("edge_touring"),
            GarminProduct::Edge510Japan => f.write_str("edge510_japan"),
            GarminProduct::HrmTri => f.write_str("hrm_tri"),
            GarminProduct::HrmRun => f.write_str("hrm_run"),
            GarminProduct::Fr920xt => f.write_str("fr920xt"),
            GarminProduct::Edge510Asia => f.write_str("edge510_asia"),
            GarminProduct::Edge810China => f.write_str("edge810_china"),
            GarminProduct::Edge810Taiwan => f.write_str("edge810_taiwan"),
            GarminProduct::Edge1000 => f.write_str("edge1000"),
            GarminProduct::VivoFit => f.write_str("vivo_fit"),
            GarminProduct::VirbRemote => f.write_str("virb_remote"),
            GarminProduct::VivoKi => f.write_str("vivo_ki"),
            GarminProduct::Fr15 => f.write_str("fr15"),
            GarminProduct::VivoActive => f.write_str("vivo_active"),
            GarminProduct::Edge510Korea => f.write_str("edge510_korea"),
            GarminProduct::Fr620Japan => f.write_str("fr620_japan"),
            GarminProduct::Fr620China => f.write_str("fr620_china"),
            GarminProduct::Fr220Japan => f.write_str("fr220_japan"),
            GarminProduct::Fr220China => f.write_str("fr220_china"),
            GarminProduct::ApproachS6 => f.write_str("approach_s6"),
            GarminProduct::VivoSmart => f.write_str("vivo_smart"),
            GarminProduct::Fenix2 => f.write_str("fenix2"),
            GarminProduct::Epix => f.write_str("epix"),
            GarminProduct::Fenix3 => f.write_str("fenix3"),
            GarminProduct::Edge1000Taiwan => f.write_str("edge1000_taiwan"),
            GarminProduct::Edge1000Japan => f.write_str("edge1000_japan"),
            GarminProduct::Fr15Japan => f.write_str("fr15_japan"),
            GarminProduct::Edge520 => f.write_str("edge520"),
            GarminProduct::Edge1000China => f.write_str("edge1000_china"),
            GarminProduct::Fr620Russia => f.write_str("fr620_russia"),
            GarminProduct::Fr220Russia => f.write_str("fr220_russia"),
            GarminProduct::VectorS => f.write_str("vector_s"),
            GarminProduct::Edge1000Korea => f.write_str("edge1000_korea"),
            GarminProduct::Fr920xtTaiwan => f.write_str("fr920xt_taiwan"),
            GarminProduct::Fr920xtChina => f.write_str("fr920xt_china"),
            GarminProduct::Fr920xtJapan => f.write_str("fr920xt_japan"),
            GarminProduct::Virbx => f.write_str("virbx"),
            GarminProduct::VivoSmartApac => f.write_str("vivo_smart_apac"),
            GarminProduct::EtrexTouch => f.write_str("etrex_touch"),
            GarminProduct::Edge25 => f.write_str("edge25"),
            GarminProduct::Fr25 => f.write_str("fr25"),
            GarminProduct::VivoFit2 => f.write_str("vivo_fit2"),
            GarminProduct::Fr225 => f.write_str("fr225"),
            GarminProduct::Fr630 => f.write_str("fr630"),
            GarminProduct::Fr230 => f.write_str("fr230"),
            GarminProduct::Fr735xt => f.write_str("fr735xt"),
            GarminProduct::VivoActiveApac => f.write_str("vivo_active_apac"),
            GarminProduct::Vector2 => f.write_str("vector_2"),
            GarminProduct::Vector2s => f.write_str("vector_2s"),
            GarminProduct::Virbxe => f.write_str("virbxe"),
            GarminProduct::Fr620Taiwan => f.write_str("fr620_taiwan"),
            GarminProduct::Fr220Taiwan => f.write_str("fr220_taiwan"),
            GarminProduct::Truswing => f.write_str("truswing"),
            GarminProduct::D2airvenu => f.write_str("d2airvenu"),
            GarminProduct::Fenix3China => f.write_str("fenix3_china"),
            GarminProduct::Fenix3Twn => f.write_str("fenix3_twn"),
            GarminProduct::VariaHeadlight => f.write_str("varia_headlight"),
            GarminProduct::VariaTaillightOld => f.write_str("varia_taillight_old"),
            GarminProduct::EdgeExplore1000 => f.write_str("edge_explore_1000"),
            GarminProduct::Fr225Asia => f.write_str("fr225_asia"),
            GarminProduct::VariaRadarTaillight => f.write_str("varia_radar_taillight"),
            GarminProduct::VariaRadarDisplay => f.write_str("varia_radar_display"),
            GarminProduct::Edge20 => f.write_str("edge20"),
            GarminProduct::Edge520Asia => f.write_str("edge520_asia"),
            GarminProduct::Edge520Japan => f.write_str("edge520_japan"),
            GarminProduct::D2Bravo => f.write_str("d2_bravo"),
            GarminProduct::ApproachS20 => f.write_str("approach_s20"),
            GarminProduct::VivoSmart2 => f.write_str("vivo_smart2"),
            GarminProduct::Edge1000Thai => f.write_str("edge1000_thai"),
            GarminProduct::VariaRemote => f.write_str("varia_remote"),
            GarminProduct::Edge25Asia => f.write_str("edge25_asia"),
            GarminProduct::Edge25Jpn => f.write_str("edge25_jpn"),
            GarminProduct::Edge20Asia => f.write_str("edge20_asia"),
            GarminProduct::ApproachX40 => f.write_str("approach_x40"),
            GarminProduct::Fenix3Japan => f.write_str("fenix3_japan"),
            GarminProduct::VivoSmartEmea => f.write_str("vivo_smart_emea"),
            GarminProduct::Fr630Asia => f.write_str("fr630_asia"),
            GarminProduct::Fr630Jpn => f.write_str("fr630_jpn"),
            GarminProduct::Fr230Jpn => f.write_str("fr230_jpn"),
            GarminProduct::Hrm4Run => f.write_str("hrm4_run"),
            GarminProduct::EpixJapan => f.write_str("epix_japan"),
            GarminProduct::VivoActiveHr => f.write_str("vivo_active_hr"),
            GarminProduct::VivoSmartGpsHr => f.write_str("vivo_smart_gps_hr"),
            GarminProduct::VivoSmartHr => f.write_str("vivo_smart_hr"),
            GarminProduct::VivoSmartHrAsia => f.write_str("vivo_smart_hr_asia"),
            GarminProduct::VivoSmartGpsHrAsia => f.write_str("vivo_smart_gps_hr_asia"),
            GarminProduct::VivoMove => f.write_str("vivo_move"),
            GarminProduct::VariaTaillight => f.write_str("varia_taillight"),
            GarminProduct::Fr235Asia => f.write_str("fr235_asia"),
            GarminProduct::Fr235Japan => f.write_str("fr235_japan"),
            GarminProduct::VariaVision => f.write_str("varia_vision"),
            GarminProduct::VivoFit3 => f.write_str("vivo_fit3"),
            GarminProduct::Fenix3Korea => f.write_str("fenix3_korea"),
            GarminProduct::Fenix3Sea => f.write_str("fenix3_sea"),
            GarminProduct::Fenix3Hr => f.write_str("fenix3_hr"),
            GarminProduct::VirbUltra30 => f.write_str("virb_ultra_30"),
            GarminProduct::IndexSmartScale => f.write_str("index_smart_scale"),
            GarminProduct::Fr235 => f.write_str("fr235"),
            GarminProduct::Fenix3Chronos => f.write_str("fenix3_chronos"),
            GarminProduct::Oregon7xx => f.write_str("oregon7xx"),
            GarminProduct::Rino7xx => f.write_str("rino7xx"),
            GarminProduct::EpixKorea => f.write_str("epix_korea"),
            GarminProduct::Fenix3HrChn => f.write_str("fenix3_hr_chn"),
            GarminProduct::Fenix3HrTwn => f.write_str("fenix3_hr_twn"),
            GarminProduct::Fenix3HrJpn => f.write_str("fenix3_hr_jpn"),
            GarminProduct::Fenix3HrSea => f.write_str("fenix3_hr_sea"),
            GarminProduct::Fenix3HrKor => f.write_str("fenix3_hr_kor"),
            GarminProduct::Nautix => f.write_str("nautix"),
            GarminProduct::VivoActiveHrApac => f.write_str("vivo_active_hr_apac"),
            GarminProduct::Fr35 => f.write_str("fr35"),
            GarminProduct::Oregon7xxWw => f.write_str("oregon7xx_ww"),
            GarminProduct::Edge820 => f.write_str("edge_820"),
            GarminProduct::EdgeExplore820 => f.write_str("edge_explore_820"),
            GarminProduct::Fr735xtApac => f.write_str("fr735xt_apac"),
            GarminProduct::Fr735xtJapan => f.write_str("fr735xt_japan"),
            GarminProduct::Fenix5s => f.write_str("fenix5s"),
            GarminProduct::D2BravoTitanium => f.write_str("d2_bravo_titanium"),
            GarminProduct::VariaUt800 => f.write_str("varia_ut800"),
            GarminProduct::RunningDynamicsPod => f.write_str("running_dynamics_pod"),
            GarminProduct::Edge820China => f.write_str("edge_820_china"),
            GarminProduct::Edge820Japan => f.write_str("edge_820_japan"),
            GarminProduct::Fenix5x => f.write_str("fenix5x"),
            GarminProduct::VivoFitJr => f.write_str("vivo_fit_jr"),
            GarminProduct::VivoSmart3 => f.write_str("vivo_smart3"),
            GarminProduct::VivoSport => f.write_str("vivo_sport"),
            GarminProduct::Edge820Taiwan => f.write_str("edge_820_taiwan"),
            GarminProduct::Edge820Korea => f.write_str("edge_820_korea"),
            GarminProduct::Edge820Sea => f.write_str("edge_820_sea"),
            GarminProduct::Fr35Hebrew => f.write_str("fr35_hebrew"),
            GarminProduct::ApproachS60 => f.write_str("approach_s60"),
            GarminProduct::Fr35Apac => f.write_str("fr35_apac"),
            GarminProduct::Fr35Japan => f.write_str("fr35_japan"),
            GarminProduct::Fenix3ChronosAsia => f.write_str("fenix3_chronos_asia"),
            GarminProduct::Virb360 => f.write_str("virb_360"),
            GarminProduct::Fr935 => f.write_str("fr935"),
            GarminProduct::Fenix5 => f.write_str("fenix5"),
            GarminProduct::Vivoactive3 => f.write_str("vivoactive3"),
            GarminProduct::Fr235ChinaNfc => f.write_str("fr235_china_nfc"),
            GarminProduct::Foretrex601701 => f.write_str("foretrex_601_701"),
            GarminProduct::VivoMoveHr => f.write_str("vivo_move_hr"),
            GarminProduct::Edge1030 => f.write_str("edge_1030"),
            GarminProduct::Fr35Sea => f.write_str("fr35_sea"),
            GarminProduct::Vector3 => f.write_str("vector_3"),
            GarminProduct::Fenix5Asia => f.write_str("fenix5_asia"),
            GarminProduct::Fenix5sAsia => f.write_str("fenix5s_asia"),
            GarminProduct::Fenix5xAsia => f.write_str("fenix5x_asia"),
            GarminProduct::ApproachZ80 => f.write_str("approach_z80"),
            GarminProduct::Fr35Korea => f.write_str("fr35_korea"),
            GarminProduct::D2charlie => f.write_str("d2charlie"),
            GarminProduct::VivoSmart3Apac => f.write_str("vivo_smart3_apac"),
            GarminProduct::VivoSportApac => f.write_str("vivo_sport_apac"),
            GarminProduct::Fr935Asia => f.write_str("fr935_asia"),
            GarminProduct::Descent => f.write_str("descent"),
            GarminProduct::VivoFit4 => f.write_str("vivo_fit4"),
            GarminProduct::Fr645 => f.write_str("fr645"),
            GarminProduct::Fr645m => f.write_str("fr645m"),
            GarminProduct::Fr30 => f.write_str("fr30"),
            GarminProduct::Fenix5sPlus => f.write_str("fenix5s_plus"),
            GarminProduct::Edge130 => f.write_str("Edge_130"),
            GarminProduct::Edge1030Asia => f.write_str("edge_1030_asia"),
            GarminProduct::Vivosmart4 => f.write_str("vivosmart_4"),
            GarminProduct::VivoMoveHrAsia => f.write_str("vivo_move_hr_asia"),
            GarminProduct::ApproachX10 => f.write_str("approach_x10"),
            GarminProduct::Fr30Asia => f.write_str("fr30_asia"),
            GarminProduct::Vivoactive3mW => f.write_str("vivoactive3m_w"),
            GarminProduct::Fr645Asia => f.write_str("fr645_asia"),
            GarminProduct::Fr645mAsia => f.write_str("fr645m_asia"),
            GarminProduct::EdgeExplore => f.write_str("edge_explore"),
            GarminProduct::Gpsmap66 => f.write_str("gpsmap66"),
            GarminProduct::ApproachS10 => f.write_str("approach_s10"),
            GarminProduct::Vivoactive3mL => f.write_str("vivoactive3m_l"),
            GarminProduct::ApproachG80 => f.write_str("approach_g80"),
            GarminProduct::Edge130Asia => f.write_str("edge_130_asia"),
            GarminProduct::Edge1030Bontrager => f.write_str("edge_1030_bontrager"),
            GarminProduct::Fenix5Plus => f.write_str("fenix5_plus"),
            GarminProduct::Fenix5xPlus => f.write_str("fenix5x_plus"),
            GarminProduct::Edge520Plus => f.write_str("edge_520_plus"),
            GarminProduct::Fr945 => f.write_str("fr945"),
            GarminProduct::Edge530 => f.write_str("edge_530"),
            GarminProduct::Edge830 => f.write_str("edge_830"),
            GarminProduct::InstinctEsports => f.write_str("instinct_esports"),
            GarminProduct::Fenix5sPlusApac => f.write_str("fenix5s_plus_apac"),
            GarminProduct::Fenix5xPlusApac => f.write_str("fenix5x_plus_apac"),
            GarminProduct::Edge520PlusApac => f.write_str("edge_520_plus_apac"),
            GarminProduct::DescentT1 => f.write_str("descent_t1"),
            GarminProduct::Fr235lAsia => f.write_str("fr235l_asia"),
            GarminProduct::Fr245Asia => f.write_str("fr245_asia"),
            GarminProduct::VivoActive3mApac => f.write_str("vivo_active3m_apac"),
            GarminProduct::Gen3Bsm => f.write_str("gen3_bsm"),
            GarminProduct::Gen3Bcm => f.write_str("gen3_bcm"),
            GarminProduct::VivoSmart4Asia => f.write_str("vivo_smart4_asia"),
            GarminProduct::Vivoactive4Small => f.write_str("vivoactive4_small"),
            GarminProduct::Vivoactive4Large => f.write_str("vivoactive4_large"),
            GarminProduct::Venu => f.write_str("venu"),
            GarminProduct::MarqDriver => f.write_str("marq_driver"),
            GarminProduct::MarqAviator => f.write_str("marq_aviator"),
            GarminProduct::MarqCaptain => f.write_str("marq_captain"),
            GarminProduct::MarqCommander => f.write_str("marq_commander"),
            GarminProduct::MarqExpedition => f.write_str("marq_expedition"),
            GarminProduct::MarqAthlete => f.write_str("marq_athlete"),
            GarminProduct::DescentMk2 => f.write_str("descent_mk2"),
            GarminProduct::Gpsmap66i => f.write_str("gpsmap66i"),
            GarminProduct::Fenix6SSport => f.write_str("fenix6S_sport"),
            GarminProduct::Fenix6S => f.write_str("fenix6S"),
            GarminProduct::Fenix6Sport => f.write_str("fenix6_sport"),
            GarminProduct::Fenix6 => f.write_str("fenix6"),
            GarminProduct::Fenix6x => f.write_str("fenix6x"),
            GarminProduct::HrmDual => f.write_str("hrm_dual"),
            GarminProduct::HrmPro => f.write_str("hrm_pro"),
            GarminProduct::VivoMove3Premium => f.write_str("vivo_move3_premium"),
            GarminProduct::ApproachS40 => f.write_str("approach_s40"),
            GarminProduct::Fr245mAsia => f.write_str("fr245m_asia"),
            GarminProduct::Edge530Apac => f.write_str("edge_530_apac"),
            GarminProduct::Edge830Apac => f.write_str("edge_830_apac"),
            GarminProduct::VivoMove3 => f.write_str("vivo_move3"),
            GarminProduct::VivoActive4SmallAsia => f.write_str("vivo_active4_small_asia"),
            GarminProduct::VivoActive4LargeAsia => f.write_str("vivo_active4_large_asia"),
            GarminProduct::VivoActive4OledAsia => f.write_str("vivo_active4_oled_asia"),
            GarminProduct::Swim2 => f.write_str("swim2"),
            GarminProduct::MarqDriverAsia => f.write_str("marq_driver_asia"),
            GarminProduct::MarqAviatorAsia => f.write_str("marq_aviator_asia"),
            GarminProduct::VivoMove3Asia => f.write_str("vivo_move3_asia"),
            GarminProduct::Fr945Asia => f.write_str("fr945_asia"),
            GarminProduct::VivoActive3tChn => f.write_str("vivo_active3t_chn"),
            GarminProduct::MarqCaptainAsia => f.write_str("marq_captain_asia"),
            GarminProduct::MarqCommanderAsia => f.write_str("marq_commander_asia"),
            GarminProduct::MarqExpeditionAsia => f.write_str("marq_expedition_asia"),
            GarminProduct::MarqAthleteAsia => f.write_str("marq_athlete_asia"),
            GarminProduct::InstinctSolar => f.write_str("instinct_solar"),
            GarminProduct::Fr45Asia => f.write_str("fr45_asia"),
            GarminProduct::Vivoactive3Daimler => f.write_str("vivoactive3_daimler"),
            GarminProduct::LegacyRey => f.write_str("legacy_rey"),
            GarminProduct::LegacyDarthVader => f.write_str("legacy_darth_vader"),
            GarminProduct::LegacyCaptainMarvel => f.write_str("legacy_captain_marvel"),
            GarminProduct::LegacyFirstAvenger => f.write_str("legacy_first_avenger"),
            GarminProduct::Fenix6sSportAsia => f.write_str("fenix6s_sport_asia"),
            GarminProduct::Fenix6sAsia => f.write_str("fenix6s_asia"),
            GarminProduct::Fenix6SportAsia => f.write_str("fenix6_sport_asia"),
            GarminProduct::Fenix6Asia => f.write_str("fenix6_asia"),
            GarminProduct::Fenix6xAsia => f.write_str("fenix6x_asia"),
            GarminProduct::LegacyCaptainMarvelAsia => f.write_str("legacy_captain_marvel_asia"),
            GarminProduct::LegacyFirstAvengerAsia => f.write_str("legacy_first_avenger_asia"),
            GarminProduct::LegacyReyAsia => f.write_str("legacy_rey_asia"),
            GarminProduct::LegacyDarthVaderAsia => f.write_str("legacy_darth_vader_asia"),
            GarminProduct::DescentMk2s => f.write_str("descent_mk2s"),
            GarminProduct::Edge130Plus => f.write_str("edge_130_plus"),
            GarminProduct::Edge1030Plus => f.write_str("edge_1030_plus"),
            GarminProduct::Rally200 => f.write_str("rally_200"),
            GarminProduct::Fr745 => f.write_str("fr745"),
            GarminProduct::Venusq => f.write_str("venusq"),
            GarminProduct::Lily => f.write_str("lily"),
            GarminProduct::MarqAdventurer => f.write_str("marq_adventurer"),
            GarminProduct::Enduro => f.write_str("enduro"),
            GarminProduct::Swim2Apac => f.write_str("swim2_apac"),
            GarminProduct::MarqAdventurerAsia => f.write_str("marq_adventurer_asia"),
            GarminProduct::Fr945Lte => f.write_str("fr945_lte"),
            GarminProduct::DescentMk2Asia => f.write_str("descent_mk2_asia"),
            GarminProduct::Venu2 => f.write_str("venu2"),
            GarminProduct::Venu2s => f.write_str("venu2s"),
            GarminProduct::VenuDaimlerAsia => f.write_str("venu_daimler_asia"),
            GarminProduct::MarqGolfer => f.write_str("marq_golfer"),
            GarminProduct::VenuDaimler => f.write_str("venu_daimler"),
            GarminProduct::Fr745Asia => f.write_str("fr745_asia"),
            GarminProduct::LilyAsia => f.write_str("lily_asia"),
            GarminProduct::Edge1030PlusAsia => f.write_str("edge_1030_plus_asia"),
            GarminProduct::Edge130PlusAsia => f.write_str("edge_130_plus_asia"),
            GarminProduct::ApproachS12 => f.write_str("approach_s12"),
            GarminProduct::EnduroAsia => f.write_str("enduro_asia"),
            GarminProduct::VenusqAsia => f.write_str("venusq_asia"),
            GarminProduct::Edge1040 => f.write_str("edge_1040"),
            GarminProduct::MarqGolferAsia => f.write_str("marq_golfer_asia"),
            GarminProduct::Venu2Plus => f.write_str("venu2_plus"),
            GarminProduct::Gnss => f.write_str("gnss"),
            GarminProduct::Fr55 => f.write_str("fr55"),
            GarminProduct::Instinct2 => f.write_str("instinct_2"),
            GarminProduct::Fenix7s => f.write_str("fenix7s"),
            GarminProduct::Fenix7 => f.write_str("fenix7"),
            GarminProduct::Fenix7x => f.write_str("fenix7x"),
            GarminProduct::Fenix7sApac => f.write_str("fenix7s_apac"),
            GarminProduct::Fenix7Apac => f.write_str("fenix7_apac"),
            GarminProduct::Fenix7xApac => f.write_str("fenix7x_apac"),
            GarminProduct::ApproachG12 => f.write_str("approach_g12"),
            GarminProduct::DescentMk2sAsia => f.write_str("descent_mk2s_asia"),
            GarminProduct::ApproachS42 => f.write_str("approach_s42"),
            GarminProduct::EpixGen2 => f.write_str("epix_gen2"),
            GarminProduct::EpixGen2Apac => f.write_str("epix_gen2_apac"),
            GarminProduct::Venu2sAsia => f.write_str("venu2s_asia"),
            GarminProduct::Venu2Asia => f.write_str("venu2_asia"),
            GarminProduct::Fr945LteAsia => f.write_str("fr945_lte_asia"),
            GarminProduct::VivoMoveSport => f.write_str("vivo_move_sport"),
            GarminProduct::VivomoveTrend => f.write_str("vivomove_trend"),
            GarminProduct::ApproachS12Asia => f.write_str("approach_S12_asia"),
            GarminProduct::Fr255Music => f.write_str("fr255_music"),
            GarminProduct::Fr255SmallMusic => f.write_str("fr255_small_music"),
            GarminProduct::Fr255 => f.write_str("fr255"),
            GarminProduct::Fr255Small => f.write_str("fr255_small"),
            GarminProduct::ApproachG12Asia => f.write_str("approach_g12_asia"),
            GarminProduct::ApproachS42Asia => f.write_str("approach_s42_asia"),
            GarminProduct::DescentG1 => f.write_str("descent_g1"),
            GarminProduct::Venu2PlusAsia => f.write_str("venu2_plus_asia"),
            GarminProduct::Fr955 => f.write_str("fr955"),
            GarminProduct::Fr55Asia => f.write_str("fr55_asia"),
            GarminProduct::Edge540 => f.write_str("edge_540"),
            GarminProduct::Edge840 => f.write_str("edge_840"),
            GarminProduct::Vivosmart5 => f.write_str("vivosmart_5"),
            GarminProduct::Instinct2Asia => f.write_str("instinct_2_asia"),
            GarminProduct::MarqGen2 => f.write_str("marq_gen2"),
            GarminProduct::Venusq2 => f.write_str("venusq2"),
            GarminProduct::Venusq2music => f.write_str("venusq2music"),
            GarminProduct::MarqGen2Aviator => f.write_str("marq_gen2_aviator"),
            GarminProduct::D2AirX10 => f.write_str("d2_air_x10"),
            GarminProduct::HrmProPlus => f.write_str("hrm_pro_plus"),
            GarminProduct::DescentG1Asia => f.write_str("descent_g1_asia"),
            GarminProduct::Tactix7 => f.write_str("tactix7"),
            GarminProduct::InstinctCrossover => f.write_str("instinct_crossover"),
            GarminProduct::EdgeExplore2 => f.write_str("edge_explore2"),
            GarminProduct::ApproachS70 => f.write_str("approach_s70"),
            GarminProduct::Fr265Large => f.write_str("fr265_large"),
            GarminProduct::Fr265Small => f.write_str("fr265_small"),
            GarminProduct::TacxNeoSmart => f.write_str("tacx_neo_smart"),
            GarminProduct::TacxNeo2Smart => f.write_str("tacx_neo2_smart"),
            GarminProduct::TacxNeo2TSmart => f.write_str("tacx_neo2_t_smart"),
            GarminProduct::TacxNeoSmartBike => f.write_str("tacx_neo_smart_bike"),
            GarminProduct::TacxSatoriSmart => f.write_str("tacx_satori_smart"),
            GarminProduct::TacxFlowSmart => f.write_str("tacx_flow_smart"),
            GarminProduct::TacxVortexSmart => f.write_str("tacx_vortex_smart"),
            GarminProduct::TacxBushidoSmart => f.write_str("tacx_bushido_smart"),
            GarminProduct::TacxGeniusSmart => f.write_str("tacx_genius_smart"),
            GarminProduct::TacxFluxFluxSSmart => f.write_str("tacx_flux_flux_s_smart"),
            GarminProduct::TacxFlux2Smart => f.write_str("tacx_flux2_smart"),
            GarminProduct::TacxMagnum => f.write_str("tacx_magnum"),
            GarminProduct::Edge1040Asia => f.write_str("edge_1040_asia"),
            GarminProduct::EpixGen2Pro42 => f.write_str("epix_gen2_pro_42"),
            GarminProduct::EpixGen2Pro47 => f.write_str("epix_gen2_pro_47"),
            GarminProduct::EpixGen2Pro51 => f.write_str("epix_gen2_pro_51"),
            GarminProduct::Fr965 => f.write_str("fr965"),
            GarminProduct::Enduro2 => f.write_str("enduro2"),
            GarminProduct::Fenix7ProSolar => f.write_str("fenix7_pro_solar"),
            GarminProduct::Instinct2x => f.write_str("instinct_2x"),
            GarminProduct::DescentT2 => f.write_str("descent_t2"),
            GarminProduct::Sdm4 => f.write_str("sdm4"),
            GarminProduct::EdgeRemote => f.write_str("edge_remote"),
            GarminProduct::TacxTrainingAppWin => f.write_str("tacx_training_app_win"),
            GarminProduct::TacxTrainingAppMac => f.write_str("tacx_training_app_mac"),
            GarminProduct::TacxTrainingAppMacCatalyst => {
                f.write_str("tacx_training_app_mac_catalyst")
            }
            GarminProduct::TrainingCenter => f.write_str("training_center"),
            GarminProduct::TacxTrainingAppAndroid => f.write_str("tacx_training_app_android"),
            GarminProduct::TacxTrainingAppIos => f.write_str("tacx_training_app_ios"),
            GarminProduct::TacxTrainingAppLegacy => f.write_str("tacx_training_app_legacy"),
            GarminProduct::ConnectiqSimulator => f.write_str("connectiq_simulator"),
            GarminProduct::AndroidAntplusPlugin => f.write_str("android_antplus_plugin"),
            GarminProduct::Connect => f.write_str("connect"),
        }
    }
}
impl GarminProduct {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            GarminProduct::Hrm1 => fit::Value::UInt16(1),
            GarminProduct::Axh01 => fit::Value::UInt16(2),
            GarminProduct::Axb01 => fit::Value::UInt16(3),
            GarminProduct::Axb02 => fit::Value::UInt16(4),
            GarminProduct::Hrm2ss => fit::Value::UInt16(5),
            GarminProduct::DsiAlf02 => fit::Value::UInt16(6),
            GarminProduct::Hrm3ss => fit::Value::UInt16(7),
            GarminProduct::HrmRunSingleByteProductId => fit::Value::UInt16(8),
            GarminProduct::Bsm => fit::Value::UInt16(9),
            GarminProduct::Bcm => fit::Value::UInt16(10),
            GarminProduct::Axs01 => fit::Value::UInt16(11),
            GarminProduct::HrmTriSingleByteProductId => fit::Value::UInt16(12),
            GarminProduct::Hrm4RunSingleByteProductId => fit::Value::UInt16(13),
            GarminProduct::Fr225SingleByteProductId => fit::Value::UInt16(14),
            GarminProduct::Gen3BsmSingleByteProductId => fit::Value::UInt16(15),
            GarminProduct::Gen3BcmSingleByteProductId => fit::Value::UInt16(16),
            GarminProduct::OHR => fit::Value::UInt16(255),
            GarminProduct::Fr301China => fit::Value::UInt16(473),
            GarminProduct::Fr301Japan => fit::Value::UInt16(474),
            GarminProduct::Fr301Korea => fit::Value::UInt16(475),
            GarminProduct::Fr301Taiwan => fit::Value::UInt16(494),
            GarminProduct::Fr405 => fit::Value::UInt16(717),
            GarminProduct::Fr50 => fit::Value::UInt16(782),
            GarminProduct::Fr405Japan => fit::Value::UInt16(987),
            GarminProduct::Fr60 => fit::Value::UInt16(988),
            GarminProduct::DsiAlf01 => fit::Value::UInt16(1011),
            GarminProduct::Fr310xt => fit::Value::UInt16(1018),
            GarminProduct::Edge500 => fit::Value::UInt16(1036),
            GarminProduct::Fr110 => fit::Value::UInt16(1124),
            GarminProduct::Edge800 => fit::Value::UInt16(1169),
            GarminProduct::Edge500Taiwan => fit::Value::UInt16(1199),
            GarminProduct::Edge500Japan => fit::Value::UInt16(1213),
            GarminProduct::Chirp => fit::Value::UInt16(1253),
            GarminProduct::Fr110Japan => fit::Value::UInt16(1274),
            GarminProduct::Edge200 => fit::Value::UInt16(1325),
            GarminProduct::Fr910xt => fit::Value::UInt16(1328),
            GarminProduct::Edge800Taiwan => fit::Value::UInt16(1333),
            GarminProduct::Edge800Japan => fit::Value::UInt16(1334),
            GarminProduct::Alf04 => fit::Value::UInt16(1341),
            GarminProduct::Fr610 => fit::Value::UInt16(1345),
            GarminProduct::Fr210Japan => fit::Value::UInt16(1360),
            GarminProduct::VectorSs => fit::Value::UInt16(1380),
            GarminProduct::VectorCp => fit::Value::UInt16(1381),
            GarminProduct::Edge800China => fit::Value::UInt16(1386),
            GarminProduct::Edge500China => fit::Value::UInt16(1387),
            GarminProduct::ApproachG10 => fit::Value::UInt16(1405),
            GarminProduct::Fr610Japan => fit::Value::UInt16(1410),
            GarminProduct::Edge500Korea => fit::Value::UInt16(1422),
            GarminProduct::Fr70 => fit::Value::UInt16(1436),
            GarminProduct::Fr310xt4t => fit::Value::UInt16(1446),
            GarminProduct::Amx => fit::Value::UInt16(1461),
            GarminProduct::Fr10 => fit::Value::UInt16(1482),
            GarminProduct::Edge800Korea => fit::Value::UInt16(1497),
            GarminProduct::Swim => fit::Value::UInt16(1499),
            GarminProduct::Fr910xtChina => fit::Value::UInt16(1537),
            GarminProduct::Fenix => fit::Value::UInt16(1551),
            GarminProduct::Edge200Taiwan => fit::Value::UInt16(1555),
            GarminProduct::Edge510 => fit::Value::UInt16(1561),
            GarminProduct::Edge810 => fit::Value::UInt16(1567),
            GarminProduct::Tempe => fit::Value::UInt16(1570),
            GarminProduct::Fr910xtJapan => fit::Value::UInt16(1600),
            GarminProduct::Fr620 => fit::Value::UInt16(1623),
            GarminProduct::Fr220 => fit::Value::UInt16(1632),
            GarminProduct::Fr910xtKorea => fit::Value::UInt16(1664),
            GarminProduct::Fr10Japan => fit::Value::UInt16(1688),
            GarminProduct::Edge810Japan => fit::Value::UInt16(1721),
            GarminProduct::VirbElite => fit::Value::UInt16(1735),
            GarminProduct::EdgeTouring => fit::Value::UInt16(1736),
            GarminProduct::Edge510Japan => fit::Value::UInt16(1742),
            GarminProduct::HrmTri => fit::Value::UInt16(1743),
            GarminProduct::HrmRun => fit::Value::UInt16(1752),
            GarminProduct::Fr920xt => fit::Value::UInt16(1765),
            GarminProduct::Edge510Asia => fit::Value::UInt16(1821),
            GarminProduct::Edge810China => fit::Value::UInt16(1822),
            GarminProduct::Edge810Taiwan => fit::Value::UInt16(1823),
            GarminProduct::Edge1000 => fit::Value::UInt16(1836),
            GarminProduct::VivoFit => fit::Value::UInt16(1837),
            GarminProduct::VirbRemote => fit::Value::UInt16(1853),
            GarminProduct::VivoKi => fit::Value::UInt16(1885),
            GarminProduct::Fr15 => fit::Value::UInt16(1903),
            GarminProduct::VivoActive => fit::Value::UInt16(1907),
            GarminProduct::Edge510Korea => fit::Value::UInt16(1918),
            GarminProduct::Fr620Japan => fit::Value::UInt16(1928),
            GarminProduct::Fr620China => fit::Value::UInt16(1929),
            GarminProduct::Fr220Japan => fit::Value::UInt16(1930),
            GarminProduct::Fr220China => fit::Value::UInt16(1931),
            GarminProduct::ApproachS6 => fit::Value::UInt16(1936),
            GarminProduct::VivoSmart => fit::Value::UInt16(1956),
            GarminProduct::Fenix2 => fit::Value::UInt16(1967),
            GarminProduct::Epix => fit::Value::UInt16(1988),
            GarminProduct::Fenix3 => fit::Value::UInt16(2050),
            GarminProduct::Edge1000Taiwan => fit::Value::UInt16(2052),
            GarminProduct::Edge1000Japan => fit::Value::UInt16(2053),
            GarminProduct::Fr15Japan => fit::Value::UInt16(2061),
            GarminProduct::Edge520 => fit::Value::UInt16(2067),
            GarminProduct::Edge1000China => fit::Value::UInt16(2070),
            GarminProduct::Fr620Russia => fit::Value::UInt16(2072),
            GarminProduct::Fr220Russia => fit::Value::UInt16(2073),
            GarminProduct::VectorS => fit::Value::UInt16(2079),
            GarminProduct::Edge1000Korea => fit::Value::UInt16(2100),
            GarminProduct::Fr920xtTaiwan => fit::Value::UInt16(2130),
            GarminProduct::Fr920xtChina => fit::Value::UInt16(2131),
            GarminProduct::Fr920xtJapan => fit::Value::UInt16(2132),
            GarminProduct::Virbx => fit::Value::UInt16(2134),
            GarminProduct::VivoSmartApac => fit::Value::UInt16(2135),
            GarminProduct::EtrexTouch => fit::Value::UInt16(2140),
            GarminProduct::Edge25 => fit::Value::UInt16(2147),
            GarminProduct::Fr25 => fit::Value::UInt16(2148),
            GarminProduct::VivoFit2 => fit::Value::UInt16(2150),
            GarminProduct::Fr225 => fit::Value::UInt16(2153),
            GarminProduct::Fr630 => fit::Value::UInt16(2156),
            GarminProduct::Fr230 => fit::Value::UInt16(2157),
            GarminProduct::Fr735xt => fit::Value::UInt16(2158),
            GarminProduct::VivoActiveApac => fit::Value::UInt16(2160),
            GarminProduct::Vector2 => fit::Value::UInt16(2161),
            GarminProduct::Vector2s => fit::Value::UInt16(2162),
            GarminProduct::Virbxe => fit::Value::UInt16(2172),
            GarminProduct::Fr620Taiwan => fit::Value::UInt16(2173),
            GarminProduct::Fr220Taiwan => fit::Value::UInt16(2174),
            GarminProduct::Truswing => fit::Value::UInt16(2175),
            GarminProduct::D2airvenu => fit::Value::UInt16(2187),
            GarminProduct::Fenix3China => fit::Value::UInt16(2188),
            GarminProduct::Fenix3Twn => fit::Value::UInt16(2189),
            GarminProduct::VariaHeadlight => fit::Value::UInt16(2192),
            GarminProduct::VariaTaillightOld => fit::Value::UInt16(2193),
            GarminProduct::EdgeExplore1000 => fit::Value::UInt16(2204),
            GarminProduct::Fr225Asia => fit::Value::UInt16(2219),
            GarminProduct::VariaRadarTaillight => fit::Value::UInt16(2225),
            GarminProduct::VariaRadarDisplay => fit::Value::UInt16(2226),
            GarminProduct::Edge20 => fit::Value::UInt16(2238),
            GarminProduct::Edge520Asia => fit::Value::UInt16(2260),
            GarminProduct::Edge520Japan => fit::Value::UInt16(2261),
            GarminProduct::D2Bravo => fit::Value::UInt16(2262),
            GarminProduct::ApproachS20 => fit::Value::UInt16(2266),
            GarminProduct::VivoSmart2 => fit::Value::UInt16(2271),
            GarminProduct::Edge1000Thai => fit::Value::UInt16(2274),
            GarminProduct::VariaRemote => fit::Value::UInt16(2276),
            GarminProduct::Edge25Asia => fit::Value::UInt16(2288),
            GarminProduct::Edge25Jpn => fit::Value::UInt16(2289),
            GarminProduct::Edge20Asia => fit::Value::UInt16(2290),
            GarminProduct::ApproachX40 => fit::Value::UInt16(2292),
            GarminProduct::Fenix3Japan => fit::Value::UInt16(2293),
            GarminProduct::VivoSmartEmea => fit::Value::UInt16(2294),
            GarminProduct::Fr630Asia => fit::Value::UInt16(2310),
            GarminProduct::Fr630Jpn => fit::Value::UInt16(2311),
            GarminProduct::Fr230Jpn => fit::Value::UInt16(2313),
            GarminProduct::Hrm4Run => fit::Value::UInt16(2327),
            GarminProduct::EpixJapan => fit::Value::UInt16(2332),
            GarminProduct::VivoActiveHr => fit::Value::UInt16(2337),
            GarminProduct::VivoSmartGpsHr => fit::Value::UInt16(2347),
            GarminProduct::VivoSmartHr => fit::Value::UInt16(2348),
            GarminProduct::VivoSmartHrAsia => fit::Value::UInt16(2361),
            GarminProduct::VivoSmartGpsHrAsia => fit::Value::UInt16(2362),
            GarminProduct::VivoMove => fit::Value::UInt16(2368),
            GarminProduct::VariaTaillight => fit::Value::UInt16(2379),
            GarminProduct::Fr235Asia => fit::Value::UInt16(2396),
            GarminProduct::Fr235Japan => fit::Value::UInt16(2397),
            GarminProduct::VariaVision => fit::Value::UInt16(2398),
            GarminProduct::VivoFit3 => fit::Value::UInt16(2406),
            GarminProduct::Fenix3Korea => fit::Value::UInt16(2407),
            GarminProduct::Fenix3Sea => fit::Value::UInt16(2408),
            GarminProduct::Fenix3Hr => fit::Value::UInt16(2413),
            GarminProduct::VirbUltra30 => fit::Value::UInt16(2417),
            GarminProduct::IndexSmartScale => fit::Value::UInt16(2429),
            GarminProduct::Fr235 => fit::Value::UInt16(2431),
            GarminProduct::Fenix3Chronos => fit::Value::UInt16(2432),
            GarminProduct::Oregon7xx => fit::Value::UInt16(2441),
            GarminProduct::Rino7xx => fit::Value::UInt16(2444),
            GarminProduct::EpixKorea => fit::Value::UInt16(2457),
            GarminProduct::Fenix3HrChn => fit::Value::UInt16(2473),
            GarminProduct::Fenix3HrTwn => fit::Value::UInt16(2474),
            GarminProduct::Fenix3HrJpn => fit::Value::UInt16(2475),
            GarminProduct::Fenix3HrSea => fit::Value::UInt16(2476),
            GarminProduct::Fenix3HrKor => fit::Value::UInt16(2477),
            GarminProduct::Nautix => fit::Value::UInt16(2496),
            GarminProduct::VivoActiveHrApac => fit::Value::UInt16(2497),
            GarminProduct::Fr35 => fit::Value::UInt16(2503),
            GarminProduct::Oregon7xxWw => fit::Value::UInt16(2512),
            GarminProduct::Edge820 => fit::Value::UInt16(2530),
            GarminProduct::EdgeExplore820 => fit::Value::UInt16(2531),
            GarminProduct::Fr735xtApac => fit::Value::UInt16(2533),
            GarminProduct::Fr735xtJapan => fit::Value::UInt16(2534),
            GarminProduct::Fenix5s => fit::Value::UInt16(2544),
            GarminProduct::D2BravoTitanium => fit::Value::UInt16(2547),
            GarminProduct::VariaUt800 => fit::Value::UInt16(2567),
            GarminProduct::RunningDynamicsPod => fit::Value::UInt16(2593),
            GarminProduct::Edge820China => fit::Value::UInt16(2599),
            GarminProduct::Edge820Japan => fit::Value::UInt16(2600),
            GarminProduct::Fenix5x => fit::Value::UInt16(2604),
            GarminProduct::VivoFitJr => fit::Value::UInt16(2606),
            GarminProduct::VivoSmart3 => fit::Value::UInt16(2622),
            GarminProduct::VivoSport => fit::Value::UInt16(2623),
            GarminProduct::Edge820Taiwan => fit::Value::UInt16(2628),
            GarminProduct::Edge820Korea => fit::Value::UInt16(2629),
            GarminProduct::Edge820Sea => fit::Value::UInt16(2630),
            GarminProduct::Fr35Hebrew => fit::Value::UInt16(2650),
            GarminProduct::ApproachS60 => fit::Value::UInt16(2656),
            GarminProduct::Fr35Apac => fit::Value::UInt16(2667),
            GarminProduct::Fr35Japan => fit::Value::UInt16(2668),
            GarminProduct::Fenix3ChronosAsia => fit::Value::UInt16(2675),
            GarminProduct::Virb360 => fit::Value::UInt16(2687),
            GarminProduct::Fr935 => fit::Value::UInt16(2691),
            GarminProduct::Fenix5 => fit::Value::UInt16(2697),
            GarminProduct::Vivoactive3 => fit::Value::UInt16(2700),
            GarminProduct::Fr235ChinaNfc => fit::Value::UInt16(2733),
            GarminProduct::Foretrex601701 => fit::Value::UInt16(2769),
            GarminProduct::VivoMoveHr => fit::Value::UInt16(2772),
            GarminProduct::Edge1030 => fit::Value::UInt16(2713),
            GarminProduct::Fr35Sea => fit::Value::UInt16(2727),
            GarminProduct::Vector3 => fit::Value::UInt16(2787),
            GarminProduct::Fenix5Asia => fit::Value::UInt16(2796),
            GarminProduct::Fenix5sAsia => fit::Value::UInt16(2797),
            GarminProduct::Fenix5xAsia => fit::Value::UInt16(2798),
            GarminProduct::ApproachZ80 => fit::Value::UInt16(2806),
            GarminProduct::Fr35Korea => fit::Value::UInt16(2814),
            GarminProduct::D2charlie => fit::Value::UInt16(2819),
            GarminProduct::VivoSmart3Apac => fit::Value::UInt16(2831),
            GarminProduct::VivoSportApac => fit::Value::UInt16(2832),
            GarminProduct::Fr935Asia => fit::Value::UInt16(2833),
            GarminProduct::Descent => fit::Value::UInt16(2859),
            GarminProduct::VivoFit4 => fit::Value::UInt16(2878),
            GarminProduct::Fr645 => fit::Value::UInt16(2886),
            GarminProduct::Fr645m => fit::Value::UInt16(2888),
            GarminProduct::Fr30 => fit::Value::UInt16(2891),
            GarminProduct::Fenix5sPlus => fit::Value::UInt16(2900),
            GarminProduct::Edge130 => fit::Value::UInt16(2909),
            GarminProduct::Edge1030Asia => fit::Value::UInt16(2924),
            GarminProduct::Vivosmart4 => fit::Value::UInt16(2927),
            GarminProduct::VivoMoveHrAsia => fit::Value::UInt16(2945),
            GarminProduct::ApproachX10 => fit::Value::UInt16(2962),
            GarminProduct::Fr30Asia => fit::Value::UInt16(2977),
            GarminProduct::Vivoactive3mW => fit::Value::UInt16(2988),
            GarminProduct::Fr645Asia => fit::Value::UInt16(3003),
            GarminProduct::Fr645mAsia => fit::Value::UInt16(3004),
            GarminProduct::EdgeExplore => fit::Value::UInt16(3011),
            GarminProduct::Gpsmap66 => fit::Value::UInt16(3028),
            GarminProduct::ApproachS10 => fit::Value::UInt16(3049),
            GarminProduct::Vivoactive3mL => fit::Value::UInt16(3066),
            GarminProduct::ApproachG80 => fit::Value::UInt16(3085),
            GarminProduct::Edge130Asia => fit::Value::UInt16(3092),
            GarminProduct::Edge1030Bontrager => fit::Value::UInt16(3095),
            GarminProduct::Fenix5Plus => fit::Value::UInt16(3110),
            GarminProduct::Fenix5xPlus => fit::Value::UInt16(3111),
            GarminProduct::Edge520Plus => fit::Value::UInt16(3112),
            GarminProduct::Fr945 => fit::Value::UInt16(3113),
            GarminProduct::Edge530 => fit::Value::UInt16(3121),
            GarminProduct::Edge830 => fit::Value::UInt16(3122),
            GarminProduct::InstinctEsports => fit::Value::UInt16(3126),
            GarminProduct::Fenix5sPlusApac => fit::Value::UInt16(3134),
            GarminProduct::Fenix5xPlusApac => fit::Value::UInt16(3135),
            GarminProduct::Edge520PlusApac => fit::Value::UInt16(3142),
            GarminProduct::DescentT1 => fit::Value::UInt16(3143),
            GarminProduct::Fr235lAsia => fit::Value::UInt16(3144),
            GarminProduct::Fr245Asia => fit::Value::UInt16(3145),
            GarminProduct::VivoActive3mApac => fit::Value::UInt16(3163),
            GarminProduct::Gen3Bsm => fit::Value::UInt16(3192),
            GarminProduct::Gen3Bcm => fit::Value::UInt16(3193),
            GarminProduct::VivoSmart4Asia => fit::Value::UInt16(3218),
            GarminProduct::Vivoactive4Small => fit::Value::UInt16(3224),
            GarminProduct::Vivoactive4Large => fit::Value::UInt16(3225),
            GarminProduct::Venu => fit::Value::UInt16(3226),
            GarminProduct::MarqDriver => fit::Value::UInt16(3246),
            GarminProduct::MarqAviator => fit::Value::UInt16(3247),
            GarminProduct::MarqCaptain => fit::Value::UInt16(3248),
            GarminProduct::MarqCommander => fit::Value::UInt16(3249),
            GarminProduct::MarqExpedition => fit::Value::UInt16(3250),
            GarminProduct::MarqAthlete => fit::Value::UInt16(3251),
            GarminProduct::DescentMk2 => fit::Value::UInt16(3258),
            GarminProduct::Gpsmap66i => fit::Value::UInt16(3284),
            GarminProduct::Fenix6SSport => fit::Value::UInt16(3287),
            GarminProduct::Fenix6S => fit::Value::UInt16(3288),
            GarminProduct::Fenix6Sport => fit::Value::UInt16(3289),
            GarminProduct::Fenix6 => fit::Value::UInt16(3290),
            GarminProduct::Fenix6x => fit::Value::UInt16(3291),
            GarminProduct::HrmDual => fit::Value::UInt16(3299),
            GarminProduct::HrmPro => fit::Value::UInt16(3300),
            GarminProduct::VivoMove3Premium => fit::Value::UInt16(3308),
            GarminProduct::ApproachS40 => fit::Value::UInt16(3314),
            GarminProduct::Fr245mAsia => fit::Value::UInt16(3321),
            GarminProduct::Edge530Apac => fit::Value::UInt16(3349),
            GarminProduct::Edge830Apac => fit::Value::UInt16(3350),
            GarminProduct::VivoMove3 => fit::Value::UInt16(3378),
            GarminProduct::VivoActive4SmallAsia => fit::Value::UInt16(3387),
            GarminProduct::VivoActive4LargeAsia => fit::Value::UInt16(3388),
            GarminProduct::VivoActive4OledAsia => fit::Value::UInt16(3389),
            GarminProduct::Swim2 => fit::Value::UInt16(3405),
            GarminProduct::MarqDriverAsia => fit::Value::UInt16(3420),
            GarminProduct::MarqAviatorAsia => fit::Value::UInt16(3421),
            GarminProduct::VivoMove3Asia => fit::Value::UInt16(3422),
            GarminProduct::Fr945Asia => fit::Value::UInt16(3441),
            GarminProduct::VivoActive3tChn => fit::Value::UInt16(3446),
            GarminProduct::MarqCaptainAsia => fit::Value::UInt16(3448),
            GarminProduct::MarqCommanderAsia => fit::Value::UInt16(3449),
            GarminProduct::MarqExpeditionAsia => fit::Value::UInt16(3450),
            GarminProduct::MarqAthleteAsia => fit::Value::UInt16(3451),
            GarminProduct::InstinctSolar => fit::Value::UInt16(3466),
            GarminProduct::Fr45Asia => fit::Value::UInt16(3469),
            GarminProduct::Vivoactive3Daimler => fit::Value::UInt16(3473),
            GarminProduct::LegacyRey => fit::Value::UInt16(3498),
            GarminProduct::LegacyDarthVader => fit::Value::UInt16(3499),
            GarminProduct::LegacyCaptainMarvel => fit::Value::UInt16(3500),
            GarminProduct::LegacyFirstAvenger => fit::Value::UInt16(3501),
            GarminProduct::Fenix6sSportAsia => fit::Value::UInt16(3512),
            GarminProduct::Fenix6sAsia => fit::Value::UInt16(3513),
            GarminProduct::Fenix6SportAsia => fit::Value::UInt16(3514),
            GarminProduct::Fenix6Asia => fit::Value::UInt16(3515),
            GarminProduct::Fenix6xAsia => fit::Value::UInt16(3516),
            GarminProduct::LegacyCaptainMarvelAsia => fit::Value::UInt16(3535),
            GarminProduct::LegacyFirstAvengerAsia => fit::Value::UInt16(3536),
            GarminProduct::LegacyReyAsia => fit::Value::UInt16(3537),
            GarminProduct::LegacyDarthVaderAsia => fit::Value::UInt16(3538),
            GarminProduct::DescentMk2s => fit::Value::UInt16(3542),
            GarminProduct::Edge130Plus => fit::Value::UInt16(3558),
            GarminProduct::Edge1030Plus => fit::Value::UInt16(3570),
            GarminProduct::Rally200 => fit::Value::UInt16(3578),
            GarminProduct::Fr745 => fit::Value::UInt16(3589),
            GarminProduct::Venusq => fit::Value::UInt16(3600),
            GarminProduct::Lily => fit::Value::UInt16(3615),
            GarminProduct::MarqAdventurer => fit::Value::UInt16(3624),
            GarminProduct::Enduro => fit::Value::UInt16(3638),
            GarminProduct::Swim2Apac => fit::Value::UInt16(3639),
            GarminProduct::MarqAdventurerAsia => fit::Value::UInt16(3648),
            GarminProduct::Fr945Lte => fit::Value::UInt16(3652),
            GarminProduct::DescentMk2Asia => fit::Value::UInt16(3702),
            GarminProduct::Venu2 => fit::Value::UInt16(3703),
            GarminProduct::Venu2s => fit::Value::UInt16(3704),
            GarminProduct::VenuDaimlerAsia => fit::Value::UInt16(3737),
            GarminProduct::MarqGolfer => fit::Value::UInt16(3739),
            GarminProduct::VenuDaimler => fit::Value::UInt16(3740),
            GarminProduct::Fr745Asia => fit::Value::UInt16(3794),
            GarminProduct::LilyAsia => fit::Value::UInt16(3809),
            GarminProduct::Edge1030PlusAsia => fit::Value::UInt16(3812),
            GarminProduct::Edge130PlusAsia => fit::Value::UInt16(3813),
            GarminProduct::ApproachS12 => fit::Value::UInt16(3823),
            GarminProduct::EnduroAsia => fit::Value::UInt16(3872),
            GarminProduct::VenusqAsia => fit::Value::UInt16(3837),
            GarminProduct::Edge1040 => fit::Value::UInt16(3843),
            GarminProduct::MarqGolferAsia => fit::Value::UInt16(3850),
            GarminProduct::Venu2Plus => fit::Value::UInt16(3851),
            GarminProduct::Gnss => fit::Value::UInt16(3865),
            GarminProduct::Fr55 => fit::Value::UInt16(3869),
            GarminProduct::Instinct2 => fit::Value::UInt16(3888),
            GarminProduct::Fenix7s => fit::Value::UInt16(3905),
            GarminProduct::Fenix7 => fit::Value::UInt16(3906),
            GarminProduct::Fenix7x => fit::Value::UInt16(3907),
            GarminProduct::Fenix7sApac => fit::Value::UInt16(3908),
            GarminProduct::Fenix7Apac => fit::Value::UInt16(3909),
            GarminProduct::Fenix7xApac => fit::Value::UInt16(3910),
            GarminProduct::ApproachG12 => fit::Value::UInt16(3927),
            GarminProduct::DescentMk2sAsia => fit::Value::UInt16(3930),
            GarminProduct::ApproachS42 => fit::Value::UInt16(3934),
            GarminProduct::EpixGen2 => fit::Value::UInt16(3943),
            GarminProduct::EpixGen2Apac => fit::Value::UInt16(3944),
            GarminProduct::Venu2sAsia => fit::Value::UInt16(3949),
            GarminProduct::Venu2Asia => fit::Value::UInt16(3950),
            GarminProduct::Fr945LteAsia => fit::Value::UInt16(3978),
            GarminProduct::VivoMoveSport => fit::Value::UInt16(3982),
            GarminProduct::VivomoveTrend => fit::Value::UInt16(3983),
            GarminProduct::ApproachS12Asia => fit::Value::UInt16(3986),
            GarminProduct::Fr255Music => fit::Value::UInt16(3990),
            GarminProduct::Fr255SmallMusic => fit::Value::UInt16(3991),
            GarminProduct::Fr255 => fit::Value::UInt16(3992),
            GarminProduct::Fr255Small => fit::Value::UInt16(3993),
            GarminProduct::ApproachG12Asia => fit::Value::UInt16(4001),
            GarminProduct::ApproachS42Asia => fit::Value::UInt16(4002),
            GarminProduct::DescentG1 => fit::Value::UInt16(4005),
            GarminProduct::Venu2PlusAsia => fit::Value::UInt16(4017),
            GarminProduct::Fr955 => fit::Value::UInt16(4024),
            GarminProduct::Fr55Asia => fit::Value::UInt16(4033),
            GarminProduct::Edge540 => fit::Value::UInt16(4061),
            GarminProduct::Edge840 => fit::Value::UInt16(4062),
            GarminProduct::Vivosmart5 => fit::Value::UInt16(4063),
            GarminProduct::Instinct2Asia => fit::Value::UInt16(4071),
            GarminProduct::MarqGen2 => fit::Value::UInt16(4105),
            GarminProduct::Venusq2 => fit::Value::UInt16(4115),
            GarminProduct::Venusq2music => fit::Value::UInt16(4116),
            GarminProduct::MarqGen2Aviator => fit::Value::UInt16(4124),
            GarminProduct::D2AirX10 => fit::Value::UInt16(4125),
            GarminProduct::HrmProPlus => fit::Value::UInt16(4130),
            GarminProduct::DescentG1Asia => fit::Value::UInt16(4132),
            GarminProduct::Tactix7 => fit::Value::UInt16(4135),
            GarminProduct::InstinctCrossover => fit::Value::UInt16(4155),
            GarminProduct::EdgeExplore2 => fit::Value::UInt16(4169),
            GarminProduct::ApproachS70 => fit::Value::UInt16(4233),
            GarminProduct::Fr265Large => fit::Value::UInt16(4257),
            GarminProduct::Fr265Small => fit::Value::UInt16(4258),
            GarminProduct::TacxNeoSmart => fit::Value::UInt16(4265),
            GarminProduct::TacxNeo2Smart => fit::Value::UInt16(4266),
            GarminProduct::TacxNeo2TSmart => fit::Value::UInt16(4267),
            GarminProduct::TacxNeoSmartBike => fit::Value::UInt16(4268),
            GarminProduct::TacxSatoriSmart => fit::Value::UInt16(4269),
            GarminProduct::TacxFlowSmart => fit::Value::UInt16(4270),
            GarminProduct::TacxVortexSmart => fit::Value::UInt16(4271),
            GarminProduct::TacxBushidoSmart => fit::Value::UInt16(4272),
            GarminProduct::TacxGeniusSmart => fit::Value::UInt16(4273),
            GarminProduct::TacxFluxFluxSSmart => fit::Value::UInt16(4274),
            GarminProduct::TacxFlux2Smart => fit::Value::UInt16(4275),
            GarminProduct::TacxMagnum => fit::Value::UInt16(4276),
            GarminProduct::Edge1040Asia => fit::Value::UInt16(4305),
            GarminProduct::EpixGen2Pro42 => fit::Value::UInt16(4312),
            GarminProduct::EpixGen2Pro47 => fit::Value::UInt16(4313),
            GarminProduct::EpixGen2Pro51 => fit::Value::UInt16(4314),
            GarminProduct::Fr965 => fit::Value::UInt16(4315),
            GarminProduct::Enduro2 => fit::Value::UInt16(4341),
            GarminProduct::Fenix7ProSolar => fit::Value::UInt16(4375),
            GarminProduct::Instinct2x => fit::Value::UInt16(4394),
            GarminProduct::DescentT2 => fit::Value::UInt16(4442),
            GarminProduct::Sdm4 => fit::Value::UInt16(10007),
            GarminProduct::EdgeRemote => fit::Value::UInt16(10014),
            GarminProduct::TacxTrainingAppWin => fit::Value::UInt16(20533),
            GarminProduct::TacxTrainingAppMac => fit::Value::UInt16(20534),
            GarminProduct::TacxTrainingAppMacCatalyst => fit::Value::UInt16(20565),
            GarminProduct::TrainingCenter => fit::Value::UInt16(20119),
            GarminProduct::TacxTrainingAppAndroid => fit::Value::UInt16(30045),
            GarminProduct::TacxTrainingAppIos => fit::Value::UInt16(30046),
            GarminProduct::TacxTrainingAppLegacy => fit::Value::UInt16(30047),
            GarminProduct::ConnectiqSimulator => fit::Value::UInt16(65531),
            GarminProduct::AndroidAntplusPlugin => fit::Value::UInt16(65532),
            GarminProduct::Connect => fit::Value::UInt16(65534),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for GarminProduct {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(1) => Ok(GarminProduct::Hrm1),
            fit::Value::UInt16(2) => Ok(GarminProduct::Axh01),
            fit::Value::UInt16(3) => Ok(GarminProduct::Axb01),
            fit::Value::UInt16(4) => Ok(GarminProduct::Axb02),
            fit::Value::UInt16(5) => Ok(GarminProduct::Hrm2ss),
            fit::Value::UInt16(6) => Ok(GarminProduct::DsiAlf02),
            fit::Value::UInt16(7) => Ok(GarminProduct::Hrm3ss),
            fit::Value::UInt16(8) => Ok(GarminProduct::HrmRunSingleByteProductId),
            fit::Value::UInt16(9) => Ok(GarminProduct::Bsm),
            fit::Value::UInt16(10) => Ok(GarminProduct::Bcm),
            fit::Value::UInt16(11) => Ok(GarminProduct::Axs01),
            fit::Value::UInt16(12) => Ok(GarminProduct::HrmTriSingleByteProductId),
            fit::Value::UInt16(13) => Ok(GarminProduct::Hrm4RunSingleByteProductId),
            fit::Value::UInt16(14) => Ok(GarminProduct::Fr225SingleByteProductId),
            fit::Value::UInt16(15) => Ok(GarminProduct::Gen3BsmSingleByteProductId),
            fit::Value::UInt16(16) => Ok(GarminProduct::Gen3BcmSingleByteProductId),
            fit::Value::UInt16(255) => Ok(GarminProduct::OHR),
            fit::Value::UInt16(473) => Ok(GarminProduct::Fr301China),
            fit::Value::UInt16(474) => Ok(GarminProduct::Fr301Japan),
            fit::Value::UInt16(475) => Ok(GarminProduct::Fr301Korea),
            fit::Value::UInt16(494) => Ok(GarminProduct::Fr301Taiwan),
            fit::Value::UInt16(717) => Ok(GarminProduct::Fr405),
            fit::Value::UInt16(782) => Ok(GarminProduct::Fr50),
            fit::Value::UInt16(987) => Ok(GarminProduct::Fr405Japan),
            fit::Value::UInt16(988) => Ok(GarminProduct::Fr60),
            fit::Value::UInt16(1011) => Ok(GarminProduct::DsiAlf01),
            fit::Value::UInt16(1018) => Ok(GarminProduct::Fr310xt),
            fit::Value::UInt16(1036) => Ok(GarminProduct::Edge500),
            fit::Value::UInt16(1124) => Ok(GarminProduct::Fr110),
            fit::Value::UInt16(1169) => Ok(GarminProduct::Edge800),
            fit::Value::UInt16(1199) => Ok(GarminProduct::Edge500Taiwan),
            fit::Value::UInt16(1213) => Ok(GarminProduct::Edge500Japan),
            fit::Value::UInt16(1253) => Ok(GarminProduct::Chirp),
            fit::Value::UInt16(1274) => Ok(GarminProduct::Fr110Japan),
            fit::Value::UInt16(1325) => Ok(GarminProduct::Edge200),
            fit::Value::UInt16(1328) => Ok(GarminProduct::Fr910xt),
            fit::Value::UInt16(1333) => Ok(GarminProduct::Edge800Taiwan),
            fit::Value::UInt16(1334) => Ok(GarminProduct::Edge800Japan),
            fit::Value::UInt16(1341) => Ok(GarminProduct::Alf04),
            fit::Value::UInt16(1345) => Ok(GarminProduct::Fr610),
            fit::Value::UInt16(1360) => Ok(GarminProduct::Fr210Japan),
            fit::Value::UInt16(1380) => Ok(GarminProduct::VectorSs),
            fit::Value::UInt16(1381) => Ok(GarminProduct::VectorCp),
            fit::Value::UInt16(1386) => Ok(GarminProduct::Edge800China),
            fit::Value::UInt16(1387) => Ok(GarminProduct::Edge500China),
            fit::Value::UInt16(1405) => Ok(GarminProduct::ApproachG10),
            fit::Value::UInt16(1410) => Ok(GarminProduct::Fr610Japan),
            fit::Value::UInt16(1422) => Ok(GarminProduct::Edge500Korea),
            fit::Value::UInt16(1436) => Ok(GarminProduct::Fr70),
            fit::Value::UInt16(1446) => Ok(GarminProduct::Fr310xt4t),
            fit::Value::UInt16(1461) => Ok(GarminProduct::Amx),
            fit::Value::UInt16(1482) => Ok(GarminProduct::Fr10),
            fit::Value::UInt16(1497) => Ok(GarminProduct::Edge800Korea),
            fit::Value::UInt16(1499) => Ok(GarminProduct::Swim),
            fit::Value::UInt16(1537) => Ok(GarminProduct::Fr910xtChina),
            fit::Value::UInt16(1551) => Ok(GarminProduct::Fenix),
            fit::Value::UInt16(1555) => Ok(GarminProduct::Edge200Taiwan),
            fit::Value::UInt16(1561) => Ok(GarminProduct::Edge510),
            fit::Value::UInt16(1567) => Ok(GarminProduct::Edge810),
            fit::Value::UInt16(1570) => Ok(GarminProduct::Tempe),
            fit::Value::UInt16(1600) => Ok(GarminProduct::Fr910xtJapan),
            fit::Value::UInt16(1623) => Ok(GarminProduct::Fr620),
            fit::Value::UInt16(1632) => Ok(GarminProduct::Fr220),
            fit::Value::UInt16(1664) => Ok(GarminProduct::Fr910xtKorea),
            fit::Value::UInt16(1688) => Ok(GarminProduct::Fr10Japan),
            fit::Value::UInt16(1721) => Ok(GarminProduct::Edge810Japan),
            fit::Value::UInt16(1735) => Ok(GarminProduct::VirbElite),
            fit::Value::UInt16(1736) => Ok(GarminProduct::EdgeTouring),
            fit::Value::UInt16(1742) => Ok(GarminProduct::Edge510Japan),
            fit::Value::UInt16(1743) => Ok(GarminProduct::HrmTri),
            fit::Value::UInt16(1752) => Ok(GarminProduct::HrmRun),
            fit::Value::UInt16(1765) => Ok(GarminProduct::Fr920xt),
            fit::Value::UInt16(1821) => Ok(GarminProduct::Edge510Asia),
            fit::Value::UInt16(1822) => Ok(GarminProduct::Edge810China),
            fit::Value::UInt16(1823) => Ok(GarminProduct::Edge810Taiwan),
            fit::Value::UInt16(1836) => Ok(GarminProduct::Edge1000),
            fit::Value::UInt16(1837) => Ok(GarminProduct::VivoFit),
            fit::Value::UInt16(1853) => Ok(GarminProduct::VirbRemote),
            fit::Value::UInt16(1885) => Ok(GarminProduct::VivoKi),
            fit::Value::UInt16(1903) => Ok(GarminProduct::Fr15),
            fit::Value::UInt16(1907) => Ok(GarminProduct::VivoActive),
            fit::Value::UInt16(1918) => Ok(GarminProduct::Edge510Korea),
            fit::Value::UInt16(1928) => Ok(GarminProduct::Fr620Japan),
            fit::Value::UInt16(1929) => Ok(GarminProduct::Fr620China),
            fit::Value::UInt16(1930) => Ok(GarminProduct::Fr220Japan),
            fit::Value::UInt16(1931) => Ok(GarminProduct::Fr220China),
            fit::Value::UInt16(1936) => Ok(GarminProduct::ApproachS6),
            fit::Value::UInt16(1956) => Ok(GarminProduct::VivoSmart),
            fit::Value::UInt16(1967) => Ok(GarminProduct::Fenix2),
            fit::Value::UInt16(1988) => Ok(GarminProduct::Epix),
            fit::Value::UInt16(2050) => Ok(GarminProduct::Fenix3),
            fit::Value::UInt16(2052) => Ok(GarminProduct::Edge1000Taiwan),
            fit::Value::UInt16(2053) => Ok(GarminProduct::Edge1000Japan),
            fit::Value::UInt16(2061) => Ok(GarminProduct::Fr15Japan),
            fit::Value::UInt16(2067) => Ok(GarminProduct::Edge520),
            fit::Value::UInt16(2070) => Ok(GarminProduct::Edge1000China),
            fit::Value::UInt16(2072) => Ok(GarminProduct::Fr620Russia),
            fit::Value::UInt16(2073) => Ok(GarminProduct::Fr220Russia),
            fit::Value::UInt16(2079) => Ok(GarminProduct::VectorS),
            fit::Value::UInt16(2100) => Ok(GarminProduct::Edge1000Korea),
            fit::Value::UInt16(2130) => Ok(GarminProduct::Fr920xtTaiwan),
            fit::Value::UInt16(2131) => Ok(GarminProduct::Fr920xtChina),
            fit::Value::UInt16(2132) => Ok(GarminProduct::Fr920xtJapan),
            fit::Value::UInt16(2134) => Ok(GarminProduct::Virbx),
            fit::Value::UInt16(2135) => Ok(GarminProduct::VivoSmartApac),
            fit::Value::UInt16(2140) => Ok(GarminProduct::EtrexTouch),
            fit::Value::UInt16(2147) => Ok(GarminProduct::Edge25),
            fit::Value::UInt16(2148) => Ok(GarminProduct::Fr25),
            fit::Value::UInt16(2150) => Ok(GarminProduct::VivoFit2),
            fit::Value::UInt16(2153) => Ok(GarminProduct::Fr225),
            fit::Value::UInt16(2156) => Ok(GarminProduct::Fr630),
            fit::Value::UInt16(2157) => Ok(GarminProduct::Fr230),
            fit::Value::UInt16(2158) => Ok(GarminProduct::Fr735xt),
            fit::Value::UInt16(2160) => Ok(GarminProduct::VivoActiveApac),
            fit::Value::UInt16(2161) => Ok(GarminProduct::Vector2),
            fit::Value::UInt16(2162) => Ok(GarminProduct::Vector2s),
            fit::Value::UInt16(2172) => Ok(GarminProduct::Virbxe),
            fit::Value::UInt16(2173) => Ok(GarminProduct::Fr620Taiwan),
            fit::Value::UInt16(2174) => Ok(GarminProduct::Fr220Taiwan),
            fit::Value::UInt16(2175) => Ok(GarminProduct::Truswing),
            fit::Value::UInt16(2187) => Ok(GarminProduct::D2airvenu),
            fit::Value::UInt16(2188) => Ok(GarminProduct::Fenix3China),
            fit::Value::UInt16(2189) => Ok(GarminProduct::Fenix3Twn),
            fit::Value::UInt16(2192) => Ok(GarminProduct::VariaHeadlight),
            fit::Value::UInt16(2193) => Ok(GarminProduct::VariaTaillightOld),
            fit::Value::UInt16(2204) => Ok(GarminProduct::EdgeExplore1000),
            fit::Value::UInt16(2219) => Ok(GarminProduct::Fr225Asia),
            fit::Value::UInt16(2225) => Ok(GarminProduct::VariaRadarTaillight),
            fit::Value::UInt16(2226) => Ok(GarminProduct::VariaRadarDisplay),
            fit::Value::UInt16(2238) => Ok(GarminProduct::Edge20),
            fit::Value::UInt16(2260) => Ok(GarminProduct::Edge520Asia),
            fit::Value::UInt16(2261) => Ok(GarminProduct::Edge520Japan),
            fit::Value::UInt16(2262) => Ok(GarminProduct::D2Bravo),
            fit::Value::UInt16(2266) => Ok(GarminProduct::ApproachS20),
            fit::Value::UInt16(2271) => Ok(GarminProduct::VivoSmart2),
            fit::Value::UInt16(2274) => Ok(GarminProduct::Edge1000Thai),
            fit::Value::UInt16(2276) => Ok(GarminProduct::VariaRemote),
            fit::Value::UInt16(2288) => Ok(GarminProduct::Edge25Asia),
            fit::Value::UInt16(2289) => Ok(GarminProduct::Edge25Jpn),
            fit::Value::UInt16(2290) => Ok(GarminProduct::Edge20Asia),
            fit::Value::UInt16(2292) => Ok(GarminProduct::ApproachX40),
            fit::Value::UInt16(2293) => Ok(GarminProduct::Fenix3Japan),
            fit::Value::UInt16(2294) => Ok(GarminProduct::VivoSmartEmea),
            fit::Value::UInt16(2310) => Ok(GarminProduct::Fr630Asia),
            fit::Value::UInt16(2311) => Ok(GarminProduct::Fr630Jpn),
            fit::Value::UInt16(2313) => Ok(GarminProduct::Fr230Jpn),
            fit::Value::UInt16(2327) => Ok(GarminProduct::Hrm4Run),
            fit::Value::UInt16(2332) => Ok(GarminProduct::EpixJapan),
            fit::Value::UInt16(2337) => Ok(GarminProduct::VivoActiveHr),
            fit::Value::UInt16(2347) => Ok(GarminProduct::VivoSmartGpsHr),
            fit::Value::UInt16(2348) => Ok(GarminProduct::VivoSmartHr),
            fit::Value::UInt16(2361) => Ok(GarminProduct::VivoSmartHrAsia),
            fit::Value::UInt16(2362) => Ok(GarminProduct::VivoSmartGpsHrAsia),
            fit::Value::UInt16(2368) => Ok(GarminProduct::VivoMove),
            fit::Value::UInt16(2379) => Ok(GarminProduct::VariaTaillight),
            fit::Value::UInt16(2396) => Ok(GarminProduct::Fr235Asia),
            fit::Value::UInt16(2397) => Ok(GarminProduct::Fr235Japan),
            fit::Value::UInt16(2398) => Ok(GarminProduct::VariaVision),
            fit::Value::UInt16(2406) => Ok(GarminProduct::VivoFit3),
            fit::Value::UInt16(2407) => Ok(GarminProduct::Fenix3Korea),
            fit::Value::UInt16(2408) => Ok(GarminProduct::Fenix3Sea),
            fit::Value::UInt16(2413) => Ok(GarminProduct::Fenix3Hr),
            fit::Value::UInt16(2417) => Ok(GarminProduct::VirbUltra30),
            fit::Value::UInt16(2429) => Ok(GarminProduct::IndexSmartScale),
            fit::Value::UInt16(2431) => Ok(GarminProduct::Fr235),
            fit::Value::UInt16(2432) => Ok(GarminProduct::Fenix3Chronos),
            fit::Value::UInt16(2441) => Ok(GarminProduct::Oregon7xx),
            fit::Value::UInt16(2444) => Ok(GarminProduct::Rino7xx),
            fit::Value::UInt16(2457) => Ok(GarminProduct::EpixKorea),
            fit::Value::UInt16(2473) => Ok(GarminProduct::Fenix3HrChn),
            fit::Value::UInt16(2474) => Ok(GarminProduct::Fenix3HrTwn),
            fit::Value::UInt16(2475) => Ok(GarminProduct::Fenix3HrJpn),
            fit::Value::UInt16(2476) => Ok(GarminProduct::Fenix3HrSea),
            fit::Value::UInt16(2477) => Ok(GarminProduct::Fenix3HrKor),
            fit::Value::UInt16(2496) => Ok(GarminProduct::Nautix),
            fit::Value::UInt16(2497) => Ok(GarminProduct::VivoActiveHrApac),
            fit::Value::UInt16(2503) => Ok(GarminProduct::Fr35),
            fit::Value::UInt16(2512) => Ok(GarminProduct::Oregon7xxWw),
            fit::Value::UInt16(2530) => Ok(GarminProduct::Edge820),
            fit::Value::UInt16(2531) => Ok(GarminProduct::EdgeExplore820),
            fit::Value::UInt16(2533) => Ok(GarminProduct::Fr735xtApac),
            fit::Value::UInt16(2534) => Ok(GarminProduct::Fr735xtJapan),
            fit::Value::UInt16(2544) => Ok(GarminProduct::Fenix5s),
            fit::Value::UInt16(2547) => Ok(GarminProduct::D2BravoTitanium),
            fit::Value::UInt16(2567) => Ok(GarminProduct::VariaUt800),
            fit::Value::UInt16(2593) => Ok(GarminProduct::RunningDynamicsPod),
            fit::Value::UInt16(2599) => Ok(GarminProduct::Edge820China),
            fit::Value::UInt16(2600) => Ok(GarminProduct::Edge820Japan),
            fit::Value::UInt16(2604) => Ok(GarminProduct::Fenix5x),
            fit::Value::UInt16(2606) => Ok(GarminProduct::VivoFitJr),
            fit::Value::UInt16(2622) => Ok(GarminProduct::VivoSmart3),
            fit::Value::UInt16(2623) => Ok(GarminProduct::VivoSport),
            fit::Value::UInt16(2628) => Ok(GarminProduct::Edge820Taiwan),
            fit::Value::UInt16(2629) => Ok(GarminProduct::Edge820Korea),
            fit::Value::UInt16(2630) => Ok(GarminProduct::Edge820Sea),
            fit::Value::UInt16(2650) => Ok(GarminProduct::Fr35Hebrew),
            fit::Value::UInt16(2656) => Ok(GarminProduct::ApproachS60),
            fit::Value::UInt16(2667) => Ok(GarminProduct::Fr35Apac),
            fit::Value::UInt16(2668) => Ok(GarminProduct::Fr35Japan),
            fit::Value::UInt16(2675) => Ok(GarminProduct::Fenix3ChronosAsia),
            fit::Value::UInt16(2687) => Ok(GarminProduct::Virb360),
            fit::Value::UInt16(2691) => Ok(GarminProduct::Fr935),
            fit::Value::UInt16(2697) => Ok(GarminProduct::Fenix5),
            fit::Value::UInt16(2700) => Ok(GarminProduct::Vivoactive3),
            fit::Value::UInt16(2733) => Ok(GarminProduct::Fr235ChinaNfc),
            fit::Value::UInt16(2769) => Ok(GarminProduct::Foretrex601701),
            fit::Value::UInt16(2772) => Ok(GarminProduct::VivoMoveHr),
            fit::Value::UInt16(2713) => Ok(GarminProduct::Edge1030),
            fit::Value::UInt16(2727) => Ok(GarminProduct::Fr35Sea),
            fit::Value::UInt16(2787) => Ok(GarminProduct::Vector3),
            fit::Value::UInt16(2796) => Ok(GarminProduct::Fenix5Asia),
            fit::Value::UInt16(2797) => Ok(GarminProduct::Fenix5sAsia),
            fit::Value::UInt16(2798) => Ok(GarminProduct::Fenix5xAsia),
            fit::Value::UInt16(2806) => Ok(GarminProduct::ApproachZ80),
            fit::Value::UInt16(2814) => Ok(GarminProduct::Fr35Korea),
            fit::Value::UInt16(2819) => Ok(GarminProduct::D2charlie),
            fit::Value::UInt16(2831) => Ok(GarminProduct::VivoSmart3Apac),
            fit::Value::UInt16(2832) => Ok(GarminProduct::VivoSportApac),
            fit::Value::UInt16(2833) => Ok(GarminProduct::Fr935Asia),
            fit::Value::UInt16(2859) => Ok(GarminProduct::Descent),
            fit::Value::UInt16(2878) => Ok(GarminProduct::VivoFit4),
            fit::Value::UInt16(2886) => Ok(GarminProduct::Fr645),
            fit::Value::UInt16(2888) => Ok(GarminProduct::Fr645m),
            fit::Value::UInt16(2891) => Ok(GarminProduct::Fr30),
            fit::Value::UInt16(2900) => Ok(GarminProduct::Fenix5sPlus),
            fit::Value::UInt16(2909) => Ok(GarminProduct::Edge130),
            fit::Value::UInt16(2924) => Ok(GarminProduct::Edge1030Asia),
            fit::Value::UInt16(2927) => Ok(GarminProduct::Vivosmart4),
            fit::Value::UInt16(2945) => Ok(GarminProduct::VivoMoveHrAsia),
            fit::Value::UInt16(2962) => Ok(GarminProduct::ApproachX10),
            fit::Value::UInt16(2977) => Ok(GarminProduct::Fr30Asia),
            fit::Value::UInt16(2988) => Ok(GarminProduct::Vivoactive3mW),
            fit::Value::UInt16(3003) => Ok(GarminProduct::Fr645Asia),
            fit::Value::UInt16(3004) => Ok(GarminProduct::Fr645mAsia),
            fit::Value::UInt16(3011) => Ok(GarminProduct::EdgeExplore),
            fit::Value::UInt16(3028) => Ok(GarminProduct::Gpsmap66),
            fit::Value::UInt16(3049) => Ok(GarminProduct::ApproachS10),
            fit::Value::UInt16(3066) => Ok(GarminProduct::Vivoactive3mL),
            fit::Value::UInt16(3085) => Ok(GarminProduct::ApproachG80),
            fit::Value::UInt16(3092) => Ok(GarminProduct::Edge130Asia),
            fit::Value::UInt16(3095) => Ok(GarminProduct::Edge1030Bontrager),
            fit::Value::UInt16(3110) => Ok(GarminProduct::Fenix5Plus),
            fit::Value::UInt16(3111) => Ok(GarminProduct::Fenix5xPlus),
            fit::Value::UInt16(3112) => Ok(GarminProduct::Edge520Plus),
            fit::Value::UInt16(3113) => Ok(GarminProduct::Fr945),
            fit::Value::UInt16(3121) => Ok(GarminProduct::Edge530),
            fit::Value::UInt16(3122) => Ok(GarminProduct::Edge830),
            fit::Value::UInt16(3126) => Ok(GarminProduct::InstinctEsports),
            fit::Value::UInt16(3134) => Ok(GarminProduct::Fenix5sPlusApac),
            fit::Value::UInt16(3135) => Ok(GarminProduct::Fenix5xPlusApac),
            fit::Value::UInt16(3142) => Ok(GarminProduct::Edge520PlusApac),
            fit::Value::UInt16(3143) => Ok(GarminProduct::DescentT1),
            fit::Value::UInt16(3144) => Ok(GarminProduct::Fr235lAsia),
            fit::Value::UInt16(3145) => Ok(GarminProduct::Fr245Asia),
            fit::Value::UInt16(3163) => Ok(GarminProduct::VivoActive3mApac),
            fit::Value::UInt16(3192) => Ok(GarminProduct::Gen3Bsm),
            fit::Value::UInt16(3193) => Ok(GarminProduct::Gen3Bcm),
            fit::Value::UInt16(3218) => Ok(GarminProduct::VivoSmart4Asia),
            fit::Value::UInt16(3224) => Ok(GarminProduct::Vivoactive4Small),
            fit::Value::UInt16(3225) => Ok(GarminProduct::Vivoactive4Large),
            fit::Value::UInt16(3226) => Ok(GarminProduct::Venu),
            fit::Value::UInt16(3246) => Ok(GarminProduct::MarqDriver),
            fit::Value::UInt16(3247) => Ok(GarminProduct::MarqAviator),
            fit::Value::UInt16(3248) => Ok(GarminProduct::MarqCaptain),
            fit::Value::UInt16(3249) => Ok(GarminProduct::MarqCommander),
            fit::Value::UInt16(3250) => Ok(GarminProduct::MarqExpedition),
            fit::Value::UInt16(3251) => Ok(GarminProduct::MarqAthlete),
            fit::Value::UInt16(3258) => Ok(GarminProduct::DescentMk2),
            fit::Value::UInt16(3284) => Ok(GarminProduct::Gpsmap66i),
            fit::Value::UInt16(3287) => Ok(GarminProduct::Fenix6SSport),
            fit::Value::UInt16(3288) => Ok(GarminProduct::Fenix6S),
            fit::Value::UInt16(3289) => Ok(GarminProduct::Fenix6Sport),
            fit::Value::UInt16(3290) => Ok(GarminProduct::Fenix6),
            fit::Value::UInt16(3291) => Ok(GarminProduct::Fenix6x),
            fit::Value::UInt16(3299) => Ok(GarminProduct::HrmDual),
            fit::Value::UInt16(3300) => Ok(GarminProduct::HrmPro),
            fit::Value::UInt16(3308) => Ok(GarminProduct::VivoMove3Premium),
            fit::Value::UInt16(3314) => Ok(GarminProduct::ApproachS40),
            fit::Value::UInt16(3321) => Ok(GarminProduct::Fr245mAsia),
            fit::Value::UInt16(3349) => Ok(GarminProduct::Edge530Apac),
            fit::Value::UInt16(3350) => Ok(GarminProduct::Edge830Apac),
            fit::Value::UInt16(3378) => Ok(GarminProduct::VivoMove3),
            fit::Value::UInt16(3387) => Ok(GarminProduct::VivoActive4SmallAsia),
            fit::Value::UInt16(3388) => Ok(GarminProduct::VivoActive4LargeAsia),
            fit::Value::UInt16(3389) => Ok(GarminProduct::VivoActive4OledAsia),
            fit::Value::UInt16(3405) => Ok(GarminProduct::Swim2),
            fit::Value::UInt16(3420) => Ok(GarminProduct::MarqDriverAsia),
            fit::Value::UInt16(3421) => Ok(GarminProduct::MarqAviatorAsia),
            fit::Value::UInt16(3422) => Ok(GarminProduct::VivoMove3Asia),
            fit::Value::UInt16(3441) => Ok(GarminProduct::Fr945Asia),
            fit::Value::UInt16(3446) => Ok(GarminProduct::VivoActive3tChn),
            fit::Value::UInt16(3448) => Ok(GarminProduct::MarqCaptainAsia),
            fit::Value::UInt16(3449) => Ok(GarminProduct::MarqCommanderAsia),
            fit::Value::UInt16(3450) => Ok(GarminProduct::MarqExpeditionAsia),
            fit::Value::UInt16(3451) => Ok(GarminProduct::MarqAthleteAsia),
            fit::Value::UInt16(3466) => Ok(GarminProduct::InstinctSolar),
            fit::Value::UInt16(3469) => Ok(GarminProduct::Fr45Asia),
            fit::Value::UInt16(3473) => Ok(GarminProduct::Vivoactive3Daimler),
            fit::Value::UInt16(3498) => Ok(GarminProduct::LegacyRey),
            fit::Value::UInt16(3499) => Ok(GarminProduct::LegacyDarthVader),
            fit::Value::UInt16(3500) => Ok(GarminProduct::LegacyCaptainMarvel),
            fit::Value::UInt16(3501) => Ok(GarminProduct::LegacyFirstAvenger),
            fit::Value::UInt16(3512) => Ok(GarminProduct::Fenix6sSportAsia),
            fit::Value::UInt16(3513) => Ok(GarminProduct::Fenix6sAsia),
            fit::Value::UInt16(3514) => Ok(GarminProduct::Fenix6SportAsia),
            fit::Value::UInt16(3515) => Ok(GarminProduct::Fenix6Asia),
            fit::Value::UInt16(3516) => Ok(GarminProduct::Fenix6xAsia),
            fit::Value::UInt16(3535) => Ok(GarminProduct::LegacyCaptainMarvelAsia),
            fit::Value::UInt16(3536) => Ok(GarminProduct::LegacyFirstAvengerAsia),
            fit::Value::UInt16(3537) => Ok(GarminProduct::LegacyReyAsia),
            fit::Value::UInt16(3538) => Ok(GarminProduct::LegacyDarthVaderAsia),
            fit::Value::UInt16(3542) => Ok(GarminProduct::DescentMk2s),
            fit::Value::UInt16(3558) => Ok(GarminProduct::Edge130Plus),
            fit::Value::UInt16(3570) => Ok(GarminProduct::Edge1030Plus),
            fit::Value::UInt16(3578) => Ok(GarminProduct::Rally200),
            fit::Value::UInt16(3589) => Ok(GarminProduct::Fr745),
            fit::Value::UInt16(3600) => Ok(GarminProduct::Venusq),
            fit::Value::UInt16(3615) => Ok(GarminProduct::Lily),
            fit::Value::UInt16(3624) => Ok(GarminProduct::MarqAdventurer),
            fit::Value::UInt16(3638) => Ok(GarminProduct::Enduro),
            fit::Value::UInt16(3639) => Ok(GarminProduct::Swim2Apac),
            fit::Value::UInt16(3648) => Ok(GarminProduct::MarqAdventurerAsia),
            fit::Value::UInt16(3652) => Ok(GarminProduct::Fr945Lte),
            fit::Value::UInt16(3702) => Ok(GarminProduct::DescentMk2Asia),
            fit::Value::UInt16(3703) => Ok(GarminProduct::Venu2),
            fit::Value::UInt16(3704) => Ok(GarminProduct::Venu2s),
            fit::Value::UInt16(3737) => Ok(GarminProduct::VenuDaimlerAsia),
            fit::Value::UInt16(3739) => Ok(GarminProduct::MarqGolfer),
            fit::Value::UInt16(3740) => Ok(GarminProduct::VenuDaimler),
            fit::Value::UInt16(3794) => Ok(GarminProduct::Fr745Asia),
            fit::Value::UInt16(3809) => Ok(GarminProduct::LilyAsia),
            fit::Value::UInt16(3812) => Ok(GarminProduct::Edge1030PlusAsia),
            fit::Value::UInt16(3813) => Ok(GarminProduct::Edge130PlusAsia),
            fit::Value::UInt16(3823) => Ok(GarminProduct::ApproachS12),
            fit::Value::UInt16(3872) => Ok(GarminProduct::EnduroAsia),
            fit::Value::UInt16(3837) => Ok(GarminProduct::VenusqAsia),
            fit::Value::UInt16(3843) => Ok(GarminProduct::Edge1040),
            fit::Value::UInt16(3850) => Ok(GarminProduct::MarqGolferAsia),
            fit::Value::UInt16(3851) => Ok(GarminProduct::Venu2Plus),
            fit::Value::UInt16(3865) => Ok(GarminProduct::Gnss),
            fit::Value::UInt16(3869) => Ok(GarminProduct::Fr55),
            fit::Value::UInt16(3888) => Ok(GarminProduct::Instinct2),
            fit::Value::UInt16(3905) => Ok(GarminProduct::Fenix7s),
            fit::Value::UInt16(3906) => Ok(GarminProduct::Fenix7),
            fit::Value::UInt16(3907) => Ok(GarminProduct::Fenix7x),
            fit::Value::UInt16(3908) => Ok(GarminProduct::Fenix7sApac),
            fit::Value::UInt16(3909) => Ok(GarminProduct::Fenix7Apac),
            fit::Value::UInt16(3910) => Ok(GarminProduct::Fenix7xApac),
            fit::Value::UInt16(3927) => Ok(GarminProduct::ApproachG12),
            fit::Value::UInt16(3930) => Ok(GarminProduct::DescentMk2sAsia),
            fit::Value::UInt16(3934) => Ok(GarminProduct::ApproachS42),
            fit::Value::UInt16(3943) => Ok(GarminProduct::EpixGen2),
            fit::Value::UInt16(3944) => Ok(GarminProduct::EpixGen2Apac),
            fit::Value::UInt16(3949) => Ok(GarminProduct::Venu2sAsia),
            fit::Value::UInt16(3950) => Ok(GarminProduct::Venu2Asia),
            fit::Value::UInt16(3978) => Ok(GarminProduct::Fr945LteAsia),
            fit::Value::UInt16(3982) => Ok(GarminProduct::VivoMoveSport),
            fit::Value::UInt16(3983) => Ok(GarminProduct::VivomoveTrend),
            fit::Value::UInt16(3986) => Ok(GarminProduct::ApproachS12Asia),
            fit::Value::UInt16(3990) => Ok(GarminProduct::Fr255Music),
            fit::Value::UInt16(3991) => Ok(GarminProduct::Fr255SmallMusic),
            fit::Value::UInt16(3992) => Ok(GarminProduct::Fr255),
            fit::Value::UInt16(3993) => Ok(GarminProduct::Fr255Small),
            fit::Value::UInt16(4001) => Ok(GarminProduct::ApproachG12Asia),
            fit::Value::UInt16(4002) => Ok(GarminProduct::ApproachS42Asia),
            fit::Value::UInt16(4005) => Ok(GarminProduct::DescentG1),
            fit::Value::UInt16(4017) => Ok(GarminProduct::Venu2PlusAsia),
            fit::Value::UInt16(4024) => Ok(GarminProduct::Fr955),
            fit::Value::UInt16(4033) => Ok(GarminProduct::Fr55Asia),
            fit::Value::UInt16(4061) => Ok(GarminProduct::Edge540),
            fit::Value::UInt16(4062) => Ok(GarminProduct::Edge840),
            fit::Value::UInt16(4063) => Ok(GarminProduct::Vivosmart5),
            fit::Value::UInt16(4071) => Ok(GarminProduct::Instinct2Asia),
            fit::Value::UInt16(4105) => Ok(GarminProduct::MarqGen2),
            fit::Value::UInt16(4115) => Ok(GarminProduct::Venusq2),
            fit::Value::UInt16(4116) => Ok(GarminProduct::Venusq2music),
            fit::Value::UInt16(4124) => Ok(GarminProduct::MarqGen2Aviator),
            fit::Value::UInt16(4125) => Ok(GarminProduct::D2AirX10),
            fit::Value::UInt16(4130) => Ok(GarminProduct::HrmProPlus),
            fit::Value::UInt16(4132) => Ok(GarminProduct::DescentG1Asia),
            fit::Value::UInt16(4135) => Ok(GarminProduct::Tactix7),
            fit::Value::UInt16(4155) => Ok(GarminProduct::InstinctCrossover),
            fit::Value::UInt16(4169) => Ok(GarminProduct::EdgeExplore2),
            fit::Value::UInt16(4233) => Ok(GarminProduct::ApproachS70),
            fit::Value::UInt16(4257) => Ok(GarminProduct::Fr265Large),
            fit::Value::UInt16(4258) => Ok(GarminProduct::Fr265Small),
            fit::Value::UInt16(4265) => Ok(GarminProduct::TacxNeoSmart),
            fit::Value::UInt16(4266) => Ok(GarminProduct::TacxNeo2Smart),
            fit::Value::UInt16(4267) => Ok(GarminProduct::TacxNeo2TSmart),
            fit::Value::UInt16(4268) => Ok(GarminProduct::TacxNeoSmartBike),
            fit::Value::UInt16(4269) => Ok(GarminProduct::TacxSatoriSmart),
            fit::Value::UInt16(4270) => Ok(GarminProduct::TacxFlowSmart),
            fit::Value::UInt16(4271) => Ok(GarminProduct::TacxVortexSmart),
            fit::Value::UInt16(4272) => Ok(GarminProduct::TacxBushidoSmart),
            fit::Value::UInt16(4273) => Ok(GarminProduct::TacxGeniusSmart),
            fit::Value::UInt16(4274) => Ok(GarminProduct::TacxFluxFluxSSmart),
            fit::Value::UInt16(4275) => Ok(GarminProduct::TacxFlux2Smart),
            fit::Value::UInt16(4276) => Ok(GarminProduct::TacxMagnum),
            fit::Value::UInt16(4305) => Ok(GarminProduct::Edge1040Asia),
            fit::Value::UInt16(4312) => Ok(GarminProduct::EpixGen2Pro42),
            fit::Value::UInt16(4313) => Ok(GarminProduct::EpixGen2Pro47),
            fit::Value::UInt16(4314) => Ok(GarminProduct::EpixGen2Pro51),
            fit::Value::UInt16(4315) => Ok(GarminProduct::Fr965),
            fit::Value::UInt16(4341) => Ok(GarminProduct::Enduro2),
            fit::Value::UInt16(4375) => Ok(GarminProduct::Fenix7ProSolar),
            fit::Value::UInt16(4394) => Ok(GarminProduct::Instinct2x),
            fit::Value::UInt16(4442) => Ok(GarminProduct::DescentT2),
            fit::Value::UInt16(10007) => Ok(GarminProduct::Sdm4),
            fit::Value::UInt16(10014) => Ok(GarminProduct::EdgeRemote),
            fit::Value::UInt16(20533) => Ok(GarminProduct::TacxTrainingAppWin),
            fit::Value::UInt16(20534) => Ok(GarminProduct::TacxTrainingAppMac),
            fit::Value::UInt16(20565) => Ok(GarminProduct::TacxTrainingAppMacCatalyst),
            fit::Value::UInt16(20119) => Ok(GarminProduct::TrainingCenter),
            fit::Value::UInt16(30045) => Ok(GarminProduct::TacxTrainingAppAndroid),
            fit::Value::UInt16(30046) => Ok(GarminProduct::TacxTrainingAppIos),
            fit::Value::UInt16(30047) => Ok(GarminProduct::TacxTrainingAppLegacy),
            fit::Value::UInt16(65531) => Ok(GarminProduct::ConnectiqSimulator),
            fit::Value::UInt16(65532) => Ok(GarminProduct::AndroidAntplusPlugin),
            fit::Value::UInt16(65534) => Ok(GarminProduct::Connect),
            _ => Err("No corresponding GarminProduct exists"),
        }
    }
}
impl TryFrom<&str> for GarminProduct {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "hrm1" => Ok(GarminProduct::Hrm1),
            "axh01" => Ok(GarminProduct::Axh01),
            "axb01" => Ok(GarminProduct::Axb01),
            "axb02" => Ok(GarminProduct::Axb02),
            "hrm2ss" => Ok(GarminProduct::Hrm2ss),
            "dsi_alf02" => Ok(GarminProduct::DsiAlf02),
            "hrm3ss" => Ok(GarminProduct::Hrm3ss),
            "hrm_run_single_byte_product_id" => Ok(GarminProduct::HrmRunSingleByteProductId),
            "bsm" => Ok(GarminProduct::Bsm),
            "bcm" => Ok(GarminProduct::Bcm),
            "axs01" => Ok(GarminProduct::Axs01),
            "hrm_tri_single_byte_product_id" => Ok(GarminProduct::HrmTriSingleByteProductId),
            "hrm4_run_single_byte_product_id" => Ok(GarminProduct::Hrm4RunSingleByteProductId),
            "fr225_single_byte_product_id" => Ok(GarminProduct::Fr225SingleByteProductId),
            "gen3_bsm_single_byte_product_id" => Ok(GarminProduct::Gen3BsmSingleByteProductId),
            "gen3_bcm_single_byte_product_id" => Ok(GarminProduct::Gen3BcmSingleByteProductId),
            "OHR" => Ok(GarminProduct::OHR),
            "fr301_china" => Ok(GarminProduct::Fr301China),
            "fr301_japan" => Ok(GarminProduct::Fr301Japan),
            "fr301_korea" => Ok(GarminProduct::Fr301Korea),
            "fr301_taiwan" => Ok(GarminProduct::Fr301Taiwan),
            "fr405" => Ok(GarminProduct::Fr405),
            "fr50" => Ok(GarminProduct::Fr50),
            "fr405_japan" => Ok(GarminProduct::Fr405Japan),
            "fr60" => Ok(GarminProduct::Fr60),
            "dsi_alf01" => Ok(GarminProduct::DsiAlf01),
            "fr310xt" => Ok(GarminProduct::Fr310xt),
            "edge500" => Ok(GarminProduct::Edge500),
            "fr110" => Ok(GarminProduct::Fr110),
            "edge800" => Ok(GarminProduct::Edge800),
            "edge500_taiwan" => Ok(GarminProduct::Edge500Taiwan),
            "edge500_japan" => Ok(GarminProduct::Edge500Japan),
            "chirp" => Ok(GarminProduct::Chirp),
            "fr110_japan" => Ok(GarminProduct::Fr110Japan),
            "edge200" => Ok(GarminProduct::Edge200),
            "fr910xt" => Ok(GarminProduct::Fr910xt),
            "edge800_taiwan" => Ok(GarminProduct::Edge800Taiwan),
            "edge800_japan" => Ok(GarminProduct::Edge800Japan),
            "alf04" => Ok(GarminProduct::Alf04),
            "fr610" => Ok(GarminProduct::Fr610),
            "fr210_japan" => Ok(GarminProduct::Fr210Japan),
            "vector_ss" => Ok(GarminProduct::VectorSs),
            "vector_cp" => Ok(GarminProduct::VectorCp),
            "edge800_china" => Ok(GarminProduct::Edge800China),
            "edge500_china" => Ok(GarminProduct::Edge500China),
            "approach_g10" => Ok(GarminProduct::ApproachG10),
            "fr610_japan" => Ok(GarminProduct::Fr610Japan),
            "edge500_korea" => Ok(GarminProduct::Edge500Korea),
            "fr70" => Ok(GarminProduct::Fr70),
            "fr310xt_4t" => Ok(GarminProduct::Fr310xt4t),
            "amx" => Ok(GarminProduct::Amx),
            "fr10" => Ok(GarminProduct::Fr10),
            "edge800_korea" => Ok(GarminProduct::Edge800Korea),
            "swim" => Ok(GarminProduct::Swim),
            "fr910xt_china" => Ok(GarminProduct::Fr910xtChina),
            "fenix" => Ok(GarminProduct::Fenix),
            "edge200_taiwan" => Ok(GarminProduct::Edge200Taiwan),
            "edge510" => Ok(GarminProduct::Edge510),
            "edge810" => Ok(GarminProduct::Edge810),
            "tempe" => Ok(GarminProduct::Tempe),
            "fr910xt_japan" => Ok(GarminProduct::Fr910xtJapan),
            "fr620" => Ok(GarminProduct::Fr620),
            "fr220" => Ok(GarminProduct::Fr220),
            "fr910xt_korea" => Ok(GarminProduct::Fr910xtKorea),
            "fr10_japan" => Ok(GarminProduct::Fr10Japan),
            "edge810_japan" => Ok(GarminProduct::Edge810Japan),
            "virb_elite" => Ok(GarminProduct::VirbElite),
            "edge_touring" => Ok(GarminProduct::EdgeTouring),
            "edge510_japan" => Ok(GarminProduct::Edge510Japan),
            "hrm_tri" => Ok(GarminProduct::HrmTri),
            "hrm_run" => Ok(GarminProduct::HrmRun),
            "fr920xt" => Ok(GarminProduct::Fr920xt),
            "edge510_asia" => Ok(GarminProduct::Edge510Asia),
            "edge810_china" => Ok(GarminProduct::Edge810China),
            "edge810_taiwan" => Ok(GarminProduct::Edge810Taiwan),
            "edge1000" => Ok(GarminProduct::Edge1000),
            "vivo_fit" => Ok(GarminProduct::VivoFit),
            "virb_remote" => Ok(GarminProduct::VirbRemote),
            "vivo_ki" => Ok(GarminProduct::VivoKi),
            "fr15" => Ok(GarminProduct::Fr15),
            "vivo_active" => Ok(GarminProduct::VivoActive),
            "edge510_korea" => Ok(GarminProduct::Edge510Korea),
            "fr620_japan" => Ok(GarminProduct::Fr620Japan),
            "fr620_china" => Ok(GarminProduct::Fr620China),
            "fr220_japan" => Ok(GarminProduct::Fr220Japan),
            "fr220_china" => Ok(GarminProduct::Fr220China),
            "approach_s6" => Ok(GarminProduct::ApproachS6),
            "vivo_smart" => Ok(GarminProduct::VivoSmart),
            "fenix2" => Ok(GarminProduct::Fenix2),
            "epix" => Ok(GarminProduct::Epix),
            "fenix3" => Ok(GarminProduct::Fenix3),
            "edge1000_taiwan" => Ok(GarminProduct::Edge1000Taiwan),
            "edge1000_japan" => Ok(GarminProduct::Edge1000Japan),
            "fr15_japan" => Ok(GarminProduct::Fr15Japan),
            "edge520" => Ok(GarminProduct::Edge520),
            "edge1000_china" => Ok(GarminProduct::Edge1000China),
            "fr620_russia" => Ok(GarminProduct::Fr620Russia),
            "fr220_russia" => Ok(GarminProduct::Fr220Russia),
            "vector_s" => Ok(GarminProduct::VectorS),
            "edge1000_korea" => Ok(GarminProduct::Edge1000Korea),
            "fr920xt_taiwan" => Ok(GarminProduct::Fr920xtTaiwan),
            "fr920xt_china" => Ok(GarminProduct::Fr920xtChina),
            "fr920xt_japan" => Ok(GarminProduct::Fr920xtJapan),
            "virbx" => Ok(GarminProduct::Virbx),
            "vivo_smart_apac" => Ok(GarminProduct::VivoSmartApac),
            "etrex_touch" => Ok(GarminProduct::EtrexTouch),
            "edge25" => Ok(GarminProduct::Edge25),
            "fr25" => Ok(GarminProduct::Fr25),
            "vivo_fit2" => Ok(GarminProduct::VivoFit2),
            "fr225" => Ok(GarminProduct::Fr225),
            "fr630" => Ok(GarminProduct::Fr630),
            "fr230" => Ok(GarminProduct::Fr230),
            "fr735xt" => Ok(GarminProduct::Fr735xt),
            "vivo_active_apac" => Ok(GarminProduct::VivoActiveApac),
            "vector_2" => Ok(GarminProduct::Vector2),
            "vector_2s" => Ok(GarminProduct::Vector2s),
            "virbxe" => Ok(GarminProduct::Virbxe),
            "fr620_taiwan" => Ok(GarminProduct::Fr620Taiwan),
            "fr220_taiwan" => Ok(GarminProduct::Fr220Taiwan),
            "truswing" => Ok(GarminProduct::Truswing),
            "d2airvenu" => Ok(GarminProduct::D2airvenu),
            "fenix3_china" => Ok(GarminProduct::Fenix3China),
            "fenix3_twn" => Ok(GarminProduct::Fenix3Twn),
            "varia_headlight" => Ok(GarminProduct::VariaHeadlight),
            "varia_taillight_old" => Ok(GarminProduct::VariaTaillightOld),
            "edge_explore_1000" => Ok(GarminProduct::EdgeExplore1000),
            "fr225_asia" => Ok(GarminProduct::Fr225Asia),
            "varia_radar_taillight" => Ok(GarminProduct::VariaRadarTaillight),
            "varia_radar_display" => Ok(GarminProduct::VariaRadarDisplay),
            "edge20" => Ok(GarminProduct::Edge20),
            "edge520_asia" => Ok(GarminProduct::Edge520Asia),
            "edge520_japan" => Ok(GarminProduct::Edge520Japan),
            "d2_bravo" => Ok(GarminProduct::D2Bravo),
            "approach_s20" => Ok(GarminProduct::ApproachS20),
            "vivo_smart2" => Ok(GarminProduct::VivoSmart2),
            "edge1000_thai" => Ok(GarminProduct::Edge1000Thai),
            "varia_remote" => Ok(GarminProduct::VariaRemote),
            "edge25_asia" => Ok(GarminProduct::Edge25Asia),
            "edge25_jpn" => Ok(GarminProduct::Edge25Jpn),
            "edge20_asia" => Ok(GarminProduct::Edge20Asia),
            "approach_x40" => Ok(GarminProduct::ApproachX40),
            "fenix3_japan" => Ok(GarminProduct::Fenix3Japan),
            "vivo_smart_emea" => Ok(GarminProduct::VivoSmartEmea),
            "fr630_asia" => Ok(GarminProduct::Fr630Asia),
            "fr630_jpn" => Ok(GarminProduct::Fr630Jpn),
            "fr230_jpn" => Ok(GarminProduct::Fr230Jpn),
            "hrm4_run" => Ok(GarminProduct::Hrm4Run),
            "epix_japan" => Ok(GarminProduct::EpixJapan),
            "vivo_active_hr" => Ok(GarminProduct::VivoActiveHr),
            "vivo_smart_gps_hr" => Ok(GarminProduct::VivoSmartGpsHr),
            "vivo_smart_hr" => Ok(GarminProduct::VivoSmartHr),
            "vivo_smart_hr_asia" => Ok(GarminProduct::VivoSmartHrAsia),
            "vivo_smart_gps_hr_asia" => Ok(GarminProduct::VivoSmartGpsHrAsia),
            "vivo_move" => Ok(GarminProduct::VivoMove),
            "varia_taillight" => Ok(GarminProduct::VariaTaillight),
            "fr235_asia" => Ok(GarminProduct::Fr235Asia),
            "fr235_japan" => Ok(GarminProduct::Fr235Japan),
            "varia_vision" => Ok(GarminProduct::VariaVision),
            "vivo_fit3" => Ok(GarminProduct::VivoFit3),
            "fenix3_korea" => Ok(GarminProduct::Fenix3Korea),
            "fenix3_sea" => Ok(GarminProduct::Fenix3Sea),
            "fenix3_hr" => Ok(GarminProduct::Fenix3Hr),
            "virb_ultra_30" => Ok(GarminProduct::VirbUltra30),
            "index_smart_scale" => Ok(GarminProduct::IndexSmartScale),
            "fr235" => Ok(GarminProduct::Fr235),
            "fenix3_chronos" => Ok(GarminProduct::Fenix3Chronos),
            "oregon7xx" => Ok(GarminProduct::Oregon7xx),
            "rino7xx" => Ok(GarminProduct::Rino7xx),
            "epix_korea" => Ok(GarminProduct::EpixKorea),
            "fenix3_hr_chn" => Ok(GarminProduct::Fenix3HrChn),
            "fenix3_hr_twn" => Ok(GarminProduct::Fenix3HrTwn),
            "fenix3_hr_jpn" => Ok(GarminProduct::Fenix3HrJpn),
            "fenix3_hr_sea" => Ok(GarminProduct::Fenix3HrSea),
            "fenix3_hr_kor" => Ok(GarminProduct::Fenix3HrKor),
            "nautix" => Ok(GarminProduct::Nautix),
            "vivo_active_hr_apac" => Ok(GarminProduct::VivoActiveHrApac),
            "fr35" => Ok(GarminProduct::Fr35),
            "oregon7xx_ww" => Ok(GarminProduct::Oregon7xxWw),
            "edge_820" => Ok(GarminProduct::Edge820),
            "edge_explore_820" => Ok(GarminProduct::EdgeExplore820),
            "fr735xt_apac" => Ok(GarminProduct::Fr735xtApac),
            "fr735xt_japan" => Ok(GarminProduct::Fr735xtJapan),
            "fenix5s" => Ok(GarminProduct::Fenix5s),
            "d2_bravo_titanium" => Ok(GarminProduct::D2BravoTitanium),
            "varia_ut800" => Ok(GarminProduct::VariaUt800),
            "running_dynamics_pod" => Ok(GarminProduct::RunningDynamicsPod),
            "edge_820_china" => Ok(GarminProduct::Edge820China),
            "edge_820_japan" => Ok(GarminProduct::Edge820Japan),
            "fenix5x" => Ok(GarminProduct::Fenix5x),
            "vivo_fit_jr" => Ok(GarminProduct::VivoFitJr),
            "vivo_smart3" => Ok(GarminProduct::VivoSmart3),
            "vivo_sport" => Ok(GarminProduct::VivoSport),
            "edge_820_taiwan" => Ok(GarminProduct::Edge820Taiwan),
            "edge_820_korea" => Ok(GarminProduct::Edge820Korea),
            "edge_820_sea" => Ok(GarminProduct::Edge820Sea),
            "fr35_hebrew" => Ok(GarminProduct::Fr35Hebrew),
            "approach_s60" => Ok(GarminProduct::ApproachS60),
            "fr35_apac" => Ok(GarminProduct::Fr35Apac),
            "fr35_japan" => Ok(GarminProduct::Fr35Japan),
            "fenix3_chronos_asia" => Ok(GarminProduct::Fenix3ChronosAsia),
            "virb_360" => Ok(GarminProduct::Virb360),
            "fr935" => Ok(GarminProduct::Fr935),
            "fenix5" => Ok(GarminProduct::Fenix5),
            "vivoactive3" => Ok(GarminProduct::Vivoactive3),
            "fr235_china_nfc" => Ok(GarminProduct::Fr235ChinaNfc),
            "foretrex_601_701" => Ok(GarminProduct::Foretrex601701),
            "vivo_move_hr" => Ok(GarminProduct::VivoMoveHr),
            "edge_1030" => Ok(GarminProduct::Edge1030),
            "fr35_sea" => Ok(GarminProduct::Fr35Sea),
            "vector_3" => Ok(GarminProduct::Vector3),
            "fenix5_asia" => Ok(GarminProduct::Fenix5Asia),
            "fenix5s_asia" => Ok(GarminProduct::Fenix5sAsia),
            "fenix5x_asia" => Ok(GarminProduct::Fenix5xAsia),
            "approach_z80" => Ok(GarminProduct::ApproachZ80),
            "fr35_korea" => Ok(GarminProduct::Fr35Korea),
            "d2charlie" => Ok(GarminProduct::D2charlie),
            "vivo_smart3_apac" => Ok(GarminProduct::VivoSmart3Apac),
            "vivo_sport_apac" => Ok(GarminProduct::VivoSportApac),
            "fr935_asia" => Ok(GarminProduct::Fr935Asia),
            "descent" => Ok(GarminProduct::Descent),
            "vivo_fit4" => Ok(GarminProduct::VivoFit4),
            "fr645" => Ok(GarminProduct::Fr645),
            "fr645m" => Ok(GarminProduct::Fr645m),
            "fr30" => Ok(GarminProduct::Fr30),
            "fenix5s_plus" => Ok(GarminProduct::Fenix5sPlus),
            "Edge_130" => Ok(GarminProduct::Edge130),
            "edge_1030_asia" => Ok(GarminProduct::Edge1030Asia),
            "vivosmart_4" => Ok(GarminProduct::Vivosmart4),
            "vivo_move_hr_asia" => Ok(GarminProduct::VivoMoveHrAsia),
            "approach_x10" => Ok(GarminProduct::ApproachX10),
            "fr30_asia" => Ok(GarminProduct::Fr30Asia),
            "vivoactive3m_w" => Ok(GarminProduct::Vivoactive3mW),
            "fr645_asia" => Ok(GarminProduct::Fr645Asia),
            "fr645m_asia" => Ok(GarminProduct::Fr645mAsia),
            "edge_explore" => Ok(GarminProduct::EdgeExplore),
            "gpsmap66" => Ok(GarminProduct::Gpsmap66),
            "approach_s10" => Ok(GarminProduct::ApproachS10),
            "vivoactive3m_l" => Ok(GarminProduct::Vivoactive3mL),
            "approach_g80" => Ok(GarminProduct::ApproachG80),
            "edge_130_asia" => Ok(GarminProduct::Edge130Asia),
            "edge_1030_bontrager" => Ok(GarminProduct::Edge1030Bontrager),
            "fenix5_plus" => Ok(GarminProduct::Fenix5Plus),
            "fenix5x_plus" => Ok(GarminProduct::Fenix5xPlus),
            "edge_520_plus" => Ok(GarminProduct::Edge520Plus),
            "fr945" => Ok(GarminProduct::Fr945),
            "edge_530" => Ok(GarminProduct::Edge530),
            "edge_830" => Ok(GarminProduct::Edge830),
            "instinct_esports" => Ok(GarminProduct::InstinctEsports),
            "fenix5s_plus_apac" => Ok(GarminProduct::Fenix5sPlusApac),
            "fenix5x_plus_apac" => Ok(GarminProduct::Fenix5xPlusApac),
            "edge_520_plus_apac" => Ok(GarminProduct::Edge520PlusApac),
            "descent_t1" => Ok(GarminProduct::DescentT1),
            "fr235l_asia" => Ok(GarminProduct::Fr235lAsia),
            "fr245_asia" => Ok(GarminProduct::Fr245Asia),
            "vivo_active3m_apac" => Ok(GarminProduct::VivoActive3mApac),
            "gen3_bsm" => Ok(GarminProduct::Gen3Bsm),
            "gen3_bcm" => Ok(GarminProduct::Gen3Bcm),
            "vivo_smart4_asia" => Ok(GarminProduct::VivoSmart4Asia),
            "vivoactive4_small" => Ok(GarminProduct::Vivoactive4Small),
            "vivoactive4_large" => Ok(GarminProduct::Vivoactive4Large),
            "venu" => Ok(GarminProduct::Venu),
            "marq_driver" => Ok(GarminProduct::MarqDriver),
            "marq_aviator" => Ok(GarminProduct::MarqAviator),
            "marq_captain" => Ok(GarminProduct::MarqCaptain),
            "marq_commander" => Ok(GarminProduct::MarqCommander),
            "marq_expedition" => Ok(GarminProduct::MarqExpedition),
            "marq_athlete" => Ok(GarminProduct::MarqAthlete),
            "descent_mk2" => Ok(GarminProduct::DescentMk2),
            "gpsmap66i" => Ok(GarminProduct::Gpsmap66i),
            "fenix6S_sport" => Ok(GarminProduct::Fenix6SSport),
            "fenix6S" => Ok(GarminProduct::Fenix6S),
            "fenix6_sport" => Ok(GarminProduct::Fenix6Sport),
            "fenix6" => Ok(GarminProduct::Fenix6),
            "fenix6x" => Ok(GarminProduct::Fenix6x),
            "hrm_dual" => Ok(GarminProduct::HrmDual),
            "hrm_pro" => Ok(GarminProduct::HrmPro),
            "vivo_move3_premium" => Ok(GarminProduct::VivoMove3Premium),
            "approach_s40" => Ok(GarminProduct::ApproachS40),
            "fr245m_asia" => Ok(GarminProduct::Fr245mAsia),
            "edge_530_apac" => Ok(GarminProduct::Edge530Apac),
            "edge_830_apac" => Ok(GarminProduct::Edge830Apac),
            "vivo_move3" => Ok(GarminProduct::VivoMove3),
            "vivo_active4_small_asia" => Ok(GarminProduct::VivoActive4SmallAsia),
            "vivo_active4_large_asia" => Ok(GarminProduct::VivoActive4LargeAsia),
            "vivo_active4_oled_asia" => Ok(GarminProduct::VivoActive4OledAsia),
            "swim2" => Ok(GarminProduct::Swim2),
            "marq_driver_asia" => Ok(GarminProduct::MarqDriverAsia),
            "marq_aviator_asia" => Ok(GarminProduct::MarqAviatorAsia),
            "vivo_move3_asia" => Ok(GarminProduct::VivoMove3Asia),
            "fr945_asia" => Ok(GarminProduct::Fr945Asia),
            "vivo_active3t_chn" => Ok(GarminProduct::VivoActive3tChn),
            "marq_captain_asia" => Ok(GarminProduct::MarqCaptainAsia),
            "marq_commander_asia" => Ok(GarminProduct::MarqCommanderAsia),
            "marq_expedition_asia" => Ok(GarminProduct::MarqExpeditionAsia),
            "marq_athlete_asia" => Ok(GarminProduct::MarqAthleteAsia),
            "instinct_solar" => Ok(GarminProduct::InstinctSolar),
            "fr45_asia" => Ok(GarminProduct::Fr45Asia),
            "vivoactive3_daimler" => Ok(GarminProduct::Vivoactive3Daimler),
            "legacy_rey" => Ok(GarminProduct::LegacyRey),
            "legacy_darth_vader" => Ok(GarminProduct::LegacyDarthVader),
            "legacy_captain_marvel" => Ok(GarminProduct::LegacyCaptainMarvel),
            "legacy_first_avenger" => Ok(GarminProduct::LegacyFirstAvenger),
            "fenix6s_sport_asia" => Ok(GarminProduct::Fenix6sSportAsia),
            "fenix6s_asia" => Ok(GarminProduct::Fenix6sAsia),
            "fenix6_sport_asia" => Ok(GarminProduct::Fenix6SportAsia),
            "fenix6_asia" => Ok(GarminProduct::Fenix6Asia),
            "fenix6x_asia" => Ok(GarminProduct::Fenix6xAsia),
            "legacy_captain_marvel_asia" => Ok(GarminProduct::LegacyCaptainMarvelAsia),
            "legacy_first_avenger_asia" => Ok(GarminProduct::LegacyFirstAvengerAsia),
            "legacy_rey_asia" => Ok(GarminProduct::LegacyReyAsia),
            "legacy_darth_vader_asia" => Ok(GarminProduct::LegacyDarthVaderAsia),
            "descent_mk2s" => Ok(GarminProduct::DescentMk2s),
            "edge_130_plus" => Ok(GarminProduct::Edge130Plus),
            "edge_1030_plus" => Ok(GarminProduct::Edge1030Plus),
            "rally_200" => Ok(GarminProduct::Rally200),
            "fr745" => Ok(GarminProduct::Fr745),
            "venusq" => Ok(GarminProduct::Venusq),
            "lily" => Ok(GarminProduct::Lily),
            "marq_adventurer" => Ok(GarminProduct::MarqAdventurer),
            "enduro" => Ok(GarminProduct::Enduro),
            "swim2_apac" => Ok(GarminProduct::Swim2Apac),
            "marq_adventurer_asia" => Ok(GarminProduct::MarqAdventurerAsia),
            "fr945_lte" => Ok(GarminProduct::Fr945Lte),
            "descent_mk2_asia" => Ok(GarminProduct::DescentMk2Asia),
            "venu2" => Ok(GarminProduct::Venu2),
            "venu2s" => Ok(GarminProduct::Venu2s),
            "venu_daimler_asia" => Ok(GarminProduct::VenuDaimlerAsia),
            "marq_golfer" => Ok(GarminProduct::MarqGolfer),
            "venu_daimler" => Ok(GarminProduct::VenuDaimler),
            "fr745_asia" => Ok(GarminProduct::Fr745Asia),
            "lily_asia" => Ok(GarminProduct::LilyAsia),
            "edge_1030_plus_asia" => Ok(GarminProduct::Edge1030PlusAsia),
            "edge_130_plus_asia" => Ok(GarminProduct::Edge130PlusAsia),
            "approach_s12" => Ok(GarminProduct::ApproachS12),
            "enduro_asia" => Ok(GarminProduct::EnduroAsia),
            "venusq_asia" => Ok(GarminProduct::VenusqAsia),
            "edge_1040" => Ok(GarminProduct::Edge1040),
            "marq_golfer_asia" => Ok(GarminProduct::MarqGolferAsia),
            "venu2_plus" => Ok(GarminProduct::Venu2Plus),
            "gnss" => Ok(GarminProduct::Gnss),
            "fr55" => Ok(GarminProduct::Fr55),
            "instinct_2" => Ok(GarminProduct::Instinct2),
            "fenix7s" => Ok(GarminProduct::Fenix7s),
            "fenix7" => Ok(GarminProduct::Fenix7),
            "fenix7x" => Ok(GarminProduct::Fenix7x),
            "fenix7s_apac" => Ok(GarminProduct::Fenix7sApac),
            "fenix7_apac" => Ok(GarminProduct::Fenix7Apac),
            "fenix7x_apac" => Ok(GarminProduct::Fenix7xApac),
            "approach_g12" => Ok(GarminProduct::ApproachG12),
            "descent_mk2s_asia" => Ok(GarminProduct::DescentMk2sAsia),
            "approach_s42" => Ok(GarminProduct::ApproachS42),
            "epix_gen2" => Ok(GarminProduct::EpixGen2),
            "epix_gen2_apac" => Ok(GarminProduct::EpixGen2Apac),
            "venu2s_asia" => Ok(GarminProduct::Venu2sAsia),
            "venu2_asia" => Ok(GarminProduct::Venu2Asia),
            "fr945_lte_asia" => Ok(GarminProduct::Fr945LteAsia),
            "vivo_move_sport" => Ok(GarminProduct::VivoMoveSport),
            "vivomove_trend" => Ok(GarminProduct::VivomoveTrend),
            "approach_S12_asia" => Ok(GarminProduct::ApproachS12Asia),
            "fr255_music" => Ok(GarminProduct::Fr255Music),
            "fr255_small_music" => Ok(GarminProduct::Fr255SmallMusic),
            "fr255" => Ok(GarminProduct::Fr255),
            "fr255_small" => Ok(GarminProduct::Fr255Small),
            "approach_g12_asia" => Ok(GarminProduct::ApproachG12Asia),
            "approach_s42_asia" => Ok(GarminProduct::ApproachS42Asia),
            "descent_g1" => Ok(GarminProduct::DescentG1),
            "venu2_plus_asia" => Ok(GarminProduct::Venu2PlusAsia),
            "fr955" => Ok(GarminProduct::Fr955),
            "fr55_asia" => Ok(GarminProduct::Fr55Asia),
            "edge_540" => Ok(GarminProduct::Edge540),
            "edge_840" => Ok(GarminProduct::Edge840),
            "vivosmart_5" => Ok(GarminProduct::Vivosmart5),
            "instinct_2_asia" => Ok(GarminProduct::Instinct2Asia),
            "marq_gen2" => Ok(GarminProduct::MarqGen2),
            "venusq2" => Ok(GarminProduct::Venusq2),
            "venusq2music" => Ok(GarminProduct::Venusq2music),
            "marq_gen2_aviator" => Ok(GarminProduct::MarqGen2Aviator),
            "d2_air_x10" => Ok(GarminProduct::D2AirX10),
            "hrm_pro_plus" => Ok(GarminProduct::HrmProPlus),
            "descent_g1_asia" => Ok(GarminProduct::DescentG1Asia),
            "tactix7" => Ok(GarminProduct::Tactix7),
            "instinct_crossover" => Ok(GarminProduct::InstinctCrossover),
            "edge_explore2" => Ok(GarminProduct::EdgeExplore2),
            "approach_s70" => Ok(GarminProduct::ApproachS70),
            "fr265_large" => Ok(GarminProduct::Fr265Large),
            "fr265_small" => Ok(GarminProduct::Fr265Small),
            "tacx_neo_smart" => Ok(GarminProduct::TacxNeoSmart),
            "tacx_neo2_smart" => Ok(GarminProduct::TacxNeo2Smart),
            "tacx_neo2_t_smart" => Ok(GarminProduct::TacxNeo2TSmart),
            "tacx_neo_smart_bike" => Ok(GarminProduct::TacxNeoSmartBike),
            "tacx_satori_smart" => Ok(GarminProduct::TacxSatoriSmart),
            "tacx_flow_smart" => Ok(GarminProduct::TacxFlowSmart),
            "tacx_vortex_smart" => Ok(GarminProduct::TacxVortexSmart),
            "tacx_bushido_smart" => Ok(GarminProduct::TacxBushidoSmart),
            "tacx_genius_smart" => Ok(GarminProduct::TacxGeniusSmart),
            "tacx_flux_flux_s_smart" => Ok(GarminProduct::TacxFluxFluxSSmart),
            "tacx_flux2_smart" => Ok(GarminProduct::TacxFlux2Smart),
            "tacx_magnum" => Ok(GarminProduct::TacxMagnum),
            "edge_1040_asia" => Ok(GarminProduct::Edge1040Asia),
            "epix_gen2_pro_42" => Ok(GarminProduct::EpixGen2Pro42),
            "epix_gen2_pro_47" => Ok(GarminProduct::EpixGen2Pro47),
            "epix_gen2_pro_51" => Ok(GarminProduct::EpixGen2Pro51),
            "fr965" => Ok(GarminProduct::Fr965),
            "enduro2" => Ok(GarminProduct::Enduro2),
            "fenix7_pro_solar" => Ok(GarminProduct::Fenix7ProSolar),
            "instinct_2x" => Ok(GarminProduct::Instinct2x),
            "descent_t2" => Ok(GarminProduct::DescentT2),
            "sdm4" => Ok(GarminProduct::Sdm4),
            "edge_remote" => Ok(GarminProduct::EdgeRemote),
            "tacx_training_app_win" => Ok(GarminProduct::TacxTrainingAppWin),
            "tacx_training_app_mac" => Ok(GarminProduct::TacxTrainingAppMac),
            "tacx_training_app_mac_catalyst" => Ok(GarminProduct::TacxTrainingAppMacCatalyst),
            "training_center" => Ok(GarminProduct::TrainingCenter),
            "tacx_training_app_android" => Ok(GarminProduct::TacxTrainingAppAndroid),
            "tacx_training_app_ios" => Ok(GarminProduct::TacxTrainingAppIos),
            "tacx_training_app_legacy" => Ok(GarminProduct::TacxTrainingAppLegacy),
            "connectiq_simulator" => Ok(GarminProduct::ConnectiqSimulator),
            "android_antplus_plugin" => Ok(GarminProduct::AndroidAntplusPlugin),
            "connect" => Ok(GarminProduct::Connect),
            _ => Err("No corresponding GarminProduct exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum AntplusDeviceType {
    Antfs,
    BikePower,
    EnvironmentSensorLegacy,
    MultiSportSpeedDistance,
    Control,
    FitnessEquipment,
    BloodPressure,
    GeocacheNode,
    LightElectricVehicle,
    EnvSensor,
    Racquet,
    ControlHub,
    MuscleOxygen,
    Shifting,
    BikeLightMain,
    BikeLightShared,
    Exd,
    BikeRadar,
    BikeAero,
    WeightScale,
    HeartRate,
    BikeSpeedCadence,
    BikeCadence,
    BikeSpeed,
    StrideSpeedDistance,
}
impl fmt::Display for AntplusDeviceType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AntplusDeviceType::Antfs => f.write_str("antfs"),
            AntplusDeviceType::BikePower => f.write_str("bike_power"),
            AntplusDeviceType::EnvironmentSensorLegacy => f.write_str("environment_sensor_legacy"),
            AntplusDeviceType::MultiSportSpeedDistance => f.write_str("multi_sport_speed_distance"),
            AntplusDeviceType::Control => f.write_str("control"),
            AntplusDeviceType::FitnessEquipment => f.write_str("fitness_equipment"),
            AntplusDeviceType::BloodPressure => f.write_str("blood_pressure"),
            AntplusDeviceType::GeocacheNode => f.write_str("geocache_node"),
            AntplusDeviceType::LightElectricVehicle => f.write_str("light_electric_vehicle"),
            AntplusDeviceType::EnvSensor => f.write_str("env_sensor"),
            AntplusDeviceType::Racquet => f.write_str("racquet"),
            AntplusDeviceType::ControlHub => f.write_str("control_hub"),
            AntplusDeviceType::MuscleOxygen => f.write_str("muscle_oxygen"),
            AntplusDeviceType::Shifting => f.write_str("shifting"),
            AntplusDeviceType::BikeLightMain => f.write_str("bike_light_main"),
            AntplusDeviceType::BikeLightShared => f.write_str("bike_light_shared"),
            AntplusDeviceType::Exd => f.write_str("exd"),
            AntplusDeviceType::BikeRadar => f.write_str("bike_radar"),
            AntplusDeviceType::BikeAero => f.write_str("bike_aero"),
            AntplusDeviceType::WeightScale => f.write_str("weight_scale"),
            AntplusDeviceType::HeartRate => f.write_str("heart_rate"),
            AntplusDeviceType::BikeSpeedCadence => f.write_str("bike_speed_cadence"),
            AntplusDeviceType::BikeCadence => f.write_str("bike_cadence"),
            AntplusDeviceType::BikeSpeed => f.write_str("bike_speed"),
            AntplusDeviceType::StrideSpeedDistance => f.write_str("stride_speed_distance"),
        }
    }
}
impl AntplusDeviceType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            AntplusDeviceType::Antfs => fit::Value::UInt8(1),
            AntplusDeviceType::BikePower => fit::Value::UInt8(11),
            AntplusDeviceType::EnvironmentSensorLegacy => fit::Value::UInt8(12),
            AntplusDeviceType::MultiSportSpeedDistance => fit::Value::UInt8(15),
            AntplusDeviceType::Control => fit::Value::UInt8(16),
            AntplusDeviceType::FitnessEquipment => fit::Value::UInt8(17),
            AntplusDeviceType::BloodPressure => fit::Value::UInt8(18),
            AntplusDeviceType::GeocacheNode => fit::Value::UInt8(19),
            AntplusDeviceType::LightElectricVehicle => fit::Value::UInt8(20),
            AntplusDeviceType::EnvSensor => fit::Value::UInt8(25),
            AntplusDeviceType::Racquet => fit::Value::UInt8(26),
            AntplusDeviceType::ControlHub => fit::Value::UInt8(27),
            AntplusDeviceType::MuscleOxygen => fit::Value::UInt8(31),
            AntplusDeviceType::Shifting => fit::Value::UInt8(34),
            AntplusDeviceType::BikeLightMain => fit::Value::UInt8(35),
            AntplusDeviceType::BikeLightShared => fit::Value::UInt8(36),
            AntplusDeviceType::Exd => fit::Value::UInt8(38),
            AntplusDeviceType::BikeRadar => fit::Value::UInt8(40),
            AntplusDeviceType::BikeAero => fit::Value::UInt8(46),
            AntplusDeviceType::WeightScale => fit::Value::UInt8(119),
            AntplusDeviceType::HeartRate => fit::Value::UInt8(120),
            AntplusDeviceType::BikeSpeedCadence => fit::Value::UInt8(121),
            AntplusDeviceType::BikeCadence => fit::Value::UInt8(122),
            AntplusDeviceType::BikeSpeed => fit::Value::UInt8(123),
            AntplusDeviceType::StrideSpeedDistance => fit::Value::UInt8(124),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for AntplusDeviceType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(1) => Ok(AntplusDeviceType::Antfs),
            fit::Value::UInt8(11) => Ok(AntplusDeviceType::BikePower),
            fit::Value::UInt8(12) => Ok(AntplusDeviceType::EnvironmentSensorLegacy),
            fit::Value::UInt8(15) => Ok(AntplusDeviceType::MultiSportSpeedDistance),
            fit::Value::UInt8(16) => Ok(AntplusDeviceType::Control),
            fit::Value::UInt8(17) => Ok(AntplusDeviceType::FitnessEquipment),
            fit::Value::UInt8(18) => Ok(AntplusDeviceType::BloodPressure),
            fit::Value::UInt8(19) => Ok(AntplusDeviceType::GeocacheNode),
            fit::Value::UInt8(20) => Ok(AntplusDeviceType::LightElectricVehicle),
            fit::Value::UInt8(25) => Ok(AntplusDeviceType::EnvSensor),
            fit::Value::UInt8(26) => Ok(AntplusDeviceType::Racquet),
            fit::Value::UInt8(27) => Ok(AntplusDeviceType::ControlHub),
            fit::Value::UInt8(31) => Ok(AntplusDeviceType::MuscleOxygen),
            fit::Value::UInt8(34) => Ok(AntplusDeviceType::Shifting),
            fit::Value::UInt8(35) => Ok(AntplusDeviceType::BikeLightMain),
            fit::Value::UInt8(36) => Ok(AntplusDeviceType::BikeLightShared),
            fit::Value::UInt8(38) => Ok(AntplusDeviceType::Exd),
            fit::Value::UInt8(40) => Ok(AntplusDeviceType::BikeRadar),
            fit::Value::UInt8(46) => Ok(AntplusDeviceType::BikeAero),
            fit::Value::UInt8(119) => Ok(AntplusDeviceType::WeightScale),
            fit::Value::UInt8(120) => Ok(AntplusDeviceType::HeartRate),
            fit::Value::UInt8(121) => Ok(AntplusDeviceType::BikeSpeedCadence),
            fit::Value::UInt8(122) => Ok(AntplusDeviceType::BikeCadence),
            fit::Value::UInt8(123) => Ok(AntplusDeviceType::BikeSpeed),
            fit::Value::UInt8(124) => Ok(AntplusDeviceType::StrideSpeedDistance),
            _ => Err("No corresponding AntplusDeviceType exists"),
        }
    }
}
impl TryFrom<&str> for AntplusDeviceType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "antfs" => Ok(AntplusDeviceType::Antfs),
            "bike_power" => Ok(AntplusDeviceType::BikePower),
            "environment_sensor_legacy" => Ok(AntplusDeviceType::EnvironmentSensorLegacy),
            "multi_sport_speed_distance" => Ok(AntplusDeviceType::MultiSportSpeedDistance),
            "control" => Ok(AntplusDeviceType::Control),
            "fitness_equipment" => Ok(AntplusDeviceType::FitnessEquipment),
            "blood_pressure" => Ok(AntplusDeviceType::BloodPressure),
            "geocache_node" => Ok(AntplusDeviceType::GeocacheNode),
            "light_electric_vehicle" => Ok(AntplusDeviceType::LightElectricVehicle),
            "env_sensor" => Ok(AntplusDeviceType::EnvSensor),
            "racquet" => Ok(AntplusDeviceType::Racquet),
            "control_hub" => Ok(AntplusDeviceType::ControlHub),
            "muscle_oxygen" => Ok(AntplusDeviceType::MuscleOxygen),
            "shifting" => Ok(AntplusDeviceType::Shifting),
            "bike_light_main" => Ok(AntplusDeviceType::BikeLightMain),
            "bike_light_shared" => Ok(AntplusDeviceType::BikeLightShared),
            "exd" => Ok(AntplusDeviceType::Exd),
            "bike_radar" => Ok(AntplusDeviceType::BikeRadar),
            "bike_aero" => Ok(AntplusDeviceType::BikeAero),
            "weight_scale" => Ok(AntplusDeviceType::WeightScale),
            "heart_rate" => Ok(AntplusDeviceType::HeartRate),
            "bike_speed_cadence" => Ok(AntplusDeviceType::BikeSpeedCadence),
            "bike_cadence" => Ok(AntplusDeviceType::BikeCadence),
            "bike_speed" => Ok(AntplusDeviceType::BikeSpeed),
            "stride_speed_distance" => Ok(AntplusDeviceType::StrideSpeedDistance),
            _ => Err("No corresponding AntplusDeviceType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum AntNetwork {
    Public,
    Antplus,
    Antfs,
    Private,
}
impl fmt::Display for AntNetwork {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AntNetwork::Public => f.write_str("public"),
            AntNetwork::Antplus => f.write_str("antplus"),
            AntNetwork::Antfs => f.write_str("antfs"),
            AntNetwork::Private => f.write_str("private"),
        }
    }
}
impl AntNetwork {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            AntNetwork::Public => fit::Value::Enum(0),
            AntNetwork::Antplus => fit::Value::Enum(1),
            AntNetwork::Antfs => fit::Value::Enum(2),
            AntNetwork::Private => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for AntNetwork {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(AntNetwork::Public),
            fit::Value::Enum(1) => Ok(AntNetwork::Antplus),
            fit::Value::Enum(2) => Ok(AntNetwork::Antfs),
            fit::Value::Enum(3) => Ok(AntNetwork::Private),
            _ => Err("No corresponding AntNetwork exists"),
        }
    }
}
impl TryFrom<&str> for AntNetwork {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "public" => Ok(AntNetwork::Public),
            "antplus" => Ok(AntNetwork::Antplus),
            "antfs" => Ok(AntNetwork::Antfs),
            "private" => Ok(AntNetwork::Private),
            _ => Err("No corresponding AntNetwork exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WorkoutCapabilities {
    Interval,
    Custom,
    FitnessEquipment,
    Firstbeat,
    NewLeaf,
    /// For backwards compatibility. Watch should add missing id fields then clear flag.
    Tcx,
    /// Speed source required for workout step.
    Speed,
    /// Heart rate source required for workout step.
    HeartRate,
    /// Distance source required for workout step.
    Distance,
    /// Cadence source required for workout step.
    Cadence,
    /// Power source required for workout step.
    Power,
    /// Grade source required for workout step.
    Grade,
    /// Resistance source required for workout step.
    Resistance,
    Protected,
}
impl fmt::Display for WorkoutCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WorkoutCapabilities::Interval => f.write_str("interval"),
            WorkoutCapabilities::Custom => f.write_str("custom"),
            WorkoutCapabilities::FitnessEquipment => f.write_str("fitness_equipment"),
            WorkoutCapabilities::Firstbeat => f.write_str("firstbeat"),
            WorkoutCapabilities::NewLeaf => f.write_str("new_leaf"),
            WorkoutCapabilities::Tcx => f.write_str("tcx"),
            WorkoutCapabilities::Speed => f.write_str("speed"),
            WorkoutCapabilities::HeartRate => f.write_str("heart_rate"),
            WorkoutCapabilities::Distance => f.write_str("distance"),
            WorkoutCapabilities::Cadence => f.write_str("cadence"),
            WorkoutCapabilities::Power => f.write_str("power"),
            WorkoutCapabilities::Grade => f.write_str("grade"),
            WorkoutCapabilities::Resistance => f.write_str("resistance"),
            WorkoutCapabilities::Protected => f.write_str("protected"),
        }
    }
}
impl WorkoutCapabilities {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WorkoutCapabilities::Interval => fit::Value::UInt32z(0x00000001),
            WorkoutCapabilities::Custom => fit::Value::UInt32z(0x00000002),
            WorkoutCapabilities::FitnessEquipment => fit::Value::UInt32z(0x00000004),
            WorkoutCapabilities::Firstbeat => fit::Value::UInt32z(0x00000008),
            WorkoutCapabilities::NewLeaf => fit::Value::UInt32z(0x00000010),
            WorkoutCapabilities::Tcx => fit::Value::UInt32z(0x00000020),
            WorkoutCapabilities::Speed => fit::Value::UInt32z(0x00000080),
            WorkoutCapabilities::HeartRate => fit::Value::UInt32z(0x00000100),
            WorkoutCapabilities::Distance => fit::Value::UInt32z(0x00000200),
            WorkoutCapabilities::Cadence => fit::Value::UInt32z(0x00000400),
            WorkoutCapabilities::Power => fit::Value::UInt32z(0x00000800),
            WorkoutCapabilities::Grade => fit::Value::UInt32z(0x00001000),
            WorkoutCapabilities::Resistance => fit::Value::UInt32z(0x00002000),
            WorkoutCapabilities::Protected => fit::Value::UInt32z(0x00004000),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32z"
    }
}
impl TryFrom<&fit::Value> for WorkoutCapabilities {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32z(0x00000001) => Ok(WorkoutCapabilities::Interval),
            fit::Value::UInt32z(0x00000002) => Ok(WorkoutCapabilities::Custom),
            fit::Value::UInt32z(0x00000004) => Ok(WorkoutCapabilities::FitnessEquipment),
            fit::Value::UInt32z(0x00000008) => Ok(WorkoutCapabilities::Firstbeat),
            fit::Value::UInt32z(0x00000010) => Ok(WorkoutCapabilities::NewLeaf),
            fit::Value::UInt32z(0x00000020) => Ok(WorkoutCapabilities::Tcx),
            fit::Value::UInt32z(0x00000080) => Ok(WorkoutCapabilities::Speed),
            fit::Value::UInt32z(0x00000100) => Ok(WorkoutCapabilities::HeartRate),
            fit::Value::UInt32z(0x00000200) => Ok(WorkoutCapabilities::Distance),
            fit::Value::UInt32z(0x00000400) => Ok(WorkoutCapabilities::Cadence),
            fit::Value::UInt32z(0x00000800) => Ok(WorkoutCapabilities::Power),
            fit::Value::UInt32z(0x00001000) => Ok(WorkoutCapabilities::Grade),
            fit::Value::UInt32z(0x00002000) => Ok(WorkoutCapabilities::Resistance),
            fit::Value::UInt32z(0x00004000) => Ok(WorkoutCapabilities::Protected),
            _ => Err("No corresponding WorkoutCapabilities exists"),
        }
    }
}
impl TryFrom<&str> for WorkoutCapabilities {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "interval" => Ok(WorkoutCapabilities::Interval),
            "custom" => Ok(WorkoutCapabilities::Custom),
            "fitness_equipment" => Ok(WorkoutCapabilities::FitnessEquipment),
            "firstbeat" => Ok(WorkoutCapabilities::Firstbeat),
            "new_leaf" => Ok(WorkoutCapabilities::NewLeaf),
            "tcx" => Ok(WorkoutCapabilities::Tcx),
            "speed" => Ok(WorkoutCapabilities::Speed),
            "heart_rate" => Ok(WorkoutCapabilities::HeartRate),
            "distance" => Ok(WorkoutCapabilities::Distance),
            "cadence" => Ok(WorkoutCapabilities::Cadence),
            "power" => Ok(WorkoutCapabilities::Power),
            "grade" => Ok(WorkoutCapabilities::Grade),
            "resistance" => Ok(WorkoutCapabilities::Resistance),
            "protected" => Ok(WorkoutCapabilities::Protected),
            _ => Err("No corresponding WorkoutCapabilities exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum BatteryStatus {
    New,
    Good,
    Ok,
    Low,
    Critical,
    Charging,
    Unknown,
}
impl fmt::Display for BatteryStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BatteryStatus::New => f.write_str("new"),
            BatteryStatus::Good => f.write_str("good"),
            BatteryStatus::Ok => f.write_str("ok"),
            BatteryStatus::Low => f.write_str("low"),
            BatteryStatus::Critical => f.write_str("critical"),
            BatteryStatus::Charging => f.write_str("charging"),
            BatteryStatus::Unknown => f.write_str("unknown"),
        }
    }
}
impl BatteryStatus {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            BatteryStatus::New => fit::Value::UInt8(1),
            BatteryStatus::Good => fit::Value::UInt8(2),
            BatteryStatus::Ok => fit::Value::UInt8(3),
            BatteryStatus::Low => fit::Value::UInt8(4),
            BatteryStatus::Critical => fit::Value::UInt8(5),
            BatteryStatus::Charging => fit::Value::UInt8(6),
            BatteryStatus::Unknown => fit::Value::UInt8(7),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for BatteryStatus {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(1) => Ok(BatteryStatus::New),
            fit::Value::UInt8(2) => Ok(BatteryStatus::Good),
            fit::Value::UInt8(3) => Ok(BatteryStatus::Ok),
            fit::Value::UInt8(4) => Ok(BatteryStatus::Low),
            fit::Value::UInt8(5) => Ok(BatteryStatus::Critical),
            fit::Value::UInt8(6) => Ok(BatteryStatus::Charging),
            fit::Value::UInt8(7) => Ok(BatteryStatus::Unknown),
            _ => Err("No corresponding BatteryStatus exists"),
        }
    }
}
impl TryFrom<&str> for BatteryStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "new" => Ok(BatteryStatus::New),
            "good" => Ok(BatteryStatus::Good),
            "ok" => Ok(BatteryStatus::Ok),
            "low" => Ok(BatteryStatus::Low),
            "critical" => Ok(BatteryStatus::Critical),
            "charging" => Ok(BatteryStatus::Charging),
            "unknown" => Ok(BatteryStatus::Unknown),
            _ => Err("No corresponding BatteryStatus exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum HrType {
    Normal,
    Irregular,
}
impl fmt::Display for HrType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            HrType::Normal => f.write_str("normal"),
            HrType::Irregular => f.write_str("irregular"),
        }
    }
}
impl HrType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            HrType::Normal => fit::Value::Enum(0),
            HrType::Irregular => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for HrType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(HrType::Normal),
            fit::Value::Enum(1) => Ok(HrType::Irregular),
            _ => Err("No corresponding HrType exists"),
        }
    }
}
impl TryFrom<&str> for HrType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "normal" => Ok(HrType::Normal),
            "irregular" => Ok(HrType::Irregular),
            _ => Err("No corresponding HrType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CourseCapabilities {
    Processed,
    Valid,
    Time,
    Distance,
    Position,
    HeartRate,
    Power,
    Cadence,
    Training,
    Navigation,
    Bikeway,
    /// Denote course files to be used as flight plans
    Aviation,
}
impl fmt::Display for CourseCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CourseCapabilities::Processed => f.write_str("processed"),
            CourseCapabilities::Valid => f.write_str("valid"),
            CourseCapabilities::Time => f.write_str("time"),
            CourseCapabilities::Distance => f.write_str("distance"),
            CourseCapabilities::Position => f.write_str("position"),
            CourseCapabilities::HeartRate => f.write_str("heart_rate"),
            CourseCapabilities::Power => f.write_str("power"),
            CourseCapabilities::Cadence => f.write_str("cadence"),
            CourseCapabilities::Training => f.write_str("training"),
            CourseCapabilities::Navigation => f.write_str("navigation"),
            CourseCapabilities::Bikeway => f.write_str("bikeway"),
            CourseCapabilities::Aviation => f.write_str("aviation"),
        }
    }
}
impl CourseCapabilities {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CourseCapabilities::Processed => fit::Value::UInt32z(0x00000001),
            CourseCapabilities::Valid => fit::Value::UInt32z(0x00000002),
            CourseCapabilities::Time => fit::Value::UInt32z(0x00000004),
            CourseCapabilities::Distance => fit::Value::UInt32z(0x00000008),
            CourseCapabilities::Position => fit::Value::UInt32z(0x00000010),
            CourseCapabilities::HeartRate => fit::Value::UInt32z(0x00000020),
            CourseCapabilities::Power => fit::Value::UInt32z(0x00000040),
            CourseCapabilities::Cadence => fit::Value::UInt32z(0x00000080),
            CourseCapabilities::Training => fit::Value::UInt32z(0x00000100),
            CourseCapabilities::Navigation => fit::Value::UInt32z(0x00000200),
            CourseCapabilities::Bikeway => fit::Value::UInt32z(0x00000400),
            CourseCapabilities::Aviation => fit::Value::UInt32z(0x00001000),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32z"
    }
}
impl TryFrom<&fit::Value> for CourseCapabilities {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32z(0x00000001) => Ok(CourseCapabilities::Processed),
            fit::Value::UInt32z(0x00000002) => Ok(CourseCapabilities::Valid),
            fit::Value::UInt32z(0x00000004) => Ok(CourseCapabilities::Time),
            fit::Value::UInt32z(0x00000008) => Ok(CourseCapabilities::Distance),
            fit::Value::UInt32z(0x00000010) => Ok(CourseCapabilities::Position),
            fit::Value::UInt32z(0x00000020) => Ok(CourseCapabilities::HeartRate),
            fit::Value::UInt32z(0x00000040) => Ok(CourseCapabilities::Power),
            fit::Value::UInt32z(0x00000080) => Ok(CourseCapabilities::Cadence),
            fit::Value::UInt32z(0x00000100) => Ok(CourseCapabilities::Training),
            fit::Value::UInt32z(0x00000200) => Ok(CourseCapabilities::Navigation),
            fit::Value::UInt32z(0x00000400) => Ok(CourseCapabilities::Bikeway),
            fit::Value::UInt32z(0x00001000) => Ok(CourseCapabilities::Aviation),
            _ => Err("No corresponding CourseCapabilities exists"),
        }
    }
}
impl TryFrom<&str> for CourseCapabilities {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "processed" => Ok(CourseCapabilities::Processed),
            "valid" => Ok(CourseCapabilities::Valid),
            "time" => Ok(CourseCapabilities::Time),
            "distance" => Ok(CourseCapabilities::Distance),
            "position" => Ok(CourseCapabilities::Position),
            "heart_rate" => Ok(CourseCapabilities::HeartRate),
            "power" => Ok(CourseCapabilities::Power),
            "cadence" => Ok(CourseCapabilities::Cadence),
            "training" => Ok(CourseCapabilities::Training),
            "navigation" => Ok(CourseCapabilities::Navigation),
            "bikeway" => Ok(CourseCapabilities::Bikeway),
            "aviation" => Ok(CourseCapabilities::Aviation),
            _ => Err("No corresponding CourseCapabilities exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Weight {
    Calculating,
}
impl fmt::Display for Weight {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Weight::Calculating => f.write_str("calculating"),
        }
    }
}
impl Weight {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Weight::Calculating => fit::Value::UInt16(0xFFFE),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for Weight {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0xFFFE) => Ok(Weight::Calculating),
            _ => Err("No corresponding Weight exists"),
        }
    }
}
impl TryFrom<&str> for Weight {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "calculating" => Ok(Weight::Calculating),
            _ => Err("No corresponding Weight exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WorkoutHr {
    BpmOffset,
}
impl fmt::Display for WorkoutHr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WorkoutHr::BpmOffset => f.write_str("bpm_offset"),
        }
    }
}
impl WorkoutHr {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WorkoutHr::BpmOffset => fit::Value::UInt32(100),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32"
    }
}
impl TryFrom<&fit::Value> for WorkoutHr {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32(100) => Ok(WorkoutHr::BpmOffset),
            _ => Err("No corresponding WorkoutHr exists"),
        }
    }
}
impl TryFrom<&str> for WorkoutHr {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "bpm_offset" => Ok(WorkoutHr::BpmOffset),
            _ => Err("No corresponding WorkoutHr exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WorkoutPower {
    WattsOffset,
}
impl fmt::Display for WorkoutPower {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WorkoutPower::WattsOffset => f.write_str("watts_offset"),
        }
    }
}
impl WorkoutPower {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WorkoutPower::WattsOffset => fit::Value::UInt32(1000),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32"
    }
}
impl TryFrom<&fit::Value> for WorkoutPower {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32(1000) => Ok(WorkoutPower::WattsOffset),
            _ => Err("No corresponding WorkoutPower exists"),
        }
    }
}
impl TryFrom<&str> for WorkoutPower {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "watts_offset" => Ok(WorkoutPower::WattsOffset),
            _ => Err("No corresponding WorkoutPower exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum BpStatus {
    NoError,
    ErrorIncompleteData,
    ErrorNoMeasurement,
    ErrorDataOutOfRange,
    ErrorIrregularHeartRate,
}
impl fmt::Display for BpStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BpStatus::NoError => f.write_str("no_error"),
            BpStatus::ErrorIncompleteData => f.write_str("error_incomplete_data"),
            BpStatus::ErrorNoMeasurement => f.write_str("error_no_measurement"),
            BpStatus::ErrorDataOutOfRange => f.write_str("error_data_out_of_range"),
            BpStatus::ErrorIrregularHeartRate => f.write_str("error_irregular_heart_rate"),
        }
    }
}
impl BpStatus {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            BpStatus::NoError => fit::Value::Enum(0),
            BpStatus::ErrorIncompleteData => fit::Value::Enum(1),
            BpStatus::ErrorNoMeasurement => fit::Value::Enum(2),
            BpStatus::ErrorDataOutOfRange => fit::Value::Enum(3),
            BpStatus::ErrorIrregularHeartRate => fit::Value::Enum(4),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for BpStatus {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(BpStatus::NoError),
            fit::Value::Enum(1) => Ok(BpStatus::ErrorIncompleteData),
            fit::Value::Enum(2) => Ok(BpStatus::ErrorNoMeasurement),
            fit::Value::Enum(3) => Ok(BpStatus::ErrorDataOutOfRange),
            fit::Value::Enum(4) => Ok(BpStatus::ErrorIrregularHeartRate),
            _ => Err("No corresponding BpStatus exists"),
        }
    }
}
impl TryFrom<&str> for BpStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "no_error" => Ok(BpStatus::NoError),
            "error_incomplete_data" => Ok(BpStatus::ErrorIncompleteData),
            "error_no_measurement" => Ok(BpStatus::ErrorNoMeasurement),
            "error_data_out_of_range" => Ok(BpStatus::ErrorDataOutOfRange),
            "error_irregular_heart_rate" => Ok(BpStatus::ErrorIrregularHeartRate),
            _ => Err("No corresponding BpStatus exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum UserLocalId {
    LocalMin,
    LocalMax,
    StationaryMin,
    StationaryMax,
    PortableMin,
    PortableMax,
}
impl fmt::Display for UserLocalId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            UserLocalId::LocalMin => f.write_str("local_min"),
            UserLocalId::LocalMax => f.write_str("local_max"),
            UserLocalId::StationaryMin => f.write_str("stationary_min"),
            UserLocalId::StationaryMax => f.write_str("stationary_max"),
            UserLocalId::PortableMin => f.write_str("portable_min"),
            UserLocalId::PortableMax => f.write_str("portable_max"),
        }
    }
}
impl UserLocalId {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            UserLocalId::LocalMin => fit::Value::UInt16(0x0000),
            UserLocalId::LocalMax => fit::Value::UInt16(0x000F),
            UserLocalId::StationaryMin => fit::Value::UInt16(0x0010),
            UserLocalId::StationaryMax => fit::Value::UInt16(0x00FF),
            UserLocalId::PortableMin => fit::Value::UInt16(0x0100),
            UserLocalId::PortableMax => fit::Value::UInt16(0xFFFE),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for UserLocalId {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0x0000) => Ok(UserLocalId::LocalMin),
            fit::Value::UInt16(0x000F) => Ok(UserLocalId::LocalMax),
            fit::Value::UInt16(0x0010) => Ok(UserLocalId::StationaryMin),
            fit::Value::UInt16(0x00FF) => Ok(UserLocalId::StationaryMax),
            fit::Value::UInt16(0x0100) => Ok(UserLocalId::PortableMin),
            fit::Value::UInt16(0xFFFE) => Ok(UserLocalId::PortableMax),
            _ => Err("No corresponding UserLocalId exists"),
        }
    }
}
impl TryFrom<&str> for UserLocalId {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "local_min" => Ok(UserLocalId::LocalMin),
            "local_max" => Ok(UserLocalId::LocalMax),
            "stationary_min" => Ok(UserLocalId::StationaryMin),
            "stationary_max" => Ok(UserLocalId::StationaryMax),
            "portable_min" => Ok(UserLocalId::PortableMin),
            "portable_max" => Ok(UserLocalId::PortableMax),
            _ => Err("No corresponding UserLocalId exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SwimStroke {
    Freestyle,
    Backstroke,
    Breaststroke,
    Butterfly,
    Drill,
    Mixed,
    /// IM is a mixed interval containing the same number of lengths for each of: Butterfly, Backstroke, Breaststroke, Freestyle, swam in that order.
    Im,
}
impl fmt::Display for SwimStroke {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SwimStroke::Freestyle => f.write_str("freestyle"),
            SwimStroke::Backstroke => f.write_str("backstroke"),
            SwimStroke::Breaststroke => f.write_str("breaststroke"),
            SwimStroke::Butterfly => f.write_str("butterfly"),
            SwimStroke::Drill => f.write_str("drill"),
            SwimStroke::Mixed => f.write_str("mixed"),
            SwimStroke::Im => f.write_str("im"),
        }
    }
}
impl SwimStroke {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SwimStroke::Freestyle => fit::Value::Enum(0),
            SwimStroke::Backstroke => fit::Value::Enum(1),
            SwimStroke::Breaststroke => fit::Value::Enum(2),
            SwimStroke::Butterfly => fit::Value::Enum(3),
            SwimStroke::Drill => fit::Value::Enum(4),
            SwimStroke::Mixed => fit::Value::Enum(5),
            SwimStroke::Im => fit::Value::Enum(6),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SwimStroke {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SwimStroke::Freestyle),
            fit::Value::Enum(1) => Ok(SwimStroke::Backstroke),
            fit::Value::Enum(2) => Ok(SwimStroke::Breaststroke),
            fit::Value::Enum(3) => Ok(SwimStroke::Butterfly),
            fit::Value::Enum(4) => Ok(SwimStroke::Drill),
            fit::Value::Enum(5) => Ok(SwimStroke::Mixed),
            fit::Value::Enum(6) => Ok(SwimStroke::Im),
            _ => Err("No corresponding SwimStroke exists"),
        }
    }
}
impl TryFrom<&str> for SwimStroke {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "freestyle" => Ok(SwimStroke::Freestyle),
            "backstroke" => Ok(SwimStroke::Backstroke),
            "breaststroke" => Ok(SwimStroke::Breaststroke),
            "butterfly" => Ok(SwimStroke::Butterfly),
            "drill" => Ok(SwimStroke::Drill),
            "mixed" => Ok(SwimStroke::Mixed),
            "im" => Ok(SwimStroke::Im),
            _ => Err("No corresponding SwimStroke exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ActivityType {
    Generic,
    Running,
    Cycling,
    /// Mulitsport transition
    Transition,
    FitnessEquipment,
    Swimming,
    Walking,
    Sedentary,
    /// All is for goals only to include all sports.
    All,
}
impl fmt::Display for ActivityType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ActivityType::Generic => f.write_str("generic"),
            ActivityType::Running => f.write_str("running"),
            ActivityType::Cycling => f.write_str("cycling"),
            ActivityType::Transition => f.write_str("transition"),
            ActivityType::FitnessEquipment => f.write_str("fitness_equipment"),
            ActivityType::Swimming => f.write_str("swimming"),
            ActivityType::Walking => f.write_str("walking"),
            ActivityType::Sedentary => f.write_str("sedentary"),
            ActivityType::All => f.write_str("all"),
        }
    }
}
impl ActivityType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ActivityType::Generic => fit::Value::Enum(0),
            ActivityType::Running => fit::Value::Enum(1),
            ActivityType::Cycling => fit::Value::Enum(2),
            ActivityType::Transition => fit::Value::Enum(3),
            ActivityType::FitnessEquipment => fit::Value::Enum(4),
            ActivityType::Swimming => fit::Value::Enum(5),
            ActivityType::Walking => fit::Value::Enum(6),
            ActivityType::Sedentary => fit::Value::Enum(8),
            ActivityType::All => fit::Value::Enum(254),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for ActivityType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(ActivityType::Generic),
            fit::Value::Enum(1) => Ok(ActivityType::Running),
            fit::Value::Enum(2) => Ok(ActivityType::Cycling),
            fit::Value::Enum(3) => Ok(ActivityType::Transition),
            fit::Value::Enum(4) => Ok(ActivityType::FitnessEquipment),
            fit::Value::Enum(5) => Ok(ActivityType::Swimming),
            fit::Value::Enum(6) => Ok(ActivityType::Walking),
            fit::Value::Enum(8) => Ok(ActivityType::Sedentary),
            fit::Value::Enum(254) => Ok(ActivityType::All),
            _ => Err("No corresponding ActivityType exists"),
        }
    }
}
impl TryFrom<&str> for ActivityType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "generic" => Ok(ActivityType::Generic),
            "running" => Ok(ActivityType::Running),
            "cycling" => Ok(ActivityType::Cycling),
            "transition" => Ok(ActivityType::Transition),
            "fitness_equipment" => Ok(ActivityType::FitnessEquipment),
            "swimming" => Ok(ActivityType::Swimming),
            "walking" => Ok(ActivityType::Walking),
            "sedentary" => Ok(ActivityType::Sedentary),
            "all" => Ok(ActivityType::All),
            _ => Err("No corresponding ActivityType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ActivitySubtype {
    Generic,
    /// Run
    Treadmill,
    /// Run
    Street,
    /// Run
    Trail,
    /// Run
    Track,
    /// Cycling
    Spin,
    /// Cycling
    IndoorCycling,
    /// Cycling
    Road,
    /// Cycling
    Mountain,
    /// Cycling
    Downhill,
    /// Cycling
    Recumbent,
    /// Cycling
    Cyclocross,
    /// Cycling
    HandCycling,
    /// Cycling
    TrackCycling,
    /// Fitness Equipment
    IndoorRowing,
    /// Fitness Equipment
    Elliptical,
    /// Fitness Equipment
    StairClimbing,
    /// Swimming
    LapSwimming,
    /// Swimming
    OpenWater,
    All,
}
impl fmt::Display for ActivitySubtype {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ActivitySubtype::Generic => f.write_str("generic"),
            ActivitySubtype::Treadmill => f.write_str("treadmill"),
            ActivitySubtype::Street => f.write_str("street"),
            ActivitySubtype::Trail => f.write_str("trail"),
            ActivitySubtype::Track => f.write_str("track"),
            ActivitySubtype::Spin => f.write_str("spin"),
            ActivitySubtype::IndoorCycling => f.write_str("indoor_cycling"),
            ActivitySubtype::Road => f.write_str("road"),
            ActivitySubtype::Mountain => f.write_str("mountain"),
            ActivitySubtype::Downhill => f.write_str("downhill"),
            ActivitySubtype::Recumbent => f.write_str("recumbent"),
            ActivitySubtype::Cyclocross => f.write_str("cyclocross"),
            ActivitySubtype::HandCycling => f.write_str("hand_cycling"),
            ActivitySubtype::TrackCycling => f.write_str("track_cycling"),
            ActivitySubtype::IndoorRowing => f.write_str("indoor_rowing"),
            ActivitySubtype::Elliptical => f.write_str("elliptical"),
            ActivitySubtype::StairClimbing => f.write_str("stair_climbing"),
            ActivitySubtype::LapSwimming => f.write_str("lap_swimming"),
            ActivitySubtype::OpenWater => f.write_str("open_water"),
            ActivitySubtype::All => f.write_str("all"),
        }
    }
}
impl ActivitySubtype {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ActivitySubtype::Generic => fit::Value::Enum(0),
            ActivitySubtype::Treadmill => fit::Value::Enum(1),
            ActivitySubtype::Street => fit::Value::Enum(2),
            ActivitySubtype::Trail => fit::Value::Enum(3),
            ActivitySubtype::Track => fit::Value::Enum(4),
            ActivitySubtype::Spin => fit::Value::Enum(5),
            ActivitySubtype::IndoorCycling => fit::Value::Enum(6),
            ActivitySubtype::Road => fit::Value::Enum(7),
            ActivitySubtype::Mountain => fit::Value::Enum(8),
            ActivitySubtype::Downhill => fit::Value::Enum(9),
            ActivitySubtype::Recumbent => fit::Value::Enum(10),
            ActivitySubtype::Cyclocross => fit::Value::Enum(11),
            ActivitySubtype::HandCycling => fit::Value::Enum(12),
            ActivitySubtype::TrackCycling => fit::Value::Enum(13),
            ActivitySubtype::IndoorRowing => fit::Value::Enum(14),
            ActivitySubtype::Elliptical => fit::Value::Enum(15),
            ActivitySubtype::StairClimbing => fit::Value::Enum(16),
            ActivitySubtype::LapSwimming => fit::Value::Enum(17),
            ActivitySubtype::OpenWater => fit::Value::Enum(18),
            ActivitySubtype::All => fit::Value::Enum(254),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for ActivitySubtype {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(ActivitySubtype::Generic),
            fit::Value::Enum(1) => Ok(ActivitySubtype::Treadmill),
            fit::Value::Enum(2) => Ok(ActivitySubtype::Street),
            fit::Value::Enum(3) => Ok(ActivitySubtype::Trail),
            fit::Value::Enum(4) => Ok(ActivitySubtype::Track),
            fit::Value::Enum(5) => Ok(ActivitySubtype::Spin),
            fit::Value::Enum(6) => Ok(ActivitySubtype::IndoorCycling),
            fit::Value::Enum(7) => Ok(ActivitySubtype::Road),
            fit::Value::Enum(8) => Ok(ActivitySubtype::Mountain),
            fit::Value::Enum(9) => Ok(ActivitySubtype::Downhill),
            fit::Value::Enum(10) => Ok(ActivitySubtype::Recumbent),
            fit::Value::Enum(11) => Ok(ActivitySubtype::Cyclocross),
            fit::Value::Enum(12) => Ok(ActivitySubtype::HandCycling),
            fit::Value::Enum(13) => Ok(ActivitySubtype::TrackCycling),
            fit::Value::Enum(14) => Ok(ActivitySubtype::IndoorRowing),
            fit::Value::Enum(15) => Ok(ActivitySubtype::Elliptical),
            fit::Value::Enum(16) => Ok(ActivitySubtype::StairClimbing),
            fit::Value::Enum(17) => Ok(ActivitySubtype::LapSwimming),
            fit::Value::Enum(18) => Ok(ActivitySubtype::OpenWater),
            fit::Value::Enum(254) => Ok(ActivitySubtype::All),
            _ => Err("No corresponding ActivitySubtype exists"),
        }
    }
}
impl TryFrom<&str> for ActivitySubtype {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "generic" => Ok(ActivitySubtype::Generic),
            "treadmill" => Ok(ActivitySubtype::Treadmill),
            "street" => Ok(ActivitySubtype::Street),
            "trail" => Ok(ActivitySubtype::Trail),
            "track" => Ok(ActivitySubtype::Track),
            "spin" => Ok(ActivitySubtype::Spin),
            "indoor_cycling" => Ok(ActivitySubtype::IndoorCycling),
            "road" => Ok(ActivitySubtype::Road),
            "mountain" => Ok(ActivitySubtype::Mountain),
            "downhill" => Ok(ActivitySubtype::Downhill),
            "recumbent" => Ok(ActivitySubtype::Recumbent),
            "cyclocross" => Ok(ActivitySubtype::Cyclocross),
            "hand_cycling" => Ok(ActivitySubtype::HandCycling),
            "track_cycling" => Ok(ActivitySubtype::TrackCycling),
            "indoor_rowing" => Ok(ActivitySubtype::IndoorRowing),
            "elliptical" => Ok(ActivitySubtype::Elliptical),
            "stair_climbing" => Ok(ActivitySubtype::StairClimbing),
            "lap_swimming" => Ok(ActivitySubtype::LapSwimming),
            "open_water" => Ok(ActivitySubtype::OpenWater),
            "all" => Ok(ActivitySubtype::All),
            _ => Err("No corresponding ActivitySubtype exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ActivityLevel {
    Low,
    Medium,
    High,
}
impl fmt::Display for ActivityLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ActivityLevel::Low => f.write_str("low"),
            ActivityLevel::Medium => f.write_str("medium"),
            ActivityLevel::High => f.write_str("high"),
        }
    }
}
impl ActivityLevel {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ActivityLevel::Low => fit::Value::Enum(0),
            ActivityLevel::Medium => fit::Value::Enum(1),
            ActivityLevel::High => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for ActivityLevel {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(ActivityLevel::Low),
            fit::Value::Enum(1) => Ok(ActivityLevel::Medium),
            fit::Value::Enum(2) => Ok(ActivityLevel::High),
            _ => Err("No corresponding ActivityLevel exists"),
        }
    }
}
impl TryFrom<&str> for ActivityLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "low" => Ok(ActivityLevel::Low),
            "medium" => Ok(ActivityLevel::Medium),
            "high" => Ok(ActivityLevel::High),
            _ => Err("No corresponding ActivityLevel exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Side {
    Right,
    Left,
}
impl fmt::Display for Side {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Side::Right => f.write_str("right"),
            Side::Left => f.write_str("left"),
        }
    }
}
impl Side {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Side::Right => fit::Value::Enum(0),
            Side::Left => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Side {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Side::Right),
            fit::Value::Enum(1) => Ok(Side::Left),
            _ => Err("No corresponding Side exists"),
        }
    }
}
impl TryFrom<&str> for Side {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "right" => Ok(Side::Right),
            "left" => Ok(Side::Left),
            _ => Err("No corresponding Side exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LeftRightBalance {
    /// % contribution
    Mask,
    /// data corresponds to right if set, otherwise unknown
    Right,
}
impl fmt::Display for LeftRightBalance {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LeftRightBalance::Mask => f.write_str("mask"),
            LeftRightBalance::Right => f.write_str("right"),
        }
    }
}
impl LeftRightBalance {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LeftRightBalance::Mask => fit::Value::UInt8(0x7F),
            LeftRightBalance::Right => fit::Value::UInt8(0x80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for LeftRightBalance {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(0x7F) => Ok(LeftRightBalance::Mask),
            fit::Value::UInt8(0x80) => Ok(LeftRightBalance::Right),
            _ => Err("No corresponding LeftRightBalance exists"),
        }
    }
}
impl TryFrom<&str> for LeftRightBalance {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "mask" => Ok(LeftRightBalance::Mask),
            "right" => Ok(LeftRightBalance::Right),
            _ => Err("No corresponding LeftRightBalance exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LeftRightBalance100 {
    /// % contribution scaled by 100
    Mask,
    /// data corresponds to right if set, otherwise unknown
    Right,
}
impl fmt::Display for LeftRightBalance100 {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LeftRightBalance100::Mask => f.write_str("mask"),
            LeftRightBalance100::Right => f.write_str("right"),
        }
    }
}
impl LeftRightBalance100 {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LeftRightBalance100::Mask => fit::Value::UInt16(0x3FFF),
            LeftRightBalance100::Right => fit::Value::UInt16(0x8000),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for LeftRightBalance100 {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0x3FFF) => Ok(LeftRightBalance100::Mask),
            fit::Value::UInt16(0x8000) => Ok(LeftRightBalance100::Right),
            _ => Err("No corresponding LeftRightBalance100 exists"),
        }
    }
}
impl TryFrom<&str> for LeftRightBalance100 {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "mask" => Ok(LeftRightBalance100::Mask),
            "right" => Ok(LeftRightBalance100::Right),
            _ => Err("No corresponding LeftRightBalance100 exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LengthType {
    /// Rest period. Length with no strokes
    Idle,
    /// Length with strokes.
    Active,
}
impl fmt::Display for LengthType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LengthType::Idle => f.write_str("idle"),
            LengthType::Active => f.write_str("active"),
        }
    }
}
impl LengthType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LengthType::Idle => fit::Value::Enum(0),
            LengthType::Active => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for LengthType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(LengthType::Idle),
            fit::Value::Enum(1) => Ok(LengthType::Active),
            _ => Err("No corresponding LengthType exists"),
        }
    }
}
impl TryFrom<&str> for LengthType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "idle" => Ok(LengthType::Idle),
            "active" => Ok(LengthType::Active),
            _ => Err("No corresponding LengthType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DayOfWeek {
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday,
}
impl fmt::Display for DayOfWeek {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DayOfWeek::Sunday => f.write_str("sunday"),
            DayOfWeek::Monday => f.write_str("monday"),
            DayOfWeek::Tuesday => f.write_str("tuesday"),
            DayOfWeek::Wednesday => f.write_str("wednesday"),
            DayOfWeek::Thursday => f.write_str("thursday"),
            DayOfWeek::Friday => f.write_str("friday"),
            DayOfWeek::Saturday => f.write_str("saturday"),
        }
    }
}
impl DayOfWeek {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DayOfWeek::Sunday => fit::Value::Enum(0),
            DayOfWeek::Monday => fit::Value::Enum(1),
            DayOfWeek::Tuesday => fit::Value::Enum(2),
            DayOfWeek::Wednesday => fit::Value::Enum(3),
            DayOfWeek::Thursday => fit::Value::Enum(4),
            DayOfWeek::Friday => fit::Value::Enum(5),
            DayOfWeek::Saturday => fit::Value::Enum(6),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DayOfWeek {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DayOfWeek::Sunday),
            fit::Value::Enum(1) => Ok(DayOfWeek::Monday),
            fit::Value::Enum(2) => Ok(DayOfWeek::Tuesday),
            fit::Value::Enum(3) => Ok(DayOfWeek::Wednesday),
            fit::Value::Enum(4) => Ok(DayOfWeek::Thursday),
            fit::Value::Enum(5) => Ok(DayOfWeek::Friday),
            fit::Value::Enum(6) => Ok(DayOfWeek::Saturday),
            _ => Err("No corresponding DayOfWeek exists"),
        }
    }
}
impl TryFrom<&str> for DayOfWeek {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "sunday" => Ok(DayOfWeek::Sunday),
            "monday" => Ok(DayOfWeek::Monday),
            "tuesday" => Ok(DayOfWeek::Tuesday),
            "wednesday" => Ok(DayOfWeek::Wednesday),
            "thursday" => Ok(DayOfWeek::Thursday),
            "friday" => Ok(DayOfWeek::Friday),
            "saturday" => Ok(DayOfWeek::Saturday),
            _ => Err("No corresponding DayOfWeek exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ConnectivityCapabilities {
    Bluetooth,
    BluetoothLe,
    Ant,
    ActivityUpload,
    CourseDownload,
    WorkoutDownload,
    LiveTrack,
    WeatherConditions,
    WeatherAlerts,
    GpsEphemerisDownload,
    ExplicitArchive,
    SetupIncomplete,
    ContinueSyncAfterSoftwareUpdate,
    ConnectIqAppDownload,
    GolfCourseDownload,
    /// Indicates device is in control of initiating all syncs
    DeviceInitiatesSync,
    ConnectIqWatchAppDownload,
    ConnectIqWidgetDownload,
    ConnectIqWatchFaceDownload,
    ConnectIqDataFieldDownload,
    /// Device supports delete and reorder of apps via GCM
    ConnectIqAppManagment,
    SwingSensor,
    SwingSensorRemote,
    /// Device supports incident detection
    IncidentDetection,
    AudioPrompts,
    /// Device supports reporting wifi verification via GCM
    WifiVerification,
    /// Device supports True Up
    TrueUp,
    /// Device supports Find My Watch
    FindMyWatch,
    RemoteManualSync,
    /// Device supports LiveTrack auto start
    LiveTrackAutoStart,
    /// Device supports LiveTrack Messaging
    LiveTrackMessaging,
    /// Device supports instant input feature
    InstantInput,
}
impl fmt::Display for ConnectivityCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ConnectivityCapabilities::Bluetooth => f.write_str("bluetooth"),
            ConnectivityCapabilities::BluetoothLe => f.write_str("bluetooth_le"),
            ConnectivityCapabilities::Ant => f.write_str("ant"),
            ConnectivityCapabilities::ActivityUpload => f.write_str("activity_upload"),
            ConnectivityCapabilities::CourseDownload => f.write_str("course_download"),
            ConnectivityCapabilities::WorkoutDownload => f.write_str("workout_download"),
            ConnectivityCapabilities::LiveTrack => f.write_str("live_track"),
            ConnectivityCapabilities::WeatherConditions => f.write_str("weather_conditions"),
            ConnectivityCapabilities::WeatherAlerts => f.write_str("weather_alerts"),
            ConnectivityCapabilities::GpsEphemerisDownload => f.write_str("gps_ephemeris_download"),
            ConnectivityCapabilities::ExplicitArchive => f.write_str("explicit_archive"),
            ConnectivityCapabilities::SetupIncomplete => f.write_str("setup_incomplete"),
            ConnectivityCapabilities::ContinueSyncAfterSoftwareUpdate => {
                f.write_str("continue_sync_after_software_update")
            }
            ConnectivityCapabilities::ConnectIqAppDownload => {
                f.write_str("connect_iq_app_download")
            }
            ConnectivityCapabilities::GolfCourseDownload => f.write_str("golf_course_download"),
            ConnectivityCapabilities::DeviceInitiatesSync => f.write_str("device_initiates_sync"),
            ConnectivityCapabilities::ConnectIqWatchAppDownload => {
                f.write_str("connect_iq_watch_app_download")
            }
            ConnectivityCapabilities::ConnectIqWidgetDownload => {
                f.write_str("connect_iq_widget_download")
            }
            ConnectivityCapabilities::ConnectIqWatchFaceDownload => {
                f.write_str("connect_iq_watch_face_download")
            }
            ConnectivityCapabilities::ConnectIqDataFieldDownload => {
                f.write_str("connect_iq_data_field_download")
            }
            ConnectivityCapabilities::ConnectIqAppManagment => {
                f.write_str("connect_iq_app_managment")
            }
            ConnectivityCapabilities::SwingSensor => f.write_str("swing_sensor"),
            ConnectivityCapabilities::SwingSensorRemote => f.write_str("swing_sensor_remote"),
            ConnectivityCapabilities::IncidentDetection => f.write_str("incident_detection"),
            ConnectivityCapabilities::AudioPrompts => f.write_str("audio_prompts"),
            ConnectivityCapabilities::WifiVerification => f.write_str("wifi_verification"),
            ConnectivityCapabilities::TrueUp => f.write_str("true_up"),
            ConnectivityCapabilities::FindMyWatch => f.write_str("find_my_watch"),
            ConnectivityCapabilities::RemoteManualSync => f.write_str("remote_manual_sync"),
            ConnectivityCapabilities::LiveTrackAutoStart => f.write_str("live_track_auto_start"),
            ConnectivityCapabilities::LiveTrackMessaging => f.write_str("live_track_messaging"),
            ConnectivityCapabilities::InstantInput => f.write_str("instant_input"),
        }
    }
}
impl ConnectivityCapabilities {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ConnectivityCapabilities::Bluetooth => fit::Value::UInt32z(0x00000001),
            ConnectivityCapabilities::BluetoothLe => fit::Value::UInt32z(0x00000002),
            ConnectivityCapabilities::Ant => fit::Value::UInt32z(0x00000004),
            ConnectivityCapabilities::ActivityUpload => fit::Value::UInt32z(0x00000008),
            ConnectivityCapabilities::CourseDownload => fit::Value::UInt32z(0x00000010),
            ConnectivityCapabilities::WorkoutDownload => fit::Value::UInt32z(0x00000020),
            ConnectivityCapabilities::LiveTrack => fit::Value::UInt32z(0x00000040),
            ConnectivityCapabilities::WeatherConditions => fit::Value::UInt32z(0x00000080),
            ConnectivityCapabilities::WeatherAlerts => fit::Value::UInt32z(0x00000100),
            ConnectivityCapabilities::GpsEphemerisDownload => fit::Value::UInt32z(0x00000200),
            ConnectivityCapabilities::ExplicitArchive => fit::Value::UInt32z(0x00000400),
            ConnectivityCapabilities::SetupIncomplete => fit::Value::UInt32z(0x00000800),
            ConnectivityCapabilities::ContinueSyncAfterSoftwareUpdate => {
                fit::Value::UInt32z(0x00001000)
            }
            ConnectivityCapabilities::ConnectIqAppDownload => fit::Value::UInt32z(0x00002000),
            ConnectivityCapabilities::GolfCourseDownload => fit::Value::UInt32z(0x00004000),
            ConnectivityCapabilities::DeviceInitiatesSync => fit::Value::UInt32z(0x00008000),
            ConnectivityCapabilities::ConnectIqWatchAppDownload => fit::Value::UInt32z(0x00010000),
            ConnectivityCapabilities::ConnectIqWidgetDownload => fit::Value::UInt32z(0x00020000),
            ConnectivityCapabilities::ConnectIqWatchFaceDownload => fit::Value::UInt32z(0x00040000),
            ConnectivityCapabilities::ConnectIqDataFieldDownload => fit::Value::UInt32z(0x00080000),
            ConnectivityCapabilities::ConnectIqAppManagment => fit::Value::UInt32z(0x00100000),
            ConnectivityCapabilities::SwingSensor => fit::Value::UInt32z(0x00200000),
            ConnectivityCapabilities::SwingSensorRemote => fit::Value::UInt32z(0x00400000),
            ConnectivityCapabilities::IncidentDetection => fit::Value::UInt32z(0x00800000),
            ConnectivityCapabilities::AudioPrompts => fit::Value::UInt32z(0x01000000),
            ConnectivityCapabilities::WifiVerification => fit::Value::UInt32z(0x02000000),
            ConnectivityCapabilities::TrueUp => fit::Value::UInt32z(0x04000000),
            ConnectivityCapabilities::FindMyWatch => fit::Value::UInt32z(0x08000000),
            ConnectivityCapabilities::RemoteManualSync => fit::Value::UInt32z(0x10000000),
            ConnectivityCapabilities::LiveTrackAutoStart => fit::Value::UInt32z(0x20000000),
            ConnectivityCapabilities::LiveTrackMessaging => fit::Value::UInt32z(0x40000000),
            ConnectivityCapabilities::InstantInput => fit::Value::UInt32z(0x80000000),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32z"
    }
}
impl TryFrom<&fit::Value> for ConnectivityCapabilities {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32z(0x00000001) => Ok(ConnectivityCapabilities::Bluetooth),
            fit::Value::UInt32z(0x00000002) => Ok(ConnectivityCapabilities::BluetoothLe),
            fit::Value::UInt32z(0x00000004) => Ok(ConnectivityCapabilities::Ant),
            fit::Value::UInt32z(0x00000008) => Ok(ConnectivityCapabilities::ActivityUpload),
            fit::Value::UInt32z(0x00000010) => Ok(ConnectivityCapabilities::CourseDownload),
            fit::Value::UInt32z(0x00000020) => Ok(ConnectivityCapabilities::WorkoutDownload),
            fit::Value::UInt32z(0x00000040) => Ok(ConnectivityCapabilities::LiveTrack),
            fit::Value::UInt32z(0x00000080) => Ok(ConnectivityCapabilities::WeatherConditions),
            fit::Value::UInt32z(0x00000100) => Ok(ConnectivityCapabilities::WeatherAlerts),
            fit::Value::UInt32z(0x00000200) => Ok(ConnectivityCapabilities::GpsEphemerisDownload),
            fit::Value::UInt32z(0x00000400) => Ok(ConnectivityCapabilities::ExplicitArchive),
            fit::Value::UInt32z(0x00000800) => Ok(ConnectivityCapabilities::SetupIncomplete),
            fit::Value::UInt32z(0x00001000) => {
                Ok(ConnectivityCapabilities::ContinueSyncAfterSoftwareUpdate)
            }
            fit::Value::UInt32z(0x00002000) => Ok(ConnectivityCapabilities::ConnectIqAppDownload),
            fit::Value::UInt32z(0x00004000) => Ok(ConnectivityCapabilities::GolfCourseDownload),
            fit::Value::UInt32z(0x00008000) => Ok(ConnectivityCapabilities::DeviceInitiatesSync),
            fit::Value::UInt32z(0x00010000) => {
                Ok(ConnectivityCapabilities::ConnectIqWatchAppDownload)
            }
            fit::Value::UInt32z(0x00020000) => {
                Ok(ConnectivityCapabilities::ConnectIqWidgetDownload)
            }
            fit::Value::UInt32z(0x00040000) => {
                Ok(ConnectivityCapabilities::ConnectIqWatchFaceDownload)
            }
            fit::Value::UInt32z(0x00080000) => {
                Ok(ConnectivityCapabilities::ConnectIqDataFieldDownload)
            }
            fit::Value::UInt32z(0x00100000) => Ok(ConnectivityCapabilities::ConnectIqAppManagment),
            fit::Value::UInt32z(0x00200000) => Ok(ConnectivityCapabilities::SwingSensor),
            fit::Value::UInt32z(0x00400000) => Ok(ConnectivityCapabilities::SwingSensorRemote),
            fit::Value::UInt32z(0x00800000) => Ok(ConnectivityCapabilities::IncidentDetection),
            fit::Value::UInt32z(0x01000000) => Ok(ConnectivityCapabilities::AudioPrompts),
            fit::Value::UInt32z(0x02000000) => Ok(ConnectivityCapabilities::WifiVerification),
            fit::Value::UInt32z(0x04000000) => Ok(ConnectivityCapabilities::TrueUp),
            fit::Value::UInt32z(0x08000000) => Ok(ConnectivityCapabilities::FindMyWatch),
            fit::Value::UInt32z(0x10000000) => Ok(ConnectivityCapabilities::RemoteManualSync),
            fit::Value::UInt32z(0x20000000) => Ok(ConnectivityCapabilities::LiveTrackAutoStart),
            fit::Value::UInt32z(0x40000000) => Ok(ConnectivityCapabilities::LiveTrackMessaging),
            fit::Value::UInt32z(0x80000000) => Ok(ConnectivityCapabilities::InstantInput),
            _ => Err("No corresponding ConnectivityCapabilities exists"),
        }
    }
}
impl TryFrom<&str> for ConnectivityCapabilities {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "bluetooth" => Ok(ConnectivityCapabilities::Bluetooth),
            "bluetooth_le" => Ok(ConnectivityCapabilities::BluetoothLe),
            "ant" => Ok(ConnectivityCapabilities::Ant),
            "activity_upload" => Ok(ConnectivityCapabilities::ActivityUpload),
            "course_download" => Ok(ConnectivityCapabilities::CourseDownload),
            "workout_download" => Ok(ConnectivityCapabilities::WorkoutDownload),
            "live_track" => Ok(ConnectivityCapabilities::LiveTrack),
            "weather_conditions" => Ok(ConnectivityCapabilities::WeatherConditions),
            "weather_alerts" => Ok(ConnectivityCapabilities::WeatherAlerts),
            "gps_ephemeris_download" => Ok(ConnectivityCapabilities::GpsEphemerisDownload),
            "explicit_archive" => Ok(ConnectivityCapabilities::ExplicitArchive),
            "setup_incomplete" => Ok(ConnectivityCapabilities::SetupIncomplete),
            "continue_sync_after_software_update" => {
                Ok(ConnectivityCapabilities::ContinueSyncAfterSoftwareUpdate)
            }
            "connect_iq_app_download" => Ok(ConnectivityCapabilities::ConnectIqAppDownload),
            "golf_course_download" => Ok(ConnectivityCapabilities::GolfCourseDownload),
            "device_initiates_sync" => Ok(ConnectivityCapabilities::DeviceInitiatesSync),
            "connect_iq_watch_app_download" => {
                Ok(ConnectivityCapabilities::ConnectIqWatchAppDownload)
            }
            "connect_iq_widget_download" => Ok(ConnectivityCapabilities::ConnectIqWidgetDownload),
            "connect_iq_watch_face_download" => {
                Ok(ConnectivityCapabilities::ConnectIqWatchFaceDownload)
            }
            "connect_iq_data_field_download" => {
                Ok(ConnectivityCapabilities::ConnectIqDataFieldDownload)
            }
            "connect_iq_app_managment" => Ok(ConnectivityCapabilities::ConnectIqAppManagment),
            "swing_sensor" => Ok(ConnectivityCapabilities::SwingSensor),
            "swing_sensor_remote" => Ok(ConnectivityCapabilities::SwingSensorRemote),
            "incident_detection" => Ok(ConnectivityCapabilities::IncidentDetection),
            "audio_prompts" => Ok(ConnectivityCapabilities::AudioPrompts),
            "wifi_verification" => Ok(ConnectivityCapabilities::WifiVerification),
            "true_up" => Ok(ConnectivityCapabilities::TrueUp),
            "find_my_watch" => Ok(ConnectivityCapabilities::FindMyWatch),
            "remote_manual_sync" => Ok(ConnectivityCapabilities::RemoteManualSync),
            "live_track_auto_start" => Ok(ConnectivityCapabilities::LiveTrackAutoStart),
            "live_track_messaging" => Ok(ConnectivityCapabilities::LiveTrackMessaging),
            "instant_input" => Ok(ConnectivityCapabilities::InstantInput),
            _ => Err("No corresponding ConnectivityCapabilities exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WeatherReport {
    Current,
    /// Deprecated use hourly_forecast instead
    Forecast,
    HourlyForecast,
    DailyForecast,
}
impl fmt::Display for WeatherReport {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WeatherReport::Current => f.write_str("current"),
            WeatherReport::Forecast => f.write_str("forecast"),
            WeatherReport::HourlyForecast => f.write_str("hourly_forecast"),
            WeatherReport::DailyForecast => f.write_str("daily_forecast"),
        }
    }
}
impl WeatherReport {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WeatherReport::Current => fit::Value::Enum(0),
            WeatherReport::Forecast => fit::Value::Enum(1),
            WeatherReport::HourlyForecast => fit::Value::Enum(1),
            WeatherReport::DailyForecast => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for WeatherReport {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(WeatherReport::Current),
            fit::Value::Enum(1) => Ok(WeatherReport::Forecast),
            fit::Value::Enum(1) => Ok(WeatherReport::HourlyForecast),
            fit::Value::Enum(2) => Ok(WeatherReport::DailyForecast),
            _ => Err("No corresponding WeatherReport exists"),
        }
    }
}
impl TryFrom<&str> for WeatherReport {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "current" => Ok(WeatherReport::Current),
            "forecast" => Ok(WeatherReport::Forecast),
            "hourly_forecast" => Ok(WeatherReport::HourlyForecast),
            "daily_forecast" => Ok(WeatherReport::DailyForecast),
            _ => Err("No corresponding WeatherReport exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WeatherStatus {
    Clear,
    PartlyCloudy,
    MostlyCloudy,
    Rain,
    Snow,
    Windy,
    Thunderstorms,
    WintryMix,
    Fog,
    Hazy,
    Hail,
    ScatteredShowers,
    ScatteredThunderstorms,
    UnknownPrecipitation,
    LightRain,
    HeavyRain,
    LightSnow,
    HeavySnow,
    LightRainSnow,
    HeavyRainSnow,
    Cloudy,
}
impl fmt::Display for WeatherStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WeatherStatus::Clear => f.write_str("clear"),
            WeatherStatus::PartlyCloudy => f.write_str("partly_cloudy"),
            WeatherStatus::MostlyCloudy => f.write_str("mostly_cloudy"),
            WeatherStatus::Rain => f.write_str("rain"),
            WeatherStatus::Snow => f.write_str("snow"),
            WeatherStatus::Windy => f.write_str("windy"),
            WeatherStatus::Thunderstorms => f.write_str("thunderstorms"),
            WeatherStatus::WintryMix => f.write_str("wintry_mix"),
            WeatherStatus::Fog => f.write_str("fog"),
            WeatherStatus::Hazy => f.write_str("hazy"),
            WeatherStatus::Hail => f.write_str("hail"),
            WeatherStatus::ScatteredShowers => f.write_str("scattered_showers"),
            WeatherStatus::ScatteredThunderstorms => f.write_str("scattered_thunderstorms"),
            WeatherStatus::UnknownPrecipitation => f.write_str("unknown_precipitation"),
            WeatherStatus::LightRain => f.write_str("light_rain"),
            WeatherStatus::HeavyRain => f.write_str("heavy_rain"),
            WeatherStatus::LightSnow => f.write_str("light_snow"),
            WeatherStatus::HeavySnow => f.write_str("heavy_snow"),
            WeatherStatus::LightRainSnow => f.write_str("light_rain_snow"),
            WeatherStatus::HeavyRainSnow => f.write_str("heavy_rain_snow"),
            WeatherStatus::Cloudy => f.write_str("cloudy"),
        }
    }
}
impl WeatherStatus {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WeatherStatus::Clear => fit::Value::Enum(0),
            WeatherStatus::PartlyCloudy => fit::Value::Enum(1),
            WeatherStatus::MostlyCloudy => fit::Value::Enum(2),
            WeatherStatus::Rain => fit::Value::Enum(3),
            WeatherStatus::Snow => fit::Value::Enum(4),
            WeatherStatus::Windy => fit::Value::Enum(5),
            WeatherStatus::Thunderstorms => fit::Value::Enum(6),
            WeatherStatus::WintryMix => fit::Value::Enum(7),
            WeatherStatus::Fog => fit::Value::Enum(8),
            WeatherStatus::Hazy => fit::Value::Enum(11),
            WeatherStatus::Hail => fit::Value::Enum(12),
            WeatherStatus::ScatteredShowers => fit::Value::Enum(13),
            WeatherStatus::ScatteredThunderstorms => fit::Value::Enum(14),
            WeatherStatus::UnknownPrecipitation => fit::Value::Enum(15),
            WeatherStatus::LightRain => fit::Value::Enum(16),
            WeatherStatus::HeavyRain => fit::Value::Enum(17),
            WeatherStatus::LightSnow => fit::Value::Enum(18),
            WeatherStatus::HeavySnow => fit::Value::Enum(19),
            WeatherStatus::LightRainSnow => fit::Value::Enum(20),
            WeatherStatus::HeavyRainSnow => fit::Value::Enum(21),
            WeatherStatus::Cloudy => fit::Value::Enum(22),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for WeatherStatus {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(WeatherStatus::Clear),
            fit::Value::Enum(1) => Ok(WeatherStatus::PartlyCloudy),
            fit::Value::Enum(2) => Ok(WeatherStatus::MostlyCloudy),
            fit::Value::Enum(3) => Ok(WeatherStatus::Rain),
            fit::Value::Enum(4) => Ok(WeatherStatus::Snow),
            fit::Value::Enum(5) => Ok(WeatherStatus::Windy),
            fit::Value::Enum(6) => Ok(WeatherStatus::Thunderstorms),
            fit::Value::Enum(7) => Ok(WeatherStatus::WintryMix),
            fit::Value::Enum(8) => Ok(WeatherStatus::Fog),
            fit::Value::Enum(11) => Ok(WeatherStatus::Hazy),
            fit::Value::Enum(12) => Ok(WeatherStatus::Hail),
            fit::Value::Enum(13) => Ok(WeatherStatus::ScatteredShowers),
            fit::Value::Enum(14) => Ok(WeatherStatus::ScatteredThunderstorms),
            fit::Value::Enum(15) => Ok(WeatherStatus::UnknownPrecipitation),
            fit::Value::Enum(16) => Ok(WeatherStatus::LightRain),
            fit::Value::Enum(17) => Ok(WeatherStatus::HeavyRain),
            fit::Value::Enum(18) => Ok(WeatherStatus::LightSnow),
            fit::Value::Enum(19) => Ok(WeatherStatus::HeavySnow),
            fit::Value::Enum(20) => Ok(WeatherStatus::LightRainSnow),
            fit::Value::Enum(21) => Ok(WeatherStatus::HeavyRainSnow),
            fit::Value::Enum(22) => Ok(WeatherStatus::Cloudy),
            _ => Err("No corresponding WeatherStatus exists"),
        }
    }
}
impl TryFrom<&str> for WeatherStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "clear" => Ok(WeatherStatus::Clear),
            "partly_cloudy" => Ok(WeatherStatus::PartlyCloudy),
            "mostly_cloudy" => Ok(WeatherStatus::MostlyCloudy),
            "rain" => Ok(WeatherStatus::Rain),
            "snow" => Ok(WeatherStatus::Snow),
            "windy" => Ok(WeatherStatus::Windy),
            "thunderstorms" => Ok(WeatherStatus::Thunderstorms),
            "wintry_mix" => Ok(WeatherStatus::WintryMix),
            "fog" => Ok(WeatherStatus::Fog),
            "hazy" => Ok(WeatherStatus::Hazy),
            "hail" => Ok(WeatherStatus::Hail),
            "scattered_showers" => Ok(WeatherStatus::ScatteredShowers),
            "scattered_thunderstorms" => Ok(WeatherStatus::ScatteredThunderstorms),
            "unknown_precipitation" => Ok(WeatherStatus::UnknownPrecipitation),
            "light_rain" => Ok(WeatherStatus::LightRain),
            "heavy_rain" => Ok(WeatherStatus::HeavyRain),
            "light_snow" => Ok(WeatherStatus::LightSnow),
            "heavy_snow" => Ok(WeatherStatus::HeavySnow),
            "light_rain_snow" => Ok(WeatherStatus::LightRainSnow),
            "heavy_rain_snow" => Ok(WeatherStatus::HeavyRainSnow),
            "cloudy" => Ok(WeatherStatus::Cloudy),
            _ => Err("No corresponding WeatherStatus exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WeatherSeverity {
    Unknown,
    Warning,
    Watch,
    Advisory,
    Statement,
}
impl fmt::Display for WeatherSeverity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WeatherSeverity::Unknown => f.write_str("unknown"),
            WeatherSeverity::Warning => f.write_str("warning"),
            WeatherSeverity::Watch => f.write_str("watch"),
            WeatherSeverity::Advisory => f.write_str("advisory"),
            WeatherSeverity::Statement => f.write_str("statement"),
        }
    }
}
impl WeatherSeverity {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WeatherSeverity::Unknown => fit::Value::Enum(0),
            WeatherSeverity::Warning => fit::Value::Enum(1),
            WeatherSeverity::Watch => fit::Value::Enum(2),
            WeatherSeverity::Advisory => fit::Value::Enum(3),
            WeatherSeverity::Statement => fit::Value::Enum(4),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for WeatherSeverity {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(WeatherSeverity::Unknown),
            fit::Value::Enum(1) => Ok(WeatherSeverity::Warning),
            fit::Value::Enum(2) => Ok(WeatherSeverity::Watch),
            fit::Value::Enum(3) => Ok(WeatherSeverity::Advisory),
            fit::Value::Enum(4) => Ok(WeatherSeverity::Statement),
            _ => Err("No corresponding WeatherSeverity exists"),
        }
    }
}
impl TryFrom<&str> for WeatherSeverity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "unknown" => Ok(WeatherSeverity::Unknown),
            "warning" => Ok(WeatherSeverity::Warning),
            "watch" => Ok(WeatherSeverity::Watch),
            "advisory" => Ok(WeatherSeverity::Advisory),
            "statement" => Ok(WeatherSeverity::Statement),
            _ => Err("No corresponding WeatherSeverity exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WeatherSevereType {
    Unspecified,
    Tornado,
    Tsunami,
    Hurricane,
    ExtremeWind,
    Typhoon,
    InlandHurricane,
    HurricaneForceWind,
    Waterspout,
    SevereThunderstorm,
    WreckhouseWinds,
    LesSuetesWind,
    Avalanche,
    FlashFlood,
    TropicalStorm,
    InlandTropicalStorm,
    Blizzard,
    IceStorm,
    FreezingRain,
    DebrisFlow,
    FlashFreeze,
    DustStorm,
    HighWind,
    WinterStorm,
    HeavyFreezingSpray,
    ExtremeCold,
    WindChill,
    ColdWave,
    HeavySnowAlert,
    LakeEffectBlowingSnow,
    SnowSquall,
    LakeEffectSnow,
    WinterWeather,
    Sleet,
    Snowfall,
    SnowAndBlowingSnow,
    BlowingSnow,
    SnowAlert,
    ArcticOutflow,
    FreezingDrizzle,
    Storm,
    StormSurge,
    Rainfall,
    ArealFlood,
    CoastalFlood,
    LakeshoreFlood,
    ExcessiveHeat,
    Heat,
    Weather,
    HighHeatAndHumidity,
    HumidexAndHealth,
    Humidex,
    Gale,
    FreezingSpray,
    SpecialMarine,
    Squall,
    StrongWind,
    LakeWind,
    MarineWeather,
    Wind,
    SmallCraftHazardousSeas,
    HazardousSeas,
    SmallCraft,
    SmallCraftWinds,
    SmallCraftRoughBar,
    HighWaterLevel,
    Ashfall,
    FreezingFog,
    DenseFog,
    DenseSmoke,
    BlowingDust,
    HardFreeze,
    Freeze,
    Frost,
    FireWeather,
    Flood,
    RipTide,
    HighSurf,
    Smog,
    AirQuality,
    BriskWind,
    AirStagnation,
    LowWater,
    Hydrological,
    SpecialWeather,
}
impl fmt::Display for WeatherSevereType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WeatherSevereType::Unspecified => f.write_str("unspecified"),
            WeatherSevereType::Tornado => f.write_str("tornado"),
            WeatherSevereType::Tsunami => f.write_str("tsunami"),
            WeatherSevereType::Hurricane => f.write_str("hurricane"),
            WeatherSevereType::ExtremeWind => f.write_str("extreme_wind"),
            WeatherSevereType::Typhoon => f.write_str("typhoon"),
            WeatherSevereType::InlandHurricane => f.write_str("inland_hurricane"),
            WeatherSevereType::HurricaneForceWind => f.write_str("hurricane_force_wind"),
            WeatherSevereType::Waterspout => f.write_str("waterspout"),
            WeatherSevereType::SevereThunderstorm => f.write_str("severe_thunderstorm"),
            WeatherSevereType::WreckhouseWinds => f.write_str("wreckhouse_winds"),
            WeatherSevereType::LesSuetesWind => f.write_str("les_suetes_wind"),
            WeatherSevereType::Avalanche => f.write_str("avalanche"),
            WeatherSevereType::FlashFlood => f.write_str("flash_flood"),
            WeatherSevereType::TropicalStorm => f.write_str("tropical_storm"),
            WeatherSevereType::InlandTropicalStorm => f.write_str("inland_tropical_storm"),
            WeatherSevereType::Blizzard => f.write_str("blizzard"),
            WeatherSevereType::IceStorm => f.write_str("ice_storm"),
            WeatherSevereType::FreezingRain => f.write_str("freezing_rain"),
            WeatherSevereType::DebrisFlow => f.write_str("debris_flow"),
            WeatherSevereType::FlashFreeze => f.write_str("flash_freeze"),
            WeatherSevereType::DustStorm => f.write_str("dust_storm"),
            WeatherSevereType::HighWind => f.write_str("high_wind"),
            WeatherSevereType::WinterStorm => f.write_str("winter_storm"),
            WeatherSevereType::HeavyFreezingSpray => f.write_str("heavy_freezing_spray"),
            WeatherSevereType::ExtremeCold => f.write_str("extreme_cold"),
            WeatherSevereType::WindChill => f.write_str("wind_chill"),
            WeatherSevereType::ColdWave => f.write_str("cold_wave"),
            WeatherSevereType::HeavySnowAlert => f.write_str("heavy_snow_alert"),
            WeatherSevereType::LakeEffectBlowingSnow => f.write_str("lake_effect_blowing_snow"),
            WeatherSevereType::SnowSquall => f.write_str("snow_squall"),
            WeatherSevereType::LakeEffectSnow => f.write_str("lake_effect_snow"),
            WeatherSevereType::WinterWeather => f.write_str("winter_weather"),
            WeatherSevereType::Sleet => f.write_str("sleet"),
            WeatherSevereType::Snowfall => f.write_str("snowfall"),
            WeatherSevereType::SnowAndBlowingSnow => f.write_str("snow_and_blowing_snow"),
            WeatherSevereType::BlowingSnow => f.write_str("blowing_snow"),
            WeatherSevereType::SnowAlert => f.write_str("snow_alert"),
            WeatherSevereType::ArcticOutflow => f.write_str("arctic_outflow"),
            WeatherSevereType::FreezingDrizzle => f.write_str("freezing_drizzle"),
            WeatherSevereType::Storm => f.write_str("storm"),
            WeatherSevereType::StormSurge => f.write_str("storm_surge"),
            WeatherSevereType::Rainfall => f.write_str("rainfall"),
            WeatherSevereType::ArealFlood => f.write_str("areal_flood"),
            WeatherSevereType::CoastalFlood => f.write_str("coastal_flood"),
            WeatherSevereType::LakeshoreFlood => f.write_str("lakeshore_flood"),
            WeatherSevereType::ExcessiveHeat => f.write_str("excessive_heat"),
            WeatherSevereType::Heat => f.write_str("heat"),
            WeatherSevereType::Weather => f.write_str("weather"),
            WeatherSevereType::HighHeatAndHumidity => f.write_str("high_heat_and_humidity"),
            WeatherSevereType::HumidexAndHealth => f.write_str("humidex_and_health"),
            WeatherSevereType::Humidex => f.write_str("humidex"),
            WeatherSevereType::Gale => f.write_str("gale"),
            WeatherSevereType::FreezingSpray => f.write_str("freezing_spray"),
            WeatherSevereType::SpecialMarine => f.write_str("special_marine"),
            WeatherSevereType::Squall => f.write_str("squall"),
            WeatherSevereType::StrongWind => f.write_str("strong_wind"),
            WeatherSevereType::LakeWind => f.write_str("lake_wind"),
            WeatherSevereType::MarineWeather => f.write_str("marine_weather"),
            WeatherSevereType::Wind => f.write_str("wind"),
            WeatherSevereType::SmallCraftHazardousSeas => f.write_str("small_craft_hazardous_seas"),
            WeatherSevereType::HazardousSeas => f.write_str("hazardous_seas"),
            WeatherSevereType::SmallCraft => f.write_str("small_craft"),
            WeatherSevereType::SmallCraftWinds => f.write_str("small_craft_winds"),
            WeatherSevereType::SmallCraftRoughBar => f.write_str("small_craft_rough_bar"),
            WeatherSevereType::HighWaterLevel => f.write_str("high_water_level"),
            WeatherSevereType::Ashfall => f.write_str("ashfall"),
            WeatherSevereType::FreezingFog => f.write_str("freezing_fog"),
            WeatherSevereType::DenseFog => f.write_str("dense_fog"),
            WeatherSevereType::DenseSmoke => f.write_str("dense_smoke"),
            WeatherSevereType::BlowingDust => f.write_str("blowing_dust"),
            WeatherSevereType::HardFreeze => f.write_str("hard_freeze"),
            WeatherSevereType::Freeze => f.write_str("freeze"),
            WeatherSevereType::Frost => f.write_str("frost"),
            WeatherSevereType::FireWeather => f.write_str("fire_weather"),
            WeatherSevereType::Flood => f.write_str("flood"),
            WeatherSevereType::RipTide => f.write_str("rip_tide"),
            WeatherSevereType::HighSurf => f.write_str("high_surf"),
            WeatherSevereType::Smog => f.write_str("smog"),
            WeatherSevereType::AirQuality => f.write_str("air_quality"),
            WeatherSevereType::BriskWind => f.write_str("brisk_wind"),
            WeatherSevereType::AirStagnation => f.write_str("air_stagnation"),
            WeatherSevereType::LowWater => f.write_str("low_water"),
            WeatherSevereType::Hydrological => f.write_str("hydrological"),
            WeatherSevereType::SpecialWeather => f.write_str("special_weather"),
        }
    }
}
impl WeatherSevereType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WeatherSevereType::Unspecified => fit::Value::Enum(0),
            WeatherSevereType::Tornado => fit::Value::Enum(1),
            WeatherSevereType::Tsunami => fit::Value::Enum(2),
            WeatherSevereType::Hurricane => fit::Value::Enum(3),
            WeatherSevereType::ExtremeWind => fit::Value::Enum(4),
            WeatherSevereType::Typhoon => fit::Value::Enum(5),
            WeatherSevereType::InlandHurricane => fit::Value::Enum(6),
            WeatherSevereType::HurricaneForceWind => fit::Value::Enum(7),
            WeatherSevereType::Waterspout => fit::Value::Enum(8),
            WeatherSevereType::SevereThunderstorm => fit::Value::Enum(9),
            WeatherSevereType::WreckhouseWinds => fit::Value::Enum(10),
            WeatherSevereType::LesSuetesWind => fit::Value::Enum(11),
            WeatherSevereType::Avalanche => fit::Value::Enum(12),
            WeatherSevereType::FlashFlood => fit::Value::Enum(13),
            WeatherSevereType::TropicalStorm => fit::Value::Enum(14),
            WeatherSevereType::InlandTropicalStorm => fit::Value::Enum(15),
            WeatherSevereType::Blizzard => fit::Value::Enum(16),
            WeatherSevereType::IceStorm => fit::Value::Enum(17),
            WeatherSevereType::FreezingRain => fit::Value::Enum(18),
            WeatherSevereType::DebrisFlow => fit::Value::Enum(19),
            WeatherSevereType::FlashFreeze => fit::Value::Enum(20),
            WeatherSevereType::DustStorm => fit::Value::Enum(21),
            WeatherSevereType::HighWind => fit::Value::Enum(22),
            WeatherSevereType::WinterStorm => fit::Value::Enum(23),
            WeatherSevereType::HeavyFreezingSpray => fit::Value::Enum(24),
            WeatherSevereType::ExtremeCold => fit::Value::Enum(25),
            WeatherSevereType::WindChill => fit::Value::Enum(26),
            WeatherSevereType::ColdWave => fit::Value::Enum(27),
            WeatherSevereType::HeavySnowAlert => fit::Value::Enum(28),
            WeatherSevereType::LakeEffectBlowingSnow => fit::Value::Enum(29),
            WeatherSevereType::SnowSquall => fit::Value::Enum(30),
            WeatherSevereType::LakeEffectSnow => fit::Value::Enum(31),
            WeatherSevereType::WinterWeather => fit::Value::Enum(32),
            WeatherSevereType::Sleet => fit::Value::Enum(33),
            WeatherSevereType::Snowfall => fit::Value::Enum(34),
            WeatherSevereType::SnowAndBlowingSnow => fit::Value::Enum(35),
            WeatherSevereType::BlowingSnow => fit::Value::Enum(36),
            WeatherSevereType::SnowAlert => fit::Value::Enum(37),
            WeatherSevereType::ArcticOutflow => fit::Value::Enum(38),
            WeatherSevereType::FreezingDrizzle => fit::Value::Enum(39),
            WeatherSevereType::Storm => fit::Value::Enum(40),
            WeatherSevereType::StormSurge => fit::Value::Enum(41),
            WeatherSevereType::Rainfall => fit::Value::Enum(42),
            WeatherSevereType::ArealFlood => fit::Value::Enum(43),
            WeatherSevereType::CoastalFlood => fit::Value::Enum(44),
            WeatherSevereType::LakeshoreFlood => fit::Value::Enum(45),
            WeatherSevereType::ExcessiveHeat => fit::Value::Enum(46),
            WeatherSevereType::Heat => fit::Value::Enum(47),
            WeatherSevereType::Weather => fit::Value::Enum(48),
            WeatherSevereType::HighHeatAndHumidity => fit::Value::Enum(49),
            WeatherSevereType::HumidexAndHealth => fit::Value::Enum(50),
            WeatherSevereType::Humidex => fit::Value::Enum(51),
            WeatherSevereType::Gale => fit::Value::Enum(52),
            WeatherSevereType::FreezingSpray => fit::Value::Enum(53),
            WeatherSevereType::SpecialMarine => fit::Value::Enum(54),
            WeatherSevereType::Squall => fit::Value::Enum(55),
            WeatherSevereType::StrongWind => fit::Value::Enum(56),
            WeatherSevereType::LakeWind => fit::Value::Enum(57),
            WeatherSevereType::MarineWeather => fit::Value::Enum(58),
            WeatherSevereType::Wind => fit::Value::Enum(59),
            WeatherSevereType::SmallCraftHazardousSeas => fit::Value::Enum(60),
            WeatherSevereType::HazardousSeas => fit::Value::Enum(61),
            WeatherSevereType::SmallCraft => fit::Value::Enum(62),
            WeatherSevereType::SmallCraftWinds => fit::Value::Enum(63),
            WeatherSevereType::SmallCraftRoughBar => fit::Value::Enum(64),
            WeatherSevereType::HighWaterLevel => fit::Value::Enum(65),
            WeatherSevereType::Ashfall => fit::Value::Enum(66),
            WeatherSevereType::FreezingFog => fit::Value::Enum(67),
            WeatherSevereType::DenseFog => fit::Value::Enum(68),
            WeatherSevereType::DenseSmoke => fit::Value::Enum(69),
            WeatherSevereType::BlowingDust => fit::Value::Enum(70),
            WeatherSevereType::HardFreeze => fit::Value::Enum(71),
            WeatherSevereType::Freeze => fit::Value::Enum(72),
            WeatherSevereType::Frost => fit::Value::Enum(73),
            WeatherSevereType::FireWeather => fit::Value::Enum(74),
            WeatherSevereType::Flood => fit::Value::Enum(75),
            WeatherSevereType::RipTide => fit::Value::Enum(76),
            WeatherSevereType::HighSurf => fit::Value::Enum(77),
            WeatherSevereType::Smog => fit::Value::Enum(78),
            WeatherSevereType::AirQuality => fit::Value::Enum(79),
            WeatherSevereType::BriskWind => fit::Value::Enum(80),
            WeatherSevereType::AirStagnation => fit::Value::Enum(81),
            WeatherSevereType::LowWater => fit::Value::Enum(82),
            WeatherSevereType::Hydrological => fit::Value::Enum(83),
            WeatherSevereType::SpecialWeather => fit::Value::Enum(84),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for WeatherSevereType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(WeatherSevereType::Unspecified),
            fit::Value::Enum(1) => Ok(WeatherSevereType::Tornado),
            fit::Value::Enum(2) => Ok(WeatherSevereType::Tsunami),
            fit::Value::Enum(3) => Ok(WeatherSevereType::Hurricane),
            fit::Value::Enum(4) => Ok(WeatherSevereType::ExtremeWind),
            fit::Value::Enum(5) => Ok(WeatherSevereType::Typhoon),
            fit::Value::Enum(6) => Ok(WeatherSevereType::InlandHurricane),
            fit::Value::Enum(7) => Ok(WeatherSevereType::HurricaneForceWind),
            fit::Value::Enum(8) => Ok(WeatherSevereType::Waterspout),
            fit::Value::Enum(9) => Ok(WeatherSevereType::SevereThunderstorm),
            fit::Value::Enum(10) => Ok(WeatherSevereType::WreckhouseWinds),
            fit::Value::Enum(11) => Ok(WeatherSevereType::LesSuetesWind),
            fit::Value::Enum(12) => Ok(WeatherSevereType::Avalanche),
            fit::Value::Enum(13) => Ok(WeatherSevereType::FlashFlood),
            fit::Value::Enum(14) => Ok(WeatherSevereType::TropicalStorm),
            fit::Value::Enum(15) => Ok(WeatherSevereType::InlandTropicalStorm),
            fit::Value::Enum(16) => Ok(WeatherSevereType::Blizzard),
            fit::Value::Enum(17) => Ok(WeatherSevereType::IceStorm),
            fit::Value::Enum(18) => Ok(WeatherSevereType::FreezingRain),
            fit::Value::Enum(19) => Ok(WeatherSevereType::DebrisFlow),
            fit::Value::Enum(20) => Ok(WeatherSevereType::FlashFreeze),
            fit::Value::Enum(21) => Ok(WeatherSevereType::DustStorm),
            fit::Value::Enum(22) => Ok(WeatherSevereType::HighWind),
            fit::Value::Enum(23) => Ok(WeatherSevereType::WinterStorm),
            fit::Value::Enum(24) => Ok(WeatherSevereType::HeavyFreezingSpray),
            fit::Value::Enum(25) => Ok(WeatherSevereType::ExtremeCold),
            fit::Value::Enum(26) => Ok(WeatherSevereType::WindChill),
            fit::Value::Enum(27) => Ok(WeatherSevereType::ColdWave),
            fit::Value::Enum(28) => Ok(WeatherSevereType::HeavySnowAlert),
            fit::Value::Enum(29) => Ok(WeatherSevereType::LakeEffectBlowingSnow),
            fit::Value::Enum(30) => Ok(WeatherSevereType::SnowSquall),
            fit::Value::Enum(31) => Ok(WeatherSevereType::LakeEffectSnow),
            fit::Value::Enum(32) => Ok(WeatherSevereType::WinterWeather),
            fit::Value::Enum(33) => Ok(WeatherSevereType::Sleet),
            fit::Value::Enum(34) => Ok(WeatherSevereType::Snowfall),
            fit::Value::Enum(35) => Ok(WeatherSevereType::SnowAndBlowingSnow),
            fit::Value::Enum(36) => Ok(WeatherSevereType::BlowingSnow),
            fit::Value::Enum(37) => Ok(WeatherSevereType::SnowAlert),
            fit::Value::Enum(38) => Ok(WeatherSevereType::ArcticOutflow),
            fit::Value::Enum(39) => Ok(WeatherSevereType::FreezingDrizzle),
            fit::Value::Enum(40) => Ok(WeatherSevereType::Storm),
            fit::Value::Enum(41) => Ok(WeatherSevereType::StormSurge),
            fit::Value::Enum(42) => Ok(WeatherSevereType::Rainfall),
            fit::Value::Enum(43) => Ok(WeatherSevereType::ArealFlood),
            fit::Value::Enum(44) => Ok(WeatherSevereType::CoastalFlood),
            fit::Value::Enum(45) => Ok(WeatherSevereType::LakeshoreFlood),
            fit::Value::Enum(46) => Ok(WeatherSevereType::ExcessiveHeat),
            fit::Value::Enum(47) => Ok(WeatherSevereType::Heat),
            fit::Value::Enum(48) => Ok(WeatherSevereType::Weather),
            fit::Value::Enum(49) => Ok(WeatherSevereType::HighHeatAndHumidity),
            fit::Value::Enum(50) => Ok(WeatherSevereType::HumidexAndHealth),
            fit::Value::Enum(51) => Ok(WeatherSevereType::Humidex),
            fit::Value::Enum(52) => Ok(WeatherSevereType::Gale),
            fit::Value::Enum(53) => Ok(WeatherSevereType::FreezingSpray),
            fit::Value::Enum(54) => Ok(WeatherSevereType::SpecialMarine),
            fit::Value::Enum(55) => Ok(WeatherSevereType::Squall),
            fit::Value::Enum(56) => Ok(WeatherSevereType::StrongWind),
            fit::Value::Enum(57) => Ok(WeatherSevereType::LakeWind),
            fit::Value::Enum(58) => Ok(WeatherSevereType::MarineWeather),
            fit::Value::Enum(59) => Ok(WeatherSevereType::Wind),
            fit::Value::Enum(60) => Ok(WeatherSevereType::SmallCraftHazardousSeas),
            fit::Value::Enum(61) => Ok(WeatherSevereType::HazardousSeas),
            fit::Value::Enum(62) => Ok(WeatherSevereType::SmallCraft),
            fit::Value::Enum(63) => Ok(WeatherSevereType::SmallCraftWinds),
            fit::Value::Enum(64) => Ok(WeatherSevereType::SmallCraftRoughBar),
            fit::Value::Enum(65) => Ok(WeatherSevereType::HighWaterLevel),
            fit::Value::Enum(66) => Ok(WeatherSevereType::Ashfall),
            fit::Value::Enum(67) => Ok(WeatherSevereType::FreezingFog),
            fit::Value::Enum(68) => Ok(WeatherSevereType::DenseFog),
            fit::Value::Enum(69) => Ok(WeatherSevereType::DenseSmoke),
            fit::Value::Enum(70) => Ok(WeatherSevereType::BlowingDust),
            fit::Value::Enum(71) => Ok(WeatherSevereType::HardFreeze),
            fit::Value::Enum(72) => Ok(WeatherSevereType::Freeze),
            fit::Value::Enum(73) => Ok(WeatherSevereType::Frost),
            fit::Value::Enum(74) => Ok(WeatherSevereType::FireWeather),
            fit::Value::Enum(75) => Ok(WeatherSevereType::Flood),
            fit::Value::Enum(76) => Ok(WeatherSevereType::RipTide),
            fit::Value::Enum(77) => Ok(WeatherSevereType::HighSurf),
            fit::Value::Enum(78) => Ok(WeatherSevereType::Smog),
            fit::Value::Enum(79) => Ok(WeatherSevereType::AirQuality),
            fit::Value::Enum(80) => Ok(WeatherSevereType::BriskWind),
            fit::Value::Enum(81) => Ok(WeatherSevereType::AirStagnation),
            fit::Value::Enum(82) => Ok(WeatherSevereType::LowWater),
            fit::Value::Enum(83) => Ok(WeatherSevereType::Hydrological),
            fit::Value::Enum(84) => Ok(WeatherSevereType::SpecialWeather),
            _ => Err("No corresponding WeatherSevereType exists"),
        }
    }
}
impl TryFrom<&str> for WeatherSevereType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "unspecified" => Ok(WeatherSevereType::Unspecified),
            "tornado" => Ok(WeatherSevereType::Tornado),
            "tsunami" => Ok(WeatherSevereType::Tsunami),
            "hurricane" => Ok(WeatherSevereType::Hurricane),
            "extreme_wind" => Ok(WeatherSevereType::ExtremeWind),
            "typhoon" => Ok(WeatherSevereType::Typhoon),
            "inland_hurricane" => Ok(WeatherSevereType::InlandHurricane),
            "hurricane_force_wind" => Ok(WeatherSevereType::HurricaneForceWind),
            "waterspout" => Ok(WeatherSevereType::Waterspout),
            "severe_thunderstorm" => Ok(WeatherSevereType::SevereThunderstorm),
            "wreckhouse_winds" => Ok(WeatherSevereType::WreckhouseWinds),
            "les_suetes_wind" => Ok(WeatherSevereType::LesSuetesWind),
            "avalanche" => Ok(WeatherSevereType::Avalanche),
            "flash_flood" => Ok(WeatherSevereType::FlashFlood),
            "tropical_storm" => Ok(WeatherSevereType::TropicalStorm),
            "inland_tropical_storm" => Ok(WeatherSevereType::InlandTropicalStorm),
            "blizzard" => Ok(WeatherSevereType::Blizzard),
            "ice_storm" => Ok(WeatherSevereType::IceStorm),
            "freezing_rain" => Ok(WeatherSevereType::FreezingRain),
            "debris_flow" => Ok(WeatherSevereType::DebrisFlow),
            "flash_freeze" => Ok(WeatherSevereType::FlashFreeze),
            "dust_storm" => Ok(WeatherSevereType::DustStorm),
            "high_wind" => Ok(WeatherSevereType::HighWind),
            "winter_storm" => Ok(WeatherSevereType::WinterStorm),
            "heavy_freezing_spray" => Ok(WeatherSevereType::HeavyFreezingSpray),
            "extreme_cold" => Ok(WeatherSevereType::ExtremeCold),
            "wind_chill" => Ok(WeatherSevereType::WindChill),
            "cold_wave" => Ok(WeatherSevereType::ColdWave),
            "heavy_snow_alert" => Ok(WeatherSevereType::HeavySnowAlert),
            "lake_effect_blowing_snow" => Ok(WeatherSevereType::LakeEffectBlowingSnow),
            "snow_squall" => Ok(WeatherSevereType::SnowSquall),
            "lake_effect_snow" => Ok(WeatherSevereType::LakeEffectSnow),
            "winter_weather" => Ok(WeatherSevereType::WinterWeather),
            "sleet" => Ok(WeatherSevereType::Sleet),
            "snowfall" => Ok(WeatherSevereType::Snowfall),
            "snow_and_blowing_snow" => Ok(WeatherSevereType::SnowAndBlowingSnow),
            "blowing_snow" => Ok(WeatherSevereType::BlowingSnow),
            "snow_alert" => Ok(WeatherSevereType::SnowAlert),
            "arctic_outflow" => Ok(WeatherSevereType::ArcticOutflow),
            "freezing_drizzle" => Ok(WeatherSevereType::FreezingDrizzle),
            "storm" => Ok(WeatherSevereType::Storm),
            "storm_surge" => Ok(WeatherSevereType::StormSurge),
            "rainfall" => Ok(WeatherSevereType::Rainfall),
            "areal_flood" => Ok(WeatherSevereType::ArealFlood),
            "coastal_flood" => Ok(WeatherSevereType::CoastalFlood),
            "lakeshore_flood" => Ok(WeatherSevereType::LakeshoreFlood),
            "excessive_heat" => Ok(WeatherSevereType::ExcessiveHeat),
            "heat" => Ok(WeatherSevereType::Heat),
            "weather" => Ok(WeatherSevereType::Weather),
            "high_heat_and_humidity" => Ok(WeatherSevereType::HighHeatAndHumidity),
            "humidex_and_health" => Ok(WeatherSevereType::HumidexAndHealth),
            "humidex" => Ok(WeatherSevereType::Humidex),
            "gale" => Ok(WeatherSevereType::Gale),
            "freezing_spray" => Ok(WeatherSevereType::FreezingSpray),
            "special_marine" => Ok(WeatherSevereType::SpecialMarine),
            "squall" => Ok(WeatherSevereType::Squall),
            "strong_wind" => Ok(WeatherSevereType::StrongWind),
            "lake_wind" => Ok(WeatherSevereType::LakeWind),
            "marine_weather" => Ok(WeatherSevereType::MarineWeather),
            "wind" => Ok(WeatherSevereType::Wind),
            "small_craft_hazardous_seas" => Ok(WeatherSevereType::SmallCraftHazardousSeas),
            "hazardous_seas" => Ok(WeatherSevereType::HazardousSeas),
            "small_craft" => Ok(WeatherSevereType::SmallCraft),
            "small_craft_winds" => Ok(WeatherSevereType::SmallCraftWinds),
            "small_craft_rough_bar" => Ok(WeatherSevereType::SmallCraftRoughBar),
            "high_water_level" => Ok(WeatherSevereType::HighWaterLevel),
            "ashfall" => Ok(WeatherSevereType::Ashfall),
            "freezing_fog" => Ok(WeatherSevereType::FreezingFog),
            "dense_fog" => Ok(WeatherSevereType::DenseFog),
            "dense_smoke" => Ok(WeatherSevereType::DenseSmoke),
            "blowing_dust" => Ok(WeatherSevereType::BlowingDust),
            "hard_freeze" => Ok(WeatherSevereType::HardFreeze),
            "freeze" => Ok(WeatherSevereType::Freeze),
            "frost" => Ok(WeatherSevereType::Frost),
            "fire_weather" => Ok(WeatherSevereType::FireWeather),
            "flood" => Ok(WeatherSevereType::Flood),
            "rip_tide" => Ok(WeatherSevereType::RipTide),
            "high_surf" => Ok(WeatherSevereType::HighSurf),
            "smog" => Ok(WeatherSevereType::Smog),
            "air_quality" => Ok(WeatherSevereType::AirQuality),
            "brisk_wind" => Ok(WeatherSevereType::BriskWind),
            "air_stagnation" => Ok(WeatherSevereType::AirStagnation),
            "low_water" => Ok(WeatherSevereType::LowWater),
            "hydrological" => Ok(WeatherSevereType::Hydrological),
            "special_weather" => Ok(WeatherSevereType::SpecialWeather),
            _ => Err("No corresponding WeatherSevereType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum TimeIntoDay {
    Value(u32),
}
impl fmt::Display for TimeIntoDay {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TimeIntoDay::Value(val) => f.write_str(&val.to_string()),
        }
    }
}
impl TimeIntoDay {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            TimeIntoDay::Value(val) => fit::Value::UInt32(*val),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32"
    }
}
impl TryFrom<&fit::Value> for TimeIntoDay {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32(val) => Ok(TimeIntoDay::Value(*val)),
            _ => Err("No corresponding TimeIntoDay exists"),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LocaltimeIntoDay {
    Value(u32),
}
impl fmt::Display for LocaltimeIntoDay {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LocaltimeIntoDay::Value(val) => f.write_str(&val.to_string()),
        }
    }
}
impl LocaltimeIntoDay {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LocaltimeIntoDay::Value(val) => fit::Value::UInt32(*val),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32"
    }
}
impl TryFrom<&fit::Value> for LocaltimeIntoDay {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32(val) => Ok(LocaltimeIntoDay::Value(*val)),
            _ => Err("No corresponding LocaltimeIntoDay exists"),
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum StrokeType {
    NoEvent,
    /// stroke was detected but cannot be identified
    Other,
    Serve,
    Forehand,
    Backhand,
    Smash,
}
impl fmt::Display for StrokeType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            StrokeType::NoEvent => f.write_str("no_event"),
            StrokeType::Other => f.write_str("other"),
            StrokeType::Serve => f.write_str("serve"),
            StrokeType::Forehand => f.write_str("forehand"),
            StrokeType::Backhand => f.write_str("backhand"),
            StrokeType::Smash => f.write_str("smash"),
        }
    }
}
impl StrokeType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            StrokeType::NoEvent => fit::Value::Enum(0),
            StrokeType::Other => fit::Value::Enum(1),
            StrokeType::Serve => fit::Value::Enum(2),
            StrokeType::Forehand => fit::Value::Enum(3),
            StrokeType::Backhand => fit::Value::Enum(4),
            StrokeType::Smash => fit::Value::Enum(5),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for StrokeType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(StrokeType::NoEvent),
            fit::Value::Enum(1) => Ok(StrokeType::Other),
            fit::Value::Enum(2) => Ok(StrokeType::Serve),
            fit::Value::Enum(3) => Ok(StrokeType::Forehand),
            fit::Value::Enum(4) => Ok(StrokeType::Backhand),
            fit::Value::Enum(5) => Ok(StrokeType::Smash),
            _ => Err("No corresponding StrokeType exists"),
        }
    }
}
impl TryFrom<&str> for StrokeType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "no_event" => Ok(StrokeType::NoEvent),
            "other" => Ok(StrokeType::Other),
            "serve" => Ok(StrokeType::Serve),
            "forehand" => Ok(StrokeType::Forehand),
            "backhand" => Ok(StrokeType::Backhand),
            "smash" => Ok(StrokeType::Smash),
            _ => Err("No corresponding StrokeType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum BodyLocation {
    LeftLeg,
    LeftCalf,
    LeftShin,
    LeftHamstring,
    LeftQuad,
    LeftGlute,
    RightLeg,
    RightCalf,
    RightShin,
    RightHamstring,
    RightQuad,
    RightGlute,
    TorsoBack,
    LeftLowerBack,
    LeftUpperBack,
    RightLowerBack,
    RightUpperBack,
    TorsoFront,
    LeftAbdomen,
    LeftChest,
    RightAbdomen,
    RightChest,
    LeftArm,
    LeftShoulder,
    LeftBicep,
    LeftTricep,
    /// Left anterior forearm
    LeftBrachioradialis,
    /// Left posterior forearm
    LeftForearmExtensors,
    RightArm,
    RightShoulder,
    RightBicep,
    RightTricep,
    /// Right anterior forearm
    RightBrachioradialis,
    /// Right posterior forearm
    RightForearmExtensors,
    Neck,
    Throat,
    WaistMidBack,
    WaistFront,
    WaistLeft,
    WaistRight,
}
impl fmt::Display for BodyLocation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BodyLocation::LeftLeg => f.write_str("left_leg"),
            BodyLocation::LeftCalf => f.write_str("left_calf"),
            BodyLocation::LeftShin => f.write_str("left_shin"),
            BodyLocation::LeftHamstring => f.write_str("left_hamstring"),
            BodyLocation::LeftQuad => f.write_str("left_quad"),
            BodyLocation::LeftGlute => f.write_str("left_glute"),
            BodyLocation::RightLeg => f.write_str("right_leg"),
            BodyLocation::RightCalf => f.write_str("right_calf"),
            BodyLocation::RightShin => f.write_str("right_shin"),
            BodyLocation::RightHamstring => f.write_str("right_hamstring"),
            BodyLocation::RightQuad => f.write_str("right_quad"),
            BodyLocation::RightGlute => f.write_str("right_glute"),
            BodyLocation::TorsoBack => f.write_str("torso_back"),
            BodyLocation::LeftLowerBack => f.write_str("left_lower_back"),
            BodyLocation::LeftUpperBack => f.write_str("left_upper_back"),
            BodyLocation::RightLowerBack => f.write_str("right_lower_back"),
            BodyLocation::RightUpperBack => f.write_str("right_upper_back"),
            BodyLocation::TorsoFront => f.write_str("torso_front"),
            BodyLocation::LeftAbdomen => f.write_str("left_abdomen"),
            BodyLocation::LeftChest => f.write_str("left_chest"),
            BodyLocation::RightAbdomen => f.write_str("right_abdomen"),
            BodyLocation::RightChest => f.write_str("right_chest"),
            BodyLocation::LeftArm => f.write_str("left_arm"),
            BodyLocation::LeftShoulder => f.write_str("left_shoulder"),
            BodyLocation::LeftBicep => f.write_str("left_bicep"),
            BodyLocation::LeftTricep => f.write_str("left_tricep"),
            BodyLocation::LeftBrachioradialis => f.write_str("left_brachioradialis"),
            BodyLocation::LeftForearmExtensors => f.write_str("left_forearm_extensors"),
            BodyLocation::RightArm => f.write_str("right_arm"),
            BodyLocation::RightShoulder => f.write_str("right_shoulder"),
            BodyLocation::RightBicep => f.write_str("right_bicep"),
            BodyLocation::RightTricep => f.write_str("right_tricep"),
            BodyLocation::RightBrachioradialis => f.write_str("right_brachioradialis"),
            BodyLocation::RightForearmExtensors => f.write_str("right_forearm_extensors"),
            BodyLocation::Neck => f.write_str("neck"),
            BodyLocation::Throat => f.write_str("throat"),
            BodyLocation::WaistMidBack => f.write_str("waist_mid_back"),
            BodyLocation::WaistFront => f.write_str("waist_front"),
            BodyLocation::WaistLeft => f.write_str("waist_left"),
            BodyLocation::WaistRight => f.write_str("waist_right"),
        }
    }
}
impl BodyLocation {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            BodyLocation::LeftLeg => fit::Value::Enum(0),
            BodyLocation::LeftCalf => fit::Value::Enum(1),
            BodyLocation::LeftShin => fit::Value::Enum(2),
            BodyLocation::LeftHamstring => fit::Value::Enum(3),
            BodyLocation::LeftQuad => fit::Value::Enum(4),
            BodyLocation::LeftGlute => fit::Value::Enum(5),
            BodyLocation::RightLeg => fit::Value::Enum(6),
            BodyLocation::RightCalf => fit::Value::Enum(7),
            BodyLocation::RightShin => fit::Value::Enum(8),
            BodyLocation::RightHamstring => fit::Value::Enum(9),
            BodyLocation::RightQuad => fit::Value::Enum(10),
            BodyLocation::RightGlute => fit::Value::Enum(11),
            BodyLocation::TorsoBack => fit::Value::Enum(12),
            BodyLocation::LeftLowerBack => fit::Value::Enum(13),
            BodyLocation::LeftUpperBack => fit::Value::Enum(14),
            BodyLocation::RightLowerBack => fit::Value::Enum(15),
            BodyLocation::RightUpperBack => fit::Value::Enum(16),
            BodyLocation::TorsoFront => fit::Value::Enum(17),
            BodyLocation::LeftAbdomen => fit::Value::Enum(18),
            BodyLocation::LeftChest => fit::Value::Enum(19),
            BodyLocation::RightAbdomen => fit::Value::Enum(20),
            BodyLocation::RightChest => fit::Value::Enum(21),
            BodyLocation::LeftArm => fit::Value::Enum(22),
            BodyLocation::LeftShoulder => fit::Value::Enum(23),
            BodyLocation::LeftBicep => fit::Value::Enum(24),
            BodyLocation::LeftTricep => fit::Value::Enum(25),
            BodyLocation::LeftBrachioradialis => fit::Value::Enum(26),
            BodyLocation::LeftForearmExtensors => fit::Value::Enum(27),
            BodyLocation::RightArm => fit::Value::Enum(28),
            BodyLocation::RightShoulder => fit::Value::Enum(29),
            BodyLocation::RightBicep => fit::Value::Enum(30),
            BodyLocation::RightTricep => fit::Value::Enum(31),
            BodyLocation::RightBrachioradialis => fit::Value::Enum(32),
            BodyLocation::RightForearmExtensors => fit::Value::Enum(33),
            BodyLocation::Neck => fit::Value::Enum(34),
            BodyLocation::Throat => fit::Value::Enum(35),
            BodyLocation::WaistMidBack => fit::Value::Enum(36),
            BodyLocation::WaistFront => fit::Value::Enum(37),
            BodyLocation::WaistLeft => fit::Value::Enum(38),
            BodyLocation::WaistRight => fit::Value::Enum(39),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for BodyLocation {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(BodyLocation::LeftLeg),
            fit::Value::Enum(1) => Ok(BodyLocation::LeftCalf),
            fit::Value::Enum(2) => Ok(BodyLocation::LeftShin),
            fit::Value::Enum(3) => Ok(BodyLocation::LeftHamstring),
            fit::Value::Enum(4) => Ok(BodyLocation::LeftQuad),
            fit::Value::Enum(5) => Ok(BodyLocation::LeftGlute),
            fit::Value::Enum(6) => Ok(BodyLocation::RightLeg),
            fit::Value::Enum(7) => Ok(BodyLocation::RightCalf),
            fit::Value::Enum(8) => Ok(BodyLocation::RightShin),
            fit::Value::Enum(9) => Ok(BodyLocation::RightHamstring),
            fit::Value::Enum(10) => Ok(BodyLocation::RightQuad),
            fit::Value::Enum(11) => Ok(BodyLocation::RightGlute),
            fit::Value::Enum(12) => Ok(BodyLocation::TorsoBack),
            fit::Value::Enum(13) => Ok(BodyLocation::LeftLowerBack),
            fit::Value::Enum(14) => Ok(BodyLocation::LeftUpperBack),
            fit::Value::Enum(15) => Ok(BodyLocation::RightLowerBack),
            fit::Value::Enum(16) => Ok(BodyLocation::RightUpperBack),
            fit::Value::Enum(17) => Ok(BodyLocation::TorsoFront),
            fit::Value::Enum(18) => Ok(BodyLocation::LeftAbdomen),
            fit::Value::Enum(19) => Ok(BodyLocation::LeftChest),
            fit::Value::Enum(20) => Ok(BodyLocation::RightAbdomen),
            fit::Value::Enum(21) => Ok(BodyLocation::RightChest),
            fit::Value::Enum(22) => Ok(BodyLocation::LeftArm),
            fit::Value::Enum(23) => Ok(BodyLocation::LeftShoulder),
            fit::Value::Enum(24) => Ok(BodyLocation::LeftBicep),
            fit::Value::Enum(25) => Ok(BodyLocation::LeftTricep),
            fit::Value::Enum(26) => Ok(BodyLocation::LeftBrachioradialis),
            fit::Value::Enum(27) => Ok(BodyLocation::LeftForearmExtensors),
            fit::Value::Enum(28) => Ok(BodyLocation::RightArm),
            fit::Value::Enum(29) => Ok(BodyLocation::RightShoulder),
            fit::Value::Enum(30) => Ok(BodyLocation::RightBicep),
            fit::Value::Enum(31) => Ok(BodyLocation::RightTricep),
            fit::Value::Enum(32) => Ok(BodyLocation::RightBrachioradialis),
            fit::Value::Enum(33) => Ok(BodyLocation::RightForearmExtensors),
            fit::Value::Enum(34) => Ok(BodyLocation::Neck),
            fit::Value::Enum(35) => Ok(BodyLocation::Throat),
            fit::Value::Enum(36) => Ok(BodyLocation::WaistMidBack),
            fit::Value::Enum(37) => Ok(BodyLocation::WaistFront),
            fit::Value::Enum(38) => Ok(BodyLocation::WaistLeft),
            fit::Value::Enum(39) => Ok(BodyLocation::WaistRight),
            _ => Err("No corresponding BodyLocation exists"),
        }
    }
}
impl TryFrom<&str> for BodyLocation {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "left_leg" => Ok(BodyLocation::LeftLeg),
            "left_calf" => Ok(BodyLocation::LeftCalf),
            "left_shin" => Ok(BodyLocation::LeftShin),
            "left_hamstring" => Ok(BodyLocation::LeftHamstring),
            "left_quad" => Ok(BodyLocation::LeftQuad),
            "left_glute" => Ok(BodyLocation::LeftGlute),
            "right_leg" => Ok(BodyLocation::RightLeg),
            "right_calf" => Ok(BodyLocation::RightCalf),
            "right_shin" => Ok(BodyLocation::RightShin),
            "right_hamstring" => Ok(BodyLocation::RightHamstring),
            "right_quad" => Ok(BodyLocation::RightQuad),
            "right_glute" => Ok(BodyLocation::RightGlute),
            "torso_back" => Ok(BodyLocation::TorsoBack),
            "left_lower_back" => Ok(BodyLocation::LeftLowerBack),
            "left_upper_back" => Ok(BodyLocation::LeftUpperBack),
            "right_lower_back" => Ok(BodyLocation::RightLowerBack),
            "right_upper_back" => Ok(BodyLocation::RightUpperBack),
            "torso_front" => Ok(BodyLocation::TorsoFront),
            "left_abdomen" => Ok(BodyLocation::LeftAbdomen),
            "left_chest" => Ok(BodyLocation::LeftChest),
            "right_abdomen" => Ok(BodyLocation::RightAbdomen),
            "right_chest" => Ok(BodyLocation::RightChest),
            "left_arm" => Ok(BodyLocation::LeftArm),
            "left_shoulder" => Ok(BodyLocation::LeftShoulder),
            "left_bicep" => Ok(BodyLocation::LeftBicep),
            "left_tricep" => Ok(BodyLocation::LeftTricep),
            "left_brachioradialis" => Ok(BodyLocation::LeftBrachioradialis),
            "left_forearm_extensors" => Ok(BodyLocation::LeftForearmExtensors),
            "right_arm" => Ok(BodyLocation::RightArm),
            "right_shoulder" => Ok(BodyLocation::RightShoulder),
            "right_bicep" => Ok(BodyLocation::RightBicep),
            "right_tricep" => Ok(BodyLocation::RightTricep),
            "right_brachioradialis" => Ok(BodyLocation::RightBrachioradialis),
            "right_forearm_extensors" => Ok(BodyLocation::RightForearmExtensors),
            "neck" => Ok(BodyLocation::Neck),
            "throat" => Ok(BodyLocation::Throat),
            "waist_mid_back" => Ok(BodyLocation::WaistMidBack),
            "waist_front" => Ok(BodyLocation::WaistFront),
            "waist_left" => Ok(BodyLocation::WaistLeft),
            "waist_right" => Ok(BodyLocation::WaistRight),
            _ => Err("No corresponding BodyLocation exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SegmentLapStatus {
    End,
    Fail,
}
impl fmt::Display for SegmentLapStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SegmentLapStatus::End => f.write_str("end"),
            SegmentLapStatus::Fail => f.write_str("fail"),
        }
    }
}
impl SegmentLapStatus {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SegmentLapStatus::End => fit::Value::Enum(0),
            SegmentLapStatus::Fail => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SegmentLapStatus {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SegmentLapStatus::End),
            fit::Value::Enum(1) => Ok(SegmentLapStatus::Fail),
            _ => Err("No corresponding SegmentLapStatus exists"),
        }
    }
}
impl TryFrom<&str> for SegmentLapStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "end" => Ok(SegmentLapStatus::End),
            "fail" => Ok(SegmentLapStatus::Fail),
            _ => Err("No corresponding SegmentLapStatus exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SegmentLeaderboardType {
    Overall,
    PersonalBest,
    Connections,
    Group,
    Challenger,
    Kom,
    Qom,
    Pr,
    Goal,
    Rival,
    ClubLeader,
}
impl fmt::Display for SegmentLeaderboardType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SegmentLeaderboardType::Overall => f.write_str("overall"),
            SegmentLeaderboardType::PersonalBest => f.write_str("personal_best"),
            SegmentLeaderboardType::Connections => f.write_str("connections"),
            SegmentLeaderboardType::Group => f.write_str("group"),
            SegmentLeaderboardType::Challenger => f.write_str("challenger"),
            SegmentLeaderboardType::Kom => f.write_str("kom"),
            SegmentLeaderboardType::Qom => f.write_str("qom"),
            SegmentLeaderboardType::Pr => f.write_str("pr"),
            SegmentLeaderboardType::Goal => f.write_str("goal"),
            SegmentLeaderboardType::Rival => f.write_str("rival"),
            SegmentLeaderboardType::ClubLeader => f.write_str("club_leader"),
        }
    }
}
impl SegmentLeaderboardType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SegmentLeaderboardType::Overall => fit::Value::Enum(0),
            SegmentLeaderboardType::PersonalBest => fit::Value::Enum(1),
            SegmentLeaderboardType::Connections => fit::Value::Enum(2),
            SegmentLeaderboardType::Group => fit::Value::Enum(3),
            SegmentLeaderboardType::Challenger => fit::Value::Enum(4),
            SegmentLeaderboardType::Kom => fit::Value::Enum(5),
            SegmentLeaderboardType::Qom => fit::Value::Enum(6),
            SegmentLeaderboardType::Pr => fit::Value::Enum(7),
            SegmentLeaderboardType::Goal => fit::Value::Enum(8),
            SegmentLeaderboardType::Rival => fit::Value::Enum(9),
            SegmentLeaderboardType::ClubLeader => fit::Value::Enum(10),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SegmentLeaderboardType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SegmentLeaderboardType::Overall),
            fit::Value::Enum(1) => Ok(SegmentLeaderboardType::PersonalBest),
            fit::Value::Enum(2) => Ok(SegmentLeaderboardType::Connections),
            fit::Value::Enum(3) => Ok(SegmentLeaderboardType::Group),
            fit::Value::Enum(4) => Ok(SegmentLeaderboardType::Challenger),
            fit::Value::Enum(5) => Ok(SegmentLeaderboardType::Kom),
            fit::Value::Enum(6) => Ok(SegmentLeaderboardType::Qom),
            fit::Value::Enum(7) => Ok(SegmentLeaderboardType::Pr),
            fit::Value::Enum(8) => Ok(SegmentLeaderboardType::Goal),
            fit::Value::Enum(9) => Ok(SegmentLeaderboardType::Rival),
            fit::Value::Enum(10) => Ok(SegmentLeaderboardType::ClubLeader),
            _ => Err("No corresponding SegmentLeaderboardType exists"),
        }
    }
}
impl TryFrom<&str> for SegmentLeaderboardType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "overall" => Ok(SegmentLeaderboardType::Overall),
            "personal_best" => Ok(SegmentLeaderboardType::PersonalBest),
            "connections" => Ok(SegmentLeaderboardType::Connections),
            "group" => Ok(SegmentLeaderboardType::Group),
            "challenger" => Ok(SegmentLeaderboardType::Challenger),
            "kom" => Ok(SegmentLeaderboardType::Kom),
            "qom" => Ok(SegmentLeaderboardType::Qom),
            "pr" => Ok(SegmentLeaderboardType::Pr),
            "goal" => Ok(SegmentLeaderboardType::Goal),
            "rival" => Ok(SegmentLeaderboardType::Rival),
            "club_leader" => Ok(SegmentLeaderboardType::ClubLeader),
            _ => Err("No corresponding SegmentLeaderboardType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SegmentDeleteStatus {
    DoNotDelete,
    DeleteOne,
    DeleteAll,
}
impl fmt::Display for SegmentDeleteStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SegmentDeleteStatus::DoNotDelete => f.write_str("do_not_delete"),
            SegmentDeleteStatus::DeleteOne => f.write_str("delete_one"),
            SegmentDeleteStatus::DeleteAll => f.write_str("delete_all"),
        }
    }
}
impl SegmentDeleteStatus {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SegmentDeleteStatus::DoNotDelete => fit::Value::Enum(0),
            SegmentDeleteStatus::DeleteOne => fit::Value::Enum(1),
            SegmentDeleteStatus::DeleteAll => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SegmentDeleteStatus {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SegmentDeleteStatus::DoNotDelete),
            fit::Value::Enum(1) => Ok(SegmentDeleteStatus::DeleteOne),
            fit::Value::Enum(2) => Ok(SegmentDeleteStatus::DeleteAll),
            _ => Err("No corresponding SegmentDeleteStatus exists"),
        }
    }
}
impl TryFrom<&str> for SegmentDeleteStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "do_not_delete" => Ok(SegmentDeleteStatus::DoNotDelete),
            "delete_one" => Ok(SegmentDeleteStatus::DeleteOne),
            "delete_all" => Ok(SegmentDeleteStatus::DeleteAll),
            _ => Err("No corresponding SegmentDeleteStatus exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SegmentSelectionType {
    Starred,
    Suggested,
}
impl fmt::Display for SegmentSelectionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SegmentSelectionType::Starred => f.write_str("starred"),
            SegmentSelectionType::Suggested => f.write_str("suggested"),
        }
    }
}
impl SegmentSelectionType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SegmentSelectionType::Starred => fit::Value::Enum(0),
            SegmentSelectionType::Suggested => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SegmentSelectionType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SegmentSelectionType::Starred),
            fit::Value::Enum(1) => Ok(SegmentSelectionType::Suggested),
            _ => Err("No corresponding SegmentSelectionType exists"),
        }
    }
}
impl TryFrom<&str> for SegmentSelectionType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "starred" => Ok(SegmentSelectionType::Starred),
            "suggested" => Ok(SegmentSelectionType::Suggested),
            _ => Err("No corresponding SegmentSelectionType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SourceType {
    /// External device connected with ANT
    Ant,
    /// External device connected with ANT+
    Antplus,
    /// External device connected with BT
    Bluetooth,
    /// External device connected with BLE
    BluetoothLowEnergy,
    /// External device connected with Wifi
    Wifi,
    /// Onboard device
    Local,
}
impl fmt::Display for SourceType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SourceType::Ant => f.write_str("ant"),
            SourceType::Antplus => f.write_str("antplus"),
            SourceType::Bluetooth => f.write_str("bluetooth"),
            SourceType::BluetoothLowEnergy => f.write_str("bluetooth_low_energy"),
            SourceType::Wifi => f.write_str("wifi"),
            SourceType::Local => f.write_str("local"),
        }
    }
}
impl SourceType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SourceType::Ant => fit::Value::Enum(0),
            SourceType::Antplus => fit::Value::Enum(1),
            SourceType::Bluetooth => fit::Value::Enum(2),
            SourceType::BluetoothLowEnergy => fit::Value::Enum(3),
            SourceType::Wifi => fit::Value::Enum(4),
            SourceType::Local => fit::Value::Enum(5),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SourceType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SourceType::Ant),
            fit::Value::Enum(1) => Ok(SourceType::Antplus),
            fit::Value::Enum(2) => Ok(SourceType::Bluetooth),
            fit::Value::Enum(3) => Ok(SourceType::BluetoothLowEnergy),
            fit::Value::Enum(4) => Ok(SourceType::Wifi),
            fit::Value::Enum(5) => Ok(SourceType::Local),
            _ => Err("No corresponding SourceType exists"),
        }
    }
}
impl TryFrom<&str> for SourceType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "ant" => Ok(SourceType::Ant),
            "antplus" => Ok(SourceType::Antplus),
            "bluetooth" => Ok(SourceType::Bluetooth),
            "bluetooth_low_energy" => Ok(SourceType::BluetoothLowEnergy),
            "wifi" => Ok(SourceType::Wifi),
            "local" => Ok(SourceType::Local),
            _ => Err("No corresponding SourceType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LocalDeviceType {
    /// Onboard gps receiver
    Gps,
    /// Onboard glonass receiver
    Glonass,
    /// Onboard gps glonass receiver
    GpsGlonass,
    /// Onboard sensor
    Accelerometer,
    /// Onboard sensor
    Barometer,
    /// Onboard sensor
    Temperature,
    /// Onboard wrist HR sensor
    Whr,
    /// Onboard software package
    SensorHub,
}
impl fmt::Display for LocalDeviceType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LocalDeviceType::Gps => f.write_str("gps"),
            LocalDeviceType::Glonass => f.write_str("glonass"),
            LocalDeviceType::GpsGlonass => f.write_str("gps_glonass"),
            LocalDeviceType::Accelerometer => f.write_str("accelerometer"),
            LocalDeviceType::Barometer => f.write_str("barometer"),
            LocalDeviceType::Temperature => f.write_str("temperature"),
            LocalDeviceType::Whr => f.write_str("whr"),
            LocalDeviceType::SensorHub => f.write_str("sensor_hub"),
        }
    }
}
impl LocalDeviceType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LocalDeviceType::Gps => fit::Value::UInt8(0),
            LocalDeviceType::Glonass => fit::Value::UInt8(1),
            LocalDeviceType::GpsGlonass => fit::Value::UInt8(2),
            LocalDeviceType::Accelerometer => fit::Value::UInt8(3),
            LocalDeviceType::Barometer => fit::Value::UInt8(4),
            LocalDeviceType::Temperature => fit::Value::UInt8(5),
            LocalDeviceType::Whr => fit::Value::UInt8(10),
            LocalDeviceType::SensorHub => fit::Value::UInt8(12),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for LocalDeviceType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(0) => Ok(LocalDeviceType::Gps),
            fit::Value::UInt8(1) => Ok(LocalDeviceType::Glonass),
            fit::Value::UInt8(2) => Ok(LocalDeviceType::GpsGlonass),
            fit::Value::UInt8(3) => Ok(LocalDeviceType::Accelerometer),
            fit::Value::UInt8(4) => Ok(LocalDeviceType::Barometer),
            fit::Value::UInt8(5) => Ok(LocalDeviceType::Temperature),
            fit::Value::UInt8(10) => Ok(LocalDeviceType::Whr),
            fit::Value::UInt8(12) => Ok(LocalDeviceType::SensorHub),
            _ => Err("No corresponding LocalDeviceType exists"),
        }
    }
}
impl TryFrom<&str> for LocalDeviceType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "gps" => Ok(LocalDeviceType::Gps),
            "glonass" => Ok(LocalDeviceType::Glonass),
            "gps_glonass" => Ok(LocalDeviceType::GpsGlonass),
            "accelerometer" => Ok(LocalDeviceType::Accelerometer),
            "barometer" => Ok(LocalDeviceType::Barometer),
            "temperature" => Ok(LocalDeviceType::Temperature),
            "whr" => Ok(LocalDeviceType::Whr),
            "sensor_hub" => Ok(LocalDeviceType::SensorHub),
            _ => Err("No corresponding LocalDeviceType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum BleDeviceType {
    /// GPS that is provided over a proprietary bluetooth service
    ConnectedGps,
    HeartRate,
    BikePower,
    BikeSpeedCadence,
    BikeSpeed,
    BikeCadence,
    Footpod,
    /// Indoor-Bike FTMS protocol
    BikeTrainer,
}
impl fmt::Display for BleDeviceType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BleDeviceType::ConnectedGps => f.write_str("connected_gps"),
            BleDeviceType::HeartRate => f.write_str("heart_rate"),
            BleDeviceType::BikePower => f.write_str("bike_power"),
            BleDeviceType::BikeSpeedCadence => f.write_str("bike_speed_cadence"),
            BleDeviceType::BikeSpeed => f.write_str("bike_speed"),
            BleDeviceType::BikeCadence => f.write_str("bike_cadence"),
            BleDeviceType::Footpod => f.write_str("footpod"),
            BleDeviceType::BikeTrainer => f.write_str("bike_trainer"),
        }
    }
}
impl BleDeviceType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            BleDeviceType::ConnectedGps => fit::Value::UInt8(0),
            BleDeviceType::HeartRate => fit::Value::UInt8(1),
            BleDeviceType::BikePower => fit::Value::UInt8(2),
            BleDeviceType::BikeSpeedCadence => fit::Value::UInt8(3),
            BleDeviceType::BikeSpeed => fit::Value::UInt8(4),
            BleDeviceType::BikeCadence => fit::Value::UInt8(5),
            BleDeviceType::Footpod => fit::Value::UInt8(6),
            BleDeviceType::BikeTrainer => fit::Value::UInt8(7),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for BleDeviceType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(0) => Ok(BleDeviceType::ConnectedGps),
            fit::Value::UInt8(1) => Ok(BleDeviceType::HeartRate),
            fit::Value::UInt8(2) => Ok(BleDeviceType::BikePower),
            fit::Value::UInt8(3) => Ok(BleDeviceType::BikeSpeedCadence),
            fit::Value::UInt8(4) => Ok(BleDeviceType::BikeSpeed),
            fit::Value::UInt8(5) => Ok(BleDeviceType::BikeCadence),
            fit::Value::UInt8(6) => Ok(BleDeviceType::Footpod),
            fit::Value::UInt8(7) => Ok(BleDeviceType::BikeTrainer),
            _ => Err("No corresponding BleDeviceType exists"),
        }
    }
}
impl TryFrom<&str> for BleDeviceType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "connected_gps" => Ok(BleDeviceType::ConnectedGps),
            "heart_rate" => Ok(BleDeviceType::HeartRate),
            "bike_power" => Ok(BleDeviceType::BikePower),
            "bike_speed_cadence" => Ok(BleDeviceType::BikeSpeedCadence),
            "bike_speed" => Ok(BleDeviceType::BikeSpeed),
            "bike_cadence" => Ok(BleDeviceType::BikeCadence),
            "footpod" => Ok(BleDeviceType::Footpod),
            "bike_trainer" => Ok(BleDeviceType::BikeTrainer),
            _ => Err("No corresponding BleDeviceType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum AntChannelId {
    AntExtendedDeviceNumberUpperNibble,
    AntTransmissionTypeLowerNibble,
    AntDeviceType,
    AntDeviceNumber,
}
impl fmt::Display for AntChannelId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AntChannelId::AntExtendedDeviceNumberUpperNibble => {
                f.write_str("ant_extended_device_number_upper_nibble")
            }
            AntChannelId::AntTransmissionTypeLowerNibble => {
                f.write_str("ant_transmission_type_lower_nibble")
            }
            AntChannelId::AntDeviceType => f.write_str("ant_device_type"),
            AntChannelId::AntDeviceNumber => f.write_str("ant_device_number"),
        }
    }
}
impl AntChannelId {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            AntChannelId::AntExtendedDeviceNumberUpperNibble => fit::Value::UInt32z(0xF0000000),
            AntChannelId::AntTransmissionTypeLowerNibble => fit::Value::UInt32z(0x0F000000),
            AntChannelId::AntDeviceType => fit::Value::UInt32z(0x00FF0000),
            AntChannelId::AntDeviceNumber => fit::Value::UInt32z(0x0000FFFF),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32z"
    }
}
impl TryFrom<&fit::Value> for AntChannelId {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32z(0xF0000000) => Ok(AntChannelId::AntExtendedDeviceNumberUpperNibble),
            fit::Value::UInt32z(0x0F000000) => Ok(AntChannelId::AntTransmissionTypeLowerNibble),
            fit::Value::UInt32z(0x00FF0000) => Ok(AntChannelId::AntDeviceType),
            fit::Value::UInt32z(0x0000FFFF) => Ok(AntChannelId::AntDeviceNumber),
            _ => Err("No corresponding AntChannelId exists"),
        }
    }
}
impl TryFrom<&str> for AntChannelId {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "ant_extended_device_number_upper_nibble" => {
                Ok(AntChannelId::AntExtendedDeviceNumberUpperNibble)
            }
            "ant_transmission_type_lower_nibble" => {
                Ok(AntChannelId::AntTransmissionTypeLowerNibble)
            }
            "ant_device_type" => Ok(AntChannelId::AntDeviceType),
            "ant_device_number" => Ok(AntChannelId::AntDeviceNumber),
            _ => Err("No corresponding AntChannelId exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DisplayOrientation {
    /// automatic if the device supports it
    Auto,
    Portrait,
    Landscape,
    /// portrait mode but rotated 180 degrees
    PortraitFlipped,
    /// landscape mode but rotated 180 degrees
    LandscapeFlipped,
}
impl fmt::Display for DisplayOrientation {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DisplayOrientation::Auto => f.write_str("auto"),
            DisplayOrientation::Portrait => f.write_str("portrait"),
            DisplayOrientation::Landscape => f.write_str("landscape"),
            DisplayOrientation::PortraitFlipped => f.write_str("portrait_flipped"),
            DisplayOrientation::LandscapeFlipped => f.write_str("landscape_flipped"),
        }
    }
}
impl DisplayOrientation {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DisplayOrientation::Auto => fit::Value::Enum(0),
            DisplayOrientation::Portrait => fit::Value::Enum(1),
            DisplayOrientation::Landscape => fit::Value::Enum(2),
            DisplayOrientation::PortraitFlipped => fit::Value::Enum(3),
            DisplayOrientation::LandscapeFlipped => fit::Value::Enum(4),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DisplayOrientation {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DisplayOrientation::Auto),
            fit::Value::Enum(1) => Ok(DisplayOrientation::Portrait),
            fit::Value::Enum(2) => Ok(DisplayOrientation::Landscape),
            fit::Value::Enum(3) => Ok(DisplayOrientation::PortraitFlipped),
            fit::Value::Enum(4) => Ok(DisplayOrientation::LandscapeFlipped),
            _ => Err("No corresponding DisplayOrientation exists"),
        }
    }
}
impl TryFrom<&str> for DisplayOrientation {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "auto" => Ok(DisplayOrientation::Auto),
            "portrait" => Ok(DisplayOrientation::Portrait),
            "landscape" => Ok(DisplayOrientation::Landscape),
            "portrait_flipped" => Ok(DisplayOrientation::PortraitFlipped),
            "landscape_flipped" => Ok(DisplayOrientation::LandscapeFlipped),
            _ => Err("No corresponding DisplayOrientation exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WorkoutEquipment {
    None,
    SwimFins,
    SwimKickboard,
    SwimPaddles,
    SwimPullBuoy,
    SwimSnorkel,
}
impl fmt::Display for WorkoutEquipment {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WorkoutEquipment::None => f.write_str("none"),
            WorkoutEquipment::SwimFins => f.write_str("swim_fins"),
            WorkoutEquipment::SwimKickboard => f.write_str("swim_kickboard"),
            WorkoutEquipment::SwimPaddles => f.write_str("swim_paddles"),
            WorkoutEquipment::SwimPullBuoy => f.write_str("swim_pull_buoy"),
            WorkoutEquipment::SwimSnorkel => f.write_str("swim_snorkel"),
        }
    }
}
impl WorkoutEquipment {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WorkoutEquipment::None => fit::Value::Enum(0),
            WorkoutEquipment::SwimFins => fit::Value::Enum(1),
            WorkoutEquipment::SwimKickboard => fit::Value::Enum(2),
            WorkoutEquipment::SwimPaddles => fit::Value::Enum(3),
            WorkoutEquipment::SwimPullBuoy => fit::Value::Enum(4),
            WorkoutEquipment::SwimSnorkel => fit::Value::Enum(5),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for WorkoutEquipment {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(WorkoutEquipment::None),
            fit::Value::Enum(1) => Ok(WorkoutEquipment::SwimFins),
            fit::Value::Enum(2) => Ok(WorkoutEquipment::SwimKickboard),
            fit::Value::Enum(3) => Ok(WorkoutEquipment::SwimPaddles),
            fit::Value::Enum(4) => Ok(WorkoutEquipment::SwimPullBuoy),
            fit::Value::Enum(5) => Ok(WorkoutEquipment::SwimSnorkel),
            _ => Err("No corresponding WorkoutEquipment exists"),
        }
    }
}
impl TryFrom<&str> for WorkoutEquipment {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "none" => Ok(WorkoutEquipment::None),
            "swim_fins" => Ok(WorkoutEquipment::SwimFins),
            "swim_kickboard" => Ok(WorkoutEquipment::SwimKickboard),
            "swim_paddles" => Ok(WorkoutEquipment::SwimPaddles),
            "swim_pull_buoy" => Ok(WorkoutEquipment::SwimPullBuoy),
            "swim_snorkel" => Ok(WorkoutEquipment::SwimSnorkel),
            _ => Err("No corresponding WorkoutEquipment exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WatchfaceMode {
    Digital,
    Analog,
    ConnectIq,
    Disabled,
}
impl fmt::Display for WatchfaceMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WatchfaceMode::Digital => f.write_str("digital"),
            WatchfaceMode::Analog => f.write_str("analog"),
            WatchfaceMode::ConnectIq => f.write_str("connect_iq"),
            WatchfaceMode::Disabled => f.write_str("disabled"),
        }
    }
}
impl WatchfaceMode {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WatchfaceMode::Digital => fit::Value::Enum(0),
            WatchfaceMode::Analog => fit::Value::Enum(1),
            WatchfaceMode::ConnectIq => fit::Value::Enum(2),
            WatchfaceMode::Disabled => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for WatchfaceMode {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(WatchfaceMode::Digital),
            fit::Value::Enum(1) => Ok(WatchfaceMode::Analog),
            fit::Value::Enum(2) => Ok(WatchfaceMode::ConnectIq),
            fit::Value::Enum(3) => Ok(WatchfaceMode::Disabled),
            _ => Err("No corresponding WatchfaceMode exists"),
        }
    }
}
impl TryFrom<&str> for WatchfaceMode {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "digital" => Ok(WatchfaceMode::Digital),
            "analog" => Ok(WatchfaceMode::Analog),
            "connect_iq" => Ok(WatchfaceMode::ConnectIq),
            "disabled" => Ok(WatchfaceMode::Disabled),
            _ => Err("No corresponding WatchfaceMode exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DigitalWatchfaceLayout {
    Traditional,
    Modern,
    Bold,
}
impl fmt::Display for DigitalWatchfaceLayout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DigitalWatchfaceLayout::Traditional => f.write_str("traditional"),
            DigitalWatchfaceLayout::Modern => f.write_str("modern"),
            DigitalWatchfaceLayout::Bold => f.write_str("bold"),
        }
    }
}
impl DigitalWatchfaceLayout {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DigitalWatchfaceLayout::Traditional => fit::Value::Enum(0),
            DigitalWatchfaceLayout::Modern => fit::Value::Enum(1),
            DigitalWatchfaceLayout::Bold => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DigitalWatchfaceLayout {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DigitalWatchfaceLayout::Traditional),
            fit::Value::Enum(1) => Ok(DigitalWatchfaceLayout::Modern),
            fit::Value::Enum(2) => Ok(DigitalWatchfaceLayout::Bold),
            _ => Err("No corresponding DigitalWatchfaceLayout exists"),
        }
    }
}
impl TryFrom<&str> for DigitalWatchfaceLayout {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "traditional" => Ok(DigitalWatchfaceLayout::Traditional),
            "modern" => Ok(DigitalWatchfaceLayout::Modern),
            "bold" => Ok(DigitalWatchfaceLayout::Bold),
            _ => Err("No corresponding DigitalWatchfaceLayout exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum AnalogWatchfaceLayout {
    Minimal,
    Traditional,
    Modern,
}
impl fmt::Display for AnalogWatchfaceLayout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AnalogWatchfaceLayout::Minimal => f.write_str("minimal"),
            AnalogWatchfaceLayout::Traditional => f.write_str("traditional"),
            AnalogWatchfaceLayout::Modern => f.write_str("modern"),
        }
    }
}
impl AnalogWatchfaceLayout {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            AnalogWatchfaceLayout::Minimal => fit::Value::Enum(0),
            AnalogWatchfaceLayout::Traditional => fit::Value::Enum(1),
            AnalogWatchfaceLayout::Modern => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for AnalogWatchfaceLayout {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(AnalogWatchfaceLayout::Minimal),
            fit::Value::Enum(1) => Ok(AnalogWatchfaceLayout::Traditional),
            fit::Value::Enum(2) => Ok(AnalogWatchfaceLayout::Modern),
            _ => Err("No corresponding AnalogWatchfaceLayout exists"),
        }
    }
}
impl TryFrom<&str> for AnalogWatchfaceLayout {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "minimal" => Ok(AnalogWatchfaceLayout::Minimal),
            "traditional" => Ok(AnalogWatchfaceLayout::Traditional),
            "modern" => Ok(AnalogWatchfaceLayout::Modern),
            _ => Err("No corresponding AnalogWatchfaceLayout exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum RiderPositionType {
    Seated,
    Standing,
    TransitionToSeated,
    TransitionToStanding,
}
impl fmt::Display for RiderPositionType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RiderPositionType::Seated => f.write_str("seated"),
            RiderPositionType::Standing => f.write_str("standing"),
            RiderPositionType::TransitionToSeated => f.write_str("transition_to_seated"),
            RiderPositionType::TransitionToStanding => f.write_str("transition_to_standing"),
        }
    }
}
impl RiderPositionType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            RiderPositionType::Seated => fit::Value::Enum(0),
            RiderPositionType::Standing => fit::Value::Enum(1),
            RiderPositionType::TransitionToSeated => fit::Value::Enum(2),
            RiderPositionType::TransitionToStanding => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for RiderPositionType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(RiderPositionType::Seated),
            fit::Value::Enum(1) => Ok(RiderPositionType::Standing),
            fit::Value::Enum(2) => Ok(RiderPositionType::TransitionToSeated),
            fit::Value::Enum(3) => Ok(RiderPositionType::TransitionToStanding),
            _ => Err("No corresponding RiderPositionType exists"),
        }
    }
}
impl TryFrom<&str> for RiderPositionType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "seated" => Ok(RiderPositionType::Seated),
            "standing" => Ok(RiderPositionType::Standing),
            "transition_to_seated" => Ok(RiderPositionType::TransitionToSeated),
            "transition_to_standing" => Ok(RiderPositionType::TransitionToStanding),
            _ => Err("No corresponding RiderPositionType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum PowerPhaseType {
    PowerPhaseStartAngle,
    PowerPhaseEndAngle,
    PowerPhaseArcLength,
    PowerPhaseCenter,
}
impl fmt::Display for PowerPhaseType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PowerPhaseType::PowerPhaseStartAngle => f.write_str("power_phase_start_angle"),
            PowerPhaseType::PowerPhaseEndAngle => f.write_str("power_phase_end_angle"),
            PowerPhaseType::PowerPhaseArcLength => f.write_str("power_phase_arc_length"),
            PowerPhaseType::PowerPhaseCenter => f.write_str("power_phase_center"),
        }
    }
}
impl PowerPhaseType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            PowerPhaseType::PowerPhaseStartAngle => fit::Value::Enum(0),
            PowerPhaseType::PowerPhaseEndAngle => fit::Value::Enum(1),
            PowerPhaseType::PowerPhaseArcLength => fit::Value::Enum(2),
            PowerPhaseType::PowerPhaseCenter => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for PowerPhaseType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(PowerPhaseType::PowerPhaseStartAngle),
            fit::Value::Enum(1) => Ok(PowerPhaseType::PowerPhaseEndAngle),
            fit::Value::Enum(2) => Ok(PowerPhaseType::PowerPhaseArcLength),
            fit::Value::Enum(3) => Ok(PowerPhaseType::PowerPhaseCenter),
            _ => Err("No corresponding PowerPhaseType exists"),
        }
    }
}
impl TryFrom<&str> for PowerPhaseType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "power_phase_start_angle" => Ok(PowerPhaseType::PowerPhaseStartAngle),
            "power_phase_end_angle" => Ok(PowerPhaseType::PowerPhaseEndAngle),
            "power_phase_arc_length" => Ok(PowerPhaseType::PowerPhaseArcLength),
            "power_phase_center" => Ok(PowerPhaseType::PowerPhaseCenter),
            _ => Err("No corresponding PowerPhaseType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CameraEventType {
    /// Start of video recording
    VideoStart,
    /// Mark of video file split (end of one file, beginning of the other)
    VideoSplit,
    /// End of video recording
    VideoEnd,
    /// Still photo taken
    PhotoTaken,
    VideoSecondStreamStart,
    VideoSecondStreamSplit,
    VideoSecondStreamEnd,
    /// Mark of video file split start
    VideoSplitStart,
    VideoSecondStreamSplitStart,
    /// Mark when a video recording has been paused
    VideoPause,
    VideoSecondStreamPause,
    /// Mark when a video recording has been resumed
    VideoResume,
    VideoSecondStreamResume,
}
impl fmt::Display for CameraEventType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CameraEventType::VideoStart => f.write_str("video_start"),
            CameraEventType::VideoSplit => f.write_str("video_split"),
            CameraEventType::VideoEnd => f.write_str("video_end"),
            CameraEventType::PhotoTaken => f.write_str("photo_taken"),
            CameraEventType::VideoSecondStreamStart => f.write_str("video_second_stream_start"),
            CameraEventType::VideoSecondStreamSplit => f.write_str("video_second_stream_split"),
            CameraEventType::VideoSecondStreamEnd => f.write_str("video_second_stream_end"),
            CameraEventType::VideoSplitStart => f.write_str("video_split_start"),
            CameraEventType::VideoSecondStreamSplitStart => {
                f.write_str("video_second_stream_split_start")
            }
            CameraEventType::VideoPause => f.write_str("video_pause"),
            CameraEventType::VideoSecondStreamPause => f.write_str("video_second_stream_pause"),
            CameraEventType::VideoResume => f.write_str("video_resume"),
            CameraEventType::VideoSecondStreamResume => f.write_str("video_second_stream_resume"),
        }
    }
}
impl CameraEventType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CameraEventType::VideoStart => fit::Value::Enum(0),
            CameraEventType::VideoSplit => fit::Value::Enum(1),
            CameraEventType::VideoEnd => fit::Value::Enum(2),
            CameraEventType::PhotoTaken => fit::Value::Enum(3),
            CameraEventType::VideoSecondStreamStart => fit::Value::Enum(4),
            CameraEventType::VideoSecondStreamSplit => fit::Value::Enum(5),
            CameraEventType::VideoSecondStreamEnd => fit::Value::Enum(6),
            CameraEventType::VideoSplitStart => fit::Value::Enum(7),
            CameraEventType::VideoSecondStreamSplitStart => fit::Value::Enum(8),
            CameraEventType::VideoPause => fit::Value::Enum(11),
            CameraEventType::VideoSecondStreamPause => fit::Value::Enum(12),
            CameraEventType::VideoResume => fit::Value::Enum(13),
            CameraEventType::VideoSecondStreamResume => fit::Value::Enum(14),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for CameraEventType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(CameraEventType::VideoStart),
            fit::Value::Enum(1) => Ok(CameraEventType::VideoSplit),
            fit::Value::Enum(2) => Ok(CameraEventType::VideoEnd),
            fit::Value::Enum(3) => Ok(CameraEventType::PhotoTaken),
            fit::Value::Enum(4) => Ok(CameraEventType::VideoSecondStreamStart),
            fit::Value::Enum(5) => Ok(CameraEventType::VideoSecondStreamSplit),
            fit::Value::Enum(6) => Ok(CameraEventType::VideoSecondStreamEnd),
            fit::Value::Enum(7) => Ok(CameraEventType::VideoSplitStart),
            fit::Value::Enum(8) => Ok(CameraEventType::VideoSecondStreamSplitStart),
            fit::Value::Enum(11) => Ok(CameraEventType::VideoPause),
            fit::Value::Enum(12) => Ok(CameraEventType::VideoSecondStreamPause),
            fit::Value::Enum(13) => Ok(CameraEventType::VideoResume),
            fit::Value::Enum(14) => Ok(CameraEventType::VideoSecondStreamResume),
            _ => Err("No corresponding CameraEventType exists"),
        }
    }
}
impl TryFrom<&str> for CameraEventType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "video_start" => Ok(CameraEventType::VideoStart),
            "video_split" => Ok(CameraEventType::VideoSplit),
            "video_end" => Ok(CameraEventType::VideoEnd),
            "photo_taken" => Ok(CameraEventType::PhotoTaken),
            "video_second_stream_start" => Ok(CameraEventType::VideoSecondStreamStart),
            "video_second_stream_split" => Ok(CameraEventType::VideoSecondStreamSplit),
            "video_second_stream_end" => Ok(CameraEventType::VideoSecondStreamEnd),
            "video_split_start" => Ok(CameraEventType::VideoSplitStart),
            "video_second_stream_split_start" => Ok(CameraEventType::VideoSecondStreamSplitStart),
            "video_pause" => Ok(CameraEventType::VideoPause),
            "video_second_stream_pause" => Ok(CameraEventType::VideoSecondStreamPause),
            "video_resume" => Ok(CameraEventType::VideoResume),
            "video_second_stream_resume" => Ok(CameraEventType::VideoSecondStreamResume),
            _ => Err("No corresponding CameraEventType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SensorType {
    Accelerometer,
    Gyroscope,
    /// Magnetometer
    Compass,
    Barometer,
}
impl fmt::Display for SensorType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SensorType::Accelerometer => f.write_str("accelerometer"),
            SensorType::Gyroscope => f.write_str("gyroscope"),
            SensorType::Compass => f.write_str("compass"),
            SensorType::Barometer => f.write_str("barometer"),
        }
    }
}
impl SensorType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SensorType::Accelerometer => fit::Value::Enum(0),
            SensorType::Gyroscope => fit::Value::Enum(1),
            SensorType::Compass => fit::Value::Enum(2),
            SensorType::Barometer => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SensorType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SensorType::Accelerometer),
            fit::Value::Enum(1) => Ok(SensorType::Gyroscope),
            fit::Value::Enum(2) => Ok(SensorType::Compass),
            fit::Value::Enum(3) => Ok(SensorType::Barometer),
            _ => Err("No corresponding SensorType exists"),
        }
    }
}
impl TryFrom<&str> for SensorType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "accelerometer" => Ok(SensorType::Accelerometer),
            "gyroscope" => Ok(SensorType::Gyroscope),
            "compass" => Ok(SensorType::Compass),
            "barometer" => Ok(SensorType::Barometer),
            _ => Err("No corresponding SensorType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum BikeLightNetworkConfigType {
    Auto,
    Individual,
    HighVisibility,
    Trail,
}
impl fmt::Display for BikeLightNetworkConfigType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BikeLightNetworkConfigType::Auto => f.write_str("auto"),
            BikeLightNetworkConfigType::Individual => f.write_str("individual"),
            BikeLightNetworkConfigType::HighVisibility => f.write_str("high_visibility"),
            BikeLightNetworkConfigType::Trail => f.write_str("trail"),
        }
    }
}
impl BikeLightNetworkConfigType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            BikeLightNetworkConfigType::Auto => fit::Value::Enum(0),
            BikeLightNetworkConfigType::Individual => fit::Value::Enum(4),
            BikeLightNetworkConfigType::HighVisibility => fit::Value::Enum(5),
            BikeLightNetworkConfigType::Trail => fit::Value::Enum(6),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for BikeLightNetworkConfigType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(BikeLightNetworkConfigType::Auto),
            fit::Value::Enum(4) => Ok(BikeLightNetworkConfigType::Individual),
            fit::Value::Enum(5) => Ok(BikeLightNetworkConfigType::HighVisibility),
            fit::Value::Enum(6) => Ok(BikeLightNetworkConfigType::Trail),
            _ => Err("No corresponding BikeLightNetworkConfigType exists"),
        }
    }
}
impl TryFrom<&str> for BikeLightNetworkConfigType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "auto" => Ok(BikeLightNetworkConfigType::Auto),
            "individual" => Ok(BikeLightNetworkConfigType::Individual),
            "high_visibility" => Ok(BikeLightNetworkConfigType::HighVisibility),
            "trail" => Ok(BikeLightNetworkConfigType::Trail),
            _ => Err("No corresponding BikeLightNetworkConfigType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CommTimeoutType {
    /// Timeout pairing to any device
    WildcardPairingTimeout,
    /// Timeout pairing to previously paired device
    PairingTimeout,
    /// Temporary loss of communications
    ConnectionLost,
    /// Connection closed due to extended bad communications
    ConnectionTimeout,
}
impl fmt::Display for CommTimeoutType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CommTimeoutType::WildcardPairingTimeout => f.write_str("wildcard_pairing_timeout"),
            CommTimeoutType::PairingTimeout => f.write_str("pairing_timeout"),
            CommTimeoutType::ConnectionLost => f.write_str("connection_lost"),
            CommTimeoutType::ConnectionTimeout => f.write_str("connection_timeout"),
        }
    }
}
impl CommTimeoutType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CommTimeoutType::WildcardPairingTimeout => fit::Value::UInt16(0),
            CommTimeoutType::PairingTimeout => fit::Value::UInt16(1),
            CommTimeoutType::ConnectionLost => fit::Value::UInt16(2),
            CommTimeoutType::ConnectionTimeout => fit::Value::UInt16(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for CommTimeoutType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(CommTimeoutType::WildcardPairingTimeout),
            fit::Value::UInt16(1) => Ok(CommTimeoutType::PairingTimeout),
            fit::Value::UInt16(2) => Ok(CommTimeoutType::ConnectionLost),
            fit::Value::UInt16(3) => Ok(CommTimeoutType::ConnectionTimeout),
            _ => Err("No corresponding CommTimeoutType exists"),
        }
    }
}
impl TryFrom<&str> for CommTimeoutType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "wildcard_pairing_timeout" => Ok(CommTimeoutType::WildcardPairingTimeout),
            "pairing_timeout" => Ok(CommTimeoutType::PairingTimeout),
            "connection_lost" => Ok(CommTimeoutType::ConnectionLost),
            "connection_timeout" => Ok(CommTimeoutType::ConnectionTimeout),
            _ => Err("No corresponding CommTimeoutType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CameraOrientationType {
    CameraOrientation0,
    CameraOrientation90,
    CameraOrientation180,
    CameraOrientation270,
}
impl fmt::Display for CameraOrientationType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CameraOrientationType::CameraOrientation0 => f.write_str("camera_orientation_0"),
            CameraOrientationType::CameraOrientation90 => f.write_str("camera_orientation_90"),
            CameraOrientationType::CameraOrientation180 => f.write_str("camera_orientation_180"),
            CameraOrientationType::CameraOrientation270 => f.write_str("camera_orientation_270"),
        }
    }
}
impl CameraOrientationType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CameraOrientationType::CameraOrientation0 => fit::Value::Enum(0),
            CameraOrientationType::CameraOrientation90 => fit::Value::Enum(1),
            CameraOrientationType::CameraOrientation180 => fit::Value::Enum(2),
            CameraOrientationType::CameraOrientation270 => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for CameraOrientationType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(CameraOrientationType::CameraOrientation0),
            fit::Value::Enum(1) => Ok(CameraOrientationType::CameraOrientation90),
            fit::Value::Enum(2) => Ok(CameraOrientationType::CameraOrientation180),
            fit::Value::Enum(3) => Ok(CameraOrientationType::CameraOrientation270),
            _ => Err("No corresponding CameraOrientationType exists"),
        }
    }
}
impl TryFrom<&str> for CameraOrientationType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "camera_orientation_0" => Ok(CameraOrientationType::CameraOrientation0),
            "camera_orientation_90" => Ok(CameraOrientationType::CameraOrientation90),
            "camera_orientation_180" => Ok(CameraOrientationType::CameraOrientation180),
            "camera_orientation_270" => Ok(CameraOrientationType::CameraOrientation270),
            _ => Err("No corresponding CameraOrientationType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum AttitudeStage {
    Failed,
    Aligning,
    Degraded,
    Valid,
}
impl fmt::Display for AttitudeStage {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AttitudeStage::Failed => f.write_str("failed"),
            AttitudeStage::Aligning => f.write_str("aligning"),
            AttitudeStage::Degraded => f.write_str("degraded"),
            AttitudeStage::Valid => f.write_str("valid"),
        }
    }
}
impl AttitudeStage {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            AttitudeStage::Failed => fit::Value::Enum(0),
            AttitudeStage::Aligning => fit::Value::Enum(1),
            AttitudeStage::Degraded => fit::Value::Enum(2),
            AttitudeStage::Valid => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for AttitudeStage {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(AttitudeStage::Failed),
            fit::Value::Enum(1) => Ok(AttitudeStage::Aligning),
            fit::Value::Enum(2) => Ok(AttitudeStage::Degraded),
            fit::Value::Enum(3) => Ok(AttitudeStage::Valid),
            _ => Err("No corresponding AttitudeStage exists"),
        }
    }
}
impl TryFrom<&str> for AttitudeStage {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "failed" => Ok(AttitudeStage::Failed),
            "aligning" => Ok(AttitudeStage::Aligning),
            "degraded" => Ok(AttitudeStage::Degraded),
            "valid" => Ok(AttitudeStage::Valid),
            _ => Err("No corresponding AttitudeStage exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum AttitudeValidity {
    TrackAngleHeadingValid,
    PitchValid,
    RollValid,
    LateralBodyAccelValid,
    NormalBodyAccelValid,
    TurnRateValid,
    HwFail,
    MagInvalid,
    NoGps,
    GpsInvalid,
    SolutionCoasting,
    TrueTrackAngle,
    MagneticHeading,
}
impl fmt::Display for AttitudeValidity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AttitudeValidity::TrackAngleHeadingValid => f.write_str("track_angle_heading_valid"),
            AttitudeValidity::PitchValid => f.write_str("pitch_valid"),
            AttitudeValidity::RollValid => f.write_str("roll_valid"),
            AttitudeValidity::LateralBodyAccelValid => f.write_str("lateral_body_accel_valid"),
            AttitudeValidity::NormalBodyAccelValid => f.write_str("normal_body_accel_valid"),
            AttitudeValidity::TurnRateValid => f.write_str("turn_rate_valid"),
            AttitudeValidity::HwFail => f.write_str("hw_fail"),
            AttitudeValidity::MagInvalid => f.write_str("mag_invalid"),
            AttitudeValidity::NoGps => f.write_str("no_gps"),
            AttitudeValidity::GpsInvalid => f.write_str("gps_invalid"),
            AttitudeValidity::SolutionCoasting => f.write_str("solution_coasting"),
            AttitudeValidity::TrueTrackAngle => f.write_str("true_track_angle"),
            AttitudeValidity::MagneticHeading => f.write_str("magnetic_heading"),
        }
    }
}
impl AttitudeValidity {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            AttitudeValidity::TrackAngleHeadingValid => fit::Value::UInt16(0x0001),
            AttitudeValidity::PitchValid => fit::Value::UInt16(0x0002),
            AttitudeValidity::RollValid => fit::Value::UInt16(0x0004),
            AttitudeValidity::LateralBodyAccelValid => fit::Value::UInt16(0x0008),
            AttitudeValidity::NormalBodyAccelValid => fit::Value::UInt16(0x0010),
            AttitudeValidity::TurnRateValid => fit::Value::UInt16(0x0020),
            AttitudeValidity::HwFail => fit::Value::UInt16(0x0040),
            AttitudeValidity::MagInvalid => fit::Value::UInt16(0x0080),
            AttitudeValidity::NoGps => fit::Value::UInt16(0x0100),
            AttitudeValidity::GpsInvalid => fit::Value::UInt16(0x0200),
            AttitudeValidity::SolutionCoasting => fit::Value::UInt16(0x0400),
            AttitudeValidity::TrueTrackAngle => fit::Value::UInt16(0x0800),
            AttitudeValidity::MagneticHeading => fit::Value::UInt16(0x1000),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for AttitudeValidity {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0x0001) => Ok(AttitudeValidity::TrackAngleHeadingValid),
            fit::Value::UInt16(0x0002) => Ok(AttitudeValidity::PitchValid),
            fit::Value::UInt16(0x0004) => Ok(AttitudeValidity::RollValid),
            fit::Value::UInt16(0x0008) => Ok(AttitudeValidity::LateralBodyAccelValid),
            fit::Value::UInt16(0x0010) => Ok(AttitudeValidity::NormalBodyAccelValid),
            fit::Value::UInt16(0x0020) => Ok(AttitudeValidity::TurnRateValid),
            fit::Value::UInt16(0x0040) => Ok(AttitudeValidity::HwFail),
            fit::Value::UInt16(0x0080) => Ok(AttitudeValidity::MagInvalid),
            fit::Value::UInt16(0x0100) => Ok(AttitudeValidity::NoGps),
            fit::Value::UInt16(0x0200) => Ok(AttitudeValidity::GpsInvalid),
            fit::Value::UInt16(0x0400) => Ok(AttitudeValidity::SolutionCoasting),
            fit::Value::UInt16(0x0800) => Ok(AttitudeValidity::TrueTrackAngle),
            fit::Value::UInt16(0x1000) => Ok(AttitudeValidity::MagneticHeading),
            _ => Err("No corresponding AttitudeValidity exists"),
        }
    }
}
impl TryFrom<&str> for AttitudeValidity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "track_angle_heading_valid" => Ok(AttitudeValidity::TrackAngleHeadingValid),
            "pitch_valid" => Ok(AttitudeValidity::PitchValid),
            "roll_valid" => Ok(AttitudeValidity::RollValid),
            "lateral_body_accel_valid" => Ok(AttitudeValidity::LateralBodyAccelValid),
            "normal_body_accel_valid" => Ok(AttitudeValidity::NormalBodyAccelValid),
            "turn_rate_valid" => Ok(AttitudeValidity::TurnRateValid),
            "hw_fail" => Ok(AttitudeValidity::HwFail),
            "mag_invalid" => Ok(AttitudeValidity::MagInvalid),
            "no_gps" => Ok(AttitudeValidity::NoGps),
            "gps_invalid" => Ok(AttitudeValidity::GpsInvalid),
            "solution_coasting" => Ok(AttitudeValidity::SolutionCoasting),
            "true_track_angle" => Ok(AttitudeValidity::TrueTrackAngle),
            "magnetic_heading" => Ok(AttitudeValidity::MagneticHeading),
            _ => Err("No corresponding AttitudeValidity exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum AutoSyncFrequency {
    Never,
    Occasionally,
    Frequent,
    OnceADay,
    Remote,
}
impl fmt::Display for AutoSyncFrequency {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AutoSyncFrequency::Never => f.write_str("never"),
            AutoSyncFrequency::Occasionally => f.write_str("occasionally"),
            AutoSyncFrequency::Frequent => f.write_str("frequent"),
            AutoSyncFrequency::OnceADay => f.write_str("once_a_day"),
            AutoSyncFrequency::Remote => f.write_str("remote"),
        }
    }
}
impl AutoSyncFrequency {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            AutoSyncFrequency::Never => fit::Value::Enum(0),
            AutoSyncFrequency::Occasionally => fit::Value::Enum(1),
            AutoSyncFrequency::Frequent => fit::Value::Enum(2),
            AutoSyncFrequency::OnceADay => fit::Value::Enum(3),
            AutoSyncFrequency::Remote => fit::Value::Enum(4),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for AutoSyncFrequency {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(AutoSyncFrequency::Never),
            fit::Value::Enum(1) => Ok(AutoSyncFrequency::Occasionally),
            fit::Value::Enum(2) => Ok(AutoSyncFrequency::Frequent),
            fit::Value::Enum(3) => Ok(AutoSyncFrequency::OnceADay),
            fit::Value::Enum(4) => Ok(AutoSyncFrequency::Remote),
            _ => Err("No corresponding AutoSyncFrequency exists"),
        }
    }
}
impl TryFrom<&str> for AutoSyncFrequency {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "never" => Ok(AutoSyncFrequency::Never),
            "occasionally" => Ok(AutoSyncFrequency::Occasionally),
            "frequent" => Ok(AutoSyncFrequency::Frequent),
            "once_a_day" => Ok(AutoSyncFrequency::OnceADay),
            "remote" => Ok(AutoSyncFrequency::Remote),
            _ => Err("No corresponding AutoSyncFrequency exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ExdLayout {
    FullScreen,
    HalfVertical,
    HalfHorizontal,
    HalfVerticalRightSplit,
    HalfHorizontalBottomSplit,
    FullQuarterSplit,
    HalfVerticalLeftSplit,
    HalfHorizontalTopSplit,
    /// The EXD may display the configured concepts in any layout it sees fit.
    Dynamic,
}
impl fmt::Display for ExdLayout {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ExdLayout::FullScreen => f.write_str("full_screen"),
            ExdLayout::HalfVertical => f.write_str("half_vertical"),
            ExdLayout::HalfHorizontal => f.write_str("half_horizontal"),
            ExdLayout::HalfVerticalRightSplit => f.write_str("half_vertical_right_split"),
            ExdLayout::HalfHorizontalBottomSplit => f.write_str("half_horizontal_bottom_split"),
            ExdLayout::FullQuarterSplit => f.write_str("full_quarter_split"),
            ExdLayout::HalfVerticalLeftSplit => f.write_str("half_vertical_left_split"),
            ExdLayout::HalfHorizontalTopSplit => f.write_str("half_horizontal_top_split"),
            ExdLayout::Dynamic => f.write_str("dynamic"),
        }
    }
}
impl ExdLayout {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ExdLayout::FullScreen => fit::Value::Enum(0),
            ExdLayout::HalfVertical => fit::Value::Enum(1),
            ExdLayout::HalfHorizontal => fit::Value::Enum(2),
            ExdLayout::HalfVerticalRightSplit => fit::Value::Enum(3),
            ExdLayout::HalfHorizontalBottomSplit => fit::Value::Enum(4),
            ExdLayout::FullQuarterSplit => fit::Value::Enum(5),
            ExdLayout::HalfVerticalLeftSplit => fit::Value::Enum(6),
            ExdLayout::HalfHorizontalTopSplit => fit::Value::Enum(7),
            ExdLayout::Dynamic => fit::Value::Enum(8),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for ExdLayout {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(ExdLayout::FullScreen),
            fit::Value::Enum(1) => Ok(ExdLayout::HalfVertical),
            fit::Value::Enum(2) => Ok(ExdLayout::HalfHorizontal),
            fit::Value::Enum(3) => Ok(ExdLayout::HalfVerticalRightSplit),
            fit::Value::Enum(4) => Ok(ExdLayout::HalfHorizontalBottomSplit),
            fit::Value::Enum(5) => Ok(ExdLayout::FullQuarterSplit),
            fit::Value::Enum(6) => Ok(ExdLayout::HalfVerticalLeftSplit),
            fit::Value::Enum(7) => Ok(ExdLayout::HalfHorizontalTopSplit),
            fit::Value::Enum(8) => Ok(ExdLayout::Dynamic),
            _ => Err("No corresponding ExdLayout exists"),
        }
    }
}
impl TryFrom<&str> for ExdLayout {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "full_screen" => Ok(ExdLayout::FullScreen),
            "half_vertical" => Ok(ExdLayout::HalfVertical),
            "half_horizontal" => Ok(ExdLayout::HalfHorizontal),
            "half_vertical_right_split" => Ok(ExdLayout::HalfVerticalRightSplit),
            "half_horizontal_bottom_split" => Ok(ExdLayout::HalfHorizontalBottomSplit),
            "full_quarter_split" => Ok(ExdLayout::FullQuarterSplit),
            "half_vertical_left_split" => Ok(ExdLayout::HalfVerticalLeftSplit),
            "half_horizontal_top_split" => Ok(ExdLayout::HalfHorizontalTopSplit),
            "dynamic" => Ok(ExdLayout::Dynamic),
            _ => Err("No corresponding ExdLayout exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ExdDisplayType {
    Numerical,
    Simple,
    Graph,
    Bar,
    CircleGraph,
    VirtualPartner,
    Balance,
    StringList,
    String,
    SimpleDynamicIcon,
    Gauge,
}
impl fmt::Display for ExdDisplayType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ExdDisplayType::Numerical => f.write_str("numerical"),
            ExdDisplayType::Simple => f.write_str("simple"),
            ExdDisplayType::Graph => f.write_str("graph"),
            ExdDisplayType::Bar => f.write_str("bar"),
            ExdDisplayType::CircleGraph => f.write_str("circle_graph"),
            ExdDisplayType::VirtualPartner => f.write_str("virtual_partner"),
            ExdDisplayType::Balance => f.write_str("balance"),
            ExdDisplayType::StringList => f.write_str("string_list"),
            ExdDisplayType::String => f.write_str("string"),
            ExdDisplayType::SimpleDynamicIcon => f.write_str("simple_dynamic_icon"),
            ExdDisplayType::Gauge => f.write_str("gauge"),
        }
    }
}
impl ExdDisplayType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ExdDisplayType::Numerical => fit::Value::Enum(0),
            ExdDisplayType::Simple => fit::Value::Enum(1),
            ExdDisplayType::Graph => fit::Value::Enum(2),
            ExdDisplayType::Bar => fit::Value::Enum(3),
            ExdDisplayType::CircleGraph => fit::Value::Enum(4),
            ExdDisplayType::VirtualPartner => fit::Value::Enum(5),
            ExdDisplayType::Balance => fit::Value::Enum(6),
            ExdDisplayType::StringList => fit::Value::Enum(7),
            ExdDisplayType::String => fit::Value::Enum(8),
            ExdDisplayType::SimpleDynamicIcon => fit::Value::Enum(9),
            ExdDisplayType::Gauge => fit::Value::Enum(10),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for ExdDisplayType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(ExdDisplayType::Numerical),
            fit::Value::Enum(1) => Ok(ExdDisplayType::Simple),
            fit::Value::Enum(2) => Ok(ExdDisplayType::Graph),
            fit::Value::Enum(3) => Ok(ExdDisplayType::Bar),
            fit::Value::Enum(4) => Ok(ExdDisplayType::CircleGraph),
            fit::Value::Enum(5) => Ok(ExdDisplayType::VirtualPartner),
            fit::Value::Enum(6) => Ok(ExdDisplayType::Balance),
            fit::Value::Enum(7) => Ok(ExdDisplayType::StringList),
            fit::Value::Enum(8) => Ok(ExdDisplayType::String),
            fit::Value::Enum(9) => Ok(ExdDisplayType::SimpleDynamicIcon),
            fit::Value::Enum(10) => Ok(ExdDisplayType::Gauge),
            _ => Err("No corresponding ExdDisplayType exists"),
        }
    }
}
impl TryFrom<&str> for ExdDisplayType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "numerical" => Ok(ExdDisplayType::Numerical),
            "simple" => Ok(ExdDisplayType::Simple),
            "graph" => Ok(ExdDisplayType::Graph),
            "bar" => Ok(ExdDisplayType::Bar),
            "circle_graph" => Ok(ExdDisplayType::CircleGraph),
            "virtual_partner" => Ok(ExdDisplayType::VirtualPartner),
            "balance" => Ok(ExdDisplayType::Balance),
            "string_list" => Ok(ExdDisplayType::StringList),
            "string" => Ok(ExdDisplayType::String),
            "simple_dynamic_icon" => Ok(ExdDisplayType::SimpleDynamicIcon),
            "gauge" => Ok(ExdDisplayType::Gauge),
            _ => Err("No corresponding ExdDisplayType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ExdDataUnits {
    NoUnits,
    Laps,
    MilesPerHour,
    KilometersPerHour,
    FeetPerHour,
    MetersPerHour,
    DegreesCelsius,
    DegreesFarenheit,
    Zone,
    Gear,
    Rpm,
    Bpm,
    Degrees,
    Millimeters,
    Meters,
    Kilometers,
    Feet,
    Yards,
    Kilofeet,
    Miles,
    Time,
    EnumTurnType,
    Percent,
    Watts,
    WattsPerKilogram,
    EnumBatteryStatus,
    EnumBikeLightBeamAngleMode,
    EnumBikeLightBatteryStatus,
    EnumBikeLightNetworkConfigType,
    Lights,
    Seconds,
    Minutes,
    Hours,
    Calories,
    Kilojoules,
    Milliseconds,
    SecondPerMile,
    SecondPerKilometer,
    Centimeter,
    EnumCoursePoint,
    Bradians,
    EnumSport,
    InchesHg,
    MmHg,
    Mbars,
    HectoPascals,
    FeetPerMin,
    MetersPerMin,
    MetersPerSec,
    EightCardinal,
}
impl fmt::Display for ExdDataUnits {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ExdDataUnits::NoUnits => f.write_str("no_units"),
            ExdDataUnits::Laps => f.write_str("laps"),
            ExdDataUnits::MilesPerHour => f.write_str("miles_per_hour"),
            ExdDataUnits::KilometersPerHour => f.write_str("kilometers_per_hour"),
            ExdDataUnits::FeetPerHour => f.write_str("feet_per_hour"),
            ExdDataUnits::MetersPerHour => f.write_str("meters_per_hour"),
            ExdDataUnits::DegreesCelsius => f.write_str("degrees_celsius"),
            ExdDataUnits::DegreesFarenheit => f.write_str("degrees_farenheit"),
            ExdDataUnits::Zone => f.write_str("zone"),
            ExdDataUnits::Gear => f.write_str("gear"),
            ExdDataUnits::Rpm => f.write_str("rpm"),
            ExdDataUnits::Bpm => f.write_str("bpm"),
            ExdDataUnits::Degrees => f.write_str("degrees"),
            ExdDataUnits::Millimeters => f.write_str("millimeters"),
            ExdDataUnits::Meters => f.write_str("meters"),
            ExdDataUnits::Kilometers => f.write_str("kilometers"),
            ExdDataUnits::Feet => f.write_str("feet"),
            ExdDataUnits::Yards => f.write_str("yards"),
            ExdDataUnits::Kilofeet => f.write_str("kilofeet"),
            ExdDataUnits::Miles => f.write_str("miles"),
            ExdDataUnits::Time => f.write_str("time"),
            ExdDataUnits::EnumTurnType => f.write_str("enum_turn_type"),
            ExdDataUnits::Percent => f.write_str("percent"),
            ExdDataUnits::Watts => f.write_str("watts"),
            ExdDataUnits::WattsPerKilogram => f.write_str("watts_per_kilogram"),
            ExdDataUnits::EnumBatteryStatus => f.write_str("enum_battery_status"),
            ExdDataUnits::EnumBikeLightBeamAngleMode => {
                f.write_str("enum_bike_light_beam_angle_mode")
            }
            ExdDataUnits::EnumBikeLightBatteryStatus => {
                f.write_str("enum_bike_light_battery_status")
            }
            ExdDataUnits::EnumBikeLightNetworkConfigType => {
                f.write_str("enum_bike_light_network_config_type")
            }
            ExdDataUnits::Lights => f.write_str("lights"),
            ExdDataUnits::Seconds => f.write_str("seconds"),
            ExdDataUnits::Minutes => f.write_str("minutes"),
            ExdDataUnits::Hours => f.write_str("hours"),
            ExdDataUnits::Calories => f.write_str("calories"),
            ExdDataUnits::Kilojoules => f.write_str("kilojoules"),
            ExdDataUnits::Milliseconds => f.write_str("milliseconds"),
            ExdDataUnits::SecondPerMile => f.write_str("second_per_mile"),
            ExdDataUnits::SecondPerKilometer => f.write_str("second_per_kilometer"),
            ExdDataUnits::Centimeter => f.write_str("centimeter"),
            ExdDataUnits::EnumCoursePoint => f.write_str("enum_course_point"),
            ExdDataUnits::Bradians => f.write_str("bradians"),
            ExdDataUnits::EnumSport => f.write_str("enum_sport"),
            ExdDataUnits::InchesHg => f.write_str("inches_hg"),
            ExdDataUnits::MmHg => f.write_str("mm_hg"),
            ExdDataUnits::Mbars => f.write_str("mbars"),
            ExdDataUnits::HectoPascals => f.write_str("hecto_pascals"),
            ExdDataUnits::FeetPerMin => f.write_str("feet_per_min"),
            ExdDataUnits::MetersPerMin => f.write_str("meters_per_min"),
            ExdDataUnits::MetersPerSec => f.write_str("meters_per_sec"),
            ExdDataUnits::EightCardinal => f.write_str("eight_cardinal"),
        }
    }
}
impl ExdDataUnits {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ExdDataUnits::NoUnits => fit::Value::Enum(0),
            ExdDataUnits::Laps => fit::Value::Enum(1),
            ExdDataUnits::MilesPerHour => fit::Value::Enum(2),
            ExdDataUnits::KilometersPerHour => fit::Value::Enum(3),
            ExdDataUnits::FeetPerHour => fit::Value::Enum(4),
            ExdDataUnits::MetersPerHour => fit::Value::Enum(5),
            ExdDataUnits::DegreesCelsius => fit::Value::Enum(6),
            ExdDataUnits::DegreesFarenheit => fit::Value::Enum(7),
            ExdDataUnits::Zone => fit::Value::Enum(8),
            ExdDataUnits::Gear => fit::Value::Enum(9),
            ExdDataUnits::Rpm => fit::Value::Enum(10),
            ExdDataUnits::Bpm => fit::Value::Enum(11),
            ExdDataUnits::Degrees => fit::Value::Enum(12),
            ExdDataUnits::Millimeters => fit::Value::Enum(13),
            ExdDataUnits::Meters => fit::Value::Enum(14),
            ExdDataUnits::Kilometers => fit::Value::Enum(15),
            ExdDataUnits::Feet => fit::Value::Enum(16),
            ExdDataUnits::Yards => fit::Value::Enum(17),
            ExdDataUnits::Kilofeet => fit::Value::Enum(18),
            ExdDataUnits::Miles => fit::Value::Enum(19),
            ExdDataUnits::Time => fit::Value::Enum(20),
            ExdDataUnits::EnumTurnType => fit::Value::Enum(21),
            ExdDataUnits::Percent => fit::Value::Enum(22),
            ExdDataUnits::Watts => fit::Value::Enum(23),
            ExdDataUnits::WattsPerKilogram => fit::Value::Enum(24),
            ExdDataUnits::EnumBatteryStatus => fit::Value::Enum(25),
            ExdDataUnits::EnumBikeLightBeamAngleMode => fit::Value::Enum(26),
            ExdDataUnits::EnumBikeLightBatteryStatus => fit::Value::Enum(27),
            ExdDataUnits::EnumBikeLightNetworkConfigType => fit::Value::Enum(28),
            ExdDataUnits::Lights => fit::Value::Enum(29),
            ExdDataUnits::Seconds => fit::Value::Enum(30),
            ExdDataUnits::Minutes => fit::Value::Enum(31),
            ExdDataUnits::Hours => fit::Value::Enum(32),
            ExdDataUnits::Calories => fit::Value::Enum(33),
            ExdDataUnits::Kilojoules => fit::Value::Enum(34),
            ExdDataUnits::Milliseconds => fit::Value::Enum(35),
            ExdDataUnits::SecondPerMile => fit::Value::Enum(36),
            ExdDataUnits::SecondPerKilometer => fit::Value::Enum(37),
            ExdDataUnits::Centimeter => fit::Value::Enum(38),
            ExdDataUnits::EnumCoursePoint => fit::Value::Enum(39),
            ExdDataUnits::Bradians => fit::Value::Enum(40),
            ExdDataUnits::EnumSport => fit::Value::Enum(41),
            ExdDataUnits::InchesHg => fit::Value::Enum(42),
            ExdDataUnits::MmHg => fit::Value::Enum(43),
            ExdDataUnits::Mbars => fit::Value::Enum(44),
            ExdDataUnits::HectoPascals => fit::Value::Enum(45),
            ExdDataUnits::FeetPerMin => fit::Value::Enum(46),
            ExdDataUnits::MetersPerMin => fit::Value::Enum(47),
            ExdDataUnits::MetersPerSec => fit::Value::Enum(48),
            ExdDataUnits::EightCardinal => fit::Value::Enum(49),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for ExdDataUnits {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(ExdDataUnits::NoUnits),
            fit::Value::Enum(1) => Ok(ExdDataUnits::Laps),
            fit::Value::Enum(2) => Ok(ExdDataUnits::MilesPerHour),
            fit::Value::Enum(3) => Ok(ExdDataUnits::KilometersPerHour),
            fit::Value::Enum(4) => Ok(ExdDataUnits::FeetPerHour),
            fit::Value::Enum(5) => Ok(ExdDataUnits::MetersPerHour),
            fit::Value::Enum(6) => Ok(ExdDataUnits::DegreesCelsius),
            fit::Value::Enum(7) => Ok(ExdDataUnits::DegreesFarenheit),
            fit::Value::Enum(8) => Ok(ExdDataUnits::Zone),
            fit::Value::Enum(9) => Ok(ExdDataUnits::Gear),
            fit::Value::Enum(10) => Ok(ExdDataUnits::Rpm),
            fit::Value::Enum(11) => Ok(ExdDataUnits::Bpm),
            fit::Value::Enum(12) => Ok(ExdDataUnits::Degrees),
            fit::Value::Enum(13) => Ok(ExdDataUnits::Millimeters),
            fit::Value::Enum(14) => Ok(ExdDataUnits::Meters),
            fit::Value::Enum(15) => Ok(ExdDataUnits::Kilometers),
            fit::Value::Enum(16) => Ok(ExdDataUnits::Feet),
            fit::Value::Enum(17) => Ok(ExdDataUnits::Yards),
            fit::Value::Enum(18) => Ok(ExdDataUnits::Kilofeet),
            fit::Value::Enum(19) => Ok(ExdDataUnits::Miles),
            fit::Value::Enum(20) => Ok(ExdDataUnits::Time),
            fit::Value::Enum(21) => Ok(ExdDataUnits::EnumTurnType),
            fit::Value::Enum(22) => Ok(ExdDataUnits::Percent),
            fit::Value::Enum(23) => Ok(ExdDataUnits::Watts),
            fit::Value::Enum(24) => Ok(ExdDataUnits::WattsPerKilogram),
            fit::Value::Enum(25) => Ok(ExdDataUnits::EnumBatteryStatus),
            fit::Value::Enum(26) => Ok(ExdDataUnits::EnumBikeLightBeamAngleMode),
            fit::Value::Enum(27) => Ok(ExdDataUnits::EnumBikeLightBatteryStatus),
            fit::Value::Enum(28) => Ok(ExdDataUnits::EnumBikeLightNetworkConfigType),
            fit::Value::Enum(29) => Ok(ExdDataUnits::Lights),
            fit::Value::Enum(30) => Ok(ExdDataUnits::Seconds),
            fit::Value::Enum(31) => Ok(ExdDataUnits::Minutes),
            fit::Value::Enum(32) => Ok(ExdDataUnits::Hours),
            fit::Value::Enum(33) => Ok(ExdDataUnits::Calories),
            fit::Value::Enum(34) => Ok(ExdDataUnits::Kilojoules),
            fit::Value::Enum(35) => Ok(ExdDataUnits::Milliseconds),
            fit::Value::Enum(36) => Ok(ExdDataUnits::SecondPerMile),
            fit::Value::Enum(37) => Ok(ExdDataUnits::SecondPerKilometer),
            fit::Value::Enum(38) => Ok(ExdDataUnits::Centimeter),
            fit::Value::Enum(39) => Ok(ExdDataUnits::EnumCoursePoint),
            fit::Value::Enum(40) => Ok(ExdDataUnits::Bradians),
            fit::Value::Enum(41) => Ok(ExdDataUnits::EnumSport),
            fit::Value::Enum(42) => Ok(ExdDataUnits::InchesHg),
            fit::Value::Enum(43) => Ok(ExdDataUnits::MmHg),
            fit::Value::Enum(44) => Ok(ExdDataUnits::Mbars),
            fit::Value::Enum(45) => Ok(ExdDataUnits::HectoPascals),
            fit::Value::Enum(46) => Ok(ExdDataUnits::FeetPerMin),
            fit::Value::Enum(47) => Ok(ExdDataUnits::MetersPerMin),
            fit::Value::Enum(48) => Ok(ExdDataUnits::MetersPerSec),
            fit::Value::Enum(49) => Ok(ExdDataUnits::EightCardinal),
            _ => Err("No corresponding ExdDataUnits exists"),
        }
    }
}
impl TryFrom<&str> for ExdDataUnits {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "no_units" => Ok(ExdDataUnits::NoUnits),
            "laps" => Ok(ExdDataUnits::Laps),
            "miles_per_hour" => Ok(ExdDataUnits::MilesPerHour),
            "kilometers_per_hour" => Ok(ExdDataUnits::KilometersPerHour),
            "feet_per_hour" => Ok(ExdDataUnits::FeetPerHour),
            "meters_per_hour" => Ok(ExdDataUnits::MetersPerHour),
            "degrees_celsius" => Ok(ExdDataUnits::DegreesCelsius),
            "degrees_farenheit" => Ok(ExdDataUnits::DegreesFarenheit),
            "zone" => Ok(ExdDataUnits::Zone),
            "gear" => Ok(ExdDataUnits::Gear),
            "rpm" => Ok(ExdDataUnits::Rpm),
            "bpm" => Ok(ExdDataUnits::Bpm),
            "degrees" => Ok(ExdDataUnits::Degrees),
            "millimeters" => Ok(ExdDataUnits::Millimeters),
            "meters" => Ok(ExdDataUnits::Meters),
            "kilometers" => Ok(ExdDataUnits::Kilometers),
            "feet" => Ok(ExdDataUnits::Feet),
            "yards" => Ok(ExdDataUnits::Yards),
            "kilofeet" => Ok(ExdDataUnits::Kilofeet),
            "miles" => Ok(ExdDataUnits::Miles),
            "time" => Ok(ExdDataUnits::Time),
            "enum_turn_type" => Ok(ExdDataUnits::EnumTurnType),
            "percent" => Ok(ExdDataUnits::Percent),
            "watts" => Ok(ExdDataUnits::Watts),
            "watts_per_kilogram" => Ok(ExdDataUnits::WattsPerKilogram),
            "enum_battery_status" => Ok(ExdDataUnits::EnumBatteryStatus),
            "enum_bike_light_beam_angle_mode" => Ok(ExdDataUnits::EnumBikeLightBeamAngleMode),
            "enum_bike_light_battery_status" => Ok(ExdDataUnits::EnumBikeLightBatteryStatus),
            "enum_bike_light_network_config_type" => {
                Ok(ExdDataUnits::EnumBikeLightNetworkConfigType)
            }
            "lights" => Ok(ExdDataUnits::Lights),
            "seconds" => Ok(ExdDataUnits::Seconds),
            "minutes" => Ok(ExdDataUnits::Minutes),
            "hours" => Ok(ExdDataUnits::Hours),
            "calories" => Ok(ExdDataUnits::Calories),
            "kilojoules" => Ok(ExdDataUnits::Kilojoules),
            "milliseconds" => Ok(ExdDataUnits::Milliseconds),
            "second_per_mile" => Ok(ExdDataUnits::SecondPerMile),
            "second_per_kilometer" => Ok(ExdDataUnits::SecondPerKilometer),
            "centimeter" => Ok(ExdDataUnits::Centimeter),
            "enum_course_point" => Ok(ExdDataUnits::EnumCoursePoint),
            "bradians" => Ok(ExdDataUnits::Bradians),
            "enum_sport" => Ok(ExdDataUnits::EnumSport),
            "inches_hg" => Ok(ExdDataUnits::InchesHg),
            "mm_hg" => Ok(ExdDataUnits::MmHg),
            "mbars" => Ok(ExdDataUnits::Mbars),
            "hecto_pascals" => Ok(ExdDataUnits::HectoPascals),
            "feet_per_min" => Ok(ExdDataUnits::FeetPerMin),
            "meters_per_min" => Ok(ExdDataUnits::MetersPerMin),
            "meters_per_sec" => Ok(ExdDataUnits::MetersPerSec),
            "eight_cardinal" => Ok(ExdDataUnits::EightCardinal),
            _ => Err("No corresponding ExdDataUnits exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ExdQualifiers {
    NoQualifier,
    Instantaneous,
    Average,
    Lap,
    Maximum,
    MaximumAverage,
    MaximumLap,
    LastLap,
    AverageLap,
    ToDestination,
    ToGo,
    ToNext,
    NextCoursePoint,
    Total,
    ThreeSecondAverage,
    TenSecondAverage,
    ThirtySecondAverage,
    PercentMaximum,
    PercentMaximumAverage,
    LapPercentMaximum,
    Elapsed,
    Sunrise,
    Sunset,
    ComparedToVirtualPartner,
    Maximum24h,
    Minimum24h,
    Minimum,
    First,
    Second,
    Third,
    Shifter,
    LastSport,
    Moving,
    Stopped,
    EstimatedTotal,
    Zone9,
    Zone8,
    Zone7,
    Zone6,
    Zone5,
    Zone4,
    Zone3,
    Zone2,
    Zone1,
}
impl fmt::Display for ExdQualifiers {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ExdQualifiers::NoQualifier => f.write_str("no_qualifier"),
            ExdQualifiers::Instantaneous => f.write_str("instantaneous"),
            ExdQualifiers::Average => f.write_str("average"),
            ExdQualifiers::Lap => f.write_str("lap"),
            ExdQualifiers::Maximum => f.write_str("maximum"),
            ExdQualifiers::MaximumAverage => f.write_str("maximum_average"),
            ExdQualifiers::MaximumLap => f.write_str("maximum_lap"),
            ExdQualifiers::LastLap => f.write_str("last_lap"),
            ExdQualifiers::AverageLap => f.write_str("average_lap"),
            ExdQualifiers::ToDestination => f.write_str("to_destination"),
            ExdQualifiers::ToGo => f.write_str("to_go"),
            ExdQualifiers::ToNext => f.write_str("to_next"),
            ExdQualifiers::NextCoursePoint => f.write_str("next_course_point"),
            ExdQualifiers::Total => f.write_str("total"),
            ExdQualifiers::ThreeSecondAverage => f.write_str("three_second_average"),
            ExdQualifiers::TenSecondAverage => f.write_str("ten_second_average"),
            ExdQualifiers::ThirtySecondAverage => f.write_str("thirty_second_average"),
            ExdQualifiers::PercentMaximum => f.write_str("percent_maximum"),
            ExdQualifiers::PercentMaximumAverage => f.write_str("percent_maximum_average"),
            ExdQualifiers::LapPercentMaximum => f.write_str("lap_percent_maximum"),
            ExdQualifiers::Elapsed => f.write_str("elapsed"),
            ExdQualifiers::Sunrise => f.write_str("sunrise"),
            ExdQualifiers::Sunset => f.write_str("sunset"),
            ExdQualifiers::ComparedToVirtualPartner => f.write_str("compared_to_virtual_partner"),
            ExdQualifiers::Maximum24h => f.write_str("maximum_24h"),
            ExdQualifiers::Minimum24h => f.write_str("minimum_24h"),
            ExdQualifiers::Minimum => f.write_str("minimum"),
            ExdQualifiers::First => f.write_str("first"),
            ExdQualifiers::Second => f.write_str("second"),
            ExdQualifiers::Third => f.write_str("third"),
            ExdQualifiers::Shifter => f.write_str("shifter"),
            ExdQualifiers::LastSport => f.write_str("last_sport"),
            ExdQualifiers::Moving => f.write_str("moving"),
            ExdQualifiers::Stopped => f.write_str("stopped"),
            ExdQualifiers::EstimatedTotal => f.write_str("estimated_total"),
            ExdQualifiers::Zone9 => f.write_str("zone_9"),
            ExdQualifiers::Zone8 => f.write_str("zone_8"),
            ExdQualifiers::Zone7 => f.write_str("zone_7"),
            ExdQualifiers::Zone6 => f.write_str("zone_6"),
            ExdQualifiers::Zone5 => f.write_str("zone_5"),
            ExdQualifiers::Zone4 => f.write_str("zone_4"),
            ExdQualifiers::Zone3 => f.write_str("zone_3"),
            ExdQualifiers::Zone2 => f.write_str("zone_2"),
            ExdQualifiers::Zone1 => f.write_str("zone_1"),
        }
    }
}
impl ExdQualifiers {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ExdQualifiers::NoQualifier => fit::Value::Enum(0),
            ExdQualifiers::Instantaneous => fit::Value::Enum(1),
            ExdQualifiers::Average => fit::Value::Enum(2),
            ExdQualifiers::Lap => fit::Value::Enum(3),
            ExdQualifiers::Maximum => fit::Value::Enum(4),
            ExdQualifiers::MaximumAverage => fit::Value::Enum(5),
            ExdQualifiers::MaximumLap => fit::Value::Enum(6),
            ExdQualifiers::LastLap => fit::Value::Enum(7),
            ExdQualifiers::AverageLap => fit::Value::Enum(8),
            ExdQualifiers::ToDestination => fit::Value::Enum(9),
            ExdQualifiers::ToGo => fit::Value::Enum(10),
            ExdQualifiers::ToNext => fit::Value::Enum(11),
            ExdQualifiers::NextCoursePoint => fit::Value::Enum(12),
            ExdQualifiers::Total => fit::Value::Enum(13),
            ExdQualifiers::ThreeSecondAverage => fit::Value::Enum(14),
            ExdQualifiers::TenSecondAverage => fit::Value::Enum(15),
            ExdQualifiers::ThirtySecondAverage => fit::Value::Enum(16),
            ExdQualifiers::PercentMaximum => fit::Value::Enum(17),
            ExdQualifiers::PercentMaximumAverage => fit::Value::Enum(18),
            ExdQualifiers::LapPercentMaximum => fit::Value::Enum(19),
            ExdQualifiers::Elapsed => fit::Value::Enum(20),
            ExdQualifiers::Sunrise => fit::Value::Enum(21),
            ExdQualifiers::Sunset => fit::Value::Enum(22),
            ExdQualifiers::ComparedToVirtualPartner => fit::Value::Enum(23),
            ExdQualifiers::Maximum24h => fit::Value::Enum(24),
            ExdQualifiers::Minimum24h => fit::Value::Enum(25),
            ExdQualifiers::Minimum => fit::Value::Enum(26),
            ExdQualifiers::First => fit::Value::Enum(27),
            ExdQualifiers::Second => fit::Value::Enum(28),
            ExdQualifiers::Third => fit::Value::Enum(29),
            ExdQualifiers::Shifter => fit::Value::Enum(30),
            ExdQualifiers::LastSport => fit::Value::Enum(31),
            ExdQualifiers::Moving => fit::Value::Enum(32),
            ExdQualifiers::Stopped => fit::Value::Enum(33),
            ExdQualifiers::EstimatedTotal => fit::Value::Enum(34),
            ExdQualifiers::Zone9 => fit::Value::Enum(242),
            ExdQualifiers::Zone8 => fit::Value::Enum(243),
            ExdQualifiers::Zone7 => fit::Value::Enum(244),
            ExdQualifiers::Zone6 => fit::Value::Enum(245),
            ExdQualifiers::Zone5 => fit::Value::Enum(246),
            ExdQualifiers::Zone4 => fit::Value::Enum(247),
            ExdQualifiers::Zone3 => fit::Value::Enum(248),
            ExdQualifiers::Zone2 => fit::Value::Enum(249),
            ExdQualifiers::Zone1 => fit::Value::Enum(250),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for ExdQualifiers {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(ExdQualifiers::NoQualifier),
            fit::Value::Enum(1) => Ok(ExdQualifiers::Instantaneous),
            fit::Value::Enum(2) => Ok(ExdQualifiers::Average),
            fit::Value::Enum(3) => Ok(ExdQualifiers::Lap),
            fit::Value::Enum(4) => Ok(ExdQualifiers::Maximum),
            fit::Value::Enum(5) => Ok(ExdQualifiers::MaximumAverage),
            fit::Value::Enum(6) => Ok(ExdQualifiers::MaximumLap),
            fit::Value::Enum(7) => Ok(ExdQualifiers::LastLap),
            fit::Value::Enum(8) => Ok(ExdQualifiers::AverageLap),
            fit::Value::Enum(9) => Ok(ExdQualifiers::ToDestination),
            fit::Value::Enum(10) => Ok(ExdQualifiers::ToGo),
            fit::Value::Enum(11) => Ok(ExdQualifiers::ToNext),
            fit::Value::Enum(12) => Ok(ExdQualifiers::NextCoursePoint),
            fit::Value::Enum(13) => Ok(ExdQualifiers::Total),
            fit::Value::Enum(14) => Ok(ExdQualifiers::ThreeSecondAverage),
            fit::Value::Enum(15) => Ok(ExdQualifiers::TenSecondAverage),
            fit::Value::Enum(16) => Ok(ExdQualifiers::ThirtySecondAverage),
            fit::Value::Enum(17) => Ok(ExdQualifiers::PercentMaximum),
            fit::Value::Enum(18) => Ok(ExdQualifiers::PercentMaximumAverage),
            fit::Value::Enum(19) => Ok(ExdQualifiers::LapPercentMaximum),
            fit::Value::Enum(20) => Ok(ExdQualifiers::Elapsed),
            fit::Value::Enum(21) => Ok(ExdQualifiers::Sunrise),
            fit::Value::Enum(22) => Ok(ExdQualifiers::Sunset),
            fit::Value::Enum(23) => Ok(ExdQualifiers::ComparedToVirtualPartner),
            fit::Value::Enum(24) => Ok(ExdQualifiers::Maximum24h),
            fit::Value::Enum(25) => Ok(ExdQualifiers::Minimum24h),
            fit::Value::Enum(26) => Ok(ExdQualifiers::Minimum),
            fit::Value::Enum(27) => Ok(ExdQualifiers::First),
            fit::Value::Enum(28) => Ok(ExdQualifiers::Second),
            fit::Value::Enum(29) => Ok(ExdQualifiers::Third),
            fit::Value::Enum(30) => Ok(ExdQualifiers::Shifter),
            fit::Value::Enum(31) => Ok(ExdQualifiers::LastSport),
            fit::Value::Enum(32) => Ok(ExdQualifiers::Moving),
            fit::Value::Enum(33) => Ok(ExdQualifiers::Stopped),
            fit::Value::Enum(34) => Ok(ExdQualifiers::EstimatedTotal),
            fit::Value::Enum(242) => Ok(ExdQualifiers::Zone9),
            fit::Value::Enum(243) => Ok(ExdQualifiers::Zone8),
            fit::Value::Enum(244) => Ok(ExdQualifiers::Zone7),
            fit::Value::Enum(245) => Ok(ExdQualifiers::Zone6),
            fit::Value::Enum(246) => Ok(ExdQualifiers::Zone5),
            fit::Value::Enum(247) => Ok(ExdQualifiers::Zone4),
            fit::Value::Enum(248) => Ok(ExdQualifiers::Zone3),
            fit::Value::Enum(249) => Ok(ExdQualifiers::Zone2),
            fit::Value::Enum(250) => Ok(ExdQualifiers::Zone1),
            _ => Err("No corresponding ExdQualifiers exists"),
        }
    }
}
impl TryFrom<&str> for ExdQualifiers {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "no_qualifier" => Ok(ExdQualifiers::NoQualifier),
            "instantaneous" => Ok(ExdQualifiers::Instantaneous),
            "average" => Ok(ExdQualifiers::Average),
            "lap" => Ok(ExdQualifiers::Lap),
            "maximum" => Ok(ExdQualifiers::Maximum),
            "maximum_average" => Ok(ExdQualifiers::MaximumAverage),
            "maximum_lap" => Ok(ExdQualifiers::MaximumLap),
            "last_lap" => Ok(ExdQualifiers::LastLap),
            "average_lap" => Ok(ExdQualifiers::AverageLap),
            "to_destination" => Ok(ExdQualifiers::ToDestination),
            "to_go" => Ok(ExdQualifiers::ToGo),
            "to_next" => Ok(ExdQualifiers::ToNext),
            "next_course_point" => Ok(ExdQualifiers::NextCoursePoint),
            "total" => Ok(ExdQualifiers::Total),
            "three_second_average" => Ok(ExdQualifiers::ThreeSecondAverage),
            "ten_second_average" => Ok(ExdQualifiers::TenSecondAverage),
            "thirty_second_average" => Ok(ExdQualifiers::ThirtySecondAverage),
            "percent_maximum" => Ok(ExdQualifiers::PercentMaximum),
            "percent_maximum_average" => Ok(ExdQualifiers::PercentMaximumAverage),
            "lap_percent_maximum" => Ok(ExdQualifiers::LapPercentMaximum),
            "elapsed" => Ok(ExdQualifiers::Elapsed),
            "sunrise" => Ok(ExdQualifiers::Sunrise),
            "sunset" => Ok(ExdQualifiers::Sunset),
            "compared_to_virtual_partner" => Ok(ExdQualifiers::ComparedToVirtualPartner),
            "maximum_24h" => Ok(ExdQualifiers::Maximum24h),
            "minimum_24h" => Ok(ExdQualifiers::Minimum24h),
            "minimum" => Ok(ExdQualifiers::Minimum),
            "first" => Ok(ExdQualifiers::First),
            "second" => Ok(ExdQualifiers::Second),
            "third" => Ok(ExdQualifiers::Third),
            "shifter" => Ok(ExdQualifiers::Shifter),
            "last_sport" => Ok(ExdQualifiers::LastSport),
            "moving" => Ok(ExdQualifiers::Moving),
            "stopped" => Ok(ExdQualifiers::Stopped),
            "estimated_total" => Ok(ExdQualifiers::EstimatedTotal),
            "zone_9" => Ok(ExdQualifiers::Zone9),
            "zone_8" => Ok(ExdQualifiers::Zone8),
            "zone_7" => Ok(ExdQualifiers::Zone7),
            "zone_6" => Ok(ExdQualifiers::Zone6),
            "zone_5" => Ok(ExdQualifiers::Zone5),
            "zone_4" => Ok(ExdQualifiers::Zone4),
            "zone_3" => Ok(ExdQualifiers::Zone3),
            "zone_2" => Ok(ExdQualifiers::Zone2),
            "zone_1" => Ok(ExdQualifiers::Zone1),
            _ => Err("No corresponding ExdQualifiers exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ExdDescriptors {
    BikeLightBatteryStatus,
    BeamAngleStatus,
    BateryLevel,
    LightNetworkMode,
    NumberLightsConnected,
    Cadence,
    Distance,
    EstimatedTimeOfArrival,
    Heading,
    Time,
    BatteryLevel,
    TrainerResistance,
    TrainerTargetPower,
    TimeSeated,
    TimeStanding,
    Elevation,
    Grade,
    Ascent,
    Descent,
    VerticalSpeed,
    Di2BatteryLevel,
    FrontGear,
    RearGear,
    GearRatio,
    HeartRate,
    HeartRateZone,
    TimeInHeartRateZone,
    HeartRateReserve,
    Calories,
    GpsAccuracy,
    GpsSignalStrength,
    Temperature,
    TimeOfDay,
    Balance,
    PedalSmoothness,
    Power,
    FunctionalThresholdPower,
    IntensityFactor,
    Work,
    PowerRatio,
    NormalizedPower,
    TrainingStressScore,
    TimeOnZone,
    Speed,
    Laps,
    Reps,
    WorkoutStep,
    CourseDistance,
    NavigationDistance,
    CourseEstimatedTimeOfArrival,
    NavigationEstimatedTimeOfArrival,
    CourseTime,
    NavigationTime,
    CourseHeading,
    NavigationHeading,
    PowerZone,
    TorqueEffectiveness,
    TimerTime,
    PowerWeightRatio,
    LeftPlatformCenterOffset,
    RightPlatformCenterOffset,
    LeftPowerPhaseStartAngle,
    RightPowerPhaseStartAngle,
    LeftPowerPhaseFinishAngle,
    RightPowerPhaseFinishAngle,
    /// Combined gear information
    Gears,
    Pace,
    TrainingEffect,
    VerticalOscillation,
    VerticalRatio,
    GroundContactTime,
    LeftGroundContactTimeBalance,
    RightGroundContactTimeBalance,
    StrideLength,
    RunningCadence,
    PerformanceCondition,
    CourseType,
    TimeInPowerZone,
    NavigationTurn,
    CourseLocation,
    NavigationLocation,
    Compass,
    GearCombo,
    MuscleOxygen,
    Icon,
    CompassHeading,
    GpsHeading,
    GpsElevation,
    AnaerobicTrainingEffect,
    Course,
    OffCourse,
    GlideRatio,
    VerticalDistance,
    Vmg,
    AmbientPressure,
    Pressure,
    Vam,
}
impl fmt::Display for ExdDescriptors {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ExdDescriptors::BikeLightBatteryStatus => f.write_str("bike_light_battery_status"),
            ExdDescriptors::BeamAngleStatus => f.write_str("beam_angle_status"),
            ExdDescriptors::BateryLevel => f.write_str("batery_level"),
            ExdDescriptors::LightNetworkMode => f.write_str("light_network_mode"),
            ExdDescriptors::NumberLightsConnected => f.write_str("number_lights_connected"),
            ExdDescriptors::Cadence => f.write_str("cadence"),
            ExdDescriptors::Distance => f.write_str("distance"),
            ExdDescriptors::EstimatedTimeOfArrival => f.write_str("estimated_time_of_arrival"),
            ExdDescriptors::Heading => f.write_str("heading"),
            ExdDescriptors::Time => f.write_str("time"),
            ExdDescriptors::BatteryLevel => f.write_str("battery_level"),
            ExdDescriptors::TrainerResistance => f.write_str("trainer_resistance"),
            ExdDescriptors::TrainerTargetPower => f.write_str("trainer_target_power"),
            ExdDescriptors::TimeSeated => f.write_str("time_seated"),
            ExdDescriptors::TimeStanding => f.write_str("time_standing"),
            ExdDescriptors::Elevation => f.write_str("elevation"),
            ExdDescriptors::Grade => f.write_str("grade"),
            ExdDescriptors::Ascent => f.write_str("ascent"),
            ExdDescriptors::Descent => f.write_str("descent"),
            ExdDescriptors::VerticalSpeed => f.write_str("vertical_speed"),
            ExdDescriptors::Di2BatteryLevel => f.write_str("di2_battery_level"),
            ExdDescriptors::FrontGear => f.write_str("front_gear"),
            ExdDescriptors::RearGear => f.write_str("rear_gear"),
            ExdDescriptors::GearRatio => f.write_str("gear_ratio"),
            ExdDescriptors::HeartRate => f.write_str("heart_rate"),
            ExdDescriptors::HeartRateZone => f.write_str("heart_rate_zone"),
            ExdDescriptors::TimeInHeartRateZone => f.write_str("time_in_heart_rate_zone"),
            ExdDescriptors::HeartRateReserve => f.write_str("heart_rate_reserve"),
            ExdDescriptors::Calories => f.write_str("calories"),
            ExdDescriptors::GpsAccuracy => f.write_str("gps_accuracy"),
            ExdDescriptors::GpsSignalStrength => f.write_str("gps_signal_strength"),
            ExdDescriptors::Temperature => f.write_str("temperature"),
            ExdDescriptors::TimeOfDay => f.write_str("time_of_day"),
            ExdDescriptors::Balance => f.write_str("balance"),
            ExdDescriptors::PedalSmoothness => f.write_str("pedal_smoothness"),
            ExdDescriptors::Power => f.write_str("power"),
            ExdDescriptors::FunctionalThresholdPower => f.write_str("functional_threshold_power"),
            ExdDescriptors::IntensityFactor => f.write_str("intensity_factor"),
            ExdDescriptors::Work => f.write_str("work"),
            ExdDescriptors::PowerRatio => f.write_str("power_ratio"),
            ExdDescriptors::NormalizedPower => f.write_str("normalized_power"),
            ExdDescriptors::TrainingStressScore => f.write_str("training_stress_Score"),
            ExdDescriptors::TimeOnZone => f.write_str("time_on_zone"),
            ExdDescriptors::Speed => f.write_str("speed"),
            ExdDescriptors::Laps => f.write_str("laps"),
            ExdDescriptors::Reps => f.write_str("reps"),
            ExdDescriptors::WorkoutStep => f.write_str("workout_step"),
            ExdDescriptors::CourseDistance => f.write_str("course_distance"),
            ExdDescriptors::NavigationDistance => f.write_str("navigation_distance"),
            ExdDescriptors::CourseEstimatedTimeOfArrival => {
                f.write_str("course_estimated_time_of_arrival")
            }
            ExdDescriptors::NavigationEstimatedTimeOfArrival => {
                f.write_str("navigation_estimated_time_of_arrival")
            }
            ExdDescriptors::CourseTime => f.write_str("course_time"),
            ExdDescriptors::NavigationTime => f.write_str("navigation_time"),
            ExdDescriptors::CourseHeading => f.write_str("course_heading"),
            ExdDescriptors::NavigationHeading => f.write_str("navigation_heading"),
            ExdDescriptors::PowerZone => f.write_str("power_zone"),
            ExdDescriptors::TorqueEffectiveness => f.write_str("torque_effectiveness"),
            ExdDescriptors::TimerTime => f.write_str("timer_time"),
            ExdDescriptors::PowerWeightRatio => f.write_str("power_weight_ratio"),
            ExdDescriptors::LeftPlatformCenterOffset => f.write_str("left_platform_center_offset"),
            ExdDescriptors::RightPlatformCenterOffset => {
                f.write_str("right_platform_center_offset")
            }
            ExdDescriptors::LeftPowerPhaseStartAngle => f.write_str("left_power_phase_start_angle"),
            ExdDescriptors::RightPowerPhaseStartAngle => {
                f.write_str("right_power_phase_start_angle")
            }
            ExdDescriptors::LeftPowerPhaseFinishAngle => {
                f.write_str("left_power_phase_finish_angle")
            }
            ExdDescriptors::RightPowerPhaseFinishAngle => {
                f.write_str("right_power_phase_finish_angle")
            }
            ExdDescriptors::Gears => f.write_str("gears"),
            ExdDescriptors::Pace => f.write_str("pace"),
            ExdDescriptors::TrainingEffect => f.write_str("training_effect"),
            ExdDescriptors::VerticalOscillation => f.write_str("vertical_oscillation"),
            ExdDescriptors::VerticalRatio => f.write_str("vertical_ratio"),
            ExdDescriptors::GroundContactTime => f.write_str("ground_contact_time"),
            ExdDescriptors::LeftGroundContactTimeBalance => {
                f.write_str("left_ground_contact_time_balance")
            }
            ExdDescriptors::RightGroundContactTimeBalance => {
                f.write_str("right_ground_contact_time_balance")
            }
            ExdDescriptors::StrideLength => f.write_str("stride_length"),
            ExdDescriptors::RunningCadence => f.write_str("running_cadence"),
            ExdDescriptors::PerformanceCondition => f.write_str("performance_condition"),
            ExdDescriptors::CourseType => f.write_str("course_type"),
            ExdDescriptors::TimeInPowerZone => f.write_str("time_in_power_zone"),
            ExdDescriptors::NavigationTurn => f.write_str("navigation_turn"),
            ExdDescriptors::CourseLocation => f.write_str("course_location"),
            ExdDescriptors::NavigationLocation => f.write_str("navigation_location"),
            ExdDescriptors::Compass => f.write_str("compass"),
            ExdDescriptors::GearCombo => f.write_str("gear_combo"),
            ExdDescriptors::MuscleOxygen => f.write_str("muscle_oxygen"),
            ExdDescriptors::Icon => f.write_str("icon"),
            ExdDescriptors::CompassHeading => f.write_str("compass_heading"),
            ExdDescriptors::GpsHeading => f.write_str("gps_heading"),
            ExdDescriptors::GpsElevation => f.write_str("gps_elevation"),
            ExdDescriptors::AnaerobicTrainingEffect => f.write_str("anaerobic_training_effect"),
            ExdDescriptors::Course => f.write_str("course"),
            ExdDescriptors::OffCourse => f.write_str("off_course"),
            ExdDescriptors::GlideRatio => f.write_str("glide_ratio"),
            ExdDescriptors::VerticalDistance => f.write_str("vertical_distance"),
            ExdDescriptors::Vmg => f.write_str("vmg"),
            ExdDescriptors::AmbientPressure => f.write_str("ambient_pressure"),
            ExdDescriptors::Pressure => f.write_str("pressure"),
            ExdDescriptors::Vam => f.write_str("vam"),
        }
    }
}
impl ExdDescriptors {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ExdDescriptors::BikeLightBatteryStatus => fit::Value::Enum(0),
            ExdDescriptors::BeamAngleStatus => fit::Value::Enum(1),
            ExdDescriptors::BateryLevel => fit::Value::Enum(2),
            ExdDescriptors::LightNetworkMode => fit::Value::Enum(3),
            ExdDescriptors::NumberLightsConnected => fit::Value::Enum(4),
            ExdDescriptors::Cadence => fit::Value::Enum(5),
            ExdDescriptors::Distance => fit::Value::Enum(6),
            ExdDescriptors::EstimatedTimeOfArrival => fit::Value::Enum(7),
            ExdDescriptors::Heading => fit::Value::Enum(8),
            ExdDescriptors::Time => fit::Value::Enum(9),
            ExdDescriptors::BatteryLevel => fit::Value::Enum(10),
            ExdDescriptors::TrainerResistance => fit::Value::Enum(11),
            ExdDescriptors::TrainerTargetPower => fit::Value::Enum(12),
            ExdDescriptors::TimeSeated => fit::Value::Enum(13),
            ExdDescriptors::TimeStanding => fit::Value::Enum(14),
            ExdDescriptors::Elevation => fit::Value::Enum(15),
            ExdDescriptors::Grade => fit::Value::Enum(16),
            ExdDescriptors::Ascent => fit::Value::Enum(17),
            ExdDescriptors::Descent => fit::Value::Enum(18),
            ExdDescriptors::VerticalSpeed => fit::Value::Enum(19),
            ExdDescriptors::Di2BatteryLevel => fit::Value::Enum(20),
            ExdDescriptors::FrontGear => fit::Value::Enum(21),
            ExdDescriptors::RearGear => fit::Value::Enum(22),
            ExdDescriptors::GearRatio => fit::Value::Enum(23),
            ExdDescriptors::HeartRate => fit::Value::Enum(24),
            ExdDescriptors::HeartRateZone => fit::Value::Enum(25),
            ExdDescriptors::TimeInHeartRateZone => fit::Value::Enum(26),
            ExdDescriptors::HeartRateReserve => fit::Value::Enum(27),
            ExdDescriptors::Calories => fit::Value::Enum(28),
            ExdDescriptors::GpsAccuracy => fit::Value::Enum(29),
            ExdDescriptors::GpsSignalStrength => fit::Value::Enum(30),
            ExdDescriptors::Temperature => fit::Value::Enum(31),
            ExdDescriptors::TimeOfDay => fit::Value::Enum(32),
            ExdDescriptors::Balance => fit::Value::Enum(33),
            ExdDescriptors::PedalSmoothness => fit::Value::Enum(34),
            ExdDescriptors::Power => fit::Value::Enum(35),
            ExdDescriptors::FunctionalThresholdPower => fit::Value::Enum(36),
            ExdDescriptors::IntensityFactor => fit::Value::Enum(37),
            ExdDescriptors::Work => fit::Value::Enum(38),
            ExdDescriptors::PowerRatio => fit::Value::Enum(39),
            ExdDescriptors::NormalizedPower => fit::Value::Enum(40),
            ExdDescriptors::TrainingStressScore => fit::Value::Enum(41),
            ExdDescriptors::TimeOnZone => fit::Value::Enum(42),
            ExdDescriptors::Speed => fit::Value::Enum(43),
            ExdDescriptors::Laps => fit::Value::Enum(44),
            ExdDescriptors::Reps => fit::Value::Enum(45),
            ExdDescriptors::WorkoutStep => fit::Value::Enum(46),
            ExdDescriptors::CourseDistance => fit::Value::Enum(47),
            ExdDescriptors::NavigationDistance => fit::Value::Enum(48),
            ExdDescriptors::CourseEstimatedTimeOfArrival => fit::Value::Enum(49),
            ExdDescriptors::NavigationEstimatedTimeOfArrival => fit::Value::Enum(50),
            ExdDescriptors::CourseTime => fit::Value::Enum(51),
            ExdDescriptors::NavigationTime => fit::Value::Enum(52),
            ExdDescriptors::CourseHeading => fit::Value::Enum(53),
            ExdDescriptors::NavigationHeading => fit::Value::Enum(54),
            ExdDescriptors::PowerZone => fit::Value::Enum(55),
            ExdDescriptors::TorqueEffectiveness => fit::Value::Enum(56),
            ExdDescriptors::TimerTime => fit::Value::Enum(57),
            ExdDescriptors::PowerWeightRatio => fit::Value::Enum(58),
            ExdDescriptors::LeftPlatformCenterOffset => fit::Value::Enum(59),
            ExdDescriptors::RightPlatformCenterOffset => fit::Value::Enum(60),
            ExdDescriptors::LeftPowerPhaseStartAngle => fit::Value::Enum(61),
            ExdDescriptors::RightPowerPhaseStartAngle => fit::Value::Enum(62),
            ExdDescriptors::LeftPowerPhaseFinishAngle => fit::Value::Enum(63),
            ExdDescriptors::RightPowerPhaseFinishAngle => fit::Value::Enum(64),
            ExdDescriptors::Gears => fit::Value::Enum(65),
            ExdDescriptors::Pace => fit::Value::Enum(66),
            ExdDescriptors::TrainingEffect => fit::Value::Enum(67),
            ExdDescriptors::VerticalOscillation => fit::Value::Enum(68),
            ExdDescriptors::VerticalRatio => fit::Value::Enum(69),
            ExdDescriptors::GroundContactTime => fit::Value::Enum(70),
            ExdDescriptors::LeftGroundContactTimeBalance => fit::Value::Enum(71),
            ExdDescriptors::RightGroundContactTimeBalance => fit::Value::Enum(72),
            ExdDescriptors::StrideLength => fit::Value::Enum(73),
            ExdDescriptors::RunningCadence => fit::Value::Enum(74),
            ExdDescriptors::PerformanceCondition => fit::Value::Enum(75),
            ExdDescriptors::CourseType => fit::Value::Enum(76),
            ExdDescriptors::TimeInPowerZone => fit::Value::Enum(77),
            ExdDescriptors::NavigationTurn => fit::Value::Enum(78),
            ExdDescriptors::CourseLocation => fit::Value::Enum(79),
            ExdDescriptors::NavigationLocation => fit::Value::Enum(80),
            ExdDescriptors::Compass => fit::Value::Enum(81),
            ExdDescriptors::GearCombo => fit::Value::Enum(82),
            ExdDescriptors::MuscleOxygen => fit::Value::Enum(83),
            ExdDescriptors::Icon => fit::Value::Enum(84),
            ExdDescriptors::CompassHeading => fit::Value::Enum(85),
            ExdDescriptors::GpsHeading => fit::Value::Enum(86),
            ExdDescriptors::GpsElevation => fit::Value::Enum(87),
            ExdDescriptors::AnaerobicTrainingEffect => fit::Value::Enum(88),
            ExdDescriptors::Course => fit::Value::Enum(89),
            ExdDescriptors::OffCourse => fit::Value::Enum(90),
            ExdDescriptors::GlideRatio => fit::Value::Enum(91),
            ExdDescriptors::VerticalDistance => fit::Value::Enum(92),
            ExdDescriptors::Vmg => fit::Value::Enum(93),
            ExdDescriptors::AmbientPressure => fit::Value::Enum(94),
            ExdDescriptors::Pressure => fit::Value::Enum(95),
            ExdDescriptors::Vam => fit::Value::Enum(96),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for ExdDescriptors {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(ExdDescriptors::BikeLightBatteryStatus),
            fit::Value::Enum(1) => Ok(ExdDescriptors::BeamAngleStatus),
            fit::Value::Enum(2) => Ok(ExdDescriptors::BateryLevel),
            fit::Value::Enum(3) => Ok(ExdDescriptors::LightNetworkMode),
            fit::Value::Enum(4) => Ok(ExdDescriptors::NumberLightsConnected),
            fit::Value::Enum(5) => Ok(ExdDescriptors::Cadence),
            fit::Value::Enum(6) => Ok(ExdDescriptors::Distance),
            fit::Value::Enum(7) => Ok(ExdDescriptors::EstimatedTimeOfArrival),
            fit::Value::Enum(8) => Ok(ExdDescriptors::Heading),
            fit::Value::Enum(9) => Ok(ExdDescriptors::Time),
            fit::Value::Enum(10) => Ok(ExdDescriptors::BatteryLevel),
            fit::Value::Enum(11) => Ok(ExdDescriptors::TrainerResistance),
            fit::Value::Enum(12) => Ok(ExdDescriptors::TrainerTargetPower),
            fit::Value::Enum(13) => Ok(ExdDescriptors::TimeSeated),
            fit::Value::Enum(14) => Ok(ExdDescriptors::TimeStanding),
            fit::Value::Enum(15) => Ok(ExdDescriptors::Elevation),
            fit::Value::Enum(16) => Ok(ExdDescriptors::Grade),
            fit::Value::Enum(17) => Ok(ExdDescriptors::Ascent),
            fit::Value::Enum(18) => Ok(ExdDescriptors::Descent),
            fit::Value::Enum(19) => Ok(ExdDescriptors::VerticalSpeed),
            fit::Value::Enum(20) => Ok(ExdDescriptors::Di2BatteryLevel),
            fit::Value::Enum(21) => Ok(ExdDescriptors::FrontGear),
            fit::Value::Enum(22) => Ok(ExdDescriptors::RearGear),
            fit::Value::Enum(23) => Ok(ExdDescriptors::GearRatio),
            fit::Value::Enum(24) => Ok(ExdDescriptors::HeartRate),
            fit::Value::Enum(25) => Ok(ExdDescriptors::HeartRateZone),
            fit::Value::Enum(26) => Ok(ExdDescriptors::TimeInHeartRateZone),
            fit::Value::Enum(27) => Ok(ExdDescriptors::HeartRateReserve),
            fit::Value::Enum(28) => Ok(ExdDescriptors::Calories),
            fit::Value::Enum(29) => Ok(ExdDescriptors::GpsAccuracy),
            fit::Value::Enum(30) => Ok(ExdDescriptors::GpsSignalStrength),
            fit::Value::Enum(31) => Ok(ExdDescriptors::Temperature),
            fit::Value::Enum(32) => Ok(ExdDescriptors::TimeOfDay),
            fit::Value::Enum(33) => Ok(ExdDescriptors::Balance),
            fit::Value::Enum(34) => Ok(ExdDescriptors::PedalSmoothness),
            fit::Value::Enum(35) => Ok(ExdDescriptors::Power),
            fit::Value::Enum(36) => Ok(ExdDescriptors::FunctionalThresholdPower),
            fit::Value::Enum(37) => Ok(ExdDescriptors::IntensityFactor),
            fit::Value::Enum(38) => Ok(ExdDescriptors::Work),
            fit::Value::Enum(39) => Ok(ExdDescriptors::PowerRatio),
            fit::Value::Enum(40) => Ok(ExdDescriptors::NormalizedPower),
            fit::Value::Enum(41) => Ok(ExdDescriptors::TrainingStressScore),
            fit::Value::Enum(42) => Ok(ExdDescriptors::TimeOnZone),
            fit::Value::Enum(43) => Ok(ExdDescriptors::Speed),
            fit::Value::Enum(44) => Ok(ExdDescriptors::Laps),
            fit::Value::Enum(45) => Ok(ExdDescriptors::Reps),
            fit::Value::Enum(46) => Ok(ExdDescriptors::WorkoutStep),
            fit::Value::Enum(47) => Ok(ExdDescriptors::CourseDistance),
            fit::Value::Enum(48) => Ok(ExdDescriptors::NavigationDistance),
            fit::Value::Enum(49) => Ok(ExdDescriptors::CourseEstimatedTimeOfArrival),
            fit::Value::Enum(50) => Ok(ExdDescriptors::NavigationEstimatedTimeOfArrival),
            fit::Value::Enum(51) => Ok(ExdDescriptors::CourseTime),
            fit::Value::Enum(52) => Ok(ExdDescriptors::NavigationTime),
            fit::Value::Enum(53) => Ok(ExdDescriptors::CourseHeading),
            fit::Value::Enum(54) => Ok(ExdDescriptors::NavigationHeading),
            fit::Value::Enum(55) => Ok(ExdDescriptors::PowerZone),
            fit::Value::Enum(56) => Ok(ExdDescriptors::TorqueEffectiveness),
            fit::Value::Enum(57) => Ok(ExdDescriptors::TimerTime),
            fit::Value::Enum(58) => Ok(ExdDescriptors::PowerWeightRatio),
            fit::Value::Enum(59) => Ok(ExdDescriptors::LeftPlatformCenterOffset),
            fit::Value::Enum(60) => Ok(ExdDescriptors::RightPlatformCenterOffset),
            fit::Value::Enum(61) => Ok(ExdDescriptors::LeftPowerPhaseStartAngle),
            fit::Value::Enum(62) => Ok(ExdDescriptors::RightPowerPhaseStartAngle),
            fit::Value::Enum(63) => Ok(ExdDescriptors::LeftPowerPhaseFinishAngle),
            fit::Value::Enum(64) => Ok(ExdDescriptors::RightPowerPhaseFinishAngle),
            fit::Value::Enum(65) => Ok(ExdDescriptors::Gears),
            fit::Value::Enum(66) => Ok(ExdDescriptors::Pace),
            fit::Value::Enum(67) => Ok(ExdDescriptors::TrainingEffect),
            fit::Value::Enum(68) => Ok(ExdDescriptors::VerticalOscillation),
            fit::Value::Enum(69) => Ok(ExdDescriptors::VerticalRatio),
            fit::Value::Enum(70) => Ok(ExdDescriptors::GroundContactTime),
            fit::Value::Enum(71) => Ok(ExdDescriptors::LeftGroundContactTimeBalance),
            fit::Value::Enum(72) => Ok(ExdDescriptors::RightGroundContactTimeBalance),
            fit::Value::Enum(73) => Ok(ExdDescriptors::StrideLength),
            fit::Value::Enum(74) => Ok(ExdDescriptors::RunningCadence),
            fit::Value::Enum(75) => Ok(ExdDescriptors::PerformanceCondition),
            fit::Value::Enum(76) => Ok(ExdDescriptors::CourseType),
            fit::Value::Enum(77) => Ok(ExdDescriptors::TimeInPowerZone),
            fit::Value::Enum(78) => Ok(ExdDescriptors::NavigationTurn),
            fit::Value::Enum(79) => Ok(ExdDescriptors::CourseLocation),
            fit::Value::Enum(80) => Ok(ExdDescriptors::NavigationLocation),
            fit::Value::Enum(81) => Ok(ExdDescriptors::Compass),
            fit::Value::Enum(82) => Ok(ExdDescriptors::GearCombo),
            fit::Value::Enum(83) => Ok(ExdDescriptors::MuscleOxygen),
            fit::Value::Enum(84) => Ok(ExdDescriptors::Icon),
            fit::Value::Enum(85) => Ok(ExdDescriptors::CompassHeading),
            fit::Value::Enum(86) => Ok(ExdDescriptors::GpsHeading),
            fit::Value::Enum(87) => Ok(ExdDescriptors::GpsElevation),
            fit::Value::Enum(88) => Ok(ExdDescriptors::AnaerobicTrainingEffect),
            fit::Value::Enum(89) => Ok(ExdDescriptors::Course),
            fit::Value::Enum(90) => Ok(ExdDescriptors::OffCourse),
            fit::Value::Enum(91) => Ok(ExdDescriptors::GlideRatio),
            fit::Value::Enum(92) => Ok(ExdDescriptors::VerticalDistance),
            fit::Value::Enum(93) => Ok(ExdDescriptors::Vmg),
            fit::Value::Enum(94) => Ok(ExdDescriptors::AmbientPressure),
            fit::Value::Enum(95) => Ok(ExdDescriptors::Pressure),
            fit::Value::Enum(96) => Ok(ExdDescriptors::Vam),
            _ => Err("No corresponding ExdDescriptors exists"),
        }
    }
}
impl TryFrom<&str> for ExdDescriptors {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "bike_light_battery_status" => Ok(ExdDescriptors::BikeLightBatteryStatus),
            "beam_angle_status" => Ok(ExdDescriptors::BeamAngleStatus),
            "batery_level" => Ok(ExdDescriptors::BateryLevel),
            "light_network_mode" => Ok(ExdDescriptors::LightNetworkMode),
            "number_lights_connected" => Ok(ExdDescriptors::NumberLightsConnected),
            "cadence" => Ok(ExdDescriptors::Cadence),
            "distance" => Ok(ExdDescriptors::Distance),
            "estimated_time_of_arrival" => Ok(ExdDescriptors::EstimatedTimeOfArrival),
            "heading" => Ok(ExdDescriptors::Heading),
            "time" => Ok(ExdDescriptors::Time),
            "battery_level" => Ok(ExdDescriptors::BatteryLevel),
            "trainer_resistance" => Ok(ExdDescriptors::TrainerResistance),
            "trainer_target_power" => Ok(ExdDescriptors::TrainerTargetPower),
            "time_seated" => Ok(ExdDescriptors::TimeSeated),
            "time_standing" => Ok(ExdDescriptors::TimeStanding),
            "elevation" => Ok(ExdDescriptors::Elevation),
            "grade" => Ok(ExdDescriptors::Grade),
            "ascent" => Ok(ExdDescriptors::Ascent),
            "descent" => Ok(ExdDescriptors::Descent),
            "vertical_speed" => Ok(ExdDescriptors::VerticalSpeed),
            "di2_battery_level" => Ok(ExdDescriptors::Di2BatteryLevel),
            "front_gear" => Ok(ExdDescriptors::FrontGear),
            "rear_gear" => Ok(ExdDescriptors::RearGear),
            "gear_ratio" => Ok(ExdDescriptors::GearRatio),
            "heart_rate" => Ok(ExdDescriptors::HeartRate),
            "heart_rate_zone" => Ok(ExdDescriptors::HeartRateZone),
            "time_in_heart_rate_zone" => Ok(ExdDescriptors::TimeInHeartRateZone),
            "heart_rate_reserve" => Ok(ExdDescriptors::HeartRateReserve),
            "calories" => Ok(ExdDescriptors::Calories),
            "gps_accuracy" => Ok(ExdDescriptors::GpsAccuracy),
            "gps_signal_strength" => Ok(ExdDescriptors::GpsSignalStrength),
            "temperature" => Ok(ExdDescriptors::Temperature),
            "time_of_day" => Ok(ExdDescriptors::TimeOfDay),
            "balance" => Ok(ExdDescriptors::Balance),
            "pedal_smoothness" => Ok(ExdDescriptors::PedalSmoothness),
            "power" => Ok(ExdDescriptors::Power),
            "functional_threshold_power" => Ok(ExdDescriptors::FunctionalThresholdPower),
            "intensity_factor" => Ok(ExdDescriptors::IntensityFactor),
            "work" => Ok(ExdDescriptors::Work),
            "power_ratio" => Ok(ExdDescriptors::PowerRatio),
            "normalized_power" => Ok(ExdDescriptors::NormalizedPower),
            "training_stress_Score" => Ok(ExdDescriptors::TrainingStressScore),
            "time_on_zone" => Ok(ExdDescriptors::TimeOnZone),
            "speed" => Ok(ExdDescriptors::Speed),
            "laps" => Ok(ExdDescriptors::Laps),
            "reps" => Ok(ExdDescriptors::Reps),
            "workout_step" => Ok(ExdDescriptors::WorkoutStep),
            "course_distance" => Ok(ExdDescriptors::CourseDistance),
            "navigation_distance" => Ok(ExdDescriptors::NavigationDistance),
            "course_estimated_time_of_arrival" => Ok(ExdDescriptors::CourseEstimatedTimeOfArrival),
            "navigation_estimated_time_of_arrival" => {
                Ok(ExdDescriptors::NavigationEstimatedTimeOfArrival)
            }
            "course_time" => Ok(ExdDescriptors::CourseTime),
            "navigation_time" => Ok(ExdDescriptors::NavigationTime),
            "course_heading" => Ok(ExdDescriptors::CourseHeading),
            "navigation_heading" => Ok(ExdDescriptors::NavigationHeading),
            "power_zone" => Ok(ExdDescriptors::PowerZone),
            "torque_effectiveness" => Ok(ExdDescriptors::TorqueEffectiveness),
            "timer_time" => Ok(ExdDescriptors::TimerTime),
            "power_weight_ratio" => Ok(ExdDescriptors::PowerWeightRatio),
            "left_platform_center_offset" => Ok(ExdDescriptors::LeftPlatformCenterOffset),
            "right_platform_center_offset" => Ok(ExdDescriptors::RightPlatformCenterOffset),
            "left_power_phase_start_angle" => Ok(ExdDescriptors::LeftPowerPhaseStartAngle),
            "right_power_phase_start_angle" => Ok(ExdDescriptors::RightPowerPhaseStartAngle),
            "left_power_phase_finish_angle" => Ok(ExdDescriptors::LeftPowerPhaseFinishAngle),
            "right_power_phase_finish_angle" => Ok(ExdDescriptors::RightPowerPhaseFinishAngle),
            "gears" => Ok(ExdDescriptors::Gears),
            "pace" => Ok(ExdDescriptors::Pace),
            "training_effect" => Ok(ExdDescriptors::TrainingEffect),
            "vertical_oscillation" => Ok(ExdDescriptors::VerticalOscillation),
            "vertical_ratio" => Ok(ExdDescriptors::VerticalRatio),
            "ground_contact_time" => Ok(ExdDescriptors::GroundContactTime),
            "left_ground_contact_time_balance" => Ok(ExdDescriptors::LeftGroundContactTimeBalance),
            "right_ground_contact_time_balance" => {
                Ok(ExdDescriptors::RightGroundContactTimeBalance)
            }
            "stride_length" => Ok(ExdDescriptors::StrideLength),
            "running_cadence" => Ok(ExdDescriptors::RunningCadence),
            "performance_condition" => Ok(ExdDescriptors::PerformanceCondition),
            "course_type" => Ok(ExdDescriptors::CourseType),
            "time_in_power_zone" => Ok(ExdDescriptors::TimeInPowerZone),
            "navigation_turn" => Ok(ExdDescriptors::NavigationTurn),
            "course_location" => Ok(ExdDescriptors::CourseLocation),
            "navigation_location" => Ok(ExdDescriptors::NavigationLocation),
            "compass" => Ok(ExdDescriptors::Compass),
            "gear_combo" => Ok(ExdDescriptors::GearCombo),
            "muscle_oxygen" => Ok(ExdDescriptors::MuscleOxygen),
            "icon" => Ok(ExdDescriptors::Icon),
            "compass_heading" => Ok(ExdDescriptors::CompassHeading),
            "gps_heading" => Ok(ExdDescriptors::GpsHeading),
            "gps_elevation" => Ok(ExdDescriptors::GpsElevation),
            "anaerobic_training_effect" => Ok(ExdDescriptors::AnaerobicTrainingEffect),
            "course" => Ok(ExdDescriptors::Course),
            "off_course" => Ok(ExdDescriptors::OffCourse),
            "glide_ratio" => Ok(ExdDescriptors::GlideRatio),
            "vertical_distance" => Ok(ExdDescriptors::VerticalDistance),
            "vmg" => Ok(ExdDescriptors::Vmg),
            "ambient_pressure" => Ok(ExdDescriptors::AmbientPressure),
            "pressure" => Ok(ExdDescriptors::Pressure),
            "vam" => Ok(ExdDescriptors::Vam),
            _ => Err("No corresponding ExdDescriptors exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum AutoActivityDetect {
    None,
    Running,
    Cycling,
    Swimming,
    Walking,
    Elliptical,
    Sedentary,
}
impl fmt::Display for AutoActivityDetect {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AutoActivityDetect::None => f.write_str("none"),
            AutoActivityDetect::Running => f.write_str("running"),
            AutoActivityDetect::Cycling => f.write_str("cycling"),
            AutoActivityDetect::Swimming => f.write_str("swimming"),
            AutoActivityDetect::Walking => f.write_str("walking"),
            AutoActivityDetect::Elliptical => f.write_str("elliptical"),
            AutoActivityDetect::Sedentary => f.write_str("sedentary"),
        }
    }
}
impl AutoActivityDetect {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            AutoActivityDetect::None => fit::Value::UInt32(0x00000000),
            AutoActivityDetect::Running => fit::Value::UInt32(0x00000001),
            AutoActivityDetect::Cycling => fit::Value::UInt32(0x00000002),
            AutoActivityDetect::Swimming => fit::Value::UInt32(0x00000004),
            AutoActivityDetect::Walking => fit::Value::UInt32(0x00000008),
            AutoActivityDetect::Elliptical => fit::Value::UInt32(0x00000020),
            AutoActivityDetect::Sedentary => fit::Value::UInt32(0x00000400),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32"
    }
}
impl TryFrom<&fit::Value> for AutoActivityDetect {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32(0x00000000) => Ok(AutoActivityDetect::None),
            fit::Value::UInt32(0x00000001) => Ok(AutoActivityDetect::Running),
            fit::Value::UInt32(0x00000002) => Ok(AutoActivityDetect::Cycling),
            fit::Value::UInt32(0x00000004) => Ok(AutoActivityDetect::Swimming),
            fit::Value::UInt32(0x00000008) => Ok(AutoActivityDetect::Walking),
            fit::Value::UInt32(0x00000020) => Ok(AutoActivityDetect::Elliptical),
            fit::Value::UInt32(0x00000400) => Ok(AutoActivityDetect::Sedentary),
            _ => Err("No corresponding AutoActivityDetect exists"),
        }
    }
}
impl TryFrom<&str> for AutoActivityDetect {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "none" => Ok(AutoActivityDetect::None),
            "running" => Ok(AutoActivityDetect::Running),
            "cycling" => Ok(AutoActivityDetect::Cycling),
            "swimming" => Ok(AutoActivityDetect::Swimming),
            "walking" => Ok(AutoActivityDetect::Walking),
            "elliptical" => Ok(AutoActivityDetect::Elliptical),
            "sedentary" => Ok(AutoActivityDetect::Sedentary),
            _ => Err("No corresponding AutoActivityDetect exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SupportedExdScreenLayouts {
    FullScreen,
    HalfVertical,
    HalfHorizontal,
    HalfVerticalRightSplit,
    HalfHorizontalBottomSplit,
    FullQuarterSplit,
    HalfVerticalLeftSplit,
    HalfHorizontalTopSplit,
}
impl fmt::Display for SupportedExdScreenLayouts {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SupportedExdScreenLayouts::FullScreen => f.write_str("full_screen"),
            SupportedExdScreenLayouts::HalfVertical => f.write_str("half_vertical"),
            SupportedExdScreenLayouts::HalfHorizontal => f.write_str("half_horizontal"),
            SupportedExdScreenLayouts::HalfVerticalRightSplit => {
                f.write_str("half_vertical_right_split")
            }
            SupportedExdScreenLayouts::HalfHorizontalBottomSplit => {
                f.write_str("half_horizontal_bottom_split")
            }
            SupportedExdScreenLayouts::FullQuarterSplit => f.write_str("full_quarter_split"),
            SupportedExdScreenLayouts::HalfVerticalLeftSplit => {
                f.write_str("half_vertical_left_split")
            }
            SupportedExdScreenLayouts::HalfHorizontalTopSplit => {
                f.write_str("half_horizontal_top_split")
            }
        }
    }
}
impl SupportedExdScreenLayouts {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SupportedExdScreenLayouts::FullScreen => fit::Value::UInt32z(0x00000001),
            SupportedExdScreenLayouts::HalfVertical => fit::Value::UInt32z(0x00000002),
            SupportedExdScreenLayouts::HalfHorizontal => fit::Value::UInt32z(0x00000004),
            SupportedExdScreenLayouts::HalfVerticalRightSplit => fit::Value::UInt32z(0x00000008),
            SupportedExdScreenLayouts::HalfHorizontalBottomSplit => fit::Value::UInt32z(0x00000010),
            SupportedExdScreenLayouts::FullQuarterSplit => fit::Value::UInt32z(0x00000020),
            SupportedExdScreenLayouts::HalfVerticalLeftSplit => fit::Value::UInt32z(0x00000040),
            SupportedExdScreenLayouts::HalfHorizontalTopSplit => fit::Value::UInt32z(0x00000080),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint32z"
    }
}
impl TryFrom<&fit::Value> for SupportedExdScreenLayouts {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt32z(0x00000001) => Ok(SupportedExdScreenLayouts::FullScreen),
            fit::Value::UInt32z(0x00000002) => Ok(SupportedExdScreenLayouts::HalfVertical),
            fit::Value::UInt32z(0x00000004) => Ok(SupportedExdScreenLayouts::HalfHorizontal),
            fit::Value::UInt32z(0x00000008) => {
                Ok(SupportedExdScreenLayouts::HalfVerticalRightSplit)
            }
            fit::Value::UInt32z(0x00000010) => {
                Ok(SupportedExdScreenLayouts::HalfHorizontalBottomSplit)
            }
            fit::Value::UInt32z(0x00000020) => Ok(SupportedExdScreenLayouts::FullQuarterSplit),
            fit::Value::UInt32z(0x00000040) => Ok(SupportedExdScreenLayouts::HalfVerticalLeftSplit),
            fit::Value::UInt32z(0x00000080) => {
                Ok(SupportedExdScreenLayouts::HalfHorizontalTopSplit)
            }
            _ => Err("No corresponding SupportedExdScreenLayouts exists"),
        }
    }
}
impl TryFrom<&str> for SupportedExdScreenLayouts {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "full_screen" => Ok(SupportedExdScreenLayouts::FullScreen),
            "half_vertical" => Ok(SupportedExdScreenLayouts::HalfVertical),
            "half_horizontal" => Ok(SupportedExdScreenLayouts::HalfHorizontal),
            "half_vertical_right_split" => Ok(SupportedExdScreenLayouts::HalfVerticalRightSplit),
            "half_horizontal_bottom_split" => {
                Ok(SupportedExdScreenLayouts::HalfHorizontalBottomSplit)
            }
            "full_quarter_split" => Ok(SupportedExdScreenLayouts::FullQuarterSplit),
            "half_vertical_left_split" => Ok(SupportedExdScreenLayouts::HalfVerticalLeftSplit),
            "half_horizontal_top_split" => Ok(SupportedExdScreenLayouts::HalfHorizontalTopSplit),
            _ => Err("No corresponding SupportedExdScreenLayouts exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum FitBaseType {
    Enum,
    SInt8,
    UInt8,
    SInt16,
    UInt16,
    SInt32,
    UInt32,
    String,
    Float32,
    Float64,
    UInt8z,
    UInt16z,
    UInt32z,
    Byte,
    SInt64,
    UInt64,
    UInt64z,
}
impl fmt::Display for FitBaseType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitBaseType::Enum => f.write_str("enum"),
            FitBaseType::SInt8 => f.write_str("sint8"),
            FitBaseType::UInt8 => f.write_str("uint8"),
            FitBaseType::SInt16 => f.write_str("sint16"),
            FitBaseType::UInt16 => f.write_str("uint16"),
            FitBaseType::SInt32 => f.write_str("sint32"),
            FitBaseType::UInt32 => f.write_str("uint32"),
            FitBaseType::String => f.write_str("string"),
            FitBaseType::Float32 => f.write_str("float32"),
            FitBaseType::Float64 => f.write_str("float64"),
            FitBaseType::UInt8z => f.write_str("uint8z"),
            FitBaseType::UInt16z => f.write_str("uint16z"),
            FitBaseType::UInt32z => f.write_str("uint32z"),
            FitBaseType::Byte => f.write_str("byte"),
            FitBaseType::SInt64 => f.write_str("sint64"),
            FitBaseType::UInt64 => f.write_str("uint64"),
            FitBaseType::UInt64z => f.write_str("uint64z"),
        }
    }
}
impl FitBaseType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            FitBaseType::Enum => fit::Value::UInt8(0),
            FitBaseType::SInt8 => fit::Value::UInt8(1),
            FitBaseType::UInt8 => fit::Value::UInt8(2),
            FitBaseType::SInt16 => fit::Value::UInt8(131),
            FitBaseType::UInt16 => fit::Value::UInt8(132),
            FitBaseType::SInt32 => fit::Value::UInt8(133),
            FitBaseType::UInt32 => fit::Value::UInt8(134),
            FitBaseType::String => fit::Value::UInt8(7),
            FitBaseType::Float32 => fit::Value::UInt8(136),
            FitBaseType::Float64 => fit::Value::UInt8(137),
            FitBaseType::UInt8z => fit::Value::UInt8(10),
            FitBaseType::UInt16z => fit::Value::UInt8(139),
            FitBaseType::UInt32z => fit::Value::UInt8(140),
            FitBaseType::Byte => fit::Value::UInt8(13),
            FitBaseType::SInt64 => fit::Value::UInt8(142),
            FitBaseType::UInt64 => fit::Value::UInt8(143),
            FitBaseType::UInt64z => fit::Value::UInt8(144),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for FitBaseType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(0) => Ok(FitBaseType::Enum),
            fit::Value::UInt8(1) => Ok(FitBaseType::SInt8),
            fit::Value::UInt8(2) => Ok(FitBaseType::UInt8),
            fit::Value::UInt8(131) => Ok(FitBaseType::SInt16),
            fit::Value::UInt8(132) => Ok(FitBaseType::UInt16),
            fit::Value::UInt8(133) => Ok(FitBaseType::SInt32),
            fit::Value::UInt8(134) => Ok(FitBaseType::UInt32),
            fit::Value::UInt8(7) => Ok(FitBaseType::String),
            fit::Value::UInt8(136) => Ok(FitBaseType::Float32),
            fit::Value::UInt8(137) => Ok(FitBaseType::Float64),
            fit::Value::UInt8(10) => Ok(FitBaseType::UInt8z),
            fit::Value::UInt8(139) => Ok(FitBaseType::UInt16z),
            fit::Value::UInt8(140) => Ok(FitBaseType::UInt32z),
            fit::Value::UInt8(13) => Ok(FitBaseType::Byte),
            fit::Value::UInt8(142) => Ok(FitBaseType::SInt64),
            fit::Value::UInt8(143) => Ok(FitBaseType::UInt64),
            fit::Value::UInt8(144) => Ok(FitBaseType::UInt64z),
            _ => Err("No corresponding FitBaseType exists"),
        }
    }
}
impl TryFrom<&str> for FitBaseType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "enum" => Ok(FitBaseType::Enum),
            "sint8" => Ok(FitBaseType::SInt8),
            "uint8" => Ok(FitBaseType::UInt8),
            "sint16" => Ok(FitBaseType::SInt16),
            "uint16" => Ok(FitBaseType::UInt16),
            "sint32" => Ok(FitBaseType::SInt32),
            "uint32" => Ok(FitBaseType::UInt32),
            "string" => Ok(FitBaseType::String),
            "float32" => Ok(FitBaseType::Float32),
            "float64" => Ok(FitBaseType::Float64),
            "uint8z" => Ok(FitBaseType::UInt8z),
            "uint16z" => Ok(FitBaseType::UInt16z),
            "uint32z" => Ok(FitBaseType::UInt32z),
            "byte" => Ok(FitBaseType::Byte),
            "sint64" => Ok(FitBaseType::SInt64),
            "uint64" => Ok(FitBaseType::UInt64),
            "uint64z" => Ok(FitBaseType::UInt64z),
            _ => Err("No corresponding FitBaseType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum TurnType {
    ArrivingIdx,
    ArrivingLeftIdx,
    ArrivingRightIdx,
    ArrivingViaIdx,
    ArrivingViaLeftIdx,
    ArrivingViaRightIdx,
    BearKeepLeftIdx,
    BearKeepRightIdx,
    ContinueIdx,
    ExitLeftIdx,
    ExitRightIdx,
    FerryIdx,
    Roundabout45Idx,
    Roundabout90Idx,
    Roundabout135Idx,
    Roundabout180Idx,
    Roundabout225Idx,
    Roundabout270Idx,
    Roundabout315Idx,
    Roundabout360Idx,
    RoundaboutNeg45Idx,
    RoundaboutNeg90Idx,
    RoundaboutNeg135Idx,
    RoundaboutNeg180Idx,
    RoundaboutNeg225Idx,
    RoundaboutNeg270Idx,
    RoundaboutNeg315Idx,
    RoundaboutNeg360Idx,
    RoundaboutGenericIdx,
    RoundaboutNegGenericIdx,
    SharpTurnLeftIdx,
    SharpTurnRightIdx,
    TurnLeftIdx,
    TurnRightIdx,
    UturnLeftIdx,
    UturnRightIdx,
    IconInvIdx,
    IconIdxCnt,
}
impl fmt::Display for TurnType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TurnType::ArrivingIdx => f.write_str("arriving_idx"),
            TurnType::ArrivingLeftIdx => f.write_str("arriving_left_idx"),
            TurnType::ArrivingRightIdx => f.write_str("arriving_right_idx"),
            TurnType::ArrivingViaIdx => f.write_str("arriving_via_idx"),
            TurnType::ArrivingViaLeftIdx => f.write_str("arriving_via_left_idx"),
            TurnType::ArrivingViaRightIdx => f.write_str("arriving_via_right_idx"),
            TurnType::BearKeepLeftIdx => f.write_str("bear_keep_left_idx"),
            TurnType::BearKeepRightIdx => f.write_str("bear_keep_right_idx"),
            TurnType::ContinueIdx => f.write_str("continue_idx"),
            TurnType::ExitLeftIdx => f.write_str("exit_left_idx"),
            TurnType::ExitRightIdx => f.write_str("exit_right_idx"),
            TurnType::FerryIdx => f.write_str("ferry_idx"),
            TurnType::Roundabout45Idx => f.write_str("roundabout_45_idx"),
            TurnType::Roundabout90Idx => f.write_str("roundabout_90_idx"),
            TurnType::Roundabout135Idx => f.write_str("roundabout_135_idx"),
            TurnType::Roundabout180Idx => f.write_str("roundabout_180_idx"),
            TurnType::Roundabout225Idx => f.write_str("roundabout_225_idx"),
            TurnType::Roundabout270Idx => f.write_str("roundabout_270_idx"),
            TurnType::Roundabout315Idx => f.write_str("roundabout_315_idx"),
            TurnType::Roundabout360Idx => f.write_str("roundabout_360_idx"),
            TurnType::RoundaboutNeg45Idx => f.write_str("roundabout_neg_45_idx"),
            TurnType::RoundaboutNeg90Idx => f.write_str("roundabout_neg_90_idx"),
            TurnType::RoundaboutNeg135Idx => f.write_str("roundabout_neg_135_idx"),
            TurnType::RoundaboutNeg180Idx => f.write_str("roundabout_neg_180_idx"),
            TurnType::RoundaboutNeg225Idx => f.write_str("roundabout_neg_225_idx"),
            TurnType::RoundaboutNeg270Idx => f.write_str("roundabout_neg_270_idx"),
            TurnType::RoundaboutNeg315Idx => f.write_str("roundabout_neg_315_idx"),
            TurnType::RoundaboutNeg360Idx => f.write_str("roundabout_neg_360_idx"),
            TurnType::RoundaboutGenericIdx => f.write_str("roundabout_generic_idx"),
            TurnType::RoundaboutNegGenericIdx => f.write_str("roundabout_neg_generic_idx"),
            TurnType::SharpTurnLeftIdx => f.write_str("sharp_turn_left_idx"),
            TurnType::SharpTurnRightIdx => f.write_str("sharp_turn_right_idx"),
            TurnType::TurnLeftIdx => f.write_str("turn_left_idx"),
            TurnType::TurnRightIdx => f.write_str("turn_right_idx"),
            TurnType::UturnLeftIdx => f.write_str("uturn_left_idx"),
            TurnType::UturnRightIdx => f.write_str("uturn_right_idx"),
            TurnType::IconInvIdx => f.write_str("icon_inv_idx"),
            TurnType::IconIdxCnt => f.write_str("icon_idx_cnt"),
        }
    }
}
impl TurnType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            TurnType::ArrivingIdx => fit::Value::Enum(0),
            TurnType::ArrivingLeftIdx => fit::Value::Enum(1),
            TurnType::ArrivingRightIdx => fit::Value::Enum(2),
            TurnType::ArrivingViaIdx => fit::Value::Enum(3),
            TurnType::ArrivingViaLeftIdx => fit::Value::Enum(4),
            TurnType::ArrivingViaRightIdx => fit::Value::Enum(5),
            TurnType::BearKeepLeftIdx => fit::Value::Enum(6),
            TurnType::BearKeepRightIdx => fit::Value::Enum(7),
            TurnType::ContinueIdx => fit::Value::Enum(8),
            TurnType::ExitLeftIdx => fit::Value::Enum(9),
            TurnType::ExitRightIdx => fit::Value::Enum(10),
            TurnType::FerryIdx => fit::Value::Enum(11),
            TurnType::Roundabout45Idx => fit::Value::Enum(12),
            TurnType::Roundabout90Idx => fit::Value::Enum(13),
            TurnType::Roundabout135Idx => fit::Value::Enum(14),
            TurnType::Roundabout180Idx => fit::Value::Enum(15),
            TurnType::Roundabout225Idx => fit::Value::Enum(16),
            TurnType::Roundabout270Idx => fit::Value::Enum(17),
            TurnType::Roundabout315Idx => fit::Value::Enum(18),
            TurnType::Roundabout360Idx => fit::Value::Enum(19),
            TurnType::RoundaboutNeg45Idx => fit::Value::Enum(20),
            TurnType::RoundaboutNeg90Idx => fit::Value::Enum(21),
            TurnType::RoundaboutNeg135Idx => fit::Value::Enum(22),
            TurnType::RoundaboutNeg180Idx => fit::Value::Enum(23),
            TurnType::RoundaboutNeg225Idx => fit::Value::Enum(24),
            TurnType::RoundaboutNeg270Idx => fit::Value::Enum(25),
            TurnType::RoundaboutNeg315Idx => fit::Value::Enum(26),
            TurnType::RoundaboutNeg360Idx => fit::Value::Enum(27),
            TurnType::RoundaboutGenericIdx => fit::Value::Enum(28),
            TurnType::RoundaboutNegGenericIdx => fit::Value::Enum(29),
            TurnType::SharpTurnLeftIdx => fit::Value::Enum(30),
            TurnType::SharpTurnRightIdx => fit::Value::Enum(31),
            TurnType::TurnLeftIdx => fit::Value::Enum(32),
            TurnType::TurnRightIdx => fit::Value::Enum(33),
            TurnType::UturnLeftIdx => fit::Value::Enum(34),
            TurnType::UturnRightIdx => fit::Value::Enum(35),
            TurnType::IconInvIdx => fit::Value::Enum(36),
            TurnType::IconIdxCnt => fit::Value::Enum(37),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for TurnType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(TurnType::ArrivingIdx),
            fit::Value::Enum(1) => Ok(TurnType::ArrivingLeftIdx),
            fit::Value::Enum(2) => Ok(TurnType::ArrivingRightIdx),
            fit::Value::Enum(3) => Ok(TurnType::ArrivingViaIdx),
            fit::Value::Enum(4) => Ok(TurnType::ArrivingViaLeftIdx),
            fit::Value::Enum(5) => Ok(TurnType::ArrivingViaRightIdx),
            fit::Value::Enum(6) => Ok(TurnType::BearKeepLeftIdx),
            fit::Value::Enum(7) => Ok(TurnType::BearKeepRightIdx),
            fit::Value::Enum(8) => Ok(TurnType::ContinueIdx),
            fit::Value::Enum(9) => Ok(TurnType::ExitLeftIdx),
            fit::Value::Enum(10) => Ok(TurnType::ExitRightIdx),
            fit::Value::Enum(11) => Ok(TurnType::FerryIdx),
            fit::Value::Enum(12) => Ok(TurnType::Roundabout45Idx),
            fit::Value::Enum(13) => Ok(TurnType::Roundabout90Idx),
            fit::Value::Enum(14) => Ok(TurnType::Roundabout135Idx),
            fit::Value::Enum(15) => Ok(TurnType::Roundabout180Idx),
            fit::Value::Enum(16) => Ok(TurnType::Roundabout225Idx),
            fit::Value::Enum(17) => Ok(TurnType::Roundabout270Idx),
            fit::Value::Enum(18) => Ok(TurnType::Roundabout315Idx),
            fit::Value::Enum(19) => Ok(TurnType::Roundabout360Idx),
            fit::Value::Enum(20) => Ok(TurnType::RoundaboutNeg45Idx),
            fit::Value::Enum(21) => Ok(TurnType::RoundaboutNeg90Idx),
            fit::Value::Enum(22) => Ok(TurnType::RoundaboutNeg135Idx),
            fit::Value::Enum(23) => Ok(TurnType::RoundaboutNeg180Idx),
            fit::Value::Enum(24) => Ok(TurnType::RoundaboutNeg225Idx),
            fit::Value::Enum(25) => Ok(TurnType::RoundaboutNeg270Idx),
            fit::Value::Enum(26) => Ok(TurnType::RoundaboutNeg315Idx),
            fit::Value::Enum(27) => Ok(TurnType::RoundaboutNeg360Idx),
            fit::Value::Enum(28) => Ok(TurnType::RoundaboutGenericIdx),
            fit::Value::Enum(29) => Ok(TurnType::RoundaboutNegGenericIdx),
            fit::Value::Enum(30) => Ok(TurnType::SharpTurnLeftIdx),
            fit::Value::Enum(31) => Ok(TurnType::SharpTurnRightIdx),
            fit::Value::Enum(32) => Ok(TurnType::TurnLeftIdx),
            fit::Value::Enum(33) => Ok(TurnType::TurnRightIdx),
            fit::Value::Enum(34) => Ok(TurnType::UturnLeftIdx),
            fit::Value::Enum(35) => Ok(TurnType::UturnRightIdx),
            fit::Value::Enum(36) => Ok(TurnType::IconInvIdx),
            fit::Value::Enum(37) => Ok(TurnType::IconIdxCnt),
            _ => Err("No corresponding TurnType exists"),
        }
    }
}
impl TryFrom<&str> for TurnType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "arriving_idx" => Ok(TurnType::ArrivingIdx),
            "arriving_left_idx" => Ok(TurnType::ArrivingLeftIdx),
            "arriving_right_idx" => Ok(TurnType::ArrivingRightIdx),
            "arriving_via_idx" => Ok(TurnType::ArrivingViaIdx),
            "arriving_via_left_idx" => Ok(TurnType::ArrivingViaLeftIdx),
            "arriving_via_right_idx" => Ok(TurnType::ArrivingViaRightIdx),
            "bear_keep_left_idx" => Ok(TurnType::BearKeepLeftIdx),
            "bear_keep_right_idx" => Ok(TurnType::BearKeepRightIdx),
            "continue_idx" => Ok(TurnType::ContinueIdx),
            "exit_left_idx" => Ok(TurnType::ExitLeftIdx),
            "exit_right_idx" => Ok(TurnType::ExitRightIdx),
            "ferry_idx" => Ok(TurnType::FerryIdx),
            "roundabout_45_idx" => Ok(TurnType::Roundabout45Idx),
            "roundabout_90_idx" => Ok(TurnType::Roundabout90Idx),
            "roundabout_135_idx" => Ok(TurnType::Roundabout135Idx),
            "roundabout_180_idx" => Ok(TurnType::Roundabout180Idx),
            "roundabout_225_idx" => Ok(TurnType::Roundabout225Idx),
            "roundabout_270_idx" => Ok(TurnType::Roundabout270Idx),
            "roundabout_315_idx" => Ok(TurnType::Roundabout315Idx),
            "roundabout_360_idx" => Ok(TurnType::Roundabout360Idx),
            "roundabout_neg_45_idx" => Ok(TurnType::RoundaboutNeg45Idx),
            "roundabout_neg_90_idx" => Ok(TurnType::RoundaboutNeg90Idx),
            "roundabout_neg_135_idx" => Ok(TurnType::RoundaboutNeg135Idx),
            "roundabout_neg_180_idx" => Ok(TurnType::RoundaboutNeg180Idx),
            "roundabout_neg_225_idx" => Ok(TurnType::RoundaboutNeg225Idx),
            "roundabout_neg_270_idx" => Ok(TurnType::RoundaboutNeg270Idx),
            "roundabout_neg_315_idx" => Ok(TurnType::RoundaboutNeg315Idx),
            "roundabout_neg_360_idx" => Ok(TurnType::RoundaboutNeg360Idx),
            "roundabout_generic_idx" => Ok(TurnType::RoundaboutGenericIdx),
            "roundabout_neg_generic_idx" => Ok(TurnType::RoundaboutNegGenericIdx),
            "sharp_turn_left_idx" => Ok(TurnType::SharpTurnLeftIdx),
            "sharp_turn_right_idx" => Ok(TurnType::SharpTurnRightIdx),
            "turn_left_idx" => Ok(TurnType::TurnLeftIdx),
            "turn_right_idx" => Ok(TurnType::TurnRightIdx),
            "uturn_left_idx" => Ok(TurnType::UturnLeftIdx),
            "uturn_right_idx" => Ok(TurnType::UturnRightIdx),
            "icon_inv_idx" => Ok(TurnType::IconInvIdx),
            "icon_idx_cnt" => Ok(TurnType::IconIdxCnt),
            _ => Err("No corresponding TurnType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum BikeLightBeamAngleMode {
    Manual,
    Auto,
}
impl fmt::Display for BikeLightBeamAngleMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BikeLightBeamAngleMode::Manual => f.write_str("manual"),
            BikeLightBeamAngleMode::Auto => f.write_str("auto"),
        }
    }
}
impl BikeLightBeamAngleMode {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            BikeLightBeamAngleMode::Manual => fit::Value::UInt8(0),
            BikeLightBeamAngleMode::Auto => fit::Value::UInt8(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for BikeLightBeamAngleMode {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(0) => Ok(BikeLightBeamAngleMode::Manual),
            fit::Value::UInt8(1) => Ok(BikeLightBeamAngleMode::Auto),
            _ => Err("No corresponding BikeLightBeamAngleMode exists"),
        }
    }
}
impl TryFrom<&str> for BikeLightBeamAngleMode {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "manual" => Ok(BikeLightBeamAngleMode::Manual),
            "auto" => Ok(BikeLightBeamAngleMode::Auto),
            _ => Err("No corresponding BikeLightBeamAngleMode exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum FitBaseUnit {
    Other,
    Kilogram,
    Pound,
}
impl fmt::Display for FitBaseUnit {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FitBaseUnit::Other => f.write_str("other"),
            FitBaseUnit::Kilogram => f.write_str("kilogram"),
            FitBaseUnit::Pound => f.write_str("pound"),
        }
    }
}
impl FitBaseUnit {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            FitBaseUnit::Other => fit::Value::UInt16(0),
            FitBaseUnit::Kilogram => fit::Value::UInt16(1),
            FitBaseUnit::Pound => fit::Value::UInt16(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for FitBaseUnit {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(FitBaseUnit::Other),
            fit::Value::UInt16(1) => Ok(FitBaseUnit::Kilogram),
            fit::Value::UInt16(2) => Ok(FitBaseUnit::Pound),
            _ => Err("No corresponding FitBaseUnit exists"),
        }
    }
}
impl TryFrom<&str> for FitBaseUnit {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "other" => Ok(FitBaseUnit::Other),
            "kilogram" => Ok(FitBaseUnit::Kilogram),
            "pound" => Ok(FitBaseUnit::Pound),
            _ => Err("No corresponding FitBaseUnit exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SetType {
    Rest,
    Active,
}
impl fmt::Display for SetType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SetType::Rest => f.write_str("rest"),
            SetType::Active => f.write_str("active"),
        }
    }
}
impl SetType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SetType::Rest => fit::Value::UInt8(0),
            SetType::Active => fit::Value::UInt8(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint8"
    }
}
impl TryFrom<&fit::Value> for SetType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt8(0) => Ok(SetType::Rest),
            fit::Value::UInt8(1) => Ok(SetType::Active),
            _ => Err("No corresponding SetType exists"),
        }
    }
}
impl TryFrom<&str> for SetType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "rest" => Ok(SetType::Rest),
            "active" => Ok(SetType::Active),
            _ => Err("No corresponding SetType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum MaxMetCategory {
    Generic,
    Cycling,
}
impl fmt::Display for MaxMetCategory {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            MaxMetCategory::Generic => f.write_str("generic"),
            MaxMetCategory::Cycling => f.write_str("cycling"),
        }
    }
}
impl MaxMetCategory {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            MaxMetCategory::Generic => fit::Value::Enum(0),
            MaxMetCategory::Cycling => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for MaxMetCategory {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(MaxMetCategory::Generic),
            fit::Value::Enum(1) => Ok(MaxMetCategory::Cycling),
            _ => Err("No corresponding MaxMetCategory exists"),
        }
    }
}
impl TryFrom<&str> for MaxMetCategory {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "generic" => Ok(MaxMetCategory::Generic),
            "cycling" => Ok(MaxMetCategory::Cycling),
            _ => Err("No corresponding MaxMetCategory exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ExerciseCategory {
    BenchPress,
    CalfRaise,
    Cardio,
    Carry,
    Chop,
    Core,
    Crunch,
    Curl,
    Deadlift,
    Flye,
    HipRaise,
    HipStability,
    HipSwing,
    Hyperextension,
    LateralRaise,
    LegCurl,
    LegRaise,
    Lunge,
    OlympicLift,
    Plank,
    Plyo,
    PullUp,
    PushUp,
    Row,
    ShoulderPress,
    ShoulderStability,
    Shrug,
    SitUp,
    Squat,
    TotalBody,
    TricepsExtension,
    WarmUp,
    Run,
    Unknown,
}
impl fmt::Display for ExerciseCategory {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ExerciseCategory::BenchPress => f.write_str("bench_press"),
            ExerciseCategory::CalfRaise => f.write_str("calf_raise"),
            ExerciseCategory::Cardio => f.write_str("cardio"),
            ExerciseCategory::Carry => f.write_str("carry"),
            ExerciseCategory::Chop => f.write_str("chop"),
            ExerciseCategory::Core => f.write_str("core"),
            ExerciseCategory::Crunch => f.write_str("crunch"),
            ExerciseCategory::Curl => f.write_str("curl"),
            ExerciseCategory::Deadlift => f.write_str("deadlift"),
            ExerciseCategory::Flye => f.write_str("flye"),
            ExerciseCategory::HipRaise => f.write_str("hip_raise"),
            ExerciseCategory::HipStability => f.write_str("hip_stability"),
            ExerciseCategory::HipSwing => f.write_str("hip_swing"),
            ExerciseCategory::Hyperextension => f.write_str("hyperextension"),
            ExerciseCategory::LateralRaise => f.write_str("lateral_raise"),
            ExerciseCategory::LegCurl => f.write_str("leg_curl"),
            ExerciseCategory::LegRaise => f.write_str("leg_raise"),
            ExerciseCategory::Lunge => f.write_str("lunge"),
            ExerciseCategory::OlympicLift => f.write_str("olympic_lift"),
            ExerciseCategory::Plank => f.write_str("plank"),
            ExerciseCategory::Plyo => f.write_str("plyo"),
            ExerciseCategory::PullUp => f.write_str("pull_up"),
            ExerciseCategory::PushUp => f.write_str("push_up"),
            ExerciseCategory::Row => f.write_str("row"),
            ExerciseCategory::ShoulderPress => f.write_str("shoulder_press"),
            ExerciseCategory::ShoulderStability => f.write_str("shoulder_stability"),
            ExerciseCategory::Shrug => f.write_str("shrug"),
            ExerciseCategory::SitUp => f.write_str("sit_up"),
            ExerciseCategory::Squat => f.write_str("squat"),
            ExerciseCategory::TotalBody => f.write_str("total_body"),
            ExerciseCategory::TricepsExtension => f.write_str("triceps_extension"),
            ExerciseCategory::WarmUp => f.write_str("warm_up"),
            ExerciseCategory::Run => f.write_str("run"),
            ExerciseCategory::Unknown => f.write_str("unknown"),
        }
    }
}
impl ExerciseCategory {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ExerciseCategory::BenchPress => fit::Value::UInt16(0),
            ExerciseCategory::CalfRaise => fit::Value::UInt16(1),
            ExerciseCategory::Cardio => fit::Value::UInt16(2),
            ExerciseCategory::Carry => fit::Value::UInt16(3),
            ExerciseCategory::Chop => fit::Value::UInt16(4),
            ExerciseCategory::Core => fit::Value::UInt16(5),
            ExerciseCategory::Crunch => fit::Value::UInt16(6),
            ExerciseCategory::Curl => fit::Value::UInt16(7),
            ExerciseCategory::Deadlift => fit::Value::UInt16(8),
            ExerciseCategory::Flye => fit::Value::UInt16(9),
            ExerciseCategory::HipRaise => fit::Value::UInt16(10),
            ExerciseCategory::HipStability => fit::Value::UInt16(11),
            ExerciseCategory::HipSwing => fit::Value::UInt16(12),
            ExerciseCategory::Hyperextension => fit::Value::UInt16(13),
            ExerciseCategory::LateralRaise => fit::Value::UInt16(14),
            ExerciseCategory::LegCurl => fit::Value::UInt16(15),
            ExerciseCategory::LegRaise => fit::Value::UInt16(16),
            ExerciseCategory::Lunge => fit::Value::UInt16(17),
            ExerciseCategory::OlympicLift => fit::Value::UInt16(18),
            ExerciseCategory::Plank => fit::Value::UInt16(19),
            ExerciseCategory::Plyo => fit::Value::UInt16(20),
            ExerciseCategory::PullUp => fit::Value::UInt16(21),
            ExerciseCategory::PushUp => fit::Value::UInt16(22),
            ExerciseCategory::Row => fit::Value::UInt16(23),
            ExerciseCategory::ShoulderPress => fit::Value::UInt16(24),
            ExerciseCategory::ShoulderStability => fit::Value::UInt16(25),
            ExerciseCategory::Shrug => fit::Value::UInt16(26),
            ExerciseCategory::SitUp => fit::Value::UInt16(27),
            ExerciseCategory::Squat => fit::Value::UInt16(28),
            ExerciseCategory::TotalBody => fit::Value::UInt16(29),
            ExerciseCategory::TricepsExtension => fit::Value::UInt16(30),
            ExerciseCategory::WarmUp => fit::Value::UInt16(31),
            ExerciseCategory::Run => fit::Value::UInt16(32),
            ExerciseCategory::Unknown => fit::Value::UInt16(65534),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for ExerciseCategory {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(ExerciseCategory::BenchPress),
            fit::Value::UInt16(1) => Ok(ExerciseCategory::CalfRaise),
            fit::Value::UInt16(2) => Ok(ExerciseCategory::Cardio),
            fit::Value::UInt16(3) => Ok(ExerciseCategory::Carry),
            fit::Value::UInt16(4) => Ok(ExerciseCategory::Chop),
            fit::Value::UInt16(5) => Ok(ExerciseCategory::Core),
            fit::Value::UInt16(6) => Ok(ExerciseCategory::Crunch),
            fit::Value::UInt16(7) => Ok(ExerciseCategory::Curl),
            fit::Value::UInt16(8) => Ok(ExerciseCategory::Deadlift),
            fit::Value::UInt16(9) => Ok(ExerciseCategory::Flye),
            fit::Value::UInt16(10) => Ok(ExerciseCategory::HipRaise),
            fit::Value::UInt16(11) => Ok(ExerciseCategory::HipStability),
            fit::Value::UInt16(12) => Ok(ExerciseCategory::HipSwing),
            fit::Value::UInt16(13) => Ok(ExerciseCategory::Hyperextension),
            fit::Value::UInt16(14) => Ok(ExerciseCategory::LateralRaise),
            fit::Value::UInt16(15) => Ok(ExerciseCategory::LegCurl),
            fit::Value::UInt16(16) => Ok(ExerciseCategory::LegRaise),
            fit::Value::UInt16(17) => Ok(ExerciseCategory::Lunge),
            fit::Value::UInt16(18) => Ok(ExerciseCategory::OlympicLift),
            fit::Value::UInt16(19) => Ok(ExerciseCategory::Plank),
            fit::Value::UInt16(20) => Ok(ExerciseCategory::Plyo),
            fit::Value::UInt16(21) => Ok(ExerciseCategory::PullUp),
            fit::Value::UInt16(22) => Ok(ExerciseCategory::PushUp),
            fit::Value::UInt16(23) => Ok(ExerciseCategory::Row),
            fit::Value::UInt16(24) => Ok(ExerciseCategory::ShoulderPress),
            fit::Value::UInt16(25) => Ok(ExerciseCategory::ShoulderStability),
            fit::Value::UInt16(26) => Ok(ExerciseCategory::Shrug),
            fit::Value::UInt16(27) => Ok(ExerciseCategory::SitUp),
            fit::Value::UInt16(28) => Ok(ExerciseCategory::Squat),
            fit::Value::UInt16(29) => Ok(ExerciseCategory::TotalBody),
            fit::Value::UInt16(30) => Ok(ExerciseCategory::TricepsExtension),
            fit::Value::UInt16(31) => Ok(ExerciseCategory::WarmUp),
            fit::Value::UInt16(32) => Ok(ExerciseCategory::Run),
            fit::Value::UInt16(65534) => Ok(ExerciseCategory::Unknown),
            _ => Err("No corresponding ExerciseCategory exists"),
        }
    }
}
impl TryFrom<&str> for ExerciseCategory {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "bench_press" => Ok(ExerciseCategory::BenchPress),
            "calf_raise" => Ok(ExerciseCategory::CalfRaise),
            "cardio" => Ok(ExerciseCategory::Cardio),
            "carry" => Ok(ExerciseCategory::Carry),
            "chop" => Ok(ExerciseCategory::Chop),
            "core" => Ok(ExerciseCategory::Core),
            "crunch" => Ok(ExerciseCategory::Crunch),
            "curl" => Ok(ExerciseCategory::Curl),
            "deadlift" => Ok(ExerciseCategory::Deadlift),
            "flye" => Ok(ExerciseCategory::Flye),
            "hip_raise" => Ok(ExerciseCategory::HipRaise),
            "hip_stability" => Ok(ExerciseCategory::HipStability),
            "hip_swing" => Ok(ExerciseCategory::HipSwing),
            "hyperextension" => Ok(ExerciseCategory::Hyperextension),
            "lateral_raise" => Ok(ExerciseCategory::LateralRaise),
            "leg_curl" => Ok(ExerciseCategory::LegCurl),
            "leg_raise" => Ok(ExerciseCategory::LegRaise),
            "lunge" => Ok(ExerciseCategory::Lunge),
            "olympic_lift" => Ok(ExerciseCategory::OlympicLift),
            "plank" => Ok(ExerciseCategory::Plank),
            "plyo" => Ok(ExerciseCategory::Plyo),
            "pull_up" => Ok(ExerciseCategory::PullUp),
            "push_up" => Ok(ExerciseCategory::PushUp),
            "row" => Ok(ExerciseCategory::Row),
            "shoulder_press" => Ok(ExerciseCategory::ShoulderPress),
            "shoulder_stability" => Ok(ExerciseCategory::ShoulderStability),
            "shrug" => Ok(ExerciseCategory::Shrug),
            "sit_up" => Ok(ExerciseCategory::SitUp),
            "squat" => Ok(ExerciseCategory::Squat),
            "total_body" => Ok(ExerciseCategory::TotalBody),
            "triceps_extension" => Ok(ExerciseCategory::TricepsExtension),
            "warm_up" => Ok(ExerciseCategory::WarmUp),
            "run" => Ok(ExerciseCategory::Run),
            "unknown" => Ok(ExerciseCategory::Unknown),
            _ => Err("No corresponding ExerciseCategory exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum BenchPressExerciseName {
    AlternatingDumbbellChestPressOnSwissBall,
    BarbellBenchPress,
    BarbellBoardBenchPress,
    BarbellFloorPress,
    CloseGripBarbellBenchPress,
    DeclineDumbbellBenchPress,
    DumbbellBenchPress,
    DumbbellFloorPress,
    InclineBarbellBenchPress,
    InclineDumbbellBenchPress,
    InclineSmithMachineBenchPress,
    IsometricBarbellBenchPress,
    KettlebellChestPress,
    NeutralGripDumbbellBenchPress,
    NeutralGripDumbbellInclineBenchPress,
    OneArmFloorPress,
    WeightedOneArmFloorPress,
    PartialLockout,
    ReverseGripBarbellBenchPress,
    ReverseGripInclineBenchPress,
    SingleArmCableChestPress,
    SingleArmDumbbellBenchPress,
    SmithMachineBenchPress,
    SwissBallDumbbellChestPress,
    TripleStopBarbellBenchPress,
    WideGripBarbellBenchPress,
    AlternatingDumbbellChestPress,
}
impl fmt::Display for BenchPressExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            BenchPressExerciseName::AlternatingDumbbellChestPressOnSwissBall => {
                f.write_str("alternating_dumbbell_chest_press_on_swiss_ball")
            }
            BenchPressExerciseName::BarbellBenchPress => f.write_str("barbell_bench_press"),
            BenchPressExerciseName::BarbellBoardBenchPress => {
                f.write_str("barbell_board_bench_press")
            }
            BenchPressExerciseName::BarbellFloorPress => f.write_str("barbell_floor_press"),
            BenchPressExerciseName::CloseGripBarbellBenchPress => {
                f.write_str("close_grip_barbell_bench_press")
            }
            BenchPressExerciseName::DeclineDumbbellBenchPress => {
                f.write_str("decline_dumbbell_bench_press")
            }
            BenchPressExerciseName::DumbbellBenchPress => f.write_str("dumbbell_bench_press"),
            BenchPressExerciseName::DumbbellFloorPress => f.write_str("dumbbell_floor_press"),
            BenchPressExerciseName::InclineBarbellBenchPress => {
                f.write_str("incline_barbell_bench_press")
            }
            BenchPressExerciseName::InclineDumbbellBenchPress => {
                f.write_str("incline_dumbbell_bench_press")
            }
            BenchPressExerciseName::InclineSmithMachineBenchPress => {
                f.write_str("incline_smith_machine_bench_press")
            }
            BenchPressExerciseName::IsometricBarbellBenchPress => {
                f.write_str("isometric_barbell_bench_press")
            }
            BenchPressExerciseName::KettlebellChestPress => f.write_str("kettlebell_chest_press"),
            BenchPressExerciseName::NeutralGripDumbbellBenchPress => {
                f.write_str("neutral_grip_dumbbell_bench_press")
            }
            BenchPressExerciseName::NeutralGripDumbbellInclineBenchPress => {
                f.write_str("neutral_grip_dumbbell_incline_bench_press")
            }
            BenchPressExerciseName::OneArmFloorPress => f.write_str("one_arm_floor_press"),
            BenchPressExerciseName::WeightedOneArmFloorPress => {
                f.write_str("weighted_one_arm_floor_press")
            }
            BenchPressExerciseName::PartialLockout => f.write_str("partial_lockout"),
            BenchPressExerciseName::ReverseGripBarbellBenchPress => {
                f.write_str("reverse_grip_barbell_bench_press")
            }
            BenchPressExerciseName::ReverseGripInclineBenchPress => {
                f.write_str("reverse_grip_incline_bench_press")
            }
            BenchPressExerciseName::SingleArmCableChestPress => {
                f.write_str("single_arm_cable_chest_press")
            }
            BenchPressExerciseName::SingleArmDumbbellBenchPress => {
                f.write_str("single_arm_dumbbell_bench_press")
            }
            BenchPressExerciseName::SmithMachineBenchPress => {
                f.write_str("smith_machine_bench_press")
            }
            BenchPressExerciseName::SwissBallDumbbellChestPress => {
                f.write_str("swiss_ball_dumbbell_chest_press")
            }
            BenchPressExerciseName::TripleStopBarbellBenchPress => {
                f.write_str("triple_stop_barbell_bench_press")
            }
            BenchPressExerciseName::WideGripBarbellBenchPress => {
                f.write_str("wide_grip_barbell_bench_press")
            }
            BenchPressExerciseName::AlternatingDumbbellChestPress => {
                f.write_str("alternating_dumbbell_chest_press")
            }
        }
    }
}
impl BenchPressExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            BenchPressExerciseName::AlternatingDumbbellChestPressOnSwissBall => {
                fit::Value::UInt16(0)
            }
            BenchPressExerciseName::BarbellBenchPress => fit::Value::UInt16(1),
            BenchPressExerciseName::BarbellBoardBenchPress => fit::Value::UInt16(2),
            BenchPressExerciseName::BarbellFloorPress => fit::Value::UInt16(3),
            BenchPressExerciseName::CloseGripBarbellBenchPress => fit::Value::UInt16(4),
            BenchPressExerciseName::DeclineDumbbellBenchPress => fit::Value::UInt16(5),
            BenchPressExerciseName::DumbbellBenchPress => fit::Value::UInt16(6),
            BenchPressExerciseName::DumbbellFloorPress => fit::Value::UInt16(7),
            BenchPressExerciseName::InclineBarbellBenchPress => fit::Value::UInt16(8),
            BenchPressExerciseName::InclineDumbbellBenchPress => fit::Value::UInt16(9),
            BenchPressExerciseName::InclineSmithMachineBenchPress => fit::Value::UInt16(10),
            BenchPressExerciseName::IsometricBarbellBenchPress => fit::Value::UInt16(11),
            BenchPressExerciseName::KettlebellChestPress => fit::Value::UInt16(12),
            BenchPressExerciseName::NeutralGripDumbbellBenchPress => fit::Value::UInt16(13),
            BenchPressExerciseName::NeutralGripDumbbellInclineBenchPress => fit::Value::UInt16(14),
            BenchPressExerciseName::OneArmFloorPress => fit::Value::UInt16(15),
            BenchPressExerciseName::WeightedOneArmFloorPress => fit::Value::UInt16(16),
            BenchPressExerciseName::PartialLockout => fit::Value::UInt16(17),
            BenchPressExerciseName::ReverseGripBarbellBenchPress => fit::Value::UInt16(18),
            BenchPressExerciseName::ReverseGripInclineBenchPress => fit::Value::UInt16(19),
            BenchPressExerciseName::SingleArmCableChestPress => fit::Value::UInt16(20),
            BenchPressExerciseName::SingleArmDumbbellBenchPress => fit::Value::UInt16(21),
            BenchPressExerciseName::SmithMachineBenchPress => fit::Value::UInt16(22),
            BenchPressExerciseName::SwissBallDumbbellChestPress => fit::Value::UInt16(23),
            BenchPressExerciseName::TripleStopBarbellBenchPress => fit::Value::UInt16(24),
            BenchPressExerciseName::WideGripBarbellBenchPress => fit::Value::UInt16(25),
            BenchPressExerciseName::AlternatingDumbbellChestPress => fit::Value::UInt16(26),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for BenchPressExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => {
                Ok(BenchPressExerciseName::AlternatingDumbbellChestPressOnSwissBall)
            }
            fit::Value::UInt16(1) => Ok(BenchPressExerciseName::BarbellBenchPress),
            fit::Value::UInt16(2) => Ok(BenchPressExerciseName::BarbellBoardBenchPress),
            fit::Value::UInt16(3) => Ok(BenchPressExerciseName::BarbellFloorPress),
            fit::Value::UInt16(4) => Ok(BenchPressExerciseName::CloseGripBarbellBenchPress),
            fit::Value::UInt16(5) => Ok(BenchPressExerciseName::DeclineDumbbellBenchPress),
            fit::Value::UInt16(6) => Ok(BenchPressExerciseName::DumbbellBenchPress),
            fit::Value::UInt16(7) => Ok(BenchPressExerciseName::DumbbellFloorPress),
            fit::Value::UInt16(8) => Ok(BenchPressExerciseName::InclineBarbellBenchPress),
            fit::Value::UInt16(9) => Ok(BenchPressExerciseName::InclineDumbbellBenchPress),
            fit::Value::UInt16(10) => Ok(BenchPressExerciseName::InclineSmithMachineBenchPress),
            fit::Value::UInt16(11) => Ok(BenchPressExerciseName::IsometricBarbellBenchPress),
            fit::Value::UInt16(12) => Ok(BenchPressExerciseName::KettlebellChestPress),
            fit::Value::UInt16(13) => Ok(BenchPressExerciseName::NeutralGripDumbbellBenchPress),
            fit::Value::UInt16(14) => {
                Ok(BenchPressExerciseName::NeutralGripDumbbellInclineBenchPress)
            }
            fit::Value::UInt16(15) => Ok(BenchPressExerciseName::OneArmFloorPress),
            fit::Value::UInt16(16) => Ok(BenchPressExerciseName::WeightedOneArmFloorPress),
            fit::Value::UInt16(17) => Ok(BenchPressExerciseName::PartialLockout),
            fit::Value::UInt16(18) => Ok(BenchPressExerciseName::ReverseGripBarbellBenchPress),
            fit::Value::UInt16(19) => Ok(BenchPressExerciseName::ReverseGripInclineBenchPress),
            fit::Value::UInt16(20) => Ok(BenchPressExerciseName::SingleArmCableChestPress),
            fit::Value::UInt16(21) => Ok(BenchPressExerciseName::SingleArmDumbbellBenchPress),
            fit::Value::UInt16(22) => Ok(BenchPressExerciseName::SmithMachineBenchPress),
            fit::Value::UInt16(23) => Ok(BenchPressExerciseName::SwissBallDumbbellChestPress),
            fit::Value::UInt16(24) => Ok(BenchPressExerciseName::TripleStopBarbellBenchPress),
            fit::Value::UInt16(25) => Ok(BenchPressExerciseName::WideGripBarbellBenchPress),
            fit::Value::UInt16(26) => Ok(BenchPressExerciseName::AlternatingDumbbellChestPress),
            _ => Err("No corresponding BenchPressExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for BenchPressExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "alternating_dumbbell_chest_press_on_swiss_ball" => {
                Ok(BenchPressExerciseName::AlternatingDumbbellChestPressOnSwissBall)
            }
            "barbell_bench_press" => Ok(BenchPressExerciseName::BarbellBenchPress),
            "barbell_board_bench_press" => Ok(BenchPressExerciseName::BarbellBoardBenchPress),
            "barbell_floor_press" => Ok(BenchPressExerciseName::BarbellFloorPress),
            "close_grip_barbell_bench_press" => {
                Ok(BenchPressExerciseName::CloseGripBarbellBenchPress)
            }
            "decline_dumbbell_bench_press" => Ok(BenchPressExerciseName::DeclineDumbbellBenchPress),
            "dumbbell_bench_press" => Ok(BenchPressExerciseName::DumbbellBenchPress),
            "dumbbell_floor_press" => Ok(BenchPressExerciseName::DumbbellFloorPress),
            "incline_barbell_bench_press" => Ok(BenchPressExerciseName::InclineBarbellBenchPress),
            "incline_dumbbell_bench_press" => Ok(BenchPressExerciseName::InclineDumbbellBenchPress),
            "incline_smith_machine_bench_press" => {
                Ok(BenchPressExerciseName::InclineSmithMachineBenchPress)
            }
            "isometric_barbell_bench_press" => {
                Ok(BenchPressExerciseName::IsometricBarbellBenchPress)
            }
            "kettlebell_chest_press" => Ok(BenchPressExerciseName::KettlebellChestPress),
            "neutral_grip_dumbbell_bench_press" => {
                Ok(BenchPressExerciseName::NeutralGripDumbbellBenchPress)
            }
            "neutral_grip_dumbbell_incline_bench_press" => {
                Ok(BenchPressExerciseName::NeutralGripDumbbellInclineBenchPress)
            }
            "one_arm_floor_press" => Ok(BenchPressExerciseName::OneArmFloorPress),
            "weighted_one_arm_floor_press" => Ok(BenchPressExerciseName::WeightedOneArmFloorPress),
            "partial_lockout" => Ok(BenchPressExerciseName::PartialLockout),
            "reverse_grip_barbell_bench_press" => {
                Ok(BenchPressExerciseName::ReverseGripBarbellBenchPress)
            }
            "reverse_grip_incline_bench_press" => {
                Ok(BenchPressExerciseName::ReverseGripInclineBenchPress)
            }
            "single_arm_cable_chest_press" => Ok(BenchPressExerciseName::SingleArmCableChestPress),
            "single_arm_dumbbell_bench_press" => {
                Ok(BenchPressExerciseName::SingleArmDumbbellBenchPress)
            }
            "smith_machine_bench_press" => Ok(BenchPressExerciseName::SmithMachineBenchPress),
            "swiss_ball_dumbbell_chest_press" => {
                Ok(BenchPressExerciseName::SwissBallDumbbellChestPress)
            }
            "triple_stop_barbell_bench_press" => {
                Ok(BenchPressExerciseName::TripleStopBarbellBenchPress)
            }
            "wide_grip_barbell_bench_press" => {
                Ok(BenchPressExerciseName::WideGripBarbellBenchPress)
            }
            "alternating_dumbbell_chest_press" => {
                Ok(BenchPressExerciseName::AlternatingDumbbellChestPress)
            }
            _ => Err("No corresponding BenchPressExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CalfRaiseExerciseName {
    N3WayCalfRaise,
    N3WayWeightedCalfRaise,
    N3WaySingleLegCalfRaise,
    N3WayWeightedSingleLegCalfRaise,
    DonkeyCalfRaise,
    WeightedDonkeyCalfRaise,
    SeatedCalfRaise,
    WeightedSeatedCalfRaise,
    SeatedDumbbellToeRaise,
    SingleLegBentKneeCalfRaise,
    WeightedSingleLegBentKneeCalfRaise,
    SingleLegDeclinePushUp,
    SingleLegDonkeyCalfRaise,
    WeightedSingleLegDonkeyCalfRaise,
    SingleLegHipRaiseWithKneeHold,
    SingleLegStandingCalfRaise,
    SingleLegStandingDumbbellCalfRaise,
    StandingBarbellCalfRaise,
    StandingCalfRaise,
    WeightedStandingCalfRaise,
    StandingDumbbellCalfRaise,
}
impl fmt::Display for CalfRaiseExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CalfRaiseExerciseName::N3WayCalfRaise => f.write_str("3_way_calf_raise"),
            CalfRaiseExerciseName::N3WayWeightedCalfRaise => {
                f.write_str("3_way_weighted_calf_raise")
            }
            CalfRaiseExerciseName::N3WaySingleLegCalfRaise => {
                f.write_str("3_way_single_leg_calf_raise")
            }
            CalfRaiseExerciseName::N3WayWeightedSingleLegCalfRaise => {
                f.write_str("3_way_weighted_single_leg_calf_raise")
            }
            CalfRaiseExerciseName::DonkeyCalfRaise => f.write_str("donkey_calf_raise"),
            CalfRaiseExerciseName::WeightedDonkeyCalfRaise => {
                f.write_str("weighted_donkey_calf_raise")
            }
            CalfRaiseExerciseName::SeatedCalfRaise => f.write_str("seated_calf_raise"),
            CalfRaiseExerciseName::WeightedSeatedCalfRaise => {
                f.write_str("weighted_seated_calf_raise")
            }
            CalfRaiseExerciseName::SeatedDumbbellToeRaise => {
                f.write_str("seated_dumbbell_toe_raise")
            }
            CalfRaiseExerciseName::SingleLegBentKneeCalfRaise => {
                f.write_str("single_leg_bent_knee_calf_raise")
            }
            CalfRaiseExerciseName::WeightedSingleLegBentKneeCalfRaise => {
                f.write_str("weighted_single_leg_bent_knee_calf_raise")
            }
            CalfRaiseExerciseName::SingleLegDeclinePushUp => {
                f.write_str("single_leg_decline_push_up")
            }
            CalfRaiseExerciseName::SingleLegDonkeyCalfRaise => {
                f.write_str("single_leg_donkey_calf_raise")
            }
            CalfRaiseExerciseName::WeightedSingleLegDonkeyCalfRaise => {
                f.write_str("weighted_single_leg_donkey_calf_raise")
            }
            CalfRaiseExerciseName::SingleLegHipRaiseWithKneeHold => {
                f.write_str("single_leg_hip_raise_with_knee_hold")
            }
            CalfRaiseExerciseName::SingleLegStandingCalfRaise => {
                f.write_str("single_leg_standing_calf_raise")
            }
            CalfRaiseExerciseName::SingleLegStandingDumbbellCalfRaise => {
                f.write_str("single_leg_standing_dumbbell_calf_raise")
            }
            CalfRaiseExerciseName::StandingBarbellCalfRaise => {
                f.write_str("standing_barbell_calf_raise")
            }
            CalfRaiseExerciseName::StandingCalfRaise => f.write_str("standing_calf_raise"),
            CalfRaiseExerciseName::WeightedStandingCalfRaise => {
                f.write_str("weighted_standing_calf_raise")
            }
            CalfRaiseExerciseName::StandingDumbbellCalfRaise => {
                f.write_str("standing_dumbbell_calf_raise")
            }
        }
    }
}
impl CalfRaiseExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CalfRaiseExerciseName::N3WayCalfRaise => fit::Value::UInt16(0),
            CalfRaiseExerciseName::N3WayWeightedCalfRaise => fit::Value::UInt16(1),
            CalfRaiseExerciseName::N3WaySingleLegCalfRaise => fit::Value::UInt16(2),
            CalfRaiseExerciseName::N3WayWeightedSingleLegCalfRaise => fit::Value::UInt16(3),
            CalfRaiseExerciseName::DonkeyCalfRaise => fit::Value::UInt16(4),
            CalfRaiseExerciseName::WeightedDonkeyCalfRaise => fit::Value::UInt16(5),
            CalfRaiseExerciseName::SeatedCalfRaise => fit::Value::UInt16(6),
            CalfRaiseExerciseName::WeightedSeatedCalfRaise => fit::Value::UInt16(7),
            CalfRaiseExerciseName::SeatedDumbbellToeRaise => fit::Value::UInt16(8),
            CalfRaiseExerciseName::SingleLegBentKneeCalfRaise => fit::Value::UInt16(9),
            CalfRaiseExerciseName::WeightedSingleLegBentKneeCalfRaise => fit::Value::UInt16(10),
            CalfRaiseExerciseName::SingleLegDeclinePushUp => fit::Value::UInt16(11),
            CalfRaiseExerciseName::SingleLegDonkeyCalfRaise => fit::Value::UInt16(12),
            CalfRaiseExerciseName::WeightedSingleLegDonkeyCalfRaise => fit::Value::UInt16(13),
            CalfRaiseExerciseName::SingleLegHipRaiseWithKneeHold => fit::Value::UInt16(14),
            CalfRaiseExerciseName::SingleLegStandingCalfRaise => fit::Value::UInt16(15),
            CalfRaiseExerciseName::SingleLegStandingDumbbellCalfRaise => fit::Value::UInt16(16),
            CalfRaiseExerciseName::StandingBarbellCalfRaise => fit::Value::UInt16(17),
            CalfRaiseExerciseName::StandingCalfRaise => fit::Value::UInt16(18),
            CalfRaiseExerciseName::WeightedStandingCalfRaise => fit::Value::UInt16(19),
            CalfRaiseExerciseName::StandingDumbbellCalfRaise => fit::Value::UInt16(20),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for CalfRaiseExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(CalfRaiseExerciseName::N3WayCalfRaise),
            fit::Value::UInt16(1) => Ok(CalfRaiseExerciseName::N3WayWeightedCalfRaise),
            fit::Value::UInt16(2) => Ok(CalfRaiseExerciseName::N3WaySingleLegCalfRaise),
            fit::Value::UInt16(3) => Ok(CalfRaiseExerciseName::N3WayWeightedSingleLegCalfRaise),
            fit::Value::UInt16(4) => Ok(CalfRaiseExerciseName::DonkeyCalfRaise),
            fit::Value::UInt16(5) => Ok(CalfRaiseExerciseName::WeightedDonkeyCalfRaise),
            fit::Value::UInt16(6) => Ok(CalfRaiseExerciseName::SeatedCalfRaise),
            fit::Value::UInt16(7) => Ok(CalfRaiseExerciseName::WeightedSeatedCalfRaise),
            fit::Value::UInt16(8) => Ok(CalfRaiseExerciseName::SeatedDumbbellToeRaise),
            fit::Value::UInt16(9) => Ok(CalfRaiseExerciseName::SingleLegBentKneeCalfRaise),
            fit::Value::UInt16(10) => Ok(CalfRaiseExerciseName::WeightedSingleLegBentKneeCalfRaise),
            fit::Value::UInt16(11) => Ok(CalfRaiseExerciseName::SingleLegDeclinePushUp),
            fit::Value::UInt16(12) => Ok(CalfRaiseExerciseName::SingleLegDonkeyCalfRaise),
            fit::Value::UInt16(13) => Ok(CalfRaiseExerciseName::WeightedSingleLegDonkeyCalfRaise),
            fit::Value::UInt16(14) => Ok(CalfRaiseExerciseName::SingleLegHipRaiseWithKneeHold),
            fit::Value::UInt16(15) => Ok(CalfRaiseExerciseName::SingleLegStandingCalfRaise),
            fit::Value::UInt16(16) => Ok(CalfRaiseExerciseName::SingleLegStandingDumbbellCalfRaise),
            fit::Value::UInt16(17) => Ok(CalfRaiseExerciseName::StandingBarbellCalfRaise),
            fit::Value::UInt16(18) => Ok(CalfRaiseExerciseName::StandingCalfRaise),
            fit::Value::UInt16(19) => Ok(CalfRaiseExerciseName::WeightedStandingCalfRaise),
            fit::Value::UInt16(20) => Ok(CalfRaiseExerciseName::StandingDumbbellCalfRaise),
            _ => Err("No corresponding CalfRaiseExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for CalfRaiseExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "3_way_calf_raise" => Ok(CalfRaiseExerciseName::N3WayCalfRaise),
            "3_way_weighted_calf_raise" => Ok(CalfRaiseExerciseName::N3WayWeightedCalfRaise),
            "3_way_single_leg_calf_raise" => Ok(CalfRaiseExerciseName::N3WaySingleLegCalfRaise),
            "3_way_weighted_single_leg_calf_raise" => {
                Ok(CalfRaiseExerciseName::N3WayWeightedSingleLegCalfRaise)
            }
            "donkey_calf_raise" => Ok(CalfRaiseExerciseName::DonkeyCalfRaise),
            "weighted_donkey_calf_raise" => Ok(CalfRaiseExerciseName::WeightedDonkeyCalfRaise),
            "seated_calf_raise" => Ok(CalfRaiseExerciseName::SeatedCalfRaise),
            "weighted_seated_calf_raise" => Ok(CalfRaiseExerciseName::WeightedSeatedCalfRaise),
            "seated_dumbbell_toe_raise" => Ok(CalfRaiseExerciseName::SeatedDumbbellToeRaise),
            "single_leg_bent_knee_calf_raise" => {
                Ok(CalfRaiseExerciseName::SingleLegBentKneeCalfRaise)
            }
            "weighted_single_leg_bent_knee_calf_raise" => {
                Ok(CalfRaiseExerciseName::WeightedSingleLegBentKneeCalfRaise)
            }
            "single_leg_decline_push_up" => Ok(CalfRaiseExerciseName::SingleLegDeclinePushUp),
            "single_leg_donkey_calf_raise" => Ok(CalfRaiseExerciseName::SingleLegDonkeyCalfRaise),
            "weighted_single_leg_donkey_calf_raise" => {
                Ok(CalfRaiseExerciseName::WeightedSingleLegDonkeyCalfRaise)
            }
            "single_leg_hip_raise_with_knee_hold" => {
                Ok(CalfRaiseExerciseName::SingleLegHipRaiseWithKneeHold)
            }
            "single_leg_standing_calf_raise" => {
                Ok(CalfRaiseExerciseName::SingleLegStandingCalfRaise)
            }
            "single_leg_standing_dumbbell_calf_raise" => {
                Ok(CalfRaiseExerciseName::SingleLegStandingDumbbellCalfRaise)
            }
            "standing_barbell_calf_raise" => Ok(CalfRaiseExerciseName::StandingBarbellCalfRaise),
            "standing_calf_raise" => Ok(CalfRaiseExerciseName::StandingCalfRaise),
            "weighted_standing_calf_raise" => Ok(CalfRaiseExerciseName::WeightedStandingCalfRaise),
            "standing_dumbbell_calf_raise" => Ok(CalfRaiseExerciseName::StandingDumbbellCalfRaise),
            _ => Err("No corresponding CalfRaiseExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CardioExerciseName {
    BobAndWeaveCircle,
    WeightedBobAndWeaveCircle,
    CardioCoreCrawl,
    WeightedCardioCoreCrawl,
    DoubleUnder,
    WeightedDoubleUnder,
    JumpRope,
    WeightedJumpRope,
    JumpRopeCrossover,
    WeightedJumpRopeCrossover,
    JumpRopeJog,
    WeightedJumpRopeJog,
    JumpingJacks,
    WeightedJumpingJacks,
    SkiMoguls,
    WeightedSkiMoguls,
    SplitJacks,
    WeightedSplitJacks,
    SquatJacks,
    WeightedSquatJacks,
    TripleUnder,
    WeightedTripleUnder,
}
impl fmt::Display for CardioExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CardioExerciseName::BobAndWeaveCircle => f.write_str("bob_and_weave_circle"),
            CardioExerciseName::WeightedBobAndWeaveCircle => {
                f.write_str("weighted_bob_and_weave_circle")
            }
            CardioExerciseName::CardioCoreCrawl => f.write_str("cardio_core_crawl"),
            CardioExerciseName::WeightedCardioCoreCrawl => {
                f.write_str("weighted_cardio_core_crawl")
            }
            CardioExerciseName::DoubleUnder => f.write_str("double_under"),
            CardioExerciseName::WeightedDoubleUnder => f.write_str("weighted_double_under"),
            CardioExerciseName::JumpRope => f.write_str("jump_rope"),
            CardioExerciseName::WeightedJumpRope => f.write_str("weighted_jump_rope"),
            CardioExerciseName::JumpRopeCrossover => f.write_str("jump_rope_crossover"),
            CardioExerciseName::WeightedJumpRopeCrossover => {
                f.write_str("weighted_jump_rope_crossover")
            }
            CardioExerciseName::JumpRopeJog => f.write_str("jump_rope_jog"),
            CardioExerciseName::WeightedJumpRopeJog => f.write_str("weighted_jump_rope_jog"),
            CardioExerciseName::JumpingJacks => f.write_str("jumping_jacks"),
            CardioExerciseName::WeightedJumpingJacks => f.write_str("weighted_jumping_jacks"),
            CardioExerciseName::SkiMoguls => f.write_str("ski_moguls"),
            CardioExerciseName::WeightedSkiMoguls => f.write_str("weighted_ski_moguls"),
            CardioExerciseName::SplitJacks => f.write_str("split_jacks"),
            CardioExerciseName::WeightedSplitJacks => f.write_str("weighted_split_jacks"),
            CardioExerciseName::SquatJacks => f.write_str("squat_jacks"),
            CardioExerciseName::WeightedSquatJacks => f.write_str("weighted_squat_jacks"),
            CardioExerciseName::TripleUnder => f.write_str("triple_under"),
            CardioExerciseName::WeightedTripleUnder => f.write_str("weighted_triple_under"),
        }
    }
}
impl CardioExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CardioExerciseName::BobAndWeaveCircle => fit::Value::UInt16(0),
            CardioExerciseName::WeightedBobAndWeaveCircle => fit::Value::UInt16(1),
            CardioExerciseName::CardioCoreCrawl => fit::Value::UInt16(2),
            CardioExerciseName::WeightedCardioCoreCrawl => fit::Value::UInt16(3),
            CardioExerciseName::DoubleUnder => fit::Value::UInt16(4),
            CardioExerciseName::WeightedDoubleUnder => fit::Value::UInt16(5),
            CardioExerciseName::JumpRope => fit::Value::UInt16(6),
            CardioExerciseName::WeightedJumpRope => fit::Value::UInt16(7),
            CardioExerciseName::JumpRopeCrossover => fit::Value::UInt16(8),
            CardioExerciseName::WeightedJumpRopeCrossover => fit::Value::UInt16(9),
            CardioExerciseName::JumpRopeJog => fit::Value::UInt16(10),
            CardioExerciseName::WeightedJumpRopeJog => fit::Value::UInt16(11),
            CardioExerciseName::JumpingJacks => fit::Value::UInt16(12),
            CardioExerciseName::WeightedJumpingJacks => fit::Value::UInt16(13),
            CardioExerciseName::SkiMoguls => fit::Value::UInt16(14),
            CardioExerciseName::WeightedSkiMoguls => fit::Value::UInt16(15),
            CardioExerciseName::SplitJacks => fit::Value::UInt16(16),
            CardioExerciseName::WeightedSplitJacks => fit::Value::UInt16(17),
            CardioExerciseName::SquatJacks => fit::Value::UInt16(18),
            CardioExerciseName::WeightedSquatJacks => fit::Value::UInt16(19),
            CardioExerciseName::TripleUnder => fit::Value::UInt16(20),
            CardioExerciseName::WeightedTripleUnder => fit::Value::UInt16(21),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for CardioExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(CardioExerciseName::BobAndWeaveCircle),
            fit::Value::UInt16(1) => Ok(CardioExerciseName::WeightedBobAndWeaveCircle),
            fit::Value::UInt16(2) => Ok(CardioExerciseName::CardioCoreCrawl),
            fit::Value::UInt16(3) => Ok(CardioExerciseName::WeightedCardioCoreCrawl),
            fit::Value::UInt16(4) => Ok(CardioExerciseName::DoubleUnder),
            fit::Value::UInt16(5) => Ok(CardioExerciseName::WeightedDoubleUnder),
            fit::Value::UInt16(6) => Ok(CardioExerciseName::JumpRope),
            fit::Value::UInt16(7) => Ok(CardioExerciseName::WeightedJumpRope),
            fit::Value::UInt16(8) => Ok(CardioExerciseName::JumpRopeCrossover),
            fit::Value::UInt16(9) => Ok(CardioExerciseName::WeightedJumpRopeCrossover),
            fit::Value::UInt16(10) => Ok(CardioExerciseName::JumpRopeJog),
            fit::Value::UInt16(11) => Ok(CardioExerciseName::WeightedJumpRopeJog),
            fit::Value::UInt16(12) => Ok(CardioExerciseName::JumpingJacks),
            fit::Value::UInt16(13) => Ok(CardioExerciseName::WeightedJumpingJacks),
            fit::Value::UInt16(14) => Ok(CardioExerciseName::SkiMoguls),
            fit::Value::UInt16(15) => Ok(CardioExerciseName::WeightedSkiMoguls),
            fit::Value::UInt16(16) => Ok(CardioExerciseName::SplitJacks),
            fit::Value::UInt16(17) => Ok(CardioExerciseName::WeightedSplitJacks),
            fit::Value::UInt16(18) => Ok(CardioExerciseName::SquatJacks),
            fit::Value::UInt16(19) => Ok(CardioExerciseName::WeightedSquatJacks),
            fit::Value::UInt16(20) => Ok(CardioExerciseName::TripleUnder),
            fit::Value::UInt16(21) => Ok(CardioExerciseName::WeightedTripleUnder),
            _ => Err("No corresponding CardioExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for CardioExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "bob_and_weave_circle" => Ok(CardioExerciseName::BobAndWeaveCircle),
            "weighted_bob_and_weave_circle" => Ok(CardioExerciseName::WeightedBobAndWeaveCircle),
            "cardio_core_crawl" => Ok(CardioExerciseName::CardioCoreCrawl),
            "weighted_cardio_core_crawl" => Ok(CardioExerciseName::WeightedCardioCoreCrawl),
            "double_under" => Ok(CardioExerciseName::DoubleUnder),
            "weighted_double_under" => Ok(CardioExerciseName::WeightedDoubleUnder),
            "jump_rope" => Ok(CardioExerciseName::JumpRope),
            "weighted_jump_rope" => Ok(CardioExerciseName::WeightedJumpRope),
            "jump_rope_crossover" => Ok(CardioExerciseName::JumpRopeCrossover),
            "weighted_jump_rope_crossover" => Ok(CardioExerciseName::WeightedJumpRopeCrossover),
            "jump_rope_jog" => Ok(CardioExerciseName::JumpRopeJog),
            "weighted_jump_rope_jog" => Ok(CardioExerciseName::WeightedJumpRopeJog),
            "jumping_jacks" => Ok(CardioExerciseName::JumpingJacks),
            "weighted_jumping_jacks" => Ok(CardioExerciseName::WeightedJumpingJacks),
            "ski_moguls" => Ok(CardioExerciseName::SkiMoguls),
            "weighted_ski_moguls" => Ok(CardioExerciseName::WeightedSkiMoguls),
            "split_jacks" => Ok(CardioExerciseName::SplitJacks),
            "weighted_split_jacks" => Ok(CardioExerciseName::WeightedSplitJacks),
            "squat_jacks" => Ok(CardioExerciseName::SquatJacks),
            "weighted_squat_jacks" => Ok(CardioExerciseName::WeightedSquatJacks),
            "triple_under" => Ok(CardioExerciseName::TripleUnder),
            "weighted_triple_under" => Ok(CardioExerciseName::WeightedTripleUnder),
            _ => Err("No corresponding CardioExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CarryExerciseName {
    BarHolds,
    FarmersWalk,
    FarmersWalkOnToes,
    HexDumbbellHold,
    OverheadCarry,
}
impl fmt::Display for CarryExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CarryExerciseName::BarHolds => f.write_str("bar_holds"),
            CarryExerciseName::FarmersWalk => f.write_str("farmers_walk"),
            CarryExerciseName::FarmersWalkOnToes => f.write_str("farmers_walk_on_toes"),
            CarryExerciseName::HexDumbbellHold => f.write_str("hex_dumbbell_hold"),
            CarryExerciseName::OverheadCarry => f.write_str("overhead_carry"),
        }
    }
}
impl CarryExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CarryExerciseName::BarHolds => fit::Value::UInt16(0),
            CarryExerciseName::FarmersWalk => fit::Value::UInt16(1),
            CarryExerciseName::FarmersWalkOnToes => fit::Value::UInt16(2),
            CarryExerciseName::HexDumbbellHold => fit::Value::UInt16(3),
            CarryExerciseName::OverheadCarry => fit::Value::UInt16(4),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for CarryExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(CarryExerciseName::BarHolds),
            fit::Value::UInt16(1) => Ok(CarryExerciseName::FarmersWalk),
            fit::Value::UInt16(2) => Ok(CarryExerciseName::FarmersWalkOnToes),
            fit::Value::UInt16(3) => Ok(CarryExerciseName::HexDumbbellHold),
            fit::Value::UInt16(4) => Ok(CarryExerciseName::OverheadCarry),
            _ => Err("No corresponding CarryExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for CarryExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "bar_holds" => Ok(CarryExerciseName::BarHolds),
            "farmers_walk" => Ok(CarryExerciseName::FarmersWalk),
            "farmers_walk_on_toes" => Ok(CarryExerciseName::FarmersWalkOnToes),
            "hex_dumbbell_hold" => Ok(CarryExerciseName::HexDumbbellHold),
            "overhead_carry" => Ok(CarryExerciseName::OverheadCarry),
            _ => Err("No corresponding CarryExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ChopExerciseName {
    CablePullThrough,
    CableRotationalLift,
    CableWoodchop,
    CrossChopToKnee,
    WeightedCrossChopToKnee,
    DumbbellChop,
    HalfKneelingRotation,
    WeightedHalfKneelingRotation,
    HalfKneelingRotationalChop,
    HalfKneelingRotationalReverseChop,
    HalfKneelingStabilityChop,
    HalfKneelingStabilityReverseChop,
    KneelingRotationalChop,
    KneelingRotationalReverseChop,
    KneelingStabilityChop,
    KneelingWoodchopper,
    MedicineBallWoodChops,
    PowerSquatChops,
    WeightedPowerSquatChops,
    StandingRotationalChop,
    StandingSplitRotationalChop,
    StandingSplitRotationalReverseChop,
    StandingStabilityReverseChop,
}
impl fmt::Display for ChopExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ChopExerciseName::CablePullThrough => f.write_str("cable_pull_through"),
            ChopExerciseName::CableRotationalLift => f.write_str("cable_rotational_lift"),
            ChopExerciseName::CableWoodchop => f.write_str("cable_woodchop"),
            ChopExerciseName::CrossChopToKnee => f.write_str("cross_chop_to_knee"),
            ChopExerciseName::WeightedCrossChopToKnee => f.write_str("weighted_cross_chop_to_knee"),
            ChopExerciseName::DumbbellChop => f.write_str("dumbbell_chop"),
            ChopExerciseName::HalfKneelingRotation => f.write_str("half_kneeling_rotation"),
            ChopExerciseName::WeightedHalfKneelingRotation => {
                f.write_str("weighted_half_kneeling_rotation")
            }
            ChopExerciseName::HalfKneelingRotationalChop => {
                f.write_str("half_kneeling_rotational_chop")
            }
            ChopExerciseName::HalfKneelingRotationalReverseChop => {
                f.write_str("half_kneeling_rotational_reverse_chop")
            }
            ChopExerciseName::HalfKneelingStabilityChop => {
                f.write_str("half_kneeling_stability_chop")
            }
            ChopExerciseName::HalfKneelingStabilityReverseChop => {
                f.write_str("half_kneeling_stability_reverse_chop")
            }
            ChopExerciseName::KneelingRotationalChop => f.write_str("kneeling_rotational_chop"),
            ChopExerciseName::KneelingRotationalReverseChop => {
                f.write_str("kneeling_rotational_reverse_chop")
            }
            ChopExerciseName::KneelingStabilityChop => f.write_str("kneeling_stability_chop"),
            ChopExerciseName::KneelingWoodchopper => f.write_str("kneeling_woodchopper"),
            ChopExerciseName::MedicineBallWoodChops => f.write_str("medicine_ball_wood_chops"),
            ChopExerciseName::PowerSquatChops => f.write_str("power_squat_chops"),
            ChopExerciseName::WeightedPowerSquatChops => f.write_str("weighted_power_squat_chops"),
            ChopExerciseName::StandingRotationalChop => f.write_str("standing_rotational_chop"),
            ChopExerciseName::StandingSplitRotationalChop => {
                f.write_str("standing_split_rotational_chop")
            }
            ChopExerciseName::StandingSplitRotationalReverseChop => {
                f.write_str("standing_split_rotational_reverse_chop")
            }
            ChopExerciseName::StandingStabilityReverseChop => {
                f.write_str("standing_stability_reverse_chop")
            }
        }
    }
}
impl ChopExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ChopExerciseName::CablePullThrough => fit::Value::UInt16(0),
            ChopExerciseName::CableRotationalLift => fit::Value::UInt16(1),
            ChopExerciseName::CableWoodchop => fit::Value::UInt16(2),
            ChopExerciseName::CrossChopToKnee => fit::Value::UInt16(3),
            ChopExerciseName::WeightedCrossChopToKnee => fit::Value::UInt16(4),
            ChopExerciseName::DumbbellChop => fit::Value::UInt16(5),
            ChopExerciseName::HalfKneelingRotation => fit::Value::UInt16(6),
            ChopExerciseName::WeightedHalfKneelingRotation => fit::Value::UInt16(7),
            ChopExerciseName::HalfKneelingRotationalChop => fit::Value::UInt16(8),
            ChopExerciseName::HalfKneelingRotationalReverseChop => fit::Value::UInt16(9),
            ChopExerciseName::HalfKneelingStabilityChop => fit::Value::UInt16(10),
            ChopExerciseName::HalfKneelingStabilityReverseChop => fit::Value::UInt16(11),
            ChopExerciseName::KneelingRotationalChop => fit::Value::UInt16(12),
            ChopExerciseName::KneelingRotationalReverseChop => fit::Value::UInt16(13),
            ChopExerciseName::KneelingStabilityChop => fit::Value::UInt16(14),
            ChopExerciseName::KneelingWoodchopper => fit::Value::UInt16(15),
            ChopExerciseName::MedicineBallWoodChops => fit::Value::UInt16(16),
            ChopExerciseName::PowerSquatChops => fit::Value::UInt16(17),
            ChopExerciseName::WeightedPowerSquatChops => fit::Value::UInt16(18),
            ChopExerciseName::StandingRotationalChop => fit::Value::UInt16(19),
            ChopExerciseName::StandingSplitRotationalChop => fit::Value::UInt16(20),
            ChopExerciseName::StandingSplitRotationalReverseChop => fit::Value::UInt16(21),
            ChopExerciseName::StandingStabilityReverseChop => fit::Value::UInt16(22),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for ChopExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(ChopExerciseName::CablePullThrough),
            fit::Value::UInt16(1) => Ok(ChopExerciseName::CableRotationalLift),
            fit::Value::UInt16(2) => Ok(ChopExerciseName::CableWoodchop),
            fit::Value::UInt16(3) => Ok(ChopExerciseName::CrossChopToKnee),
            fit::Value::UInt16(4) => Ok(ChopExerciseName::WeightedCrossChopToKnee),
            fit::Value::UInt16(5) => Ok(ChopExerciseName::DumbbellChop),
            fit::Value::UInt16(6) => Ok(ChopExerciseName::HalfKneelingRotation),
            fit::Value::UInt16(7) => Ok(ChopExerciseName::WeightedHalfKneelingRotation),
            fit::Value::UInt16(8) => Ok(ChopExerciseName::HalfKneelingRotationalChop),
            fit::Value::UInt16(9) => Ok(ChopExerciseName::HalfKneelingRotationalReverseChop),
            fit::Value::UInt16(10) => Ok(ChopExerciseName::HalfKneelingStabilityChop),
            fit::Value::UInt16(11) => Ok(ChopExerciseName::HalfKneelingStabilityReverseChop),
            fit::Value::UInt16(12) => Ok(ChopExerciseName::KneelingRotationalChop),
            fit::Value::UInt16(13) => Ok(ChopExerciseName::KneelingRotationalReverseChop),
            fit::Value::UInt16(14) => Ok(ChopExerciseName::KneelingStabilityChop),
            fit::Value::UInt16(15) => Ok(ChopExerciseName::KneelingWoodchopper),
            fit::Value::UInt16(16) => Ok(ChopExerciseName::MedicineBallWoodChops),
            fit::Value::UInt16(17) => Ok(ChopExerciseName::PowerSquatChops),
            fit::Value::UInt16(18) => Ok(ChopExerciseName::WeightedPowerSquatChops),
            fit::Value::UInt16(19) => Ok(ChopExerciseName::StandingRotationalChop),
            fit::Value::UInt16(20) => Ok(ChopExerciseName::StandingSplitRotationalChop),
            fit::Value::UInt16(21) => Ok(ChopExerciseName::StandingSplitRotationalReverseChop),
            fit::Value::UInt16(22) => Ok(ChopExerciseName::StandingStabilityReverseChop),
            _ => Err("No corresponding ChopExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for ChopExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "cable_pull_through" => Ok(ChopExerciseName::CablePullThrough),
            "cable_rotational_lift" => Ok(ChopExerciseName::CableRotationalLift),
            "cable_woodchop" => Ok(ChopExerciseName::CableWoodchop),
            "cross_chop_to_knee" => Ok(ChopExerciseName::CrossChopToKnee),
            "weighted_cross_chop_to_knee" => Ok(ChopExerciseName::WeightedCrossChopToKnee),
            "dumbbell_chop" => Ok(ChopExerciseName::DumbbellChop),
            "half_kneeling_rotation" => Ok(ChopExerciseName::HalfKneelingRotation),
            "weighted_half_kneeling_rotation" => Ok(ChopExerciseName::WeightedHalfKneelingRotation),
            "half_kneeling_rotational_chop" => Ok(ChopExerciseName::HalfKneelingRotationalChop),
            "half_kneeling_rotational_reverse_chop" => {
                Ok(ChopExerciseName::HalfKneelingRotationalReverseChop)
            }
            "half_kneeling_stability_chop" => Ok(ChopExerciseName::HalfKneelingStabilityChop),
            "half_kneeling_stability_reverse_chop" => {
                Ok(ChopExerciseName::HalfKneelingStabilityReverseChop)
            }
            "kneeling_rotational_chop" => Ok(ChopExerciseName::KneelingRotationalChop),
            "kneeling_rotational_reverse_chop" => {
                Ok(ChopExerciseName::KneelingRotationalReverseChop)
            }
            "kneeling_stability_chop" => Ok(ChopExerciseName::KneelingStabilityChop),
            "kneeling_woodchopper" => Ok(ChopExerciseName::KneelingWoodchopper),
            "medicine_ball_wood_chops" => Ok(ChopExerciseName::MedicineBallWoodChops),
            "power_squat_chops" => Ok(ChopExerciseName::PowerSquatChops),
            "weighted_power_squat_chops" => Ok(ChopExerciseName::WeightedPowerSquatChops),
            "standing_rotational_chop" => Ok(ChopExerciseName::StandingRotationalChop),
            "standing_split_rotational_chop" => Ok(ChopExerciseName::StandingSplitRotationalChop),
            "standing_split_rotational_reverse_chop" => {
                Ok(ChopExerciseName::StandingSplitRotationalReverseChop)
            }
            "standing_stability_reverse_chop" => Ok(ChopExerciseName::StandingStabilityReverseChop),
            _ => Err("No corresponding ChopExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CoreExerciseName {
    AbsJabs,
    WeightedAbsJabs,
    AlternatingPlateReach,
    BarbellRollout,
    WeightedBarbellRollout,
    BodyBarObliqueTwist,
    CableCorePress,
    CableSideBend,
    SideBend,
    WeightedSideBend,
    CrescentCircle,
    WeightedCrescentCircle,
    CyclingRussianTwist,
    WeightedCyclingRussianTwist,
    ElevatedFeetRussianTwist,
    WeightedElevatedFeetRussianTwist,
    HalfTurkishGetUp,
    KettlebellWindmill,
    KneelingAbWheel,
    WeightedKneelingAbWheel,
    ModifiedFrontLever,
    OpenKneeTucks,
    WeightedOpenKneeTucks,
    SideAbsLegLift,
    WeightedSideAbsLegLift,
    SwissBallJackknife,
    WeightedSwissBallJackknife,
    SwissBallPike,
    WeightedSwissBallPike,
    SwissBallRollout,
    WeightedSwissBallRollout,
    TriangleHipPress,
    WeightedTriangleHipPress,
    TrxSuspendedJackknife,
    WeightedTrxSuspendedJackknife,
    UBoat,
    WeightedUBoat,
    WindmillSwitches,
    WeightedWindmillSwitches,
    AlternatingSlideOut,
    WeightedAlternatingSlideOut,
    GhdBackExtensions,
    WeightedGhdBackExtensions,
    OverheadWalk,
    Inchworm,
    WeightedModifiedFrontLever,
    RussianTwist,
    /// Deprecated do not use
    AbdominalLegRotations,
    ArmAndLegExtensionOnKnees,
    Bicycle,
    BicepCurlWithLegExtension,
    CatCow,
    Corkscrew,
    CrissCross,
    /// Deprecated do not use
    CrissCrossWithBall,
    DoubleLegStretch,
    KneeFolds,
    LowerLift,
    NeckPull,
    PelvicClocks,
    RollOver,
    RollUp,
    Rolling,
    Rowing1,
    Rowing2,
    Scissors,
    SingleLegCircles,
    SingleLegStretch,
    /// Deprecated do not use
    SnakeTwist1And2,
    Swan,
    Swimming,
    Teaser,
    TheHundred,
}
impl fmt::Display for CoreExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CoreExerciseName::AbsJabs => f.write_str("abs_jabs"),
            CoreExerciseName::WeightedAbsJabs => f.write_str("weighted_abs_jabs"),
            CoreExerciseName::AlternatingPlateReach => f.write_str("alternating_plate_reach"),
            CoreExerciseName::BarbellRollout => f.write_str("barbell_rollout"),
            CoreExerciseName::WeightedBarbellRollout => f.write_str("weighted_barbell_rollout"),
            CoreExerciseName::BodyBarObliqueTwist => f.write_str("body_bar_oblique_twist"),
            CoreExerciseName::CableCorePress => f.write_str("cable_core_press"),
            CoreExerciseName::CableSideBend => f.write_str("cable_side_bend"),
            CoreExerciseName::SideBend => f.write_str("side_bend"),
            CoreExerciseName::WeightedSideBend => f.write_str("weighted_side_bend"),
            CoreExerciseName::CrescentCircle => f.write_str("crescent_circle"),
            CoreExerciseName::WeightedCrescentCircle => f.write_str("weighted_crescent_circle"),
            CoreExerciseName::CyclingRussianTwist => f.write_str("cycling_russian_twist"),
            CoreExerciseName::WeightedCyclingRussianTwist => {
                f.write_str("weighted_cycling_russian_twist")
            }
            CoreExerciseName::ElevatedFeetRussianTwist => {
                f.write_str("elevated_feet_russian_twist")
            }
            CoreExerciseName::WeightedElevatedFeetRussianTwist => {
                f.write_str("weighted_elevated_feet_russian_twist")
            }
            CoreExerciseName::HalfTurkishGetUp => f.write_str("half_turkish_get_up"),
            CoreExerciseName::KettlebellWindmill => f.write_str("kettlebell_windmill"),
            CoreExerciseName::KneelingAbWheel => f.write_str("kneeling_ab_wheel"),
            CoreExerciseName::WeightedKneelingAbWheel => f.write_str("weighted_kneeling_ab_wheel"),
            CoreExerciseName::ModifiedFrontLever => f.write_str("modified_front_lever"),
            CoreExerciseName::OpenKneeTucks => f.write_str("open_knee_tucks"),
            CoreExerciseName::WeightedOpenKneeTucks => f.write_str("weighted_open_knee_tucks"),
            CoreExerciseName::SideAbsLegLift => f.write_str("side_abs_leg_lift"),
            CoreExerciseName::WeightedSideAbsLegLift => f.write_str("weighted_side_abs_leg_lift"),
            CoreExerciseName::SwissBallJackknife => f.write_str("swiss_ball_jackknife"),
            CoreExerciseName::WeightedSwissBallJackknife => {
                f.write_str("weighted_swiss_ball_jackknife")
            }
            CoreExerciseName::SwissBallPike => f.write_str("swiss_ball_pike"),
            CoreExerciseName::WeightedSwissBallPike => f.write_str("weighted_swiss_ball_pike"),
            CoreExerciseName::SwissBallRollout => f.write_str("swiss_ball_rollout"),
            CoreExerciseName::WeightedSwissBallRollout => {
                f.write_str("weighted_swiss_ball_rollout")
            }
            CoreExerciseName::TriangleHipPress => f.write_str("triangle_hip_press"),
            CoreExerciseName::WeightedTriangleHipPress => {
                f.write_str("weighted_triangle_hip_press")
            }
            CoreExerciseName::TrxSuspendedJackknife => f.write_str("trx_suspended_jackknife"),
            CoreExerciseName::WeightedTrxSuspendedJackknife => {
                f.write_str("weighted_trx_suspended_jackknife")
            }
            CoreExerciseName::UBoat => f.write_str("u_boat"),
            CoreExerciseName::WeightedUBoat => f.write_str("weighted_u_boat"),
            CoreExerciseName::WindmillSwitches => f.write_str("windmill_switches"),
            CoreExerciseName::WeightedWindmillSwitches => f.write_str("weighted_windmill_switches"),
            CoreExerciseName::AlternatingSlideOut => f.write_str("alternating_slide_out"),
            CoreExerciseName::WeightedAlternatingSlideOut => {
                f.write_str("weighted_alternating_slide_out")
            }
            CoreExerciseName::GhdBackExtensions => f.write_str("ghd_back_extensions"),
            CoreExerciseName::WeightedGhdBackExtensions => {
                f.write_str("weighted_ghd_back_extensions")
            }
            CoreExerciseName::OverheadWalk => f.write_str("overhead_walk"),
            CoreExerciseName::Inchworm => f.write_str("inchworm"),
            CoreExerciseName::WeightedModifiedFrontLever => {
                f.write_str("weighted_modified_front_lever")
            }
            CoreExerciseName::RussianTwist => f.write_str("russian_twist"),
            CoreExerciseName::AbdominalLegRotations => f.write_str("abdominal_leg_rotations"),
            CoreExerciseName::ArmAndLegExtensionOnKnees => {
                f.write_str("arm_and_leg_extension_on_knees")
            }
            CoreExerciseName::Bicycle => f.write_str("bicycle"),
            CoreExerciseName::BicepCurlWithLegExtension => {
                f.write_str("bicep_curl_with_leg_extension")
            }
            CoreExerciseName::CatCow => f.write_str("cat_cow"),
            CoreExerciseName::Corkscrew => f.write_str("corkscrew"),
            CoreExerciseName::CrissCross => f.write_str("criss_cross"),
            CoreExerciseName::CrissCrossWithBall => f.write_str("criss_cross_with_ball"),
            CoreExerciseName::DoubleLegStretch => f.write_str("double_leg_stretch"),
            CoreExerciseName::KneeFolds => f.write_str("knee_folds"),
            CoreExerciseName::LowerLift => f.write_str("lower_lift"),
            CoreExerciseName::NeckPull => f.write_str("neck_pull"),
            CoreExerciseName::PelvicClocks => f.write_str("pelvic_clocks"),
            CoreExerciseName::RollOver => f.write_str("roll_over"),
            CoreExerciseName::RollUp => f.write_str("roll_up"),
            CoreExerciseName::Rolling => f.write_str("rolling"),
            CoreExerciseName::Rowing1 => f.write_str("rowing_1"),
            CoreExerciseName::Rowing2 => f.write_str("rowing_2"),
            CoreExerciseName::Scissors => f.write_str("scissors"),
            CoreExerciseName::SingleLegCircles => f.write_str("single_leg_circles"),
            CoreExerciseName::SingleLegStretch => f.write_str("single_leg_stretch"),
            CoreExerciseName::SnakeTwist1And2 => f.write_str("snake_twist_1_and_2"),
            CoreExerciseName::Swan => f.write_str("swan"),
            CoreExerciseName::Swimming => f.write_str("swimming"),
            CoreExerciseName::Teaser => f.write_str("teaser"),
            CoreExerciseName::TheHundred => f.write_str("the_hundred"),
        }
    }
}
impl CoreExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CoreExerciseName::AbsJabs => fit::Value::UInt16(0),
            CoreExerciseName::WeightedAbsJabs => fit::Value::UInt16(1),
            CoreExerciseName::AlternatingPlateReach => fit::Value::UInt16(2),
            CoreExerciseName::BarbellRollout => fit::Value::UInt16(3),
            CoreExerciseName::WeightedBarbellRollout => fit::Value::UInt16(4),
            CoreExerciseName::BodyBarObliqueTwist => fit::Value::UInt16(5),
            CoreExerciseName::CableCorePress => fit::Value::UInt16(6),
            CoreExerciseName::CableSideBend => fit::Value::UInt16(7),
            CoreExerciseName::SideBend => fit::Value::UInt16(8),
            CoreExerciseName::WeightedSideBend => fit::Value::UInt16(9),
            CoreExerciseName::CrescentCircle => fit::Value::UInt16(10),
            CoreExerciseName::WeightedCrescentCircle => fit::Value::UInt16(11),
            CoreExerciseName::CyclingRussianTwist => fit::Value::UInt16(12),
            CoreExerciseName::WeightedCyclingRussianTwist => fit::Value::UInt16(13),
            CoreExerciseName::ElevatedFeetRussianTwist => fit::Value::UInt16(14),
            CoreExerciseName::WeightedElevatedFeetRussianTwist => fit::Value::UInt16(15),
            CoreExerciseName::HalfTurkishGetUp => fit::Value::UInt16(16),
            CoreExerciseName::KettlebellWindmill => fit::Value::UInt16(17),
            CoreExerciseName::KneelingAbWheel => fit::Value::UInt16(18),
            CoreExerciseName::WeightedKneelingAbWheel => fit::Value::UInt16(19),
            CoreExerciseName::ModifiedFrontLever => fit::Value::UInt16(20),
            CoreExerciseName::OpenKneeTucks => fit::Value::UInt16(21),
            CoreExerciseName::WeightedOpenKneeTucks => fit::Value::UInt16(22),
            CoreExerciseName::SideAbsLegLift => fit::Value::UInt16(23),
            CoreExerciseName::WeightedSideAbsLegLift => fit::Value::UInt16(24),
            CoreExerciseName::SwissBallJackknife => fit::Value::UInt16(25),
            CoreExerciseName::WeightedSwissBallJackknife => fit::Value::UInt16(26),
            CoreExerciseName::SwissBallPike => fit::Value::UInt16(27),
            CoreExerciseName::WeightedSwissBallPike => fit::Value::UInt16(28),
            CoreExerciseName::SwissBallRollout => fit::Value::UInt16(29),
            CoreExerciseName::WeightedSwissBallRollout => fit::Value::UInt16(30),
            CoreExerciseName::TriangleHipPress => fit::Value::UInt16(31),
            CoreExerciseName::WeightedTriangleHipPress => fit::Value::UInt16(32),
            CoreExerciseName::TrxSuspendedJackknife => fit::Value::UInt16(33),
            CoreExerciseName::WeightedTrxSuspendedJackknife => fit::Value::UInt16(34),
            CoreExerciseName::UBoat => fit::Value::UInt16(35),
            CoreExerciseName::WeightedUBoat => fit::Value::UInt16(36),
            CoreExerciseName::WindmillSwitches => fit::Value::UInt16(37),
            CoreExerciseName::WeightedWindmillSwitches => fit::Value::UInt16(38),
            CoreExerciseName::AlternatingSlideOut => fit::Value::UInt16(39),
            CoreExerciseName::WeightedAlternatingSlideOut => fit::Value::UInt16(40),
            CoreExerciseName::GhdBackExtensions => fit::Value::UInt16(41),
            CoreExerciseName::WeightedGhdBackExtensions => fit::Value::UInt16(42),
            CoreExerciseName::OverheadWalk => fit::Value::UInt16(43),
            CoreExerciseName::Inchworm => fit::Value::UInt16(44),
            CoreExerciseName::WeightedModifiedFrontLever => fit::Value::UInt16(45),
            CoreExerciseName::RussianTwist => fit::Value::UInt16(46),
            CoreExerciseName::AbdominalLegRotations => fit::Value::UInt16(47),
            CoreExerciseName::ArmAndLegExtensionOnKnees => fit::Value::UInt16(48),
            CoreExerciseName::Bicycle => fit::Value::UInt16(49),
            CoreExerciseName::BicepCurlWithLegExtension => fit::Value::UInt16(50),
            CoreExerciseName::CatCow => fit::Value::UInt16(51),
            CoreExerciseName::Corkscrew => fit::Value::UInt16(52),
            CoreExerciseName::CrissCross => fit::Value::UInt16(53),
            CoreExerciseName::CrissCrossWithBall => fit::Value::UInt16(54),
            CoreExerciseName::DoubleLegStretch => fit::Value::UInt16(55),
            CoreExerciseName::KneeFolds => fit::Value::UInt16(56),
            CoreExerciseName::LowerLift => fit::Value::UInt16(57),
            CoreExerciseName::NeckPull => fit::Value::UInt16(58),
            CoreExerciseName::PelvicClocks => fit::Value::UInt16(59),
            CoreExerciseName::RollOver => fit::Value::UInt16(60),
            CoreExerciseName::RollUp => fit::Value::UInt16(61),
            CoreExerciseName::Rolling => fit::Value::UInt16(62),
            CoreExerciseName::Rowing1 => fit::Value::UInt16(63),
            CoreExerciseName::Rowing2 => fit::Value::UInt16(64),
            CoreExerciseName::Scissors => fit::Value::UInt16(65),
            CoreExerciseName::SingleLegCircles => fit::Value::UInt16(66),
            CoreExerciseName::SingleLegStretch => fit::Value::UInt16(67),
            CoreExerciseName::SnakeTwist1And2 => fit::Value::UInt16(68),
            CoreExerciseName::Swan => fit::Value::UInt16(69),
            CoreExerciseName::Swimming => fit::Value::UInt16(70),
            CoreExerciseName::Teaser => fit::Value::UInt16(71),
            CoreExerciseName::TheHundred => fit::Value::UInt16(72),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for CoreExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(CoreExerciseName::AbsJabs),
            fit::Value::UInt16(1) => Ok(CoreExerciseName::WeightedAbsJabs),
            fit::Value::UInt16(2) => Ok(CoreExerciseName::AlternatingPlateReach),
            fit::Value::UInt16(3) => Ok(CoreExerciseName::BarbellRollout),
            fit::Value::UInt16(4) => Ok(CoreExerciseName::WeightedBarbellRollout),
            fit::Value::UInt16(5) => Ok(CoreExerciseName::BodyBarObliqueTwist),
            fit::Value::UInt16(6) => Ok(CoreExerciseName::CableCorePress),
            fit::Value::UInt16(7) => Ok(CoreExerciseName::CableSideBend),
            fit::Value::UInt16(8) => Ok(CoreExerciseName::SideBend),
            fit::Value::UInt16(9) => Ok(CoreExerciseName::WeightedSideBend),
            fit::Value::UInt16(10) => Ok(CoreExerciseName::CrescentCircle),
            fit::Value::UInt16(11) => Ok(CoreExerciseName::WeightedCrescentCircle),
            fit::Value::UInt16(12) => Ok(CoreExerciseName::CyclingRussianTwist),
            fit::Value::UInt16(13) => Ok(CoreExerciseName::WeightedCyclingRussianTwist),
            fit::Value::UInt16(14) => Ok(CoreExerciseName::ElevatedFeetRussianTwist),
            fit::Value::UInt16(15) => Ok(CoreExerciseName::WeightedElevatedFeetRussianTwist),
            fit::Value::UInt16(16) => Ok(CoreExerciseName::HalfTurkishGetUp),
            fit::Value::UInt16(17) => Ok(CoreExerciseName::KettlebellWindmill),
            fit::Value::UInt16(18) => Ok(CoreExerciseName::KneelingAbWheel),
            fit::Value::UInt16(19) => Ok(CoreExerciseName::WeightedKneelingAbWheel),
            fit::Value::UInt16(20) => Ok(CoreExerciseName::ModifiedFrontLever),
            fit::Value::UInt16(21) => Ok(CoreExerciseName::OpenKneeTucks),
            fit::Value::UInt16(22) => Ok(CoreExerciseName::WeightedOpenKneeTucks),
            fit::Value::UInt16(23) => Ok(CoreExerciseName::SideAbsLegLift),
            fit::Value::UInt16(24) => Ok(CoreExerciseName::WeightedSideAbsLegLift),
            fit::Value::UInt16(25) => Ok(CoreExerciseName::SwissBallJackknife),
            fit::Value::UInt16(26) => Ok(CoreExerciseName::WeightedSwissBallJackknife),
            fit::Value::UInt16(27) => Ok(CoreExerciseName::SwissBallPike),
            fit::Value::UInt16(28) => Ok(CoreExerciseName::WeightedSwissBallPike),
            fit::Value::UInt16(29) => Ok(CoreExerciseName::SwissBallRollout),
            fit::Value::UInt16(30) => Ok(CoreExerciseName::WeightedSwissBallRollout),
            fit::Value::UInt16(31) => Ok(CoreExerciseName::TriangleHipPress),
            fit::Value::UInt16(32) => Ok(CoreExerciseName::WeightedTriangleHipPress),
            fit::Value::UInt16(33) => Ok(CoreExerciseName::TrxSuspendedJackknife),
            fit::Value::UInt16(34) => Ok(CoreExerciseName::WeightedTrxSuspendedJackknife),
            fit::Value::UInt16(35) => Ok(CoreExerciseName::UBoat),
            fit::Value::UInt16(36) => Ok(CoreExerciseName::WeightedUBoat),
            fit::Value::UInt16(37) => Ok(CoreExerciseName::WindmillSwitches),
            fit::Value::UInt16(38) => Ok(CoreExerciseName::WeightedWindmillSwitches),
            fit::Value::UInt16(39) => Ok(CoreExerciseName::AlternatingSlideOut),
            fit::Value::UInt16(40) => Ok(CoreExerciseName::WeightedAlternatingSlideOut),
            fit::Value::UInt16(41) => Ok(CoreExerciseName::GhdBackExtensions),
            fit::Value::UInt16(42) => Ok(CoreExerciseName::WeightedGhdBackExtensions),
            fit::Value::UInt16(43) => Ok(CoreExerciseName::OverheadWalk),
            fit::Value::UInt16(44) => Ok(CoreExerciseName::Inchworm),
            fit::Value::UInt16(45) => Ok(CoreExerciseName::WeightedModifiedFrontLever),
            fit::Value::UInt16(46) => Ok(CoreExerciseName::RussianTwist),
            fit::Value::UInt16(47) => Ok(CoreExerciseName::AbdominalLegRotations),
            fit::Value::UInt16(48) => Ok(CoreExerciseName::ArmAndLegExtensionOnKnees),
            fit::Value::UInt16(49) => Ok(CoreExerciseName::Bicycle),
            fit::Value::UInt16(50) => Ok(CoreExerciseName::BicepCurlWithLegExtension),
            fit::Value::UInt16(51) => Ok(CoreExerciseName::CatCow),
            fit::Value::UInt16(52) => Ok(CoreExerciseName::Corkscrew),
            fit::Value::UInt16(53) => Ok(CoreExerciseName::CrissCross),
            fit::Value::UInt16(54) => Ok(CoreExerciseName::CrissCrossWithBall),
            fit::Value::UInt16(55) => Ok(CoreExerciseName::DoubleLegStretch),
            fit::Value::UInt16(56) => Ok(CoreExerciseName::KneeFolds),
            fit::Value::UInt16(57) => Ok(CoreExerciseName::LowerLift),
            fit::Value::UInt16(58) => Ok(CoreExerciseName::NeckPull),
            fit::Value::UInt16(59) => Ok(CoreExerciseName::PelvicClocks),
            fit::Value::UInt16(60) => Ok(CoreExerciseName::RollOver),
            fit::Value::UInt16(61) => Ok(CoreExerciseName::RollUp),
            fit::Value::UInt16(62) => Ok(CoreExerciseName::Rolling),
            fit::Value::UInt16(63) => Ok(CoreExerciseName::Rowing1),
            fit::Value::UInt16(64) => Ok(CoreExerciseName::Rowing2),
            fit::Value::UInt16(65) => Ok(CoreExerciseName::Scissors),
            fit::Value::UInt16(66) => Ok(CoreExerciseName::SingleLegCircles),
            fit::Value::UInt16(67) => Ok(CoreExerciseName::SingleLegStretch),
            fit::Value::UInt16(68) => Ok(CoreExerciseName::SnakeTwist1And2),
            fit::Value::UInt16(69) => Ok(CoreExerciseName::Swan),
            fit::Value::UInt16(70) => Ok(CoreExerciseName::Swimming),
            fit::Value::UInt16(71) => Ok(CoreExerciseName::Teaser),
            fit::Value::UInt16(72) => Ok(CoreExerciseName::TheHundred),
            _ => Err("No corresponding CoreExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for CoreExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "abs_jabs" => Ok(CoreExerciseName::AbsJabs),
            "weighted_abs_jabs" => Ok(CoreExerciseName::WeightedAbsJabs),
            "alternating_plate_reach" => Ok(CoreExerciseName::AlternatingPlateReach),
            "barbell_rollout" => Ok(CoreExerciseName::BarbellRollout),
            "weighted_barbell_rollout" => Ok(CoreExerciseName::WeightedBarbellRollout),
            "body_bar_oblique_twist" => Ok(CoreExerciseName::BodyBarObliqueTwist),
            "cable_core_press" => Ok(CoreExerciseName::CableCorePress),
            "cable_side_bend" => Ok(CoreExerciseName::CableSideBend),
            "side_bend" => Ok(CoreExerciseName::SideBend),
            "weighted_side_bend" => Ok(CoreExerciseName::WeightedSideBend),
            "crescent_circle" => Ok(CoreExerciseName::CrescentCircle),
            "weighted_crescent_circle" => Ok(CoreExerciseName::WeightedCrescentCircle),
            "cycling_russian_twist" => Ok(CoreExerciseName::CyclingRussianTwist),
            "weighted_cycling_russian_twist" => Ok(CoreExerciseName::WeightedCyclingRussianTwist),
            "elevated_feet_russian_twist" => Ok(CoreExerciseName::ElevatedFeetRussianTwist),
            "weighted_elevated_feet_russian_twist" => {
                Ok(CoreExerciseName::WeightedElevatedFeetRussianTwist)
            }
            "half_turkish_get_up" => Ok(CoreExerciseName::HalfTurkishGetUp),
            "kettlebell_windmill" => Ok(CoreExerciseName::KettlebellWindmill),
            "kneeling_ab_wheel" => Ok(CoreExerciseName::KneelingAbWheel),
            "weighted_kneeling_ab_wheel" => Ok(CoreExerciseName::WeightedKneelingAbWheel),
            "modified_front_lever" => Ok(CoreExerciseName::ModifiedFrontLever),
            "open_knee_tucks" => Ok(CoreExerciseName::OpenKneeTucks),
            "weighted_open_knee_tucks" => Ok(CoreExerciseName::WeightedOpenKneeTucks),
            "side_abs_leg_lift" => Ok(CoreExerciseName::SideAbsLegLift),
            "weighted_side_abs_leg_lift" => Ok(CoreExerciseName::WeightedSideAbsLegLift),
            "swiss_ball_jackknife" => Ok(CoreExerciseName::SwissBallJackknife),
            "weighted_swiss_ball_jackknife" => Ok(CoreExerciseName::WeightedSwissBallJackknife),
            "swiss_ball_pike" => Ok(CoreExerciseName::SwissBallPike),
            "weighted_swiss_ball_pike" => Ok(CoreExerciseName::WeightedSwissBallPike),
            "swiss_ball_rollout" => Ok(CoreExerciseName::SwissBallRollout),
            "weighted_swiss_ball_rollout" => Ok(CoreExerciseName::WeightedSwissBallRollout),
            "triangle_hip_press" => Ok(CoreExerciseName::TriangleHipPress),
            "weighted_triangle_hip_press" => Ok(CoreExerciseName::WeightedTriangleHipPress),
            "trx_suspended_jackknife" => Ok(CoreExerciseName::TrxSuspendedJackknife),
            "weighted_trx_suspended_jackknife" => {
                Ok(CoreExerciseName::WeightedTrxSuspendedJackknife)
            }
            "u_boat" => Ok(CoreExerciseName::UBoat),
            "weighted_u_boat" => Ok(CoreExerciseName::WeightedUBoat),
            "windmill_switches" => Ok(CoreExerciseName::WindmillSwitches),
            "weighted_windmill_switches" => Ok(CoreExerciseName::WeightedWindmillSwitches),
            "alternating_slide_out" => Ok(CoreExerciseName::AlternatingSlideOut),
            "weighted_alternating_slide_out" => Ok(CoreExerciseName::WeightedAlternatingSlideOut),
            "ghd_back_extensions" => Ok(CoreExerciseName::GhdBackExtensions),
            "weighted_ghd_back_extensions" => Ok(CoreExerciseName::WeightedGhdBackExtensions),
            "overhead_walk" => Ok(CoreExerciseName::OverheadWalk),
            "inchworm" => Ok(CoreExerciseName::Inchworm),
            "weighted_modified_front_lever" => Ok(CoreExerciseName::WeightedModifiedFrontLever),
            "russian_twist" => Ok(CoreExerciseName::RussianTwist),
            "abdominal_leg_rotations" => Ok(CoreExerciseName::AbdominalLegRotations),
            "arm_and_leg_extension_on_knees" => Ok(CoreExerciseName::ArmAndLegExtensionOnKnees),
            "bicycle" => Ok(CoreExerciseName::Bicycle),
            "bicep_curl_with_leg_extension" => Ok(CoreExerciseName::BicepCurlWithLegExtension),
            "cat_cow" => Ok(CoreExerciseName::CatCow),
            "corkscrew" => Ok(CoreExerciseName::Corkscrew),
            "criss_cross" => Ok(CoreExerciseName::CrissCross),
            "criss_cross_with_ball" => Ok(CoreExerciseName::CrissCrossWithBall),
            "double_leg_stretch" => Ok(CoreExerciseName::DoubleLegStretch),
            "knee_folds" => Ok(CoreExerciseName::KneeFolds),
            "lower_lift" => Ok(CoreExerciseName::LowerLift),
            "neck_pull" => Ok(CoreExerciseName::NeckPull),
            "pelvic_clocks" => Ok(CoreExerciseName::PelvicClocks),
            "roll_over" => Ok(CoreExerciseName::RollOver),
            "roll_up" => Ok(CoreExerciseName::RollUp),
            "rolling" => Ok(CoreExerciseName::Rolling),
            "rowing_1" => Ok(CoreExerciseName::Rowing1),
            "rowing_2" => Ok(CoreExerciseName::Rowing2),
            "scissors" => Ok(CoreExerciseName::Scissors),
            "single_leg_circles" => Ok(CoreExerciseName::SingleLegCircles),
            "single_leg_stretch" => Ok(CoreExerciseName::SingleLegStretch),
            "snake_twist_1_and_2" => Ok(CoreExerciseName::SnakeTwist1And2),
            "swan" => Ok(CoreExerciseName::Swan),
            "swimming" => Ok(CoreExerciseName::Swimming),
            "teaser" => Ok(CoreExerciseName::Teaser),
            "the_hundred" => Ok(CoreExerciseName::TheHundred),
            _ => Err("No corresponding CoreExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CrunchExerciseName {
    BicycleCrunch,
    CableCrunch,
    CircularArmCrunch,
    CrossedArmsCrunch,
    WeightedCrossedArmsCrunch,
    CrossLegReverseCrunch,
    WeightedCrossLegReverseCrunch,
    CrunchChop,
    WeightedCrunchChop,
    DoubleCrunch,
    WeightedDoubleCrunch,
    ElbowToKneeCrunch,
    WeightedElbowToKneeCrunch,
    FlutterKicks,
    WeightedFlutterKicks,
    FoamRollerReverseCrunchOnBench,
    WeightedFoamRollerReverseCrunchOnBench,
    FoamRollerReverseCrunchWithDumbbell,
    FoamRollerReverseCrunchWithMedicineBall,
    FrogPress,
    HangingKneeRaiseObliqueCrunch,
    WeightedHangingKneeRaiseObliqueCrunch,
    HipCrossover,
    WeightedHipCrossover,
    HollowRock,
    WeightedHollowRock,
    InclineReverseCrunch,
    WeightedInclineReverseCrunch,
    KneelingCableCrunch,
    KneelingCrossCrunch,
    WeightedKneelingCrossCrunch,
    KneelingObliqueCableCrunch,
    KneesToElbow,
    LegExtensions,
    WeightedLegExtensions,
    LegLevers,
    McgillCurlUp,
    WeightedMcgillCurlUp,
    ModifiedPilatesRollUpWithBall,
    WeightedModifiedPilatesRollUpWithBall,
    PilatesCrunch,
    WeightedPilatesCrunch,
    PilatesRollUpWithBall,
    WeightedPilatesRollUpWithBall,
    RaisedLegsCrunch,
    WeightedRaisedLegsCrunch,
    ReverseCrunch,
    WeightedReverseCrunch,
    ReverseCrunchOnABench,
    WeightedReverseCrunchOnABench,
    ReverseCurlAndLift,
    WeightedReverseCurlAndLift,
    RotationalLift,
    WeightedRotationalLift,
    SeatedAlternatingReverseCrunch,
    WeightedSeatedAlternatingReverseCrunch,
    SeatedLegU,
    WeightedSeatedLegU,
    SideToSideCrunchAndWeave,
    WeightedSideToSideCrunchAndWeave,
    SingleLegReverseCrunch,
    WeightedSingleLegReverseCrunch,
    SkaterCrunchCross,
    WeightedSkaterCrunchCross,
    StandingCableCrunch,
    StandingSideCrunch,
    StepClimb,
    WeightedStepClimb,
    SwissBallCrunch,
    SwissBallReverseCrunch,
    WeightedSwissBallReverseCrunch,
    SwissBallRussianTwist,
    WeightedSwissBallRussianTwist,
    SwissBallSideCrunch,
    WeightedSwissBallSideCrunch,
    ThoracicCrunchesOnFoamRoller,
    WeightedThoracicCrunchesOnFoamRoller,
    TricepsCrunch,
    WeightedBicycleCrunch,
    WeightedCrunch,
    WeightedSwissBallCrunch,
    ToesToBar,
    WeightedToesToBar,
    Crunch,
    StraightLegCrunchWithBall,
}
impl fmt::Display for CrunchExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CrunchExerciseName::BicycleCrunch => f.write_str("bicycle_crunch"),
            CrunchExerciseName::CableCrunch => f.write_str("cable_crunch"),
            CrunchExerciseName::CircularArmCrunch => f.write_str("circular_arm_crunch"),
            CrunchExerciseName::CrossedArmsCrunch => f.write_str("crossed_arms_crunch"),
            CrunchExerciseName::WeightedCrossedArmsCrunch => {
                f.write_str("weighted_crossed_arms_crunch")
            }
            CrunchExerciseName::CrossLegReverseCrunch => f.write_str("cross_leg_reverse_crunch"),
            CrunchExerciseName::WeightedCrossLegReverseCrunch => {
                f.write_str("weighted_cross_leg_reverse_crunch")
            }
            CrunchExerciseName::CrunchChop => f.write_str("crunch_chop"),
            CrunchExerciseName::WeightedCrunchChop => f.write_str("weighted_crunch_chop"),
            CrunchExerciseName::DoubleCrunch => f.write_str("double_crunch"),
            CrunchExerciseName::WeightedDoubleCrunch => f.write_str("weighted_double_crunch"),
            CrunchExerciseName::ElbowToKneeCrunch => f.write_str("elbow_to_knee_crunch"),
            CrunchExerciseName::WeightedElbowToKneeCrunch => {
                f.write_str("weighted_elbow_to_knee_crunch")
            }
            CrunchExerciseName::FlutterKicks => f.write_str("flutter_kicks"),
            CrunchExerciseName::WeightedFlutterKicks => f.write_str("weighted_flutter_kicks"),
            CrunchExerciseName::FoamRollerReverseCrunchOnBench => {
                f.write_str("foam_roller_reverse_crunch_on_bench")
            }
            CrunchExerciseName::WeightedFoamRollerReverseCrunchOnBench => {
                f.write_str("weighted_foam_roller_reverse_crunch_on_bench")
            }
            CrunchExerciseName::FoamRollerReverseCrunchWithDumbbell => {
                f.write_str("foam_roller_reverse_crunch_with_dumbbell")
            }
            CrunchExerciseName::FoamRollerReverseCrunchWithMedicineBall => {
                f.write_str("foam_roller_reverse_crunch_with_medicine_ball")
            }
            CrunchExerciseName::FrogPress => f.write_str("frog_press"),
            CrunchExerciseName::HangingKneeRaiseObliqueCrunch => {
                f.write_str("hanging_knee_raise_oblique_crunch")
            }
            CrunchExerciseName::WeightedHangingKneeRaiseObliqueCrunch => {
                f.write_str("weighted_hanging_knee_raise_oblique_crunch")
            }
            CrunchExerciseName::HipCrossover => f.write_str("hip_crossover"),
            CrunchExerciseName::WeightedHipCrossover => f.write_str("weighted_hip_crossover"),
            CrunchExerciseName::HollowRock => f.write_str("hollow_rock"),
            CrunchExerciseName::WeightedHollowRock => f.write_str("weighted_hollow_rock"),
            CrunchExerciseName::InclineReverseCrunch => f.write_str("incline_reverse_crunch"),
            CrunchExerciseName::WeightedInclineReverseCrunch => {
                f.write_str("weighted_incline_reverse_crunch")
            }
            CrunchExerciseName::KneelingCableCrunch => f.write_str("kneeling_cable_crunch"),
            CrunchExerciseName::KneelingCrossCrunch => f.write_str("kneeling_cross_crunch"),
            CrunchExerciseName::WeightedKneelingCrossCrunch => {
                f.write_str("weighted_kneeling_cross_crunch")
            }
            CrunchExerciseName::KneelingObliqueCableCrunch => {
                f.write_str("kneeling_oblique_cable_crunch")
            }
            CrunchExerciseName::KneesToElbow => f.write_str("knees_to_elbow"),
            CrunchExerciseName::LegExtensions => f.write_str("leg_extensions"),
            CrunchExerciseName::WeightedLegExtensions => f.write_str("weighted_leg_extensions"),
            CrunchExerciseName::LegLevers => f.write_str("leg_levers"),
            CrunchExerciseName::McgillCurlUp => f.write_str("mcgill_curl_up"),
            CrunchExerciseName::WeightedMcgillCurlUp => f.write_str("weighted_mcgill_curl_up"),
            CrunchExerciseName::ModifiedPilatesRollUpWithBall => {
                f.write_str("modified_pilates_roll_up_with_ball")
            }
            CrunchExerciseName::WeightedModifiedPilatesRollUpWithBall => {
                f.write_str("weighted_modified_pilates_roll_up_with_ball")
            }
            CrunchExerciseName::PilatesCrunch => f.write_str("pilates_crunch"),
            CrunchExerciseName::WeightedPilatesCrunch => f.write_str("weighted_pilates_crunch"),
            CrunchExerciseName::PilatesRollUpWithBall => f.write_str("pilates_roll_up_with_ball"),
            CrunchExerciseName::WeightedPilatesRollUpWithBall => {
                f.write_str("weighted_pilates_roll_up_with_ball")
            }
            CrunchExerciseName::RaisedLegsCrunch => f.write_str("raised_legs_crunch"),
            CrunchExerciseName::WeightedRaisedLegsCrunch => {
                f.write_str("weighted_raised_legs_crunch")
            }
            CrunchExerciseName::ReverseCrunch => f.write_str("reverse_crunch"),
            CrunchExerciseName::WeightedReverseCrunch => f.write_str("weighted_reverse_crunch"),
            CrunchExerciseName::ReverseCrunchOnABench => f.write_str("reverse_crunch_on_a_bench"),
            CrunchExerciseName::WeightedReverseCrunchOnABench => {
                f.write_str("weighted_reverse_crunch_on_a_bench")
            }
            CrunchExerciseName::ReverseCurlAndLift => f.write_str("reverse_curl_and_lift"),
            CrunchExerciseName::WeightedReverseCurlAndLift => {
                f.write_str("weighted_reverse_curl_and_lift")
            }
            CrunchExerciseName::RotationalLift => f.write_str("rotational_lift"),
            CrunchExerciseName::WeightedRotationalLift => f.write_str("weighted_rotational_lift"),
            CrunchExerciseName::SeatedAlternatingReverseCrunch => {
                f.write_str("seated_alternating_reverse_crunch")
            }
            CrunchExerciseName::WeightedSeatedAlternatingReverseCrunch => {
                f.write_str("weighted_seated_alternating_reverse_crunch")
            }
            CrunchExerciseName::SeatedLegU => f.write_str("seated_leg_u"),
            CrunchExerciseName::WeightedSeatedLegU => f.write_str("weighted_seated_leg_u"),
            CrunchExerciseName::SideToSideCrunchAndWeave => {
                f.write_str("side_to_side_crunch_and_weave")
            }
            CrunchExerciseName::WeightedSideToSideCrunchAndWeave => {
                f.write_str("weighted_side_to_side_crunch_and_weave")
            }
            CrunchExerciseName::SingleLegReverseCrunch => f.write_str("single_leg_reverse_crunch"),
            CrunchExerciseName::WeightedSingleLegReverseCrunch => {
                f.write_str("weighted_single_leg_reverse_crunch")
            }
            CrunchExerciseName::SkaterCrunchCross => f.write_str("skater_crunch_cross"),
            CrunchExerciseName::WeightedSkaterCrunchCross => {
                f.write_str("weighted_skater_crunch_cross")
            }
            CrunchExerciseName::StandingCableCrunch => f.write_str("standing_cable_crunch"),
            CrunchExerciseName::StandingSideCrunch => f.write_str("standing_side_crunch"),
            CrunchExerciseName::StepClimb => f.write_str("step_climb"),
            CrunchExerciseName::WeightedStepClimb => f.write_str("weighted_step_climb"),
            CrunchExerciseName::SwissBallCrunch => f.write_str("swiss_ball_crunch"),
            CrunchExerciseName::SwissBallReverseCrunch => f.write_str("swiss_ball_reverse_crunch"),
            CrunchExerciseName::WeightedSwissBallReverseCrunch => {
                f.write_str("weighted_swiss_ball_reverse_crunch")
            }
            CrunchExerciseName::SwissBallRussianTwist => f.write_str("swiss_ball_russian_twist"),
            CrunchExerciseName::WeightedSwissBallRussianTwist => {
                f.write_str("weighted_swiss_ball_russian_twist")
            }
            CrunchExerciseName::SwissBallSideCrunch => f.write_str("swiss_ball_side_crunch"),
            CrunchExerciseName::WeightedSwissBallSideCrunch => {
                f.write_str("weighted_swiss_ball_side_crunch")
            }
            CrunchExerciseName::ThoracicCrunchesOnFoamRoller => {
                f.write_str("thoracic_crunches_on_foam_roller")
            }
            CrunchExerciseName::WeightedThoracicCrunchesOnFoamRoller => {
                f.write_str("weighted_thoracic_crunches_on_foam_roller")
            }
            CrunchExerciseName::TricepsCrunch => f.write_str("triceps_crunch"),
            CrunchExerciseName::WeightedBicycleCrunch => f.write_str("weighted_bicycle_crunch"),
            CrunchExerciseName::WeightedCrunch => f.write_str("weighted_crunch"),
            CrunchExerciseName::WeightedSwissBallCrunch => {
                f.write_str("weighted_swiss_ball_crunch")
            }
            CrunchExerciseName::ToesToBar => f.write_str("toes_to_bar"),
            CrunchExerciseName::WeightedToesToBar => f.write_str("weighted_toes_to_bar"),
            CrunchExerciseName::Crunch => f.write_str("crunch"),
            CrunchExerciseName::StraightLegCrunchWithBall => {
                f.write_str("straight_leg_crunch_with_ball")
            }
        }
    }
}
impl CrunchExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CrunchExerciseName::BicycleCrunch => fit::Value::UInt16(0),
            CrunchExerciseName::CableCrunch => fit::Value::UInt16(1),
            CrunchExerciseName::CircularArmCrunch => fit::Value::UInt16(2),
            CrunchExerciseName::CrossedArmsCrunch => fit::Value::UInt16(3),
            CrunchExerciseName::WeightedCrossedArmsCrunch => fit::Value::UInt16(4),
            CrunchExerciseName::CrossLegReverseCrunch => fit::Value::UInt16(5),
            CrunchExerciseName::WeightedCrossLegReverseCrunch => fit::Value::UInt16(6),
            CrunchExerciseName::CrunchChop => fit::Value::UInt16(7),
            CrunchExerciseName::WeightedCrunchChop => fit::Value::UInt16(8),
            CrunchExerciseName::DoubleCrunch => fit::Value::UInt16(9),
            CrunchExerciseName::WeightedDoubleCrunch => fit::Value::UInt16(10),
            CrunchExerciseName::ElbowToKneeCrunch => fit::Value::UInt16(11),
            CrunchExerciseName::WeightedElbowToKneeCrunch => fit::Value::UInt16(12),
            CrunchExerciseName::FlutterKicks => fit::Value::UInt16(13),
            CrunchExerciseName::WeightedFlutterKicks => fit::Value::UInt16(14),
            CrunchExerciseName::FoamRollerReverseCrunchOnBench => fit::Value::UInt16(15),
            CrunchExerciseName::WeightedFoamRollerReverseCrunchOnBench => fit::Value::UInt16(16),
            CrunchExerciseName::FoamRollerReverseCrunchWithDumbbell => fit::Value::UInt16(17),
            CrunchExerciseName::FoamRollerReverseCrunchWithMedicineBall => fit::Value::UInt16(18),
            CrunchExerciseName::FrogPress => fit::Value::UInt16(19),
            CrunchExerciseName::HangingKneeRaiseObliqueCrunch => fit::Value::UInt16(20),
            CrunchExerciseName::WeightedHangingKneeRaiseObliqueCrunch => fit::Value::UInt16(21),
            CrunchExerciseName::HipCrossover => fit::Value::UInt16(22),
            CrunchExerciseName::WeightedHipCrossover => fit::Value::UInt16(23),
            CrunchExerciseName::HollowRock => fit::Value::UInt16(24),
            CrunchExerciseName::WeightedHollowRock => fit::Value::UInt16(25),
            CrunchExerciseName::InclineReverseCrunch => fit::Value::UInt16(26),
            CrunchExerciseName::WeightedInclineReverseCrunch => fit::Value::UInt16(27),
            CrunchExerciseName::KneelingCableCrunch => fit::Value::UInt16(28),
            CrunchExerciseName::KneelingCrossCrunch => fit::Value::UInt16(29),
            CrunchExerciseName::WeightedKneelingCrossCrunch => fit::Value::UInt16(30),
            CrunchExerciseName::KneelingObliqueCableCrunch => fit::Value::UInt16(31),
            CrunchExerciseName::KneesToElbow => fit::Value::UInt16(32),
            CrunchExerciseName::LegExtensions => fit::Value::UInt16(33),
            CrunchExerciseName::WeightedLegExtensions => fit::Value::UInt16(34),
            CrunchExerciseName::LegLevers => fit::Value::UInt16(35),
            CrunchExerciseName::McgillCurlUp => fit::Value::UInt16(36),
            CrunchExerciseName::WeightedMcgillCurlUp => fit::Value::UInt16(37),
            CrunchExerciseName::ModifiedPilatesRollUpWithBall => fit::Value::UInt16(38),
            CrunchExerciseName::WeightedModifiedPilatesRollUpWithBall => fit::Value::UInt16(39),
            CrunchExerciseName::PilatesCrunch => fit::Value::UInt16(40),
            CrunchExerciseName::WeightedPilatesCrunch => fit::Value::UInt16(41),
            CrunchExerciseName::PilatesRollUpWithBall => fit::Value::UInt16(42),
            CrunchExerciseName::WeightedPilatesRollUpWithBall => fit::Value::UInt16(43),
            CrunchExerciseName::RaisedLegsCrunch => fit::Value::UInt16(44),
            CrunchExerciseName::WeightedRaisedLegsCrunch => fit::Value::UInt16(45),
            CrunchExerciseName::ReverseCrunch => fit::Value::UInt16(46),
            CrunchExerciseName::WeightedReverseCrunch => fit::Value::UInt16(47),
            CrunchExerciseName::ReverseCrunchOnABench => fit::Value::UInt16(48),
            CrunchExerciseName::WeightedReverseCrunchOnABench => fit::Value::UInt16(49),
            CrunchExerciseName::ReverseCurlAndLift => fit::Value::UInt16(50),
            CrunchExerciseName::WeightedReverseCurlAndLift => fit::Value::UInt16(51),
            CrunchExerciseName::RotationalLift => fit::Value::UInt16(52),
            CrunchExerciseName::WeightedRotationalLift => fit::Value::UInt16(53),
            CrunchExerciseName::SeatedAlternatingReverseCrunch => fit::Value::UInt16(54),
            CrunchExerciseName::WeightedSeatedAlternatingReverseCrunch => fit::Value::UInt16(55),
            CrunchExerciseName::SeatedLegU => fit::Value::UInt16(56),
            CrunchExerciseName::WeightedSeatedLegU => fit::Value::UInt16(57),
            CrunchExerciseName::SideToSideCrunchAndWeave => fit::Value::UInt16(58),
            CrunchExerciseName::WeightedSideToSideCrunchAndWeave => fit::Value::UInt16(59),
            CrunchExerciseName::SingleLegReverseCrunch => fit::Value::UInt16(60),
            CrunchExerciseName::WeightedSingleLegReverseCrunch => fit::Value::UInt16(61),
            CrunchExerciseName::SkaterCrunchCross => fit::Value::UInt16(62),
            CrunchExerciseName::WeightedSkaterCrunchCross => fit::Value::UInt16(63),
            CrunchExerciseName::StandingCableCrunch => fit::Value::UInt16(64),
            CrunchExerciseName::StandingSideCrunch => fit::Value::UInt16(65),
            CrunchExerciseName::StepClimb => fit::Value::UInt16(66),
            CrunchExerciseName::WeightedStepClimb => fit::Value::UInt16(67),
            CrunchExerciseName::SwissBallCrunch => fit::Value::UInt16(68),
            CrunchExerciseName::SwissBallReverseCrunch => fit::Value::UInt16(69),
            CrunchExerciseName::WeightedSwissBallReverseCrunch => fit::Value::UInt16(70),
            CrunchExerciseName::SwissBallRussianTwist => fit::Value::UInt16(71),
            CrunchExerciseName::WeightedSwissBallRussianTwist => fit::Value::UInt16(72),
            CrunchExerciseName::SwissBallSideCrunch => fit::Value::UInt16(73),
            CrunchExerciseName::WeightedSwissBallSideCrunch => fit::Value::UInt16(74),
            CrunchExerciseName::ThoracicCrunchesOnFoamRoller => fit::Value::UInt16(75),
            CrunchExerciseName::WeightedThoracicCrunchesOnFoamRoller => fit::Value::UInt16(76),
            CrunchExerciseName::TricepsCrunch => fit::Value::UInt16(77),
            CrunchExerciseName::WeightedBicycleCrunch => fit::Value::UInt16(78),
            CrunchExerciseName::WeightedCrunch => fit::Value::UInt16(79),
            CrunchExerciseName::WeightedSwissBallCrunch => fit::Value::UInt16(80),
            CrunchExerciseName::ToesToBar => fit::Value::UInt16(81),
            CrunchExerciseName::WeightedToesToBar => fit::Value::UInt16(82),
            CrunchExerciseName::Crunch => fit::Value::UInt16(83),
            CrunchExerciseName::StraightLegCrunchWithBall => fit::Value::UInt16(84),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for CrunchExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(CrunchExerciseName::BicycleCrunch),
            fit::Value::UInt16(1) => Ok(CrunchExerciseName::CableCrunch),
            fit::Value::UInt16(2) => Ok(CrunchExerciseName::CircularArmCrunch),
            fit::Value::UInt16(3) => Ok(CrunchExerciseName::CrossedArmsCrunch),
            fit::Value::UInt16(4) => Ok(CrunchExerciseName::WeightedCrossedArmsCrunch),
            fit::Value::UInt16(5) => Ok(CrunchExerciseName::CrossLegReverseCrunch),
            fit::Value::UInt16(6) => Ok(CrunchExerciseName::WeightedCrossLegReverseCrunch),
            fit::Value::UInt16(7) => Ok(CrunchExerciseName::CrunchChop),
            fit::Value::UInt16(8) => Ok(CrunchExerciseName::WeightedCrunchChop),
            fit::Value::UInt16(9) => Ok(CrunchExerciseName::DoubleCrunch),
            fit::Value::UInt16(10) => Ok(CrunchExerciseName::WeightedDoubleCrunch),
            fit::Value::UInt16(11) => Ok(CrunchExerciseName::ElbowToKneeCrunch),
            fit::Value::UInt16(12) => Ok(CrunchExerciseName::WeightedElbowToKneeCrunch),
            fit::Value::UInt16(13) => Ok(CrunchExerciseName::FlutterKicks),
            fit::Value::UInt16(14) => Ok(CrunchExerciseName::WeightedFlutterKicks),
            fit::Value::UInt16(15) => Ok(CrunchExerciseName::FoamRollerReverseCrunchOnBench),
            fit::Value::UInt16(16) => {
                Ok(CrunchExerciseName::WeightedFoamRollerReverseCrunchOnBench)
            }
            fit::Value::UInt16(17) => Ok(CrunchExerciseName::FoamRollerReverseCrunchWithDumbbell),
            fit::Value::UInt16(18) => {
                Ok(CrunchExerciseName::FoamRollerReverseCrunchWithMedicineBall)
            }
            fit::Value::UInt16(19) => Ok(CrunchExerciseName::FrogPress),
            fit::Value::UInt16(20) => Ok(CrunchExerciseName::HangingKneeRaiseObliqueCrunch),
            fit::Value::UInt16(21) => Ok(CrunchExerciseName::WeightedHangingKneeRaiseObliqueCrunch),
            fit::Value::UInt16(22) => Ok(CrunchExerciseName::HipCrossover),
            fit::Value::UInt16(23) => Ok(CrunchExerciseName::WeightedHipCrossover),
            fit::Value::UInt16(24) => Ok(CrunchExerciseName::HollowRock),
            fit::Value::UInt16(25) => Ok(CrunchExerciseName::WeightedHollowRock),
            fit::Value::UInt16(26) => Ok(CrunchExerciseName::InclineReverseCrunch),
            fit::Value::UInt16(27) => Ok(CrunchExerciseName::WeightedInclineReverseCrunch),
            fit::Value::UInt16(28) => Ok(CrunchExerciseName::KneelingCableCrunch),
            fit::Value::UInt16(29) => Ok(CrunchExerciseName::KneelingCrossCrunch),
            fit::Value::UInt16(30) => Ok(CrunchExerciseName::WeightedKneelingCrossCrunch),
            fit::Value::UInt16(31) => Ok(CrunchExerciseName::KneelingObliqueCableCrunch),
            fit::Value::UInt16(32) => Ok(CrunchExerciseName::KneesToElbow),
            fit::Value::UInt16(33) => Ok(CrunchExerciseName::LegExtensions),
            fit::Value::UInt16(34) => Ok(CrunchExerciseName::WeightedLegExtensions),
            fit::Value::UInt16(35) => Ok(CrunchExerciseName::LegLevers),
            fit::Value::UInt16(36) => Ok(CrunchExerciseName::McgillCurlUp),
            fit::Value::UInt16(37) => Ok(CrunchExerciseName::WeightedMcgillCurlUp),
            fit::Value::UInt16(38) => Ok(CrunchExerciseName::ModifiedPilatesRollUpWithBall),
            fit::Value::UInt16(39) => Ok(CrunchExerciseName::WeightedModifiedPilatesRollUpWithBall),
            fit::Value::UInt16(40) => Ok(CrunchExerciseName::PilatesCrunch),
            fit::Value::UInt16(41) => Ok(CrunchExerciseName::WeightedPilatesCrunch),
            fit::Value::UInt16(42) => Ok(CrunchExerciseName::PilatesRollUpWithBall),
            fit::Value::UInt16(43) => Ok(CrunchExerciseName::WeightedPilatesRollUpWithBall),
            fit::Value::UInt16(44) => Ok(CrunchExerciseName::RaisedLegsCrunch),
            fit::Value::UInt16(45) => Ok(CrunchExerciseName::WeightedRaisedLegsCrunch),
            fit::Value::UInt16(46) => Ok(CrunchExerciseName::ReverseCrunch),
            fit::Value::UInt16(47) => Ok(CrunchExerciseName::WeightedReverseCrunch),
            fit::Value::UInt16(48) => Ok(CrunchExerciseName::ReverseCrunchOnABench),
            fit::Value::UInt16(49) => Ok(CrunchExerciseName::WeightedReverseCrunchOnABench),
            fit::Value::UInt16(50) => Ok(CrunchExerciseName::ReverseCurlAndLift),
            fit::Value::UInt16(51) => Ok(CrunchExerciseName::WeightedReverseCurlAndLift),
            fit::Value::UInt16(52) => Ok(CrunchExerciseName::RotationalLift),
            fit::Value::UInt16(53) => Ok(CrunchExerciseName::WeightedRotationalLift),
            fit::Value::UInt16(54) => Ok(CrunchExerciseName::SeatedAlternatingReverseCrunch),
            fit::Value::UInt16(55) => {
                Ok(CrunchExerciseName::WeightedSeatedAlternatingReverseCrunch)
            }
            fit::Value::UInt16(56) => Ok(CrunchExerciseName::SeatedLegU),
            fit::Value::UInt16(57) => Ok(CrunchExerciseName::WeightedSeatedLegU),
            fit::Value::UInt16(58) => Ok(CrunchExerciseName::SideToSideCrunchAndWeave),
            fit::Value::UInt16(59) => Ok(CrunchExerciseName::WeightedSideToSideCrunchAndWeave),
            fit::Value::UInt16(60) => Ok(CrunchExerciseName::SingleLegReverseCrunch),
            fit::Value::UInt16(61) => Ok(CrunchExerciseName::WeightedSingleLegReverseCrunch),
            fit::Value::UInt16(62) => Ok(CrunchExerciseName::SkaterCrunchCross),
            fit::Value::UInt16(63) => Ok(CrunchExerciseName::WeightedSkaterCrunchCross),
            fit::Value::UInt16(64) => Ok(CrunchExerciseName::StandingCableCrunch),
            fit::Value::UInt16(65) => Ok(CrunchExerciseName::StandingSideCrunch),
            fit::Value::UInt16(66) => Ok(CrunchExerciseName::StepClimb),
            fit::Value::UInt16(67) => Ok(CrunchExerciseName::WeightedStepClimb),
            fit::Value::UInt16(68) => Ok(CrunchExerciseName::SwissBallCrunch),
            fit::Value::UInt16(69) => Ok(CrunchExerciseName::SwissBallReverseCrunch),
            fit::Value::UInt16(70) => Ok(CrunchExerciseName::WeightedSwissBallReverseCrunch),
            fit::Value::UInt16(71) => Ok(CrunchExerciseName::SwissBallRussianTwist),
            fit::Value::UInt16(72) => Ok(CrunchExerciseName::WeightedSwissBallRussianTwist),
            fit::Value::UInt16(73) => Ok(CrunchExerciseName::SwissBallSideCrunch),
            fit::Value::UInt16(74) => Ok(CrunchExerciseName::WeightedSwissBallSideCrunch),
            fit::Value::UInt16(75) => Ok(CrunchExerciseName::ThoracicCrunchesOnFoamRoller),
            fit::Value::UInt16(76) => Ok(CrunchExerciseName::WeightedThoracicCrunchesOnFoamRoller),
            fit::Value::UInt16(77) => Ok(CrunchExerciseName::TricepsCrunch),
            fit::Value::UInt16(78) => Ok(CrunchExerciseName::WeightedBicycleCrunch),
            fit::Value::UInt16(79) => Ok(CrunchExerciseName::WeightedCrunch),
            fit::Value::UInt16(80) => Ok(CrunchExerciseName::WeightedSwissBallCrunch),
            fit::Value::UInt16(81) => Ok(CrunchExerciseName::ToesToBar),
            fit::Value::UInt16(82) => Ok(CrunchExerciseName::WeightedToesToBar),
            fit::Value::UInt16(83) => Ok(CrunchExerciseName::Crunch),
            fit::Value::UInt16(84) => Ok(CrunchExerciseName::StraightLegCrunchWithBall),
            _ => Err("No corresponding CrunchExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for CrunchExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "bicycle_crunch" => Ok(CrunchExerciseName::BicycleCrunch),
            "cable_crunch" => Ok(CrunchExerciseName::CableCrunch),
            "circular_arm_crunch" => Ok(CrunchExerciseName::CircularArmCrunch),
            "crossed_arms_crunch" => Ok(CrunchExerciseName::CrossedArmsCrunch),
            "weighted_crossed_arms_crunch" => Ok(CrunchExerciseName::WeightedCrossedArmsCrunch),
            "cross_leg_reverse_crunch" => Ok(CrunchExerciseName::CrossLegReverseCrunch),
            "weighted_cross_leg_reverse_crunch" => {
                Ok(CrunchExerciseName::WeightedCrossLegReverseCrunch)
            }
            "crunch_chop" => Ok(CrunchExerciseName::CrunchChop),
            "weighted_crunch_chop" => Ok(CrunchExerciseName::WeightedCrunchChop),
            "double_crunch" => Ok(CrunchExerciseName::DoubleCrunch),
            "weighted_double_crunch" => Ok(CrunchExerciseName::WeightedDoubleCrunch),
            "elbow_to_knee_crunch" => Ok(CrunchExerciseName::ElbowToKneeCrunch),
            "weighted_elbow_to_knee_crunch" => Ok(CrunchExerciseName::WeightedElbowToKneeCrunch),
            "flutter_kicks" => Ok(CrunchExerciseName::FlutterKicks),
            "weighted_flutter_kicks" => Ok(CrunchExerciseName::WeightedFlutterKicks),
            "foam_roller_reverse_crunch_on_bench" => {
                Ok(CrunchExerciseName::FoamRollerReverseCrunchOnBench)
            }
            "weighted_foam_roller_reverse_crunch_on_bench" => {
                Ok(CrunchExerciseName::WeightedFoamRollerReverseCrunchOnBench)
            }
            "foam_roller_reverse_crunch_with_dumbbell" => {
                Ok(CrunchExerciseName::FoamRollerReverseCrunchWithDumbbell)
            }
            "foam_roller_reverse_crunch_with_medicine_ball" => {
                Ok(CrunchExerciseName::FoamRollerReverseCrunchWithMedicineBall)
            }
            "frog_press" => Ok(CrunchExerciseName::FrogPress),
            "hanging_knee_raise_oblique_crunch" => {
                Ok(CrunchExerciseName::HangingKneeRaiseObliqueCrunch)
            }
            "weighted_hanging_knee_raise_oblique_crunch" => {
                Ok(CrunchExerciseName::WeightedHangingKneeRaiseObliqueCrunch)
            }
            "hip_crossover" => Ok(CrunchExerciseName::HipCrossover),
            "weighted_hip_crossover" => Ok(CrunchExerciseName::WeightedHipCrossover),
            "hollow_rock" => Ok(CrunchExerciseName::HollowRock),
            "weighted_hollow_rock" => Ok(CrunchExerciseName::WeightedHollowRock),
            "incline_reverse_crunch" => Ok(CrunchExerciseName::InclineReverseCrunch),
            "weighted_incline_reverse_crunch" => {
                Ok(CrunchExerciseName::WeightedInclineReverseCrunch)
            }
            "kneeling_cable_crunch" => Ok(CrunchExerciseName::KneelingCableCrunch),
            "kneeling_cross_crunch" => Ok(CrunchExerciseName::KneelingCrossCrunch),
            "weighted_kneeling_cross_crunch" => Ok(CrunchExerciseName::WeightedKneelingCrossCrunch),
            "kneeling_oblique_cable_crunch" => Ok(CrunchExerciseName::KneelingObliqueCableCrunch),
            "knees_to_elbow" => Ok(CrunchExerciseName::KneesToElbow),
            "leg_extensions" => Ok(CrunchExerciseName::LegExtensions),
            "weighted_leg_extensions" => Ok(CrunchExerciseName::WeightedLegExtensions),
            "leg_levers" => Ok(CrunchExerciseName::LegLevers),
            "mcgill_curl_up" => Ok(CrunchExerciseName::McgillCurlUp),
            "weighted_mcgill_curl_up" => Ok(CrunchExerciseName::WeightedMcgillCurlUp),
            "modified_pilates_roll_up_with_ball" => {
                Ok(CrunchExerciseName::ModifiedPilatesRollUpWithBall)
            }
            "weighted_modified_pilates_roll_up_with_ball" => {
                Ok(CrunchExerciseName::WeightedModifiedPilatesRollUpWithBall)
            }
            "pilates_crunch" => Ok(CrunchExerciseName::PilatesCrunch),
            "weighted_pilates_crunch" => Ok(CrunchExerciseName::WeightedPilatesCrunch),
            "pilates_roll_up_with_ball" => Ok(CrunchExerciseName::PilatesRollUpWithBall),
            "weighted_pilates_roll_up_with_ball" => {
                Ok(CrunchExerciseName::WeightedPilatesRollUpWithBall)
            }
            "raised_legs_crunch" => Ok(CrunchExerciseName::RaisedLegsCrunch),
            "weighted_raised_legs_crunch" => Ok(CrunchExerciseName::WeightedRaisedLegsCrunch),
            "reverse_crunch" => Ok(CrunchExerciseName::ReverseCrunch),
            "weighted_reverse_crunch" => Ok(CrunchExerciseName::WeightedReverseCrunch),
            "reverse_crunch_on_a_bench" => Ok(CrunchExerciseName::ReverseCrunchOnABench),
            "weighted_reverse_crunch_on_a_bench" => {
                Ok(CrunchExerciseName::WeightedReverseCrunchOnABench)
            }
            "reverse_curl_and_lift" => Ok(CrunchExerciseName::ReverseCurlAndLift),
            "weighted_reverse_curl_and_lift" => Ok(CrunchExerciseName::WeightedReverseCurlAndLift),
            "rotational_lift" => Ok(CrunchExerciseName::RotationalLift),
            "weighted_rotational_lift" => Ok(CrunchExerciseName::WeightedRotationalLift),
            "seated_alternating_reverse_crunch" => {
                Ok(CrunchExerciseName::SeatedAlternatingReverseCrunch)
            }
            "weighted_seated_alternating_reverse_crunch" => {
                Ok(CrunchExerciseName::WeightedSeatedAlternatingReverseCrunch)
            }
            "seated_leg_u" => Ok(CrunchExerciseName::SeatedLegU),
            "weighted_seated_leg_u" => Ok(CrunchExerciseName::WeightedSeatedLegU),
            "side_to_side_crunch_and_weave" => Ok(CrunchExerciseName::SideToSideCrunchAndWeave),
            "weighted_side_to_side_crunch_and_weave" => {
                Ok(CrunchExerciseName::WeightedSideToSideCrunchAndWeave)
            }
            "single_leg_reverse_crunch" => Ok(CrunchExerciseName::SingleLegReverseCrunch),
            "weighted_single_leg_reverse_crunch" => {
                Ok(CrunchExerciseName::WeightedSingleLegReverseCrunch)
            }
            "skater_crunch_cross" => Ok(CrunchExerciseName::SkaterCrunchCross),
            "weighted_skater_crunch_cross" => Ok(CrunchExerciseName::WeightedSkaterCrunchCross),
            "standing_cable_crunch" => Ok(CrunchExerciseName::StandingCableCrunch),
            "standing_side_crunch" => Ok(CrunchExerciseName::StandingSideCrunch),
            "step_climb" => Ok(CrunchExerciseName::StepClimb),
            "weighted_step_climb" => Ok(CrunchExerciseName::WeightedStepClimb),
            "swiss_ball_crunch" => Ok(CrunchExerciseName::SwissBallCrunch),
            "swiss_ball_reverse_crunch" => Ok(CrunchExerciseName::SwissBallReverseCrunch),
            "weighted_swiss_ball_reverse_crunch" => {
                Ok(CrunchExerciseName::WeightedSwissBallReverseCrunch)
            }
            "swiss_ball_russian_twist" => Ok(CrunchExerciseName::SwissBallRussianTwist),
            "weighted_swiss_ball_russian_twist" => {
                Ok(CrunchExerciseName::WeightedSwissBallRussianTwist)
            }
            "swiss_ball_side_crunch" => Ok(CrunchExerciseName::SwissBallSideCrunch),
            "weighted_swiss_ball_side_crunch" => {
                Ok(CrunchExerciseName::WeightedSwissBallSideCrunch)
            }
            "thoracic_crunches_on_foam_roller" => {
                Ok(CrunchExerciseName::ThoracicCrunchesOnFoamRoller)
            }
            "weighted_thoracic_crunches_on_foam_roller" => {
                Ok(CrunchExerciseName::WeightedThoracicCrunchesOnFoamRoller)
            }
            "triceps_crunch" => Ok(CrunchExerciseName::TricepsCrunch),
            "weighted_bicycle_crunch" => Ok(CrunchExerciseName::WeightedBicycleCrunch),
            "weighted_crunch" => Ok(CrunchExerciseName::WeightedCrunch),
            "weighted_swiss_ball_crunch" => Ok(CrunchExerciseName::WeightedSwissBallCrunch),
            "toes_to_bar" => Ok(CrunchExerciseName::ToesToBar),
            "weighted_toes_to_bar" => Ok(CrunchExerciseName::WeightedToesToBar),
            "crunch" => Ok(CrunchExerciseName::Crunch),
            "straight_leg_crunch_with_ball" => Ok(CrunchExerciseName::StraightLegCrunchWithBall),
            _ => Err("No corresponding CrunchExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CurlExerciseName {
    AlternatingDumbbellBicepsCurl,
    AlternatingDumbbellBicepsCurlOnSwissBall,
    AlternatingInclineDumbbellBicepsCurl,
    BarbellBicepsCurl,
    BarbellReverseWristCurl,
    BarbellWristCurl,
    BehindTheBackBarbellReverseWristCurl,
    BehindTheBackOneArmCableCurl,
    CableBicepsCurl,
    CableHammerCurl,
    CheatingBarbellBicepsCurl,
    CloseGripEzBarBicepsCurl,
    CrossBodyDumbbellHammerCurl,
    DeadHangBicepsCurl,
    DeclineHammerCurl,
    DumbbellBicepsCurlWithStaticHold,
    DumbbellHammerCurl,
    DumbbellReverseWristCurl,
    DumbbellWristCurl,
    EzBarPreacherCurl,
    ForwardBendBicepsCurl,
    HammerCurlToPress,
    InclineDumbbellBicepsCurl,
    InclineOffsetThumbDumbbellCurl,
    KettlebellBicepsCurl,
    LyingConcentrationCableCurl,
    OneArmPreacherCurl,
    PlatePinchCurl,
    PreacherCurlWithCable,
    ReverseEzBarCurl,
    ReverseGripWristCurl,
    ReverseGripBarbellBicepsCurl,
    SeatedAlternatingDumbbellBicepsCurl,
    SeatedDumbbellBicepsCurl,
    SeatedReverseDumbbellCurl,
    SplitStanceOffsetPinkyDumbbellCurl,
    StandingAlternatingDumbbellCurls,
    StandingDumbbellBicepsCurl,
    StandingEzBarBicepsCurl,
    StaticCurl,
    SwissBallDumbbellOverheadTricepsExtension,
    SwissBallEzBarPreacherCurl,
    TwistingStandingDumbbellBicepsCurl,
    WideGripEzBarBicepsCurl,
}
impl fmt::Display for CurlExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CurlExerciseName::AlternatingDumbbellBicepsCurl => {
                f.write_str("alternating_dumbbell_biceps_curl")
            }
            CurlExerciseName::AlternatingDumbbellBicepsCurlOnSwissBall => {
                f.write_str("alternating_dumbbell_biceps_curl_on_swiss_ball")
            }
            CurlExerciseName::AlternatingInclineDumbbellBicepsCurl => {
                f.write_str("alternating_incline_dumbbell_biceps_curl")
            }
            CurlExerciseName::BarbellBicepsCurl => f.write_str("barbell_biceps_curl"),
            CurlExerciseName::BarbellReverseWristCurl => f.write_str("barbell_reverse_wrist_curl"),
            CurlExerciseName::BarbellWristCurl => f.write_str("barbell_wrist_curl"),
            CurlExerciseName::BehindTheBackBarbellReverseWristCurl => {
                f.write_str("behind_the_back_barbell_reverse_wrist_curl")
            }
            CurlExerciseName::BehindTheBackOneArmCableCurl => {
                f.write_str("behind_the_back_one_arm_cable_curl")
            }
            CurlExerciseName::CableBicepsCurl => f.write_str("cable_biceps_curl"),
            CurlExerciseName::CableHammerCurl => f.write_str("cable_hammer_curl"),
            CurlExerciseName::CheatingBarbellBicepsCurl => {
                f.write_str("cheating_barbell_biceps_curl")
            }
            CurlExerciseName::CloseGripEzBarBicepsCurl => {
                f.write_str("close_grip_ez_bar_biceps_curl")
            }
            CurlExerciseName::CrossBodyDumbbellHammerCurl => {
                f.write_str("cross_body_dumbbell_hammer_curl")
            }
            CurlExerciseName::DeadHangBicepsCurl => f.write_str("dead_hang_biceps_curl"),
            CurlExerciseName::DeclineHammerCurl => f.write_str("decline_hammer_curl"),
            CurlExerciseName::DumbbellBicepsCurlWithStaticHold => {
                f.write_str("dumbbell_biceps_curl_with_static_hold")
            }
            CurlExerciseName::DumbbellHammerCurl => f.write_str("dumbbell_hammer_curl"),
            CurlExerciseName::DumbbellReverseWristCurl => {
                f.write_str("dumbbell_reverse_wrist_curl")
            }
            CurlExerciseName::DumbbellWristCurl => f.write_str("dumbbell_wrist_curl"),
            CurlExerciseName::EzBarPreacherCurl => f.write_str("ez_bar_preacher_curl"),
            CurlExerciseName::ForwardBendBicepsCurl => f.write_str("forward_bend_biceps_curl"),
            CurlExerciseName::HammerCurlToPress => f.write_str("hammer_curl_to_press"),
            CurlExerciseName::InclineDumbbellBicepsCurl => {
                f.write_str("incline_dumbbell_biceps_curl")
            }
            CurlExerciseName::InclineOffsetThumbDumbbellCurl => {
                f.write_str("incline_offset_thumb_dumbbell_curl")
            }
            CurlExerciseName::KettlebellBicepsCurl => f.write_str("kettlebell_biceps_curl"),
            CurlExerciseName::LyingConcentrationCableCurl => {
                f.write_str("lying_concentration_cable_curl")
            }
            CurlExerciseName::OneArmPreacherCurl => f.write_str("one_arm_preacher_curl"),
            CurlExerciseName::PlatePinchCurl => f.write_str("plate_pinch_curl"),
            CurlExerciseName::PreacherCurlWithCable => f.write_str("preacher_curl_with_cable"),
            CurlExerciseName::ReverseEzBarCurl => f.write_str("reverse_ez_bar_curl"),
            CurlExerciseName::ReverseGripWristCurl => f.write_str("reverse_grip_wrist_curl"),
            CurlExerciseName::ReverseGripBarbellBicepsCurl => {
                f.write_str("reverse_grip_barbell_biceps_curl")
            }
            CurlExerciseName::SeatedAlternatingDumbbellBicepsCurl => {
                f.write_str("seated_alternating_dumbbell_biceps_curl")
            }
            CurlExerciseName::SeatedDumbbellBicepsCurl => {
                f.write_str("seated_dumbbell_biceps_curl")
            }
            CurlExerciseName::SeatedReverseDumbbellCurl => {
                f.write_str("seated_reverse_dumbbell_curl")
            }
            CurlExerciseName::SplitStanceOffsetPinkyDumbbellCurl => {
                f.write_str("split_stance_offset_pinky_dumbbell_curl")
            }
            CurlExerciseName::StandingAlternatingDumbbellCurls => {
                f.write_str("standing_alternating_dumbbell_curls")
            }
            CurlExerciseName::StandingDumbbellBicepsCurl => {
                f.write_str("standing_dumbbell_biceps_curl")
            }
            CurlExerciseName::StandingEzBarBicepsCurl => f.write_str("standing_ez_bar_biceps_curl"),
            CurlExerciseName::StaticCurl => f.write_str("static_curl"),
            CurlExerciseName::SwissBallDumbbellOverheadTricepsExtension => {
                f.write_str("swiss_ball_dumbbell_overhead_triceps_extension")
            }
            CurlExerciseName::SwissBallEzBarPreacherCurl => {
                f.write_str("swiss_ball_ez_bar_preacher_curl")
            }
            CurlExerciseName::TwistingStandingDumbbellBicepsCurl => {
                f.write_str("twisting_standing_dumbbell_biceps_curl")
            }
            CurlExerciseName::WideGripEzBarBicepsCurl => {
                f.write_str("wide_grip_ez_bar_biceps_curl")
            }
        }
    }
}
impl CurlExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CurlExerciseName::AlternatingDumbbellBicepsCurl => fit::Value::UInt16(0),
            CurlExerciseName::AlternatingDumbbellBicepsCurlOnSwissBall => fit::Value::UInt16(1),
            CurlExerciseName::AlternatingInclineDumbbellBicepsCurl => fit::Value::UInt16(2),
            CurlExerciseName::BarbellBicepsCurl => fit::Value::UInt16(3),
            CurlExerciseName::BarbellReverseWristCurl => fit::Value::UInt16(4),
            CurlExerciseName::BarbellWristCurl => fit::Value::UInt16(5),
            CurlExerciseName::BehindTheBackBarbellReverseWristCurl => fit::Value::UInt16(6),
            CurlExerciseName::BehindTheBackOneArmCableCurl => fit::Value::UInt16(7),
            CurlExerciseName::CableBicepsCurl => fit::Value::UInt16(8),
            CurlExerciseName::CableHammerCurl => fit::Value::UInt16(9),
            CurlExerciseName::CheatingBarbellBicepsCurl => fit::Value::UInt16(10),
            CurlExerciseName::CloseGripEzBarBicepsCurl => fit::Value::UInt16(11),
            CurlExerciseName::CrossBodyDumbbellHammerCurl => fit::Value::UInt16(12),
            CurlExerciseName::DeadHangBicepsCurl => fit::Value::UInt16(13),
            CurlExerciseName::DeclineHammerCurl => fit::Value::UInt16(14),
            CurlExerciseName::DumbbellBicepsCurlWithStaticHold => fit::Value::UInt16(15),
            CurlExerciseName::DumbbellHammerCurl => fit::Value::UInt16(16),
            CurlExerciseName::DumbbellReverseWristCurl => fit::Value::UInt16(17),
            CurlExerciseName::DumbbellWristCurl => fit::Value::UInt16(18),
            CurlExerciseName::EzBarPreacherCurl => fit::Value::UInt16(19),
            CurlExerciseName::ForwardBendBicepsCurl => fit::Value::UInt16(20),
            CurlExerciseName::HammerCurlToPress => fit::Value::UInt16(21),
            CurlExerciseName::InclineDumbbellBicepsCurl => fit::Value::UInt16(22),
            CurlExerciseName::InclineOffsetThumbDumbbellCurl => fit::Value::UInt16(23),
            CurlExerciseName::KettlebellBicepsCurl => fit::Value::UInt16(24),
            CurlExerciseName::LyingConcentrationCableCurl => fit::Value::UInt16(25),
            CurlExerciseName::OneArmPreacherCurl => fit::Value::UInt16(26),
            CurlExerciseName::PlatePinchCurl => fit::Value::UInt16(27),
            CurlExerciseName::PreacherCurlWithCable => fit::Value::UInt16(28),
            CurlExerciseName::ReverseEzBarCurl => fit::Value::UInt16(29),
            CurlExerciseName::ReverseGripWristCurl => fit::Value::UInt16(30),
            CurlExerciseName::ReverseGripBarbellBicepsCurl => fit::Value::UInt16(31),
            CurlExerciseName::SeatedAlternatingDumbbellBicepsCurl => fit::Value::UInt16(32),
            CurlExerciseName::SeatedDumbbellBicepsCurl => fit::Value::UInt16(33),
            CurlExerciseName::SeatedReverseDumbbellCurl => fit::Value::UInt16(34),
            CurlExerciseName::SplitStanceOffsetPinkyDumbbellCurl => fit::Value::UInt16(35),
            CurlExerciseName::StandingAlternatingDumbbellCurls => fit::Value::UInt16(36),
            CurlExerciseName::StandingDumbbellBicepsCurl => fit::Value::UInt16(37),
            CurlExerciseName::StandingEzBarBicepsCurl => fit::Value::UInt16(38),
            CurlExerciseName::StaticCurl => fit::Value::UInt16(39),
            CurlExerciseName::SwissBallDumbbellOverheadTricepsExtension => fit::Value::UInt16(40),
            CurlExerciseName::SwissBallEzBarPreacherCurl => fit::Value::UInt16(41),
            CurlExerciseName::TwistingStandingDumbbellBicepsCurl => fit::Value::UInt16(42),
            CurlExerciseName::WideGripEzBarBicepsCurl => fit::Value::UInt16(43),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for CurlExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(CurlExerciseName::AlternatingDumbbellBicepsCurl),
            fit::Value::UInt16(1) => Ok(CurlExerciseName::AlternatingDumbbellBicepsCurlOnSwissBall),
            fit::Value::UInt16(2) => Ok(CurlExerciseName::AlternatingInclineDumbbellBicepsCurl),
            fit::Value::UInt16(3) => Ok(CurlExerciseName::BarbellBicepsCurl),
            fit::Value::UInt16(4) => Ok(CurlExerciseName::BarbellReverseWristCurl),
            fit::Value::UInt16(5) => Ok(CurlExerciseName::BarbellWristCurl),
            fit::Value::UInt16(6) => Ok(CurlExerciseName::BehindTheBackBarbellReverseWristCurl),
            fit::Value::UInt16(7) => Ok(CurlExerciseName::BehindTheBackOneArmCableCurl),
            fit::Value::UInt16(8) => Ok(CurlExerciseName::CableBicepsCurl),
            fit::Value::UInt16(9) => Ok(CurlExerciseName::CableHammerCurl),
            fit::Value::UInt16(10) => Ok(CurlExerciseName::CheatingBarbellBicepsCurl),
            fit::Value::UInt16(11) => Ok(CurlExerciseName::CloseGripEzBarBicepsCurl),
            fit::Value::UInt16(12) => Ok(CurlExerciseName::CrossBodyDumbbellHammerCurl),
            fit::Value::UInt16(13) => Ok(CurlExerciseName::DeadHangBicepsCurl),
            fit::Value::UInt16(14) => Ok(CurlExerciseName::DeclineHammerCurl),
            fit::Value::UInt16(15) => Ok(CurlExerciseName::DumbbellBicepsCurlWithStaticHold),
            fit::Value::UInt16(16) => Ok(CurlExerciseName::DumbbellHammerCurl),
            fit::Value::UInt16(17) => Ok(CurlExerciseName::DumbbellReverseWristCurl),
            fit::Value::UInt16(18) => Ok(CurlExerciseName::DumbbellWristCurl),
            fit::Value::UInt16(19) => Ok(CurlExerciseName::EzBarPreacherCurl),
            fit::Value::UInt16(20) => Ok(CurlExerciseName::ForwardBendBicepsCurl),
            fit::Value::UInt16(21) => Ok(CurlExerciseName::HammerCurlToPress),
            fit::Value::UInt16(22) => Ok(CurlExerciseName::InclineDumbbellBicepsCurl),
            fit::Value::UInt16(23) => Ok(CurlExerciseName::InclineOffsetThumbDumbbellCurl),
            fit::Value::UInt16(24) => Ok(CurlExerciseName::KettlebellBicepsCurl),
            fit::Value::UInt16(25) => Ok(CurlExerciseName::LyingConcentrationCableCurl),
            fit::Value::UInt16(26) => Ok(CurlExerciseName::OneArmPreacherCurl),
            fit::Value::UInt16(27) => Ok(CurlExerciseName::PlatePinchCurl),
            fit::Value::UInt16(28) => Ok(CurlExerciseName::PreacherCurlWithCable),
            fit::Value::UInt16(29) => Ok(CurlExerciseName::ReverseEzBarCurl),
            fit::Value::UInt16(30) => Ok(CurlExerciseName::ReverseGripWristCurl),
            fit::Value::UInt16(31) => Ok(CurlExerciseName::ReverseGripBarbellBicepsCurl),
            fit::Value::UInt16(32) => Ok(CurlExerciseName::SeatedAlternatingDumbbellBicepsCurl),
            fit::Value::UInt16(33) => Ok(CurlExerciseName::SeatedDumbbellBicepsCurl),
            fit::Value::UInt16(34) => Ok(CurlExerciseName::SeatedReverseDumbbellCurl),
            fit::Value::UInt16(35) => Ok(CurlExerciseName::SplitStanceOffsetPinkyDumbbellCurl),
            fit::Value::UInt16(36) => Ok(CurlExerciseName::StandingAlternatingDumbbellCurls),
            fit::Value::UInt16(37) => Ok(CurlExerciseName::StandingDumbbellBicepsCurl),
            fit::Value::UInt16(38) => Ok(CurlExerciseName::StandingEzBarBicepsCurl),
            fit::Value::UInt16(39) => Ok(CurlExerciseName::StaticCurl),
            fit::Value::UInt16(40) => {
                Ok(CurlExerciseName::SwissBallDumbbellOverheadTricepsExtension)
            }
            fit::Value::UInt16(41) => Ok(CurlExerciseName::SwissBallEzBarPreacherCurl),
            fit::Value::UInt16(42) => Ok(CurlExerciseName::TwistingStandingDumbbellBicepsCurl),
            fit::Value::UInt16(43) => Ok(CurlExerciseName::WideGripEzBarBicepsCurl),
            _ => Err("No corresponding CurlExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for CurlExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "alternating_dumbbell_biceps_curl" => {
                Ok(CurlExerciseName::AlternatingDumbbellBicepsCurl)
            }
            "alternating_dumbbell_biceps_curl_on_swiss_ball" => {
                Ok(CurlExerciseName::AlternatingDumbbellBicepsCurlOnSwissBall)
            }
            "alternating_incline_dumbbell_biceps_curl" => {
                Ok(CurlExerciseName::AlternatingInclineDumbbellBicepsCurl)
            }
            "barbell_biceps_curl" => Ok(CurlExerciseName::BarbellBicepsCurl),
            "barbell_reverse_wrist_curl" => Ok(CurlExerciseName::BarbellReverseWristCurl),
            "barbell_wrist_curl" => Ok(CurlExerciseName::BarbellWristCurl),
            "behind_the_back_barbell_reverse_wrist_curl" => {
                Ok(CurlExerciseName::BehindTheBackBarbellReverseWristCurl)
            }
            "behind_the_back_one_arm_cable_curl" => {
                Ok(CurlExerciseName::BehindTheBackOneArmCableCurl)
            }
            "cable_biceps_curl" => Ok(CurlExerciseName::CableBicepsCurl),
            "cable_hammer_curl" => Ok(CurlExerciseName::CableHammerCurl),
            "cheating_barbell_biceps_curl" => Ok(CurlExerciseName::CheatingBarbellBicepsCurl),
            "close_grip_ez_bar_biceps_curl" => Ok(CurlExerciseName::CloseGripEzBarBicepsCurl),
            "cross_body_dumbbell_hammer_curl" => Ok(CurlExerciseName::CrossBodyDumbbellHammerCurl),
            "dead_hang_biceps_curl" => Ok(CurlExerciseName::DeadHangBicepsCurl),
            "decline_hammer_curl" => Ok(CurlExerciseName::DeclineHammerCurl),
            "dumbbell_biceps_curl_with_static_hold" => {
                Ok(CurlExerciseName::DumbbellBicepsCurlWithStaticHold)
            }
            "dumbbell_hammer_curl" => Ok(CurlExerciseName::DumbbellHammerCurl),
            "dumbbell_reverse_wrist_curl" => Ok(CurlExerciseName::DumbbellReverseWristCurl),
            "dumbbell_wrist_curl" => Ok(CurlExerciseName::DumbbellWristCurl),
            "ez_bar_preacher_curl" => Ok(CurlExerciseName::EzBarPreacherCurl),
            "forward_bend_biceps_curl" => Ok(CurlExerciseName::ForwardBendBicepsCurl),
            "hammer_curl_to_press" => Ok(CurlExerciseName::HammerCurlToPress),
            "incline_dumbbell_biceps_curl" => Ok(CurlExerciseName::InclineDumbbellBicepsCurl),
            "incline_offset_thumb_dumbbell_curl" => {
                Ok(CurlExerciseName::InclineOffsetThumbDumbbellCurl)
            }
            "kettlebell_biceps_curl" => Ok(CurlExerciseName::KettlebellBicepsCurl),
            "lying_concentration_cable_curl" => Ok(CurlExerciseName::LyingConcentrationCableCurl),
            "one_arm_preacher_curl" => Ok(CurlExerciseName::OneArmPreacherCurl),
            "plate_pinch_curl" => Ok(CurlExerciseName::PlatePinchCurl),
            "preacher_curl_with_cable" => Ok(CurlExerciseName::PreacherCurlWithCable),
            "reverse_ez_bar_curl" => Ok(CurlExerciseName::ReverseEzBarCurl),
            "reverse_grip_wrist_curl" => Ok(CurlExerciseName::ReverseGripWristCurl),
            "reverse_grip_barbell_biceps_curl" => {
                Ok(CurlExerciseName::ReverseGripBarbellBicepsCurl)
            }
            "seated_alternating_dumbbell_biceps_curl" => {
                Ok(CurlExerciseName::SeatedAlternatingDumbbellBicepsCurl)
            }
            "seated_dumbbell_biceps_curl" => Ok(CurlExerciseName::SeatedDumbbellBicepsCurl),
            "seated_reverse_dumbbell_curl" => Ok(CurlExerciseName::SeatedReverseDumbbellCurl),
            "split_stance_offset_pinky_dumbbell_curl" => {
                Ok(CurlExerciseName::SplitStanceOffsetPinkyDumbbellCurl)
            }
            "standing_alternating_dumbbell_curls" => {
                Ok(CurlExerciseName::StandingAlternatingDumbbellCurls)
            }
            "standing_dumbbell_biceps_curl" => Ok(CurlExerciseName::StandingDumbbellBicepsCurl),
            "standing_ez_bar_biceps_curl" => Ok(CurlExerciseName::StandingEzBarBicepsCurl),
            "static_curl" => Ok(CurlExerciseName::StaticCurl),
            "swiss_ball_dumbbell_overhead_triceps_extension" => {
                Ok(CurlExerciseName::SwissBallDumbbellOverheadTricepsExtension)
            }
            "swiss_ball_ez_bar_preacher_curl" => Ok(CurlExerciseName::SwissBallEzBarPreacherCurl),
            "twisting_standing_dumbbell_biceps_curl" => {
                Ok(CurlExerciseName::TwistingStandingDumbbellBicepsCurl)
            }
            "wide_grip_ez_bar_biceps_curl" => Ok(CurlExerciseName::WideGripEzBarBicepsCurl),
            _ => Err("No corresponding CurlExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DeadliftExerciseName {
    BarbellDeadlift,
    BarbellStraightLegDeadlift,
    DumbbellDeadlift,
    DumbbellSingleLegDeadliftToRow,
    DumbbellStraightLegDeadlift,
    KettlebellFloorToShelf,
    OneArmOneLegDeadlift,
    RackPull,
    RotationalDumbbellStraightLegDeadlift,
    SingleArmDeadlift,
    SingleLegBarbellDeadlift,
    SingleLegBarbellStraightLegDeadlift,
    SingleLegDeadliftWithBarbell,
    SingleLegRdlCircuit,
    SingleLegRomanianDeadliftWithDumbbell,
    SumoDeadlift,
    SumoDeadliftHighPull,
    TrapBarDeadlift,
    WideGripBarbellDeadlift,
}
impl fmt::Display for DeadliftExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DeadliftExerciseName::BarbellDeadlift => f.write_str("barbell_deadlift"),
            DeadliftExerciseName::BarbellStraightLegDeadlift => {
                f.write_str("barbell_straight_leg_deadlift")
            }
            DeadliftExerciseName::DumbbellDeadlift => f.write_str("dumbbell_deadlift"),
            DeadliftExerciseName::DumbbellSingleLegDeadliftToRow => {
                f.write_str("dumbbell_single_leg_deadlift_to_row")
            }
            DeadliftExerciseName::DumbbellStraightLegDeadlift => {
                f.write_str("dumbbell_straight_leg_deadlift")
            }
            DeadliftExerciseName::KettlebellFloorToShelf => {
                f.write_str("kettlebell_floor_to_shelf")
            }
            DeadliftExerciseName::OneArmOneLegDeadlift => f.write_str("one_arm_one_leg_deadlift"),
            DeadliftExerciseName::RackPull => f.write_str("rack_pull"),
            DeadliftExerciseName::RotationalDumbbellStraightLegDeadlift => {
                f.write_str("rotational_dumbbell_straight_leg_deadlift")
            }
            DeadliftExerciseName::SingleArmDeadlift => f.write_str("single_arm_deadlift"),
            DeadliftExerciseName::SingleLegBarbellDeadlift => {
                f.write_str("single_leg_barbell_deadlift")
            }
            DeadliftExerciseName::SingleLegBarbellStraightLegDeadlift => {
                f.write_str("single_leg_barbell_straight_leg_deadlift")
            }
            DeadliftExerciseName::SingleLegDeadliftWithBarbell => {
                f.write_str("single_leg_deadlift_with_barbell")
            }
            DeadliftExerciseName::SingleLegRdlCircuit => f.write_str("single_leg_rdl_circuit"),
            DeadliftExerciseName::SingleLegRomanianDeadliftWithDumbbell => {
                f.write_str("single_leg_romanian_deadlift_with_dumbbell")
            }
            DeadliftExerciseName::SumoDeadlift => f.write_str("sumo_deadlift"),
            DeadliftExerciseName::SumoDeadliftHighPull => f.write_str("sumo_deadlift_high_pull"),
            DeadliftExerciseName::TrapBarDeadlift => f.write_str("trap_bar_deadlift"),
            DeadliftExerciseName::WideGripBarbellDeadlift => {
                f.write_str("wide_grip_barbell_deadlift")
            }
        }
    }
}
impl DeadliftExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DeadliftExerciseName::BarbellDeadlift => fit::Value::UInt16(0),
            DeadliftExerciseName::BarbellStraightLegDeadlift => fit::Value::UInt16(1),
            DeadliftExerciseName::DumbbellDeadlift => fit::Value::UInt16(2),
            DeadliftExerciseName::DumbbellSingleLegDeadliftToRow => fit::Value::UInt16(3),
            DeadliftExerciseName::DumbbellStraightLegDeadlift => fit::Value::UInt16(4),
            DeadliftExerciseName::KettlebellFloorToShelf => fit::Value::UInt16(5),
            DeadliftExerciseName::OneArmOneLegDeadlift => fit::Value::UInt16(6),
            DeadliftExerciseName::RackPull => fit::Value::UInt16(7),
            DeadliftExerciseName::RotationalDumbbellStraightLegDeadlift => fit::Value::UInt16(8),
            DeadliftExerciseName::SingleArmDeadlift => fit::Value::UInt16(9),
            DeadliftExerciseName::SingleLegBarbellDeadlift => fit::Value::UInt16(10),
            DeadliftExerciseName::SingleLegBarbellStraightLegDeadlift => fit::Value::UInt16(11),
            DeadliftExerciseName::SingleLegDeadliftWithBarbell => fit::Value::UInt16(12),
            DeadliftExerciseName::SingleLegRdlCircuit => fit::Value::UInt16(13),
            DeadliftExerciseName::SingleLegRomanianDeadliftWithDumbbell => fit::Value::UInt16(14),
            DeadliftExerciseName::SumoDeadlift => fit::Value::UInt16(15),
            DeadliftExerciseName::SumoDeadliftHighPull => fit::Value::UInt16(16),
            DeadliftExerciseName::TrapBarDeadlift => fit::Value::UInt16(17),
            DeadliftExerciseName::WideGripBarbellDeadlift => fit::Value::UInt16(18),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for DeadliftExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(DeadliftExerciseName::BarbellDeadlift),
            fit::Value::UInt16(1) => Ok(DeadliftExerciseName::BarbellStraightLegDeadlift),
            fit::Value::UInt16(2) => Ok(DeadliftExerciseName::DumbbellDeadlift),
            fit::Value::UInt16(3) => Ok(DeadliftExerciseName::DumbbellSingleLegDeadliftToRow),
            fit::Value::UInt16(4) => Ok(DeadliftExerciseName::DumbbellStraightLegDeadlift),
            fit::Value::UInt16(5) => Ok(DeadliftExerciseName::KettlebellFloorToShelf),
            fit::Value::UInt16(6) => Ok(DeadliftExerciseName::OneArmOneLegDeadlift),
            fit::Value::UInt16(7) => Ok(DeadliftExerciseName::RackPull),
            fit::Value::UInt16(8) => {
                Ok(DeadliftExerciseName::RotationalDumbbellStraightLegDeadlift)
            }
            fit::Value::UInt16(9) => Ok(DeadliftExerciseName::SingleArmDeadlift),
            fit::Value::UInt16(10) => Ok(DeadliftExerciseName::SingleLegBarbellDeadlift),
            fit::Value::UInt16(11) => Ok(DeadliftExerciseName::SingleLegBarbellStraightLegDeadlift),
            fit::Value::UInt16(12) => Ok(DeadliftExerciseName::SingleLegDeadliftWithBarbell),
            fit::Value::UInt16(13) => Ok(DeadliftExerciseName::SingleLegRdlCircuit),
            fit::Value::UInt16(14) => {
                Ok(DeadliftExerciseName::SingleLegRomanianDeadliftWithDumbbell)
            }
            fit::Value::UInt16(15) => Ok(DeadliftExerciseName::SumoDeadlift),
            fit::Value::UInt16(16) => Ok(DeadliftExerciseName::SumoDeadliftHighPull),
            fit::Value::UInt16(17) => Ok(DeadliftExerciseName::TrapBarDeadlift),
            fit::Value::UInt16(18) => Ok(DeadliftExerciseName::WideGripBarbellDeadlift),
            _ => Err("No corresponding DeadliftExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for DeadliftExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "barbell_deadlift" => Ok(DeadliftExerciseName::BarbellDeadlift),
            "barbell_straight_leg_deadlift" => Ok(DeadliftExerciseName::BarbellStraightLegDeadlift),
            "dumbbell_deadlift" => Ok(DeadliftExerciseName::DumbbellDeadlift),
            "dumbbell_single_leg_deadlift_to_row" => {
                Ok(DeadliftExerciseName::DumbbellSingleLegDeadliftToRow)
            }
            "dumbbell_straight_leg_deadlift" => {
                Ok(DeadliftExerciseName::DumbbellStraightLegDeadlift)
            }
            "kettlebell_floor_to_shelf" => Ok(DeadliftExerciseName::KettlebellFloorToShelf),
            "one_arm_one_leg_deadlift" => Ok(DeadliftExerciseName::OneArmOneLegDeadlift),
            "rack_pull" => Ok(DeadliftExerciseName::RackPull),
            "rotational_dumbbell_straight_leg_deadlift" => {
                Ok(DeadliftExerciseName::RotationalDumbbellStraightLegDeadlift)
            }
            "single_arm_deadlift" => Ok(DeadliftExerciseName::SingleArmDeadlift),
            "single_leg_barbell_deadlift" => Ok(DeadliftExerciseName::SingleLegBarbellDeadlift),
            "single_leg_barbell_straight_leg_deadlift" => {
                Ok(DeadliftExerciseName::SingleLegBarbellStraightLegDeadlift)
            }
            "single_leg_deadlift_with_barbell" => {
                Ok(DeadliftExerciseName::SingleLegDeadliftWithBarbell)
            }
            "single_leg_rdl_circuit" => Ok(DeadliftExerciseName::SingleLegRdlCircuit),
            "single_leg_romanian_deadlift_with_dumbbell" => {
                Ok(DeadliftExerciseName::SingleLegRomanianDeadliftWithDumbbell)
            }
            "sumo_deadlift" => Ok(DeadliftExerciseName::SumoDeadlift),
            "sumo_deadlift_high_pull" => Ok(DeadliftExerciseName::SumoDeadliftHighPull),
            "trap_bar_deadlift" => Ok(DeadliftExerciseName::TrapBarDeadlift),
            "wide_grip_barbell_deadlift" => Ok(DeadliftExerciseName::WideGripBarbellDeadlift),
            _ => Err("No corresponding DeadliftExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum FlyeExerciseName {
    CableCrossover,
    DeclineDumbbellFlye,
    DumbbellFlye,
    InclineDumbbellFlye,
    KettlebellFlye,
    KneelingRearFlye,
    SingleArmStandingCableReverseFlye,
    SwissBallDumbbellFlye,
    ArmRotations,
    HugATree,
}
impl fmt::Display for FlyeExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FlyeExerciseName::CableCrossover => f.write_str("cable_crossover"),
            FlyeExerciseName::DeclineDumbbellFlye => f.write_str("decline_dumbbell_flye"),
            FlyeExerciseName::DumbbellFlye => f.write_str("dumbbell_flye"),
            FlyeExerciseName::InclineDumbbellFlye => f.write_str("incline_dumbbell_flye"),
            FlyeExerciseName::KettlebellFlye => f.write_str("kettlebell_flye"),
            FlyeExerciseName::KneelingRearFlye => f.write_str("kneeling_rear_flye"),
            FlyeExerciseName::SingleArmStandingCableReverseFlye => {
                f.write_str("single_arm_standing_cable_reverse_flye")
            }
            FlyeExerciseName::SwissBallDumbbellFlye => f.write_str("swiss_ball_dumbbell_flye"),
            FlyeExerciseName::ArmRotations => f.write_str("arm_rotations"),
            FlyeExerciseName::HugATree => f.write_str("hug_a_tree"),
        }
    }
}
impl FlyeExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            FlyeExerciseName::CableCrossover => fit::Value::UInt16(0),
            FlyeExerciseName::DeclineDumbbellFlye => fit::Value::UInt16(1),
            FlyeExerciseName::DumbbellFlye => fit::Value::UInt16(2),
            FlyeExerciseName::InclineDumbbellFlye => fit::Value::UInt16(3),
            FlyeExerciseName::KettlebellFlye => fit::Value::UInt16(4),
            FlyeExerciseName::KneelingRearFlye => fit::Value::UInt16(5),
            FlyeExerciseName::SingleArmStandingCableReverseFlye => fit::Value::UInt16(6),
            FlyeExerciseName::SwissBallDumbbellFlye => fit::Value::UInt16(7),
            FlyeExerciseName::ArmRotations => fit::Value::UInt16(8),
            FlyeExerciseName::HugATree => fit::Value::UInt16(9),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for FlyeExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(FlyeExerciseName::CableCrossover),
            fit::Value::UInt16(1) => Ok(FlyeExerciseName::DeclineDumbbellFlye),
            fit::Value::UInt16(2) => Ok(FlyeExerciseName::DumbbellFlye),
            fit::Value::UInt16(3) => Ok(FlyeExerciseName::InclineDumbbellFlye),
            fit::Value::UInt16(4) => Ok(FlyeExerciseName::KettlebellFlye),
            fit::Value::UInt16(5) => Ok(FlyeExerciseName::KneelingRearFlye),
            fit::Value::UInt16(6) => Ok(FlyeExerciseName::SingleArmStandingCableReverseFlye),
            fit::Value::UInt16(7) => Ok(FlyeExerciseName::SwissBallDumbbellFlye),
            fit::Value::UInt16(8) => Ok(FlyeExerciseName::ArmRotations),
            fit::Value::UInt16(9) => Ok(FlyeExerciseName::HugATree),
            _ => Err("No corresponding FlyeExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for FlyeExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "cable_crossover" => Ok(FlyeExerciseName::CableCrossover),
            "decline_dumbbell_flye" => Ok(FlyeExerciseName::DeclineDumbbellFlye),
            "dumbbell_flye" => Ok(FlyeExerciseName::DumbbellFlye),
            "incline_dumbbell_flye" => Ok(FlyeExerciseName::InclineDumbbellFlye),
            "kettlebell_flye" => Ok(FlyeExerciseName::KettlebellFlye),
            "kneeling_rear_flye" => Ok(FlyeExerciseName::KneelingRearFlye),
            "single_arm_standing_cable_reverse_flye" => {
                Ok(FlyeExerciseName::SingleArmStandingCableReverseFlye)
            }
            "swiss_ball_dumbbell_flye" => Ok(FlyeExerciseName::SwissBallDumbbellFlye),
            "arm_rotations" => Ok(FlyeExerciseName::ArmRotations),
            "hug_a_tree" => Ok(FlyeExerciseName::HugATree),
            _ => Err("No corresponding FlyeExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum HipRaiseExerciseName {
    BarbellHipThrustOnFloor,
    BarbellHipThrustWithBench,
    BentKneeSwissBallReverseHipRaise,
    WeightedBentKneeSwissBallReverseHipRaise,
    BridgeWithLegExtension,
    WeightedBridgeWithLegExtension,
    ClamBridge,
    FrontKickTabletop,
    WeightedFrontKickTabletop,
    HipExtensionAndCross,
    WeightedHipExtensionAndCross,
    HipRaise,
    WeightedHipRaise,
    HipRaiseWithFeetOnSwissBall,
    WeightedHipRaiseWithFeetOnSwissBall,
    HipRaiseWithHeadOnBosuBall,
    WeightedHipRaiseWithHeadOnBosuBall,
    HipRaiseWithHeadOnSwissBall,
    WeightedHipRaiseWithHeadOnSwissBall,
    HipRaiseWithKneeSqueeze,
    WeightedHipRaiseWithKneeSqueeze,
    InclineRearLegExtension,
    WeightedInclineRearLegExtension,
    KettlebellSwing,
    MarchingHipRaise,
    WeightedMarchingHipRaise,
    MarchingHipRaiseWithFeetOnASwissBall,
    WeightedMarchingHipRaiseWithFeetOnASwissBall,
    ReverseHipRaise,
    WeightedReverseHipRaise,
    SingleLegHipRaise,
    WeightedSingleLegHipRaise,
    SingleLegHipRaiseWithFootOnBench,
    WeightedSingleLegHipRaiseWithFootOnBench,
    SingleLegHipRaiseWithFootOnBosuBall,
    WeightedSingleLegHipRaiseWithFootOnBosuBall,
    SingleLegHipRaiseWithFootOnFoamRoller,
    WeightedSingleLegHipRaiseWithFootOnFoamRoller,
    SingleLegHipRaiseWithFootOnMedicineBall,
    WeightedSingleLegHipRaiseWithFootOnMedicineBall,
    SingleLegHipRaiseWithHeadOnBosuBall,
    WeightedSingleLegHipRaiseWithHeadOnBosuBall,
    WeightedClamBridge,
    SingleLegSwissBallHipRaiseAndLegCurl,
    Clams,
    /// Deprecated do not use
    InnerThighCircles,
    /// Deprecated do not use
    InnerThighSideLift,
    LegCircles,
    LegLift,
    LegLiftInExternalRotation,
}
impl fmt::Display for HipRaiseExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            HipRaiseExerciseName::BarbellHipThrustOnFloor => {
                f.write_str("barbell_hip_thrust_on_floor")
            }
            HipRaiseExerciseName::BarbellHipThrustWithBench => {
                f.write_str("barbell_hip_thrust_with_bench")
            }
            HipRaiseExerciseName::BentKneeSwissBallReverseHipRaise => {
                f.write_str("bent_knee_swiss_ball_reverse_hip_raise")
            }
            HipRaiseExerciseName::WeightedBentKneeSwissBallReverseHipRaise => {
                f.write_str("weighted_bent_knee_swiss_ball_reverse_hip_raise")
            }
            HipRaiseExerciseName::BridgeWithLegExtension => {
                f.write_str("bridge_with_leg_extension")
            }
            HipRaiseExerciseName::WeightedBridgeWithLegExtension => {
                f.write_str("weighted_bridge_with_leg_extension")
            }
            HipRaiseExerciseName::ClamBridge => f.write_str("clam_bridge"),
            HipRaiseExerciseName::FrontKickTabletop => f.write_str("front_kick_tabletop"),
            HipRaiseExerciseName::WeightedFrontKickTabletop => {
                f.write_str("weighted_front_kick_tabletop")
            }
            HipRaiseExerciseName::HipExtensionAndCross => f.write_str("hip_extension_and_cross"),
            HipRaiseExerciseName::WeightedHipExtensionAndCross => {
                f.write_str("weighted_hip_extension_and_cross")
            }
            HipRaiseExerciseName::HipRaise => f.write_str("hip_raise"),
            HipRaiseExerciseName::WeightedHipRaise => f.write_str("weighted_hip_raise"),
            HipRaiseExerciseName::HipRaiseWithFeetOnSwissBall => {
                f.write_str("hip_raise_with_feet_on_swiss_ball")
            }
            HipRaiseExerciseName::WeightedHipRaiseWithFeetOnSwissBall => {
                f.write_str("weighted_hip_raise_with_feet_on_swiss_ball")
            }
            HipRaiseExerciseName::HipRaiseWithHeadOnBosuBall => {
                f.write_str("hip_raise_with_head_on_bosu_ball")
            }
            HipRaiseExerciseName::WeightedHipRaiseWithHeadOnBosuBall => {
                f.write_str("weighted_hip_raise_with_head_on_bosu_ball")
            }
            HipRaiseExerciseName::HipRaiseWithHeadOnSwissBall => {
                f.write_str("hip_raise_with_head_on_swiss_ball")
            }
            HipRaiseExerciseName::WeightedHipRaiseWithHeadOnSwissBall => {
                f.write_str("weighted_hip_raise_with_head_on_swiss_ball")
            }
            HipRaiseExerciseName::HipRaiseWithKneeSqueeze => {
                f.write_str("hip_raise_with_knee_squeeze")
            }
            HipRaiseExerciseName::WeightedHipRaiseWithKneeSqueeze => {
                f.write_str("weighted_hip_raise_with_knee_squeeze")
            }
            HipRaiseExerciseName::InclineRearLegExtension => {
                f.write_str("incline_rear_leg_extension")
            }
            HipRaiseExerciseName::WeightedInclineRearLegExtension => {
                f.write_str("weighted_incline_rear_leg_extension")
            }
            HipRaiseExerciseName::KettlebellSwing => f.write_str("kettlebell_swing"),
            HipRaiseExerciseName::MarchingHipRaise => f.write_str("marching_hip_raise"),
            HipRaiseExerciseName::WeightedMarchingHipRaise => {
                f.write_str("weighted_marching_hip_raise")
            }
            HipRaiseExerciseName::MarchingHipRaiseWithFeetOnASwissBall => {
                f.write_str("marching_hip_raise_with_feet_on_a_swiss_ball")
            }
            HipRaiseExerciseName::WeightedMarchingHipRaiseWithFeetOnASwissBall => {
                f.write_str("weighted_marching_hip_raise_with_feet_on_a_swiss_ball")
            }
            HipRaiseExerciseName::ReverseHipRaise => f.write_str("reverse_hip_raise"),
            HipRaiseExerciseName::WeightedReverseHipRaise => {
                f.write_str("weighted_reverse_hip_raise")
            }
            HipRaiseExerciseName::SingleLegHipRaise => f.write_str("single_leg_hip_raise"),
            HipRaiseExerciseName::WeightedSingleLegHipRaise => {
                f.write_str("weighted_single_leg_hip_raise")
            }
            HipRaiseExerciseName::SingleLegHipRaiseWithFootOnBench => {
                f.write_str("single_leg_hip_raise_with_foot_on_bench")
            }
            HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBench => {
                f.write_str("weighted_single_leg_hip_raise_with_foot_on_bench")
            }
            HipRaiseExerciseName::SingleLegHipRaiseWithFootOnBosuBall => {
                f.write_str("single_leg_hip_raise_with_foot_on_bosu_ball")
            }
            HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBosuBall => {
                f.write_str("weighted_single_leg_hip_raise_with_foot_on_bosu_ball")
            }
            HipRaiseExerciseName::SingleLegHipRaiseWithFootOnFoamRoller => {
                f.write_str("single_leg_hip_raise_with_foot_on_foam_roller")
            }
            HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnFoamRoller => {
                f.write_str("weighted_single_leg_hip_raise_with_foot_on_foam_roller")
            }
            HipRaiseExerciseName::SingleLegHipRaiseWithFootOnMedicineBall => {
                f.write_str("single_leg_hip_raise_with_foot_on_medicine_ball")
            }
            HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnMedicineBall => {
                f.write_str("weighted_single_leg_hip_raise_with_foot_on_medicine_ball")
            }
            HipRaiseExerciseName::SingleLegHipRaiseWithHeadOnBosuBall => {
                f.write_str("single_leg_hip_raise_with_head_on_bosu_ball")
            }
            HipRaiseExerciseName::WeightedSingleLegHipRaiseWithHeadOnBosuBall => {
                f.write_str("weighted_single_leg_hip_raise_with_head_on_bosu_ball")
            }
            HipRaiseExerciseName::WeightedClamBridge => f.write_str("weighted_clam_bridge"),
            HipRaiseExerciseName::SingleLegSwissBallHipRaiseAndLegCurl => {
                f.write_str("single_leg_swiss_ball_hip_raise_and_leg_curl")
            }
            HipRaiseExerciseName::Clams => f.write_str("clams"),
            HipRaiseExerciseName::InnerThighCircles => f.write_str("inner_thigh_circles"),
            HipRaiseExerciseName::InnerThighSideLift => f.write_str("inner_thigh_side_lift"),
            HipRaiseExerciseName::LegCircles => f.write_str("leg_circles"),
            HipRaiseExerciseName::LegLift => f.write_str("leg_lift"),
            HipRaiseExerciseName::LegLiftInExternalRotation => {
                f.write_str("leg_lift_in_external_rotation")
            }
        }
    }
}
impl HipRaiseExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            HipRaiseExerciseName::BarbellHipThrustOnFloor => fit::Value::UInt16(0),
            HipRaiseExerciseName::BarbellHipThrustWithBench => fit::Value::UInt16(1),
            HipRaiseExerciseName::BentKneeSwissBallReverseHipRaise => fit::Value::UInt16(2),
            HipRaiseExerciseName::WeightedBentKneeSwissBallReverseHipRaise => fit::Value::UInt16(3),
            HipRaiseExerciseName::BridgeWithLegExtension => fit::Value::UInt16(4),
            HipRaiseExerciseName::WeightedBridgeWithLegExtension => fit::Value::UInt16(5),
            HipRaiseExerciseName::ClamBridge => fit::Value::UInt16(6),
            HipRaiseExerciseName::FrontKickTabletop => fit::Value::UInt16(7),
            HipRaiseExerciseName::WeightedFrontKickTabletop => fit::Value::UInt16(8),
            HipRaiseExerciseName::HipExtensionAndCross => fit::Value::UInt16(9),
            HipRaiseExerciseName::WeightedHipExtensionAndCross => fit::Value::UInt16(10),
            HipRaiseExerciseName::HipRaise => fit::Value::UInt16(11),
            HipRaiseExerciseName::WeightedHipRaise => fit::Value::UInt16(12),
            HipRaiseExerciseName::HipRaiseWithFeetOnSwissBall => fit::Value::UInt16(13),
            HipRaiseExerciseName::WeightedHipRaiseWithFeetOnSwissBall => fit::Value::UInt16(14),
            HipRaiseExerciseName::HipRaiseWithHeadOnBosuBall => fit::Value::UInt16(15),
            HipRaiseExerciseName::WeightedHipRaiseWithHeadOnBosuBall => fit::Value::UInt16(16),
            HipRaiseExerciseName::HipRaiseWithHeadOnSwissBall => fit::Value::UInt16(17),
            HipRaiseExerciseName::WeightedHipRaiseWithHeadOnSwissBall => fit::Value::UInt16(18),
            HipRaiseExerciseName::HipRaiseWithKneeSqueeze => fit::Value::UInt16(19),
            HipRaiseExerciseName::WeightedHipRaiseWithKneeSqueeze => fit::Value::UInt16(20),
            HipRaiseExerciseName::InclineRearLegExtension => fit::Value::UInt16(21),
            HipRaiseExerciseName::WeightedInclineRearLegExtension => fit::Value::UInt16(22),
            HipRaiseExerciseName::KettlebellSwing => fit::Value::UInt16(23),
            HipRaiseExerciseName::MarchingHipRaise => fit::Value::UInt16(24),
            HipRaiseExerciseName::WeightedMarchingHipRaise => fit::Value::UInt16(25),
            HipRaiseExerciseName::MarchingHipRaiseWithFeetOnASwissBall => fit::Value::UInt16(26),
            HipRaiseExerciseName::WeightedMarchingHipRaiseWithFeetOnASwissBall => {
                fit::Value::UInt16(27)
            }
            HipRaiseExerciseName::ReverseHipRaise => fit::Value::UInt16(28),
            HipRaiseExerciseName::WeightedReverseHipRaise => fit::Value::UInt16(29),
            HipRaiseExerciseName::SingleLegHipRaise => fit::Value::UInt16(30),
            HipRaiseExerciseName::WeightedSingleLegHipRaise => fit::Value::UInt16(31),
            HipRaiseExerciseName::SingleLegHipRaiseWithFootOnBench => fit::Value::UInt16(32),
            HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBench => {
                fit::Value::UInt16(33)
            }
            HipRaiseExerciseName::SingleLegHipRaiseWithFootOnBosuBall => fit::Value::UInt16(34),
            HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBosuBall => {
                fit::Value::UInt16(35)
            }
            HipRaiseExerciseName::SingleLegHipRaiseWithFootOnFoamRoller => fit::Value::UInt16(36),
            HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnFoamRoller => {
                fit::Value::UInt16(37)
            }
            HipRaiseExerciseName::SingleLegHipRaiseWithFootOnMedicineBall => fit::Value::UInt16(38),
            HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnMedicineBall => {
                fit::Value::UInt16(39)
            }
            HipRaiseExerciseName::SingleLegHipRaiseWithHeadOnBosuBall => fit::Value::UInt16(40),
            HipRaiseExerciseName::WeightedSingleLegHipRaiseWithHeadOnBosuBall => {
                fit::Value::UInt16(41)
            }
            HipRaiseExerciseName::WeightedClamBridge => fit::Value::UInt16(42),
            HipRaiseExerciseName::SingleLegSwissBallHipRaiseAndLegCurl => fit::Value::UInt16(43),
            HipRaiseExerciseName::Clams => fit::Value::UInt16(44),
            HipRaiseExerciseName::InnerThighCircles => fit::Value::UInt16(45),
            HipRaiseExerciseName::InnerThighSideLift => fit::Value::UInt16(46),
            HipRaiseExerciseName::LegCircles => fit::Value::UInt16(47),
            HipRaiseExerciseName::LegLift => fit::Value::UInt16(48),
            HipRaiseExerciseName::LegLiftInExternalRotation => fit::Value::UInt16(49),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for HipRaiseExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(HipRaiseExerciseName::BarbellHipThrustOnFloor),
            fit::Value::UInt16(1) => Ok(HipRaiseExerciseName::BarbellHipThrustWithBench),
            fit::Value::UInt16(2) => Ok(HipRaiseExerciseName::BentKneeSwissBallReverseHipRaise),
            fit::Value::UInt16(3) => {
                Ok(HipRaiseExerciseName::WeightedBentKneeSwissBallReverseHipRaise)
            }
            fit::Value::UInt16(4) => Ok(HipRaiseExerciseName::BridgeWithLegExtension),
            fit::Value::UInt16(5) => Ok(HipRaiseExerciseName::WeightedBridgeWithLegExtension),
            fit::Value::UInt16(6) => Ok(HipRaiseExerciseName::ClamBridge),
            fit::Value::UInt16(7) => Ok(HipRaiseExerciseName::FrontKickTabletop),
            fit::Value::UInt16(8) => Ok(HipRaiseExerciseName::WeightedFrontKickTabletop),
            fit::Value::UInt16(9) => Ok(HipRaiseExerciseName::HipExtensionAndCross),
            fit::Value::UInt16(10) => Ok(HipRaiseExerciseName::WeightedHipExtensionAndCross),
            fit::Value::UInt16(11) => Ok(HipRaiseExerciseName::HipRaise),
            fit::Value::UInt16(12) => Ok(HipRaiseExerciseName::WeightedHipRaise),
            fit::Value::UInt16(13) => Ok(HipRaiseExerciseName::HipRaiseWithFeetOnSwissBall),
            fit::Value::UInt16(14) => Ok(HipRaiseExerciseName::WeightedHipRaiseWithFeetOnSwissBall),
            fit::Value::UInt16(15) => Ok(HipRaiseExerciseName::HipRaiseWithHeadOnBosuBall),
            fit::Value::UInt16(16) => Ok(HipRaiseExerciseName::WeightedHipRaiseWithHeadOnBosuBall),
            fit::Value::UInt16(17) => Ok(HipRaiseExerciseName::HipRaiseWithHeadOnSwissBall),
            fit::Value::UInt16(18) => Ok(HipRaiseExerciseName::WeightedHipRaiseWithHeadOnSwissBall),
            fit::Value::UInt16(19) => Ok(HipRaiseExerciseName::HipRaiseWithKneeSqueeze),
            fit::Value::UInt16(20) => Ok(HipRaiseExerciseName::WeightedHipRaiseWithKneeSqueeze),
            fit::Value::UInt16(21) => Ok(HipRaiseExerciseName::InclineRearLegExtension),
            fit::Value::UInt16(22) => Ok(HipRaiseExerciseName::WeightedInclineRearLegExtension),
            fit::Value::UInt16(23) => Ok(HipRaiseExerciseName::KettlebellSwing),
            fit::Value::UInt16(24) => Ok(HipRaiseExerciseName::MarchingHipRaise),
            fit::Value::UInt16(25) => Ok(HipRaiseExerciseName::WeightedMarchingHipRaise),
            fit::Value::UInt16(26) => {
                Ok(HipRaiseExerciseName::MarchingHipRaiseWithFeetOnASwissBall)
            }
            fit::Value::UInt16(27) => {
                Ok(HipRaiseExerciseName::WeightedMarchingHipRaiseWithFeetOnASwissBall)
            }
            fit::Value::UInt16(28) => Ok(HipRaiseExerciseName::ReverseHipRaise),
            fit::Value::UInt16(29) => Ok(HipRaiseExerciseName::WeightedReverseHipRaise),
            fit::Value::UInt16(30) => Ok(HipRaiseExerciseName::SingleLegHipRaise),
            fit::Value::UInt16(31) => Ok(HipRaiseExerciseName::WeightedSingleLegHipRaise),
            fit::Value::UInt16(32) => Ok(HipRaiseExerciseName::SingleLegHipRaiseWithFootOnBench),
            fit::Value::UInt16(33) => {
                Ok(HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBench)
            }
            fit::Value::UInt16(34) => Ok(HipRaiseExerciseName::SingleLegHipRaiseWithFootOnBosuBall),
            fit::Value::UInt16(35) => {
                Ok(HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBosuBall)
            }
            fit::Value::UInt16(36) => {
                Ok(HipRaiseExerciseName::SingleLegHipRaiseWithFootOnFoamRoller)
            }
            fit::Value::UInt16(37) => {
                Ok(HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnFoamRoller)
            }
            fit::Value::UInt16(38) => {
                Ok(HipRaiseExerciseName::SingleLegHipRaiseWithFootOnMedicineBall)
            }
            fit::Value::UInt16(39) => {
                Ok(HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnMedicineBall)
            }
            fit::Value::UInt16(40) => Ok(HipRaiseExerciseName::SingleLegHipRaiseWithHeadOnBosuBall),
            fit::Value::UInt16(41) => {
                Ok(HipRaiseExerciseName::WeightedSingleLegHipRaiseWithHeadOnBosuBall)
            }
            fit::Value::UInt16(42) => Ok(HipRaiseExerciseName::WeightedClamBridge),
            fit::Value::UInt16(43) => {
                Ok(HipRaiseExerciseName::SingleLegSwissBallHipRaiseAndLegCurl)
            }
            fit::Value::UInt16(44) => Ok(HipRaiseExerciseName::Clams),
            fit::Value::UInt16(45) => Ok(HipRaiseExerciseName::InnerThighCircles),
            fit::Value::UInt16(46) => Ok(HipRaiseExerciseName::InnerThighSideLift),
            fit::Value::UInt16(47) => Ok(HipRaiseExerciseName::LegCircles),
            fit::Value::UInt16(48) => Ok(HipRaiseExerciseName::LegLift),
            fit::Value::UInt16(49) => Ok(HipRaiseExerciseName::LegLiftInExternalRotation),
            _ => Err("No corresponding HipRaiseExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for HipRaiseExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "barbell_hip_thrust_on_floor" => Ok(HipRaiseExerciseName::BarbellHipThrustOnFloor),
            "barbell_hip_thrust_with_bench" => Ok(HipRaiseExerciseName::BarbellHipThrustWithBench),
            "bent_knee_swiss_ball_reverse_hip_raise" => {
                Ok(HipRaiseExerciseName::BentKneeSwissBallReverseHipRaise)
            }
            "weighted_bent_knee_swiss_ball_reverse_hip_raise" => {
                Ok(HipRaiseExerciseName::WeightedBentKneeSwissBallReverseHipRaise)
            }
            "bridge_with_leg_extension" => Ok(HipRaiseExerciseName::BridgeWithLegExtension),
            "weighted_bridge_with_leg_extension" => {
                Ok(HipRaiseExerciseName::WeightedBridgeWithLegExtension)
            }
            "clam_bridge" => Ok(HipRaiseExerciseName::ClamBridge),
            "front_kick_tabletop" => Ok(HipRaiseExerciseName::FrontKickTabletop),
            "weighted_front_kick_tabletop" => Ok(HipRaiseExerciseName::WeightedFrontKickTabletop),
            "hip_extension_and_cross" => Ok(HipRaiseExerciseName::HipExtensionAndCross),
            "weighted_hip_extension_and_cross" => {
                Ok(HipRaiseExerciseName::WeightedHipExtensionAndCross)
            }
            "hip_raise" => Ok(HipRaiseExerciseName::HipRaise),
            "weighted_hip_raise" => Ok(HipRaiseExerciseName::WeightedHipRaise),
            "hip_raise_with_feet_on_swiss_ball" => {
                Ok(HipRaiseExerciseName::HipRaiseWithFeetOnSwissBall)
            }
            "weighted_hip_raise_with_feet_on_swiss_ball" => {
                Ok(HipRaiseExerciseName::WeightedHipRaiseWithFeetOnSwissBall)
            }
            "hip_raise_with_head_on_bosu_ball" => {
                Ok(HipRaiseExerciseName::HipRaiseWithHeadOnBosuBall)
            }
            "weighted_hip_raise_with_head_on_bosu_ball" => {
                Ok(HipRaiseExerciseName::WeightedHipRaiseWithHeadOnBosuBall)
            }
            "hip_raise_with_head_on_swiss_ball" => {
                Ok(HipRaiseExerciseName::HipRaiseWithHeadOnSwissBall)
            }
            "weighted_hip_raise_with_head_on_swiss_ball" => {
                Ok(HipRaiseExerciseName::WeightedHipRaiseWithHeadOnSwissBall)
            }
            "hip_raise_with_knee_squeeze" => Ok(HipRaiseExerciseName::HipRaiseWithKneeSqueeze),
            "weighted_hip_raise_with_knee_squeeze" => {
                Ok(HipRaiseExerciseName::WeightedHipRaiseWithKneeSqueeze)
            }
            "incline_rear_leg_extension" => Ok(HipRaiseExerciseName::InclineRearLegExtension),
            "weighted_incline_rear_leg_extension" => {
                Ok(HipRaiseExerciseName::WeightedInclineRearLegExtension)
            }
            "kettlebell_swing" => Ok(HipRaiseExerciseName::KettlebellSwing),
            "marching_hip_raise" => Ok(HipRaiseExerciseName::MarchingHipRaise),
            "weighted_marching_hip_raise" => Ok(HipRaiseExerciseName::WeightedMarchingHipRaise),
            "marching_hip_raise_with_feet_on_a_swiss_ball" => {
                Ok(HipRaiseExerciseName::MarchingHipRaiseWithFeetOnASwissBall)
            }
            "weighted_marching_hip_raise_with_feet_on_a_swiss_ball" => {
                Ok(HipRaiseExerciseName::WeightedMarchingHipRaiseWithFeetOnASwissBall)
            }
            "reverse_hip_raise" => Ok(HipRaiseExerciseName::ReverseHipRaise),
            "weighted_reverse_hip_raise" => Ok(HipRaiseExerciseName::WeightedReverseHipRaise),
            "single_leg_hip_raise" => Ok(HipRaiseExerciseName::SingleLegHipRaise),
            "weighted_single_leg_hip_raise" => Ok(HipRaiseExerciseName::WeightedSingleLegHipRaise),
            "single_leg_hip_raise_with_foot_on_bench" => {
                Ok(HipRaiseExerciseName::SingleLegHipRaiseWithFootOnBench)
            }
            "weighted_single_leg_hip_raise_with_foot_on_bench" => {
                Ok(HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBench)
            }
            "single_leg_hip_raise_with_foot_on_bosu_ball" => {
                Ok(HipRaiseExerciseName::SingleLegHipRaiseWithFootOnBosuBall)
            }
            "weighted_single_leg_hip_raise_with_foot_on_bosu_ball" => {
                Ok(HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnBosuBall)
            }
            "single_leg_hip_raise_with_foot_on_foam_roller" => {
                Ok(HipRaiseExerciseName::SingleLegHipRaiseWithFootOnFoamRoller)
            }
            "weighted_single_leg_hip_raise_with_foot_on_foam_roller" => {
                Ok(HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnFoamRoller)
            }
            "single_leg_hip_raise_with_foot_on_medicine_ball" => {
                Ok(HipRaiseExerciseName::SingleLegHipRaiseWithFootOnMedicineBall)
            }
            "weighted_single_leg_hip_raise_with_foot_on_medicine_ball" => {
                Ok(HipRaiseExerciseName::WeightedSingleLegHipRaiseWithFootOnMedicineBall)
            }
            "single_leg_hip_raise_with_head_on_bosu_ball" => {
                Ok(HipRaiseExerciseName::SingleLegHipRaiseWithHeadOnBosuBall)
            }
            "weighted_single_leg_hip_raise_with_head_on_bosu_ball" => {
                Ok(HipRaiseExerciseName::WeightedSingleLegHipRaiseWithHeadOnBosuBall)
            }
            "weighted_clam_bridge" => Ok(HipRaiseExerciseName::WeightedClamBridge),
            "single_leg_swiss_ball_hip_raise_and_leg_curl" => {
                Ok(HipRaiseExerciseName::SingleLegSwissBallHipRaiseAndLegCurl)
            }
            "clams" => Ok(HipRaiseExerciseName::Clams),
            "inner_thigh_circles" => Ok(HipRaiseExerciseName::InnerThighCircles),
            "inner_thigh_side_lift" => Ok(HipRaiseExerciseName::InnerThighSideLift),
            "leg_circles" => Ok(HipRaiseExerciseName::LegCircles),
            "leg_lift" => Ok(HipRaiseExerciseName::LegLift),
            "leg_lift_in_external_rotation" => Ok(HipRaiseExerciseName::LegLiftInExternalRotation),
            _ => Err("No corresponding HipRaiseExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum HipStabilityExerciseName {
    BandSideLyingLegRaise,
    DeadBug,
    WeightedDeadBug,
    ExternalHipRaise,
    WeightedExternalHipRaise,
    FireHydrantKicks,
    WeightedFireHydrantKicks,
    HipCircles,
    WeightedHipCircles,
    InnerThighLift,
    WeightedInnerThighLift,
    LateralWalksWithBandAtAnkles,
    PretzelSideKick,
    WeightedPretzelSideKick,
    ProneHipInternalRotation,
    WeightedProneHipInternalRotation,
    Quadruped,
    QuadrupedHipExtension,
    WeightedQuadrupedHipExtension,
    QuadrupedWithLegLift,
    WeightedQuadrupedWithLegLift,
    SideLyingLegRaise,
    WeightedSideLyingLegRaise,
    SlidingHipAdduction,
    WeightedSlidingHipAdduction,
    StandingAdduction,
    WeightedStandingAdduction,
    StandingCableHipAbduction,
    StandingHipAbduction,
    WeightedStandingHipAbduction,
    StandingRearLegRaise,
    WeightedStandingRearLegRaise,
    SupineHipInternalRotation,
    WeightedSupineHipInternalRotation,
}
impl fmt::Display for HipStabilityExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            HipStabilityExerciseName::BandSideLyingLegRaise => {
                f.write_str("band_side_lying_leg_raise")
            }
            HipStabilityExerciseName::DeadBug => f.write_str("dead_bug"),
            HipStabilityExerciseName::WeightedDeadBug => f.write_str("weighted_dead_bug"),
            HipStabilityExerciseName::ExternalHipRaise => f.write_str("external_hip_raise"),
            HipStabilityExerciseName::WeightedExternalHipRaise => {
                f.write_str("weighted_external_hip_raise")
            }
            HipStabilityExerciseName::FireHydrantKicks => f.write_str("fire_hydrant_kicks"),
            HipStabilityExerciseName::WeightedFireHydrantKicks => {
                f.write_str("weighted_fire_hydrant_kicks")
            }
            HipStabilityExerciseName::HipCircles => f.write_str("hip_circles"),
            HipStabilityExerciseName::WeightedHipCircles => f.write_str("weighted_hip_circles"),
            HipStabilityExerciseName::InnerThighLift => f.write_str("inner_thigh_lift"),
            HipStabilityExerciseName::WeightedInnerThighLift => {
                f.write_str("weighted_inner_thigh_lift")
            }
            HipStabilityExerciseName::LateralWalksWithBandAtAnkles => {
                f.write_str("lateral_walks_with_band_at_ankles")
            }
            HipStabilityExerciseName::PretzelSideKick => f.write_str("pretzel_side_kick"),
            HipStabilityExerciseName::WeightedPretzelSideKick => {
                f.write_str("weighted_pretzel_side_kick")
            }
            HipStabilityExerciseName::ProneHipInternalRotation => {
                f.write_str("prone_hip_internal_rotation")
            }
            HipStabilityExerciseName::WeightedProneHipInternalRotation => {
                f.write_str("weighted_prone_hip_internal_rotation")
            }
            HipStabilityExerciseName::Quadruped => f.write_str("quadruped"),
            HipStabilityExerciseName::QuadrupedHipExtension => {
                f.write_str("quadruped_hip_extension")
            }
            HipStabilityExerciseName::WeightedQuadrupedHipExtension => {
                f.write_str("weighted_quadruped_hip_extension")
            }
            HipStabilityExerciseName::QuadrupedWithLegLift => {
                f.write_str("quadruped_with_leg_lift")
            }
            HipStabilityExerciseName::WeightedQuadrupedWithLegLift => {
                f.write_str("weighted_quadruped_with_leg_lift")
            }
            HipStabilityExerciseName::SideLyingLegRaise => f.write_str("side_lying_leg_raise"),
            HipStabilityExerciseName::WeightedSideLyingLegRaise => {
                f.write_str("weighted_side_lying_leg_raise")
            }
            HipStabilityExerciseName::SlidingHipAdduction => f.write_str("sliding_hip_adduction"),
            HipStabilityExerciseName::WeightedSlidingHipAdduction => {
                f.write_str("weighted_sliding_hip_adduction")
            }
            HipStabilityExerciseName::StandingAdduction => f.write_str("standing_adduction"),
            HipStabilityExerciseName::WeightedStandingAdduction => {
                f.write_str("weighted_standing_adduction")
            }
            HipStabilityExerciseName::StandingCableHipAbduction => {
                f.write_str("standing_cable_hip_abduction")
            }
            HipStabilityExerciseName::StandingHipAbduction => f.write_str("standing_hip_abduction"),
            HipStabilityExerciseName::WeightedStandingHipAbduction => {
                f.write_str("weighted_standing_hip_abduction")
            }
            HipStabilityExerciseName::StandingRearLegRaise => {
                f.write_str("standing_rear_leg_raise")
            }
            HipStabilityExerciseName::WeightedStandingRearLegRaise => {
                f.write_str("weighted_standing_rear_leg_raise")
            }
            HipStabilityExerciseName::SupineHipInternalRotation => {
                f.write_str("supine_hip_internal_rotation")
            }
            HipStabilityExerciseName::WeightedSupineHipInternalRotation => {
                f.write_str("weighted_supine_hip_internal_rotation")
            }
        }
    }
}
impl HipStabilityExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            HipStabilityExerciseName::BandSideLyingLegRaise => fit::Value::UInt16(0),
            HipStabilityExerciseName::DeadBug => fit::Value::UInt16(1),
            HipStabilityExerciseName::WeightedDeadBug => fit::Value::UInt16(2),
            HipStabilityExerciseName::ExternalHipRaise => fit::Value::UInt16(3),
            HipStabilityExerciseName::WeightedExternalHipRaise => fit::Value::UInt16(4),
            HipStabilityExerciseName::FireHydrantKicks => fit::Value::UInt16(5),
            HipStabilityExerciseName::WeightedFireHydrantKicks => fit::Value::UInt16(6),
            HipStabilityExerciseName::HipCircles => fit::Value::UInt16(7),
            HipStabilityExerciseName::WeightedHipCircles => fit::Value::UInt16(8),
            HipStabilityExerciseName::InnerThighLift => fit::Value::UInt16(9),
            HipStabilityExerciseName::WeightedInnerThighLift => fit::Value::UInt16(10),
            HipStabilityExerciseName::LateralWalksWithBandAtAnkles => fit::Value::UInt16(11),
            HipStabilityExerciseName::PretzelSideKick => fit::Value::UInt16(12),
            HipStabilityExerciseName::WeightedPretzelSideKick => fit::Value::UInt16(13),
            HipStabilityExerciseName::ProneHipInternalRotation => fit::Value::UInt16(14),
            HipStabilityExerciseName::WeightedProneHipInternalRotation => fit::Value::UInt16(15),
            HipStabilityExerciseName::Quadruped => fit::Value::UInt16(16),
            HipStabilityExerciseName::QuadrupedHipExtension => fit::Value::UInt16(17),
            HipStabilityExerciseName::WeightedQuadrupedHipExtension => fit::Value::UInt16(18),
            HipStabilityExerciseName::QuadrupedWithLegLift => fit::Value::UInt16(19),
            HipStabilityExerciseName::WeightedQuadrupedWithLegLift => fit::Value::UInt16(20),
            HipStabilityExerciseName::SideLyingLegRaise => fit::Value::UInt16(21),
            HipStabilityExerciseName::WeightedSideLyingLegRaise => fit::Value::UInt16(22),
            HipStabilityExerciseName::SlidingHipAdduction => fit::Value::UInt16(23),
            HipStabilityExerciseName::WeightedSlidingHipAdduction => fit::Value::UInt16(24),
            HipStabilityExerciseName::StandingAdduction => fit::Value::UInt16(25),
            HipStabilityExerciseName::WeightedStandingAdduction => fit::Value::UInt16(26),
            HipStabilityExerciseName::StandingCableHipAbduction => fit::Value::UInt16(27),
            HipStabilityExerciseName::StandingHipAbduction => fit::Value::UInt16(28),
            HipStabilityExerciseName::WeightedStandingHipAbduction => fit::Value::UInt16(29),
            HipStabilityExerciseName::StandingRearLegRaise => fit::Value::UInt16(30),
            HipStabilityExerciseName::WeightedStandingRearLegRaise => fit::Value::UInt16(31),
            HipStabilityExerciseName::SupineHipInternalRotation => fit::Value::UInt16(32),
            HipStabilityExerciseName::WeightedSupineHipInternalRotation => fit::Value::UInt16(33),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for HipStabilityExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(HipStabilityExerciseName::BandSideLyingLegRaise),
            fit::Value::UInt16(1) => Ok(HipStabilityExerciseName::DeadBug),
            fit::Value::UInt16(2) => Ok(HipStabilityExerciseName::WeightedDeadBug),
            fit::Value::UInt16(3) => Ok(HipStabilityExerciseName::ExternalHipRaise),
            fit::Value::UInt16(4) => Ok(HipStabilityExerciseName::WeightedExternalHipRaise),
            fit::Value::UInt16(5) => Ok(HipStabilityExerciseName::FireHydrantKicks),
            fit::Value::UInt16(6) => Ok(HipStabilityExerciseName::WeightedFireHydrantKicks),
            fit::Value::UInt16(7) => Ok(HipStabilityExerciseName::HipCircles),
            fit::Value::UInt16(8) => Ok(HipStabilityExerciseName::WeightedHipCircles),
            fit::Value::UInt16(9) => Ok(HipStabilityExerciseName::InnerThighLift),
            fit::Value::UInt16(10) => Ok(HipStabilityExerciseName::WeightedInnerThighLift),
            fit::Value::UInt16(11) => Ok(HipStabilityExerciseName::LateralWalksWithBandAtAnkles),
            fit::Value::UInt16(12) => Ok(HipStabilityExerciseName::PretzelSideKick),
            fit::Value::UInt16(13) => Ok(HipStabilityExerciseName::WeightedPretzelSideKick),
            fit::Value::UInt16(14) => Ok(HipStabilityExerciseName::ProneHipInternalRotation),
            fit::Value::UInt16(15) => {
                Ok(HipStabilityExerciseName::WeightedProneHipInternalRotation)
            }
            fit::Value::UInt16(16) => Ok(HipStabilityExerciseName::Quadruped),
            fit::Value::UInt16(17) => Ok(HipStabilityExerciseName::QuadrupedHipExtension),
            fit::Value::UInt16(18) => Ok(HipStabilityExerciseName::WeightedQuadrupedHipExtension),
            fit::Value::UInt16(19) => Ok(HipStabilityExerciseName::QuadrupedWithLegLift),
            fit::Value::UInt16(20) => Ok(HipStabilityExerciseName::WeightedQuadrupedWithLegLift),
            fit::Value::UInt16(21) => Ok(HipStabilityExerciseName::SideLyingLegRaise),
            fit::Value::UInt16(22) => Ok(HipStabilityExerciseName::WeightedSideLyingLegRaise),
            fit::Value::UInt16(23) => Ok(HipStabilityExerciseName::SlidingHipAdduction),
            fit::Value::UInt16(24) => Ok(HipStabilityExerciseName::WeightedSlidingHipAdduction),
            fit::Value::UInt16(25) => Ok(HipStabilityExerciseName::StandingAdduction),
            fit::Value::UInt16(26) => Ok(HipStabilityExerciseName::WeightedStandingAdduction),
            fit::Value::UInt16(27) => Ok(HipStabilityExerciseName::StandingCableHipAbduction),
            fit::Value::UInt16(28) => Ok(HipStabilityExerciseName::StandingHipAbduction),
            fit::Value::UInt16(29) => Ok(HipStabilityExerciseName::WeightedStandingHipAbduction),
            fit::Value::UInt16(30) => Ok(HipStabilityExerciseName::StandingRearLegRaise),
            fit::Value::UInt16(31) => Ok(HipStabilityExerciseName::WeightedStandingRearLegRaise),
            fit::Value::UInt16(32) => Ok(HipStabilityExerciseName::SupineHipInternalRotation),
            fit::Value::UInt16(33) => {
                Ok(HipStabilityExerciseName::WeightedSupineHipInternalRotation)
            }
            _ => Err("No corresponding HipStabilityExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for HipStabilityExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "band_side_lying_leg_raise" => Ok(HipStabilityExerciseName::BandSideLyingLegRaise),
            "dead_bug" => Ok(HipStabilityExerciseName::DeadBug),
            "weighted_dead_bug" => Ok(HipStabilityExerciseName::WeightedDeadBug),
            "external_hip_raise" => Ok(HipStabilityExerciseName::ExternalHipRaise),
            "weighted_external_hip_raise" => Ok(HipStabilityExerciseName::WeightedExternalHipRaise),
            "fire_hydrant_kicks" => Ok(HipStabilityExerciseName::FireHydrantKicks),
            "weighted_fire_hydrant_kicks" => Ok(HipStabilityExerciseName::WeightedFireHydrantKicks),
            "hip_circles" => Ok(HipStabilityExerciseName::HipCircles),
            "weighted_hip_circles" => Ok(HipStabilityExerciseName::WeightedHipCircles),
            "inner_thigh_lift" => Ok(HipStabilityExerciseName::InnerThighLift),
            "weighted_inner_thigh_lift" => Ok(HipStabilityExerciseName::WeightedInnerThighLift),
            "lateral_walks_with_band_at_ankles" => {
                Ok(HipStabilityExerciseName::LateralWalksWithBandAtAnkles)
            }
            "pretzel_side_kick" => Ok(HipStabilityExerciseName::PretzelSideKick),
            "weighted_pretzel_side_kick" => Ok(HipStabilityExerciseName::WeightedPretzelSideKick),
            "prone_hip_internal_rotation" => Ok(HipStabilityExerciseName::ProneHipInternalRotation),
            "weighted_prone_hip_internal_rotation" => {
                Ok(HipStabilityExerciseName::WeightedProneHipInternalRotation)
            }
            "quadruped" => Ok(HipStabilityExerciseName::Quadruped),
            "quadruped_hip_extension" => Ok(HipStabilityExerciseName::QuadrupedHipExtension),
            "weighted_quadruped_hip_extension" => {
                Ok(HipStabilityExerciseName::WeightedQuadrupedHipExtension)
            }
            "quadruped_with_leg_lift" => Ok(HipStabilityExerciseName::QuadrupedWithLegLift),
            "weighted_quadruped_with_leg_lift" => {
                Ok(HipStabilityExerciseName::WeightedQuadrupedWithLegLift)
            }
            "side_lying_leg_raise" => Ok(HipStabilityExerciseName::SideLyingLegRaise),
            "weighted_side_lying_leg_raise" => {
                Ok(HipStabilityExerciseName::WeightedSideLyingLegRaise)
            }
            "sliding_hip_adduction" => Ok(HipStabilityExerciseName::SlidingHipAdduction),
            "weighted_sliding_hip_adduction" => {
                Ok(HipStabilityExerciseName::WeightedSlidingHipAdduction)
            }
            "standing_adduction" => Ok(HipStabilityExerciseName::StandingAdduction),
            "weighted_standing_adduction" => {
                Ok(HipStabilityExerciseName::WeightedStandingAdduction)
            }
            "standing_cable_hip_abduction" => {
                Ok(HipStabilityExerciseName::StandingCableHipAbduction)
            }
            "standing_hip_abduction" => Ok(HipStabilityExerciseName::StandingHipAbduction),
            "weighted_standing_hip_abduction" => {
                Ok(HipStabilityExerciseName::WeightedStandingHipAbduction)
            }
            "standing_rear_leg_raise" => Ok(HipStabilityExerciseName::StandingRearLegRaise),
            "weighted_standing_rear_leg_raise" => {
                Ok(HipStabilityExerciseName::WeightedStandingRearLegRaise)
            }
            "supine_hip_internal_rotation" => {
                Ok(HipStabilityExerciseName::SupineHipInternalRotation)
            }
            "weighted_supine_hip_internal_rotation" => {
                Ok(HipStabilityExerciseName::WeightedSupineHipInternalRotation)
            }
            _ => Err("No corresponding HipStabilityExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum HipSwingExerciseName {
    SingleArmKettlebellSwing,
    SingleArmDumbbellSwing,
    StepOutSwing,
}
impl fmt::Display for HipSwingExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            HipSwingExerciseName::SingleArmKettlebellSwing => {
                f.write_str("single_arm_kettlebell_swing")
            }
            HipSwingExerciseName::SingleArmDumbbellSwing => {
                f.write_str("single_arm_dumbbell_swing")
            }
            HipSwingExerciseName::StepOutSwing => f.write_str("step_out_swing"),
        }
    }
}
impl HipSwingExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            HipSwingExerciseName::SingleArmKettlebellSwing => fit::Value::UInt16(0),
            HipSwingExerciseName::SingleArmDumbbellSwing => fit::Value::UInt16(1),
            HipSwingExerciseName::StepOutSwing => fit::Value::UInt16(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for HipSwingExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(HipSwingExerciseName::SingleArmKettlebellSwing),
            fit::Value::UInt16(1) => Ok(HipSwingExerciseName::SingleArmDumbbellSwing),
            fit::Value::UInt16(2) => Ok(HipSwingExerciseName::StepOutSwing),
            _ => Err("No corresponding HipSwingExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for HipSwingExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "single_arm_kettlebell_swing" => Ok(HipSwingExerciseName::SingleArmKettlebellSwing),
            "single_arm_dumbbell_swing" => Ok(HipSwingExerciseName::SingleArmDumbbellSwing),
            "step_out_swing" => Ok(HipSwingExerciseName::StepOutSwing),
            _ => Err("No corresponding HipSwingExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum HyperextensionExerciseName {
    BackExtensionWithOppositeArmAndLegReach,
    WeightedBackExtensionWithOppositeArmAndLegReach,
    BaseRotations,
    WeightedBaseRotations,
    BentKneeReverseHyperextension,
    WeightedBentKneeReverseHyperextension,
    HollowHoldAndRoll,
    WeightedHollowHoldAndRoll,
    Kicks,
    WeightedKicks,
    KneeRaises,
    WeightedKneeRaises,
    KneelingSuperman,
    WeightedKneelingSuperman,
    LatPullDownWithRow,
    MedicineBallDeadliftToReach,
    OneArmOneLegRow,
    OneArmRowWithBand,
    OverheadLungeWithMedicineBall,
    PlankKneeTucks,
    WeightedPlankKneeTucks,
    SideStep,
    WeightedSideStep,
    SingleLegBackExtension,
    WeightedSingleLegBackExtension,
    SpineExtension,
    WeightedSpineExtension,
    StaticBackExtension,
    WeightedStaticBackExtension,
    SupermanFromFloor,
    WeightedSupermanFromFloor,
    SwissBallBackExtension,
    WeightedSwissBallBackExtension,
    SwissBallHyperextension,
    WeightedSwissBallHyperextension,
    SwissBallOppositeArmAndLegLift,
    WeightedSwissBallOppositeArmAndLegLift,
    SupermanOnSwissBall,
    Cobra,
    /// Deprecated do not use
    SupineFloorBarre,
}
impl fmt::Display for HyperextensionExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            HyperextensionExerciseName::BackExtensionWithOppositeArmAndLegReach => {
                f.write_str("back_extension_with_opposite_arm_and_leg_reach")
            }
            HyperextensionExerciseName::WeightedBackExtensionWithOppositeArmAndLegReach => {
                f.write_str("weighted_back_extension_with_opposite_arm_and_leg_reach")
            }
            HyperextensionExerciseName::BaseRotations => f.write_str("base_rotations"),
            HyperextensionExerciseName::WeightedBaseRotations => {
                f.write_str("weighted_base_rotations")
            }
            HyperextensionExerciseName::BentKneeReverseHyperextension => {
                f.write_str("bent_knee_reverse_hyperextension")
            }
            HyperextensionExerciseName::WeightedBentKneeReverseHyperextension => {
                f.write_str("weighted_bent_knee_reverse_hyperextension")
            }
            HyperextensionExerciseName::HollowHoldAndRoll => f.write_str("hollow_hold_and_roll"),
            HyperextensionExerciseName::WeightedHollowHoldAndRoll => {
                f.write_str("weighted_hollow_hold_and_roll")
            }
            HyperextensionExerciseName::Kicks => f.write_str("kicks"),
            HyperextensionExerciseName::WeightedKicks => f.write_str("weighted_kicks"),
            HyperextensionExerciseName::KneeRaises => f.write_str("knee_raises"),
            HyperextensionExerciseName::WeightedKneeRaises => f.write_str("weighted_knee_raises"),
            HyperextensionExerciseName::KneelingSuperman => f.write_str("kneeling_superman"),
            HyperextensionExerciseName::WeightedKneelingSuperman => {
                f.write_str("weighted_kneeling_superman")
            }
            HyperextensionExerciseName::LatPullDownWithRow => f.write_str("lat_pull_down_with_row"),
            HyperextensionExerciseName::MedicineBallDeadliftToReach => {
                f.write_str("medicine_ball_deadlift_to_reach")
            }
            HyperextensionExerciseName::OneArmOneLegRow => f.write_str("one_arm_one_leg_row"),
            HyperextensionExerciseName::OneArmRowWithBand => f.write_str("one_arm_row_with_band"),
            HyperextensionExerciseName::OverheadLungeWithMedicineBall => {
                f.write_str("overhead_lunge_with_medicine_ball")
            }
            HyperextensionExerciseName::PlankKneeTucks => f.write_str("plank_knee_tucks"),
            HyperextensionExerciseName::WeightedPlankKneeTucks => {
                f.write_str("weighted_plank_knee_tucks")
            }
            HyperextensionExerciseName::SideStep => f.write_str("side_step"),
            HyperextensionExerciseName::WeightedSideStep => f.write_str("weighted_side_step"),
            HyperextensionExerciseName::SingleLegBackExtension => {
                f.write_str("single_leg_back_extension")
            }
            HyperextensionExerciseName::WeightedSingleLegBackExtension => {
                f.write_str("weighted_single_leg_back_extension")
            }
            HyperextensionExerciseName::SpineExtension => f.write_str("spine_extension"),
            HyperextensionExerciseName::WeightedSpineExtension => {
                f.write_str("weighted_spine_extension")
            }
            HyperextensionExerciseName::StaticBackExtension => f.write_str("static_back_extension"),
            HyperextensionExerciseName::WeightedStaticBackExtension => {
                f.write_str("weighted_static_back_extension")
            }
            HyperextensionExerciseName::SupermanFromFloor => f.write_str("superman_from_floor"),
            HyperextensionExerciseName::WeightedSupermanFromFloor => {
                f.write_str("weighted_superman_from_floor")
            }
            HyperextensionExerciseName::SwissBallBackExtension => {
                f.write_str("swiss_ball_back_extension")
            }
            HyperextensionExerciseName::WeightedSwissBallBackExtension => {
                f.write_str("weighted_swiss_ball_back_extension")
            }
            HyperextensionExerciseName::SwissBallHyperextension => {
                f.write_str("swiss_ball_hyperextension")
            }
            HyperextensionExerciseName::WeightedSwissBallHyperextension => {
                f.write_str("weighted_swiss_ball_hyperextension")
            }
            HyperextensionExerciseName::SwissBallOppositeArmAndLegLift => {
                f.write_str("swiss_ball_opposite_arm_and_leg_lift")
            }
            HyperextensionExerciseName::WeightedSwissBallOppositeArmAndLegLift => {
                f.write_str("weighted_swiss_ball_opposite_arm_and_leg_lift")
            }
            HyperextensionExerciseName::SupermanOnSwissBall => {
                f.write_str("superman_on_swiss_ball")
            }
            HyperextensionExerciseName::Cobra => f.write_str("cobra"),
            HyperextensionExerciseName::SupineFloorBarre => f.write_str("supine_floor_barre"),
        }
    }
}
impl HyperextensionExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            HyperextensionExerciseName::BackExtensionWithOppositeArmAndLegReach => {
                fit::Value::UInt16(0)
            }
            HyperextensionExerciseName::WeightedBackExtensionWithOppositeArmAndLegReach => {
                fit::Value::UInt16(1)
            }
            HyperextensionExerciseName::BaseRotations => fit::Value::UInt16(2),
            HyperextensionExerciseName::WeightedBaseRotations => fit::Value::UInt16(3),
            HyperextensionExerciseName::BentKneeReverseHyperextension => fit::Value::UInt16(4),
            HyperextensionExerciseName::WeightedBentKneeReverseHyperextension => {
                fit::Value::UInt16(5)
            }
            HyperextensionExerciseName::HollowHoldAndRoll => fit::Value::UInt16(6),
            HyperextensionExerciseName::WeightedHollowHoldAndRoll => fit::Value::UInt16(7),
            HyperextensionExerciseName::Kicks => fit::Value::UInt16(8),
            HyperextensionExerciseName::WeightedKicks => fit::Value::UInt16(9),
            HyperextensionExerciseName::KneeRaises => fit::Value::UInt16(10),
            HyperextensionExerciseName::WeightedKneeRaises => fit::Value::UInt16(11),
            HyperextensionExerciseName::KneelingSuperman => fit::Value::UInt16(12),
            HyperextensionExerciseName::WeightedKneelingSuperman => fit::Value::UInt16(13),
            HyperextensionExerciseName::LatPullDownWithRow => fit::Value::UInt16(14),
            HyperextensionExerciseName::MedicineBallDeadliftToReach => fit::Value::UInt16(15),
            HyperextensionExerciseName::OneArmOneLegRow => fit::Value::UInt16(16),
            HyperextensionExerciseName::OneArmRowWithBand => fit::Value::UInt16(17),
            HyperextensionExerciseName::OverheadLungeWithMedicineBall => fit::Value::UInt16(18),
            HyperextensionExerciseName::PlankKneeTucks => fit::Value::UInt16(19),
            HyperextensionExerciseName::WeightedPlankKneeTucks => fit::Value::UInt16(20),
            HyperextensionExerciseName::SideStep => fit::Value::UInt16(21),
            HyperextensionExerciseName::WeightedSideStep => fit::Value::UInt16(22),
            HyperextensionExerciseName::SingleLegBackExtension => fit::Value::UInt16(23),
            HyperextensionExerciseName::WeightedSingleLegBackExtension => fit::Value::UInt16(24),
            HyperextensionExerciseName::SpineExtension => fit::Value::UInt16(25),
            HyperextensionExerciseName::WeightedSpineExtension => fit::Value::UInt16(26),
            HyperextensionExerciseName::StaticBackExtension => fit::Value::UInt16(27),
            HyperextensionExerciseName::WeightedStaticBackExtension => fit::Value::UInt16(28),
            HyperextensionExerciseName::SupermanFromFloor => fit::Value::UInt16(29),
            HyperextensionExerciseName::WeightedSupermanFromFloor => fit::Value::UInt16(30),
            HyperextensionExerciseName::SwissBallBackExtension => fit::Value::UInt16(31),
            HyperextensionExerciseName::WeightedSwissBallBackExtension => fit::Value::UInt16(32),
            HyperextensionExerciseName::SwissBallHyperextension => fit::Value::UInt16(33),
            HyperextensionExerciseName::WeightedSwissBallHyperextension => fit::Value::UInt16(34),
            HyperextensionExerciseName::SwissBallOppositeArmAndLegLift => fit::Value::UInt16(35),
            HyperextensionExerciseName::WeightedSwissBallOppositeArmAndLegLift => {
                fit::Value::UInt16(36)
            }
            HyperextensionExerciseName::SupermanOnSwissBall => fit::Value::UInt16(37),
            HyperextensionExerciseName::Cobra => fit::Value::UInt16(38),
            HyperextensionExerciseName::SupineFloorBarre => fit::Value::UInt16(39),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for HyperextensionExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => {
                Ok(HyperextensionExerciseName::BackExtensionWithOppositeArmAndLegReach)
            }
            fit::Value::UInt16(1) => {
                Ok(HyperextensionExerciseName::WeightedBackExtensionWithOppositeArmAndLegReach)
            }
            fit::Value::UInt16(2) => Ok(HyperextensionExerciseName::BaseRotations),
            fit::Value::UInt16(3) => Ok(HyperextensionExerciseName::WeightedBaseRotations),
            fit::Value::UInt16(4) => Ok(HyperextensionExerciseName::BentKneeReverseHyperextension),
            fit::Value::UInt16(5) => {
                Ok(HyperextensionExerciseName::WeightedBentKneeReverseHyperextension)
            }
            fit::Value::UInt16(6) => Ok(HyperextensionExerciseName::HollowHoldAndRoll),
            fit::Value::UInt16(7) => Ok(HyperextensionExerciseName::WeightedHollowHoldAndRoll),
            fit::Value::UInt16(8) => Ok(HyperextensionExerciseName::Kicks),
            fit::Value::UInt16(9) => Ok(HyperextensionExerciseName::WeightedKicks),
            fit::Value::UInt16(10) => Ok(HyperextensionExerciseName::KneeRaises),
            fit::Value::UInt16(11) => Ok(HyperextensionExerciseName::WeightedKneeRaises),
            fit::Value::UInt16(12) => Ok(HyperextensionExerciseName::KneelingSuperman),
            fit::Value::UInt16(13) => Ok(HyperextensionExerciseName::WeightedKneelingSuperman),
            fit::Value::UInt16(14) => Ok(HyperextensionExerciseName::LatPullDownWithRow),
            fit::Value::UInt16(15) => Ok(HyperextensionExerciseName::MedicineBallDeadliftToReach),
            fit::Value::UInt16(16) => Ok(HyperextensionExerciseName::OneArmOneLegRow),
            fit::Value::UInt16(17) => Ok(HyperextensionExerciseName::OneArmRowWithBand),
            fit::Value::UInt16(18) => Ok(HyperextensionExerciseName::OverheadLungeWithMedicineBall),
            fit::Value::UInt16(19) => Ok(HyperextensionExerciseName::PlankKneeTucks),
            fit::Value::UInt16(20) => Ok(HyperextensionExerciseName::WeightedPlankKneeTucks),
            fit::Value::UInt16(21) => Ok(HyperextensionExerciseName::SideStep),
            fit::Value::UInt16(22) => Ok(HyperextensionExerciseName::WeightedSideStep),
            fit::Value::UInt16(23) => Ok(HyperextensionExerciseName::SingleLegBackExtension),
            fit::Value::UInt16(24) => {
                Ok(HyperextensionExerciseName::WeightedSingleLegBackExtension)
            }
            fit::Value::UInt16(25) => Ok(HyperextensionExerciseName::SpineExtension),
            fit::Value::UInt16(26) => Ok(HyperextensionExerciseName::WeightedSpineExtension),
            fit::Value::UInt16(27) => Ok(HyperextensionExerciseName::StaticBackExtension),
            fit::Value::UInt16(28) => Ok(HyperextensionExerciseName::WeightedStaticBackExtension),
            fit::Value::UInt16(29) => Ok(HyperextensionExerciseName::SupermanFromFloor),
            fit::Value::UInt16(30) => Ok(HyperextensionExerciseName::WeightedSupermanFromFloor),
            fit::Value::UInt16(31) => Ok(HyperextensionExerciseName::SwissBallBackExtension),
            fit::Value::UInt16(32) => {
                Ok(HyperextensionExerciseName::WeightedSwissBallBackExtension)
            }
            fit::Value::UInt16(33) => Ok(HyperextensionExerciseName::SwissBallHyperextension),
            fit::Value::UInt16(34) => {
                Ok(HyperextensionExerciseName::WeightedSwissBallHyperextension)
            }
            fit::Value::UInt16(35) => {
                Ok(HyperextensionExerciseName::SwissBallOppositeArmAndLegLift)
            }
            fit::Value::UInt16(36) => {
                Ok(HyperextensionExerciseName::WeightedSwissBallOppositeArmAndLegLift)
            }
            fit::Value::UInt16(37) => Ok(HyperextensionExerciseName::SupermanOnSwissBall),
            fit::Value::UInt16(38) => Ok(HyperextensionExerciseName::Cobra),
            fit::Value::UInt16(39) => Ok(HyperextensionExerciseName::SupineFloorBarre),
            _ => Err("No corresponding HyperextensionExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for HyperextensionExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "back_extension_with_opposite_arm_and_leg_reach" => {
                Ok(HyperextensionExerciseName::BackExtensionWithOppositeArmAndLegReach)
            }
            "weighted_back_extension_with_opposite_arm_and_leg_reach" => {
                Ok(HyperextensionExerciseName::WeightedBackExtensionWithOppositeArmAndLegReach)
            }
            "base_rotations" => Ok(HyperextensionExerciseName::BaseRotations),
            "weighted_base_rotations" => Ok(HyperextensionExerciseName::WeightedBaseRotations),
            "bent_knee_reverse_hyperextension" => {
                Ok(HyperextensionExerciseName::BentKneeReverseHyperextension)
            }
            "weighted_bent_knee_reverse_hyperextension" => {
                Ok(HyperextensionExerciseName::WeightedBentKneeReverseHyperextension)
            }
            "hollow_hold_and_roll" => Ok(HyperextensionExerciseName::HollowHoldAndRoll),
            "weighted_hollow_hold_and_roll" => {
                Ok(HyperextensionExerciseName::WeightedHollowHoldAndRoll)
            }
            "kicks" => Ok(HyperextensionExerciseName::Kicks),
            "weighted_kicks" => Ok(HyperextensionExerciseName::WeightedKicks),
            "knee_raises" => Ok(HyperextensionExerciseName::KneeRaises),
            "weighted_knee_raises" => Ok(HyperextensionExerciseName::WeightedKneeRaises),
            "kneeling_superman" => Ok(HyperextensionExerciseName::KneelingSuperman),
            "weighted_kneeling_superman" => {
                Ok(HyperextensionExerciseName::WeightedKneelingSuperman)
            }
            "lat_pull_down_with_row" => Ok(HyperextensionExerciseName::LatPullDownWithRow),
            "medicine_ball_deadlift_to_reach" => {
                Ok(HyperextensionExerciseName::MedicineBallDeadliftToReach)
            }
            "one_arm_one_leg_row" => Ok(HyperextensionExerciseName::OneArmOneLegRow),
            "one_arm_row_with_band" => Ok(HyperextensionExerciseName::OneArmRowWithBand),
            "overhead_lunge_with_medicine_ball" => {
                Ok(HyperextensionExerciseName::OverheadLungeWithMedicineBall)
            }
            "plank_knee_tucks" => Ok(HyperextensionExerciseName::PlankKneeTucks),
            "weighted_plank_knee_tucks" => Ok(HyperextensionExerciseName::WeightedPlankKneeTucks),
            "side_step" => Ok(HyperextensionExerciseName::SideStep),
            "weighted_side_step" => Ok(HyperextensionExerciseName::WeightedSideStep),
            "single_leg_back_extension" => Ok(HyperextensionExerciseName::SingleLegBackExtension),
            "weighted_single_leg_back_extension" => {
                Ok(HyperextensionExerciseName::WeightedSingleLegBackExtension)
            }
            "spine_extension" => Ok(HyperextensionExerciseName::SpineExtension),
            "weighted_spine_extension" => Ok(HyperextensionExerciseName::WeightedSpineExtension),
            "static_back_extension" => Ok(HyperextensionExerciseName::StaticBackExtension),
            "weighted_static_back_extension" => {
                Ok(HyperextensionExerciseName::WeightedStaticBackExtension)
            }
            "superman_from_floor" => Ok(HyperextensionExerciseName::SupermanFromFloor),
            "weighted_superman_from_floor" => {
                Ok(HyperextensionExerciseName::WeightedSupermanFromFloor)
            }
            "swiss_ball_back_extension" => Ok(HyperextensionExerciseName::SwissBallBackExtension),
            "weighted_swiss_ball_back_extension" => {
                Ok(HyperextensionExerciseName::WeightedSwissBallBackExtension)
            }
            "swiss_ball_hyperextension" => Ok(HyperextensionExerciseName::SwissBallHyperextension),
            "weighted_swiss_ball_hyperextension" => {
                Ok(HyperextensionExerciseName::WeightedSwissBallHyperextension)
            }
            "swiss_ball_opposite_arm_and_leg_lift" => {
                Ok(HyperextensionExerciseName::SwissBallOppositeArmAndLegLift)
            }
            "weighted_swiss_ball_opposite_arm_and_leg_lift" => {
                Ok(HyperextensionExerciseName::WeightedSwissBallOppositeArmAndLegLift)
            }
            "superman_on_swiss_ball" => Ok(HyperextensionExerciseName::SupermanOnSwissBall),
            "cobra" => Ok(HyperextensionExerciseName::Cobra),
            "supine_floor_barre" => Ok(HyperextensionExerciseName::SupineFloorBarre),
            _ => Err("No corresponding HyperextensionExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LateralRaiseExerciseName {
    N45DegreeCableExternalRotation,
    AlternatingLateralRaiseWithStaticHold,
    BarMuscleUp,
    BentOverLateralRaise,
    CableDiagonalRaise,
    CableFrontRaise,
    CalorieRow,
    ComboShoulderRaise,
    DumbbellDiagonalRaise,
    DumbbellVRaise,
    FrontRaise,
    LeaningDumbbellLateralRaise,
    LyingDumbbellRaise,
    MuscleUp,
    OneArmCableLateralRaise,
    OverhandGripRearLateralRaise,
    PlateRaises,
    RingDip,
    WeightedRingDip,
    RingMuscleUp,
    WeightedRingMuscleUp,
    RopeClimb,
    WeightedRopeClimb,
    Scaption,
    SeatedLateralRaise,
    SeatedRearLateralRaise,
    SideLyingLateralRaise,
    StandingLift,
    SuspendedRow,
    UnderhandGripRearLateralRaise,
    WallSlide,
    WeightedWallSlide,
    ArmCircles,
    ShavingTheHead,
}
impl fmt::Display for LateralRaiseExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LateralRaiseExerciseName::N45DegreeCableExternalRotation => {
                f.write_str("45_degree_cable_external_rotation")
            }
            LateralRaiseExerciseName::AlternatingLateralRaiseWithStaticHold => {
                f.write_str("alternating_lateral_raise_with_static_hold")
            }
            LateralRaiseExerciseName::BarMuscleUp => f.write_str("bar_muscle_up"),
            LateralRaiseExerciseName::BentOverLateralRaise => {
                f.write_str("bent_over_lateral_raise")
            }
            LateralRaiseExerciseName::CableDiagonalRaise => f.write_str("cable_diagonal_raise"),
            LateralRaiseExerciseName::CableFrontRaise => f.write_str("cable_front_raise"),
            LateralRaiseExerciseName::CalorieRow => f.write_str("calorie_row"),
            LateralRaiseExerciseName::ComboShoulderRaise => f.write_str("combo_shoulder_raise"),
            LateralRaiseExerciseName::DumbbellDiagonalRaise => {
                f.write_str("dumbbell_diagonal_raise")
            }
            LateralRaiseExerciseName::DumbbellVRaise => f.write_str("dumbbell_v_raise"),
            LateralRaiseExerciseName::FrontRaise => f.write_str("front_raise"),
            LateralRaiseExerciseName::LeaningDumbbellLateralRaise => {
                f.write_str("leaning_dumbbell_lateral_raise")
            }
            LateralRaiseExerciseName::LyingDumbbellRaise => f.write_str("lying_dumbbell_raise"),
            LateralRaiseExerciseName::MuscleUp => f.write_str("muscle_up"),
            LateralRaiseExerciseName::OneArmCableLateralRaise => {
                f.write_str("one_arm_cable_lateral_raise")
            }
            LateralRaiseExerciseName::OverhandGripRearLateralRaise => {
                f.write_str("overhand_grip_rear_lateral_raise")
            }
            LateralRaiseExerciseName::PlateRaises => f.write_str("plate_raises"),
            LateralRaiseExerciseName::RingDip => f.write_str("ring_dip"),
            LateralRaiseExerciseName::WeightedRingDip => f.write_str("weighted_ring_dip"),
            LateralRaiseExerciseName::RingMuscleUp => f.write_str("ring_muscle_up"),
            LateralRaiseExerciseName::WeightedRingMuscleUp => {
                f.write_str("weighted_ring_muscle_up")
            }
            LateralRaiseExerciseName::RopeClimb => f.write_str("rope_climb"),
            LateralRaiseExerciseName::WeightedRopeClimb => f.write_str("weighted_rope_climb"),
            LateralRaiseExerciseName::Scaption => f.write_str("scaption"),
            LateralRaiseExerciseName::SeatedLateralRaise => f.write_str("seated_lateral_raise"),
            LateralRaiseExerciseName::SeatedRearLateralRaise => {
                f.write_str("seated_rear_lateral_raise")
            }
            LateralRaiseExerciseName::SideLyingLateralRaise => {
                f.write_str("side_lying_lateral_raise")
            }
            LateralRaiseExerciseName::StandingLift => f.write_str("standing_lift"),
            LateralRaiseExerciseName::SuspendedRow => f.write_str("suspended_row"),
            LateralRaiseExerciseName::UnderhandGripRearLateralRaise => {
                f.write_str("underhand_grip_rear_lateral_raise")
            }
            LateralRaiseExerciseName::WallSlide => f.write_str("wall_slide"),
            LateralRaiseExerciseName::WeightedWallSlide => f.write_str("weighted_wall_slide"),
            LateralRaiseExerciseName::ArmCircles => f.write_str("arm_circles"),
            LateralRaiseExerciseName::ShavingTheHead => f.write_str("shaving_the_head"),
        }
    }
}
impl LateralRaiseExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LateralRaiseExerciseName::N45DegreeCableExternalRotation => fit::Value::UInt16(0),
            LateralRaiseExerciseName::AlternatingLateralRaiseWithStaticHold => {
                fit::Value::UInt16(1)
            }
            LateralRaiseExerciseName::BarMuscleUp => fit::Value::UInt16(2),
            LateralRaiseExerciseName::BentOverLateralRaise => fit::Value::UInt16(3),
            LateralRaiseExerciseName::CableDiagonalRaise => fit::Value::UInt16(4),
            LateralRaiseExerciseName::CableFrontRaise => fit::Value::UInt16(5),
            LateralRaiseExerciseName::CalorieRow => fit::Value::UInt16(6),
            LateralRaiseExerciseName::ComboShoulderRaise => fit::Value::UInt16(7),
            LateralRaiseExerciseName::DumbbellDiagonalRaise => fit::Value::UInt16(8),
            LateralRaiseExerciseName::DumbbellVRaise => fit::Value::UInt16(9),
            LateralRaiseExerciseName::FrontRaise => fit::Value::UInt16(10),
            LateralRaiseExerciseName::LeaningDumbbellLateralRaise => fit::Value::UInt16(11),
            LateralRaiseExerciseName::LyingDumbbellRaise => fit::Value::UInt16(12),
            LateralRaiseExerciseName::MuscleUp => fit::Value::UInt16(13),
            LateralRaiseExerciseName::OneArmCableLateralRaise => fit::Value::UInt16(14),
            LateralRaiseExerciseName::OverhandGripRearLateralRaise => fit::Value::UInt16(15),
            LateralRaiseExerciseName::PlateRaises => fit::Value::UInt16(16),
            LateralRaiseExerciseName::RingDip => fit::Value::UInt16(17),
            LateralRaiseExerciseName::WeightedRingDip => fit::Value::UInt16(18),
            LateralRaiseExerciseName::RingMuscleUp => fit::Value::UInt16(19),
            LateralRaiseExerciseName::WeightedRingMuscleUp => fit::Value::UInt16(20),
            LateralRaiseExerciseName::RopeClimb => fit::Value::UInt16(21),
            LateralRaiseExerciseName::WeightedRopeClimb => fit::Value::UInt16(22),
            LateralRaiseExerciseName::Scaption => fit::Value::UInt16(23),
            LateralRaiseExerciseName::SeatedLateralRaise => fit::Value::UInt16(24),
            LateralRaiseExerciseName::SeatedRearLateralRaise => fit::Value::UInt16(25),
            LateralRaiseExerciseName::SideLyingLateralRaise => fit::Value::UInt16(26),
            LateralRaiseExerciseName::StandingLift => fit::Value::UInt16(27),
            LateralRaiseExerciseName::SuspendedRow => fit::Value::UInt16(28),
            LateralRaiseExerciseName::UnderhandGripRearLateralRaise => fit::Value::UInt16(29),
            LateralRaiseExerciseName::WallSlide => fit::Value::UInt16(30),
            LateralRaiseExerciseName::WeightedWallSlide => fit::Value::UInt16(31),
            LateralRaiseExerciseName::ArmCircles => fit::Value::UInt16(32),
            LateralRaiseExerciseName::ShavingTheHead => fit::Value::UInt16(33),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for LateralRaiseExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(LateralRaiseExerciseName::N45DegreeCableExternalRotation),
            fit::Value::UInt16(1) => {
                Ok(LateralRaiseExerciseName::AlternatingLateralRaiseWithStaticHold)
            }
            fit::Value::UInt16(2) => Ok(LateralRaiseExerciseName::BarMuscleUp),
            fit::Value::UInt16(3) => Ok(LateralRaiseExerciseName::BentOverLateralRaise),
            fit::Value::UInt16(4) => Ok(LateralRaiseExerciseName::CableDiagonalRaise),
            fit::Value::UInt16(5) => Ok(LateralRaiseExerciseName::CableFrontRaise),
            fit::Value::UInt16(6) => Ok(LateralRaiseExerciseName::CalorieRow),
            fit::Value::UInt16(7) => Ok(LateralRaiseExerciseName::ComboShoulderRaise),
            fit::Value::UInt16(8) => Ok(LateralRaiseExerciseName::DumbbellDiagonalRaise),
            fit::Value::UInt16(9) => Ok(LateralRaiseExerciseName::DumbbellVRaise),
            fit::Value::UInt16(10) => Ok(LateralRaiseExerciseName::FrontRaise),
            fit::Value::UInt16(11) => Ok(LateralRaiseExerciseName::LeaningDumbbellLateralRaise),
            fit::Value::UInt16(12) => Ok(LateralRaiseExerciseName::LyingDumbbellRaise),
            fit::Value::UInt16(13) => Ok(LateralRaiseExerciseName::MuscleUp),
            fit::Value::UInt16(14) => Ok(LateralRaiseExerciseName::OneArmCableLateralRaise),
            fit::Value::UInt16(15) => Ok(LateralRaiseExerciseName::OverhandGripRearLateralRaise),
            fit::Value::UInt16(16) => Ok(LateralRaiseExerciseName::PlateRaises),
            fit::Value::UInt16(17) => Ok(LateralRaiseExerciseName::RingDip),
            fit::Value::UInt16(18) => Ok(LateralRaiseExerciseName::WeightedRingDip),
            fit::Value::UInt16(19) => Ok(LateralRaiseExerciseName::RingMuscleUp),
            fit::Value::UInt16(20) => Ok(LateralRaiseExerciseName::WeightedRingMuscleUp),
            fit::Value::UInt16(21) => Ok(LateralRaiseExerciseName::RopeClimb),
            fit::Value::UInt16(22) => Ok(LateralRaiseExerciseName::WeightedRopeClimb),
            fit::Value::UInt16(23) => Ok(LateralRaiseExerciseName::Scaption),
            fit::Value::UInt16(24) => Ok(LateralRaiseExerciseName::SeatedLateralRaise),
            fit::Value::UInt16(25) => Ok(LateralRaiseExerciseName::SeatedRearLateralRaise),
            fit::Value::UInt16(26) => Ok(LateralRaiseExerciseName::SideLyingLateralRaise),
            fit::Value::UInt16(27) => Ok(LateralRaiseExerciseName::StandingLift),
            fit::Value::UInt16(28) => Ok(LateralRaiseExerciseName::SuspendedRow),
            fit::Value::UInt16(29) => Ok(LateralRaiseExerciseName::UnderhandGripRearLateralRaise),
            fit::Value::UInt16(30) => Ok(LateralRaiseExerciseName::WallSlide),
            fit::Value::UInt16(31) => Ok(LateralRaiseExerciseName::WeightedWallSlide),
            fit::Value::UInt16(32) => Ok(LateralRaiseExerciseName::ArmCircles),
            fit::Value::UInt16(33) => Ok(LateralRaiseExerciseName::ShavingTheHead),
            _ => Err("No corresponding LateralRaiseExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for LateralRaiseExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "45_degree_cable_external_rotation" => {
                Ok(LateralRaiseExerciseName::N45DegreeCableExternalRotation)
            }
            "alternating_lateral_raise_with_static_hold" => {
                Ok(LateralRaiseExerciseName::AlternatingLateralRaiseWithStaticHold)
            }
            "bar_muscle_up" => Ok(LateralRaiseExerciseName::BarMuscleUp),
            "bent_over_lateral_raise" => Ok(LateralRaiseExerciseName::BentOverLateralRaise),
            "cable_diagonal_raise" => Ok(LateralRaiseExerciseName::CableDiagonalRaise),
            "cable_front_raise" => Ok(LateralRaiseExerciseName::CableFrontRaise),
            "calorie_row" => Ok(LateralRaiseExerciseName::CalorieRow),
            "combo_shoulder_raise" => Ok(LateralRaiseExerciseName::ComboShoulderRaise),
            "dumbbell_diagonal_raise" => Ok(LateralRaiseExerciseName::DumbbellDiagonalRaise),
            "dumbbell_v_raise" => Ok(LateralRaiseExerciseName::DumbbellVRaise),
            "front_raise" => Ok(LateralRaiseExerciseName::FrontRaise),
            "leaning_dumbbell_lateral_raise" => {
                Ok(LateralRaiseExerciseName::LeaningDumbbellLateralRaise)
            }
            "lying_dumbbell_raise" => Ok(LateralRaiseExerciseName::LyingDumbbellRaise),
            "muscle_up" => Ok(LateralRaiseExerciseName::MuscleUp),
            "one_arm_cable_lateral_raise" => Ok(LateralRaiseExerciseName::OneArmCableLateralRaise),
            "overhand_grip_rear_lateral_raise" => {
                Ok(LateralRaiseExerciseName::OverhandGripRearLateralRaise)
            }
            "plate_raises" => Ok(LateralRaiseExerciseName::PlateRaises),
            "ring_dip" => Ok(LateralRaiseExerciseName::RingDip),
            "weighted_ring_dip" => Ok(LateralRaiseExerciseName::WeightedRingDip),
            "ring_muscle_up" => Ok(LateralRaiseExerciseName::RingMuscleUp),
            "weighted_ring_muscle_up" => Ok(LateralRaiseExerciseName::WeightedRingMuscleUp),
            "rope_climb" => Ok(LateralRaiseExerciseName::RopeClimb),
            "weighted_rope_climb" => Ok(LateralRaiseExerciseName::WeightedRopeClimb),
            "scaption" => Ok(LateralRaiseExerciseName::Scaption),
            "seated_lateral_raise" => Ok(LateralRaiseExerciseName::SeatedLateralRaise),
            "seated_rear_lateral_raise" => Ok(LateralRaiseExerciseName::SeatedRearLateralRaise),
            "side_lying_lateral_raise" => Ok(LateralRaiseExerciseName::SideLyingLateralRaise),
            "standing_lift" => Ok(LateralRaiseExerciseName::StandingLift),
            "suspended_row" => Ok(LateralRaiseExerciseName::SuspendedRow),
            "underhand_grip_rear_lateral_raise" => {
                Ok(LateralRaiseExerciseName::UnderhandGripRearLateralRaise)
            }
            "wall_slide" => Ok(LateralRaiseExerciseName::WallSlide),
            "weighted_wall_slide" => Ok(LateralRaiseExerciseName::WeightedWallSlide),
            "arm_circles" => Ok(LateralRaiseExerciseName::ArmCircles),
            "shaving_the_head" => Ok(LateralRaiseExerciseName::ShavingTheHead),
            _ => Err("No corresponding LateralRaiseExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LegCurlExerciseName {
    LegCurl,
    WeightedLegCurl,
    GoodMorning,
    SeatedBarbellGoodMorning,
    SingleLegBarbellGoodMorning,
    SingleLegSlidingLegCurl,
    SlidingLegCurl,
    SplitBarbellGoodMorning,
    SplitStanceExtension,
    StaggeredStanceGoodMorning,
    SwissBallHipRaiseAndLegCurl,
    ZercherGoodMorning,
}
impl fmt::Display for LegCurlExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LegCurlExerciseName::LegCurl => f.write_str("leg_curl"),
            LegCurlExerciseName::WeightedLegCurl => f.write_str("weighted_leg_curl"),
            LegCurlExerciseName::GoodMorning => f.write_str("good_morning"),
            LegCurlExerciseName::SeatedBarbellGoodMorning => {
                f.write_str("seated_barbell_good_morning")
            }
            LegCurlExerciseName::SingleLegBarbellGoodMorning => {
                f.write_str("single_leg_barbell_good_morning")
            }
            LegCurlExerciseName::SingleLegSlidingLegCurl => {
                f.write_str("single_leg_sliding_leg_curl")
            }
            LegCurlExerciseName::SlidingLegCurl => f.write_str("sliding_leg_curl"),
            LegCurlExerciseName::SplitBarbellGoodMorning => {
                f.write_str("split_barbell_good_morning")
            }
            LegCurlExerciseName::SplitStanceExtension => f.write_str("split_stance_extension"),
            LegCurlExerciseName::StaggeredStanceGoodMorning => {
                f.write_str("staggered_stance_good_morning")
            }
            LegCurlExerciseName::SwissBallHipRaiseAndLegCurl => {
                f.write_str("swiss_ball_hip_raise_and_leg_curl")
            }
            LegCurlExerciseName::ZercherGoodMorning => f.write_str("zercher_good_morning"),
        }
    }
}
impl LegCurlExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LegCurlExerciseName::LegCurl => fit::Value::UInt16(0),
            LegCurlExerciseName::WeightedLegCurl => fit::Value::UInt16(1),
            LegCurlExerciseName::GoodMorning => fit::Value::UInt16(2),
            LegCurlExerciseName::SeatedBarbellGoodMorning => fit::Value::UInt16(3),
            LegCurlExerciseName::SingleLegBarbellGoodMorning => fit::Value::UInt16(4),
            LegCurlExerciseName::SingleLegSlidingLegCurl => fit::Value::UInt16(5),
            LegCurlExerciseName::SlidingLegCurl => fit::Value::UInt16(6),
            LegCurlExerciseName::SplitBarbellGoodMorning => fit::Value::UInt16(7),
            LegCurlExerciseName::SplitStanceExtension => fit::Value::UInt16(8),
            LegCurlExerciseName::StaggeredStanceGoodMorning => fit::Value::UInt16(9),
            LegCurlExerciseName::SwissBallHipRaiseAndLegCurl => fit::Value::UInt16(10),
            LegCurlExerciseName::ZercherGoodMorning => fit::Value::UInt16(11),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for LegCurlExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(LegCurlExerciseName::LegCurl),
            fit::Value::UInt16(1) => Ok(LegCurlExerciseName::WeightedLegCurl),
            fit::Value::UInt16(2) => Ok(LegCurlExerciseName::GoodMorning),
            fit::Value::UInt16(3) => Ok(LegCurlExerciseName::SeatedBarbellGoodMorning),
            fit::Value::UInt16(4) => Ok(LegCurlExerciseName::SingleLegBarbellGoodMorning),
            fit::Value::UInt16(5) => Ok(LegCurlExerciseName::SingleLegSlidingLegCurl),
            fit::Value::UInt16(6) => Ok(LegCurlExerciseName::SlidingLegCurl),
            fit::Value::UInt16(7) => Ok(LegCurlExerciseName::SplitBarbellGoodMorning),
            fit::Value::UInt16(8) => Ok(LegCurlExerciseName::SplitStanceExtension),
            fit::Value::UInt16(9) => Ok(LegCurlExerciseName::StaggeredStanceGoodMorning),
            fit::Value::UInt16(10) => Ok(LegCurlExerciseName::SwissBallHipRaiseAndLegCurl),
            fit::Value::UInt16(11) => Ok(LegCurlExerciseName::ZercherGoodMorning),
            _ => Err("No corresponding LegCurlExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for LegCurlExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "leg_curl" => Ok(LegCurlExerciseName::LegCurl),
            "weighted_leg_curl" => Ok(LegCurlExerciseName::WeightedLegCurl),
            "good_morning" => Ok(LegCurlExerciseName::GoodMorning),
            "seated_barbell_good_morning" => Ok(LegCurlExerciseName::SeatedBarbellGoodMorning),
            "single_leg_barbell_good_morning" => {
                Ok(LegCurlExerciseName::SingleLegBarbellGoodMorning)
            }
            "single_leg_sliding_leg_curl" => Ok(LegCurlExerciseName::SingleLegSlidingLegCurl),
            "sliding_leg_curl" => Ok(LegCurlExerciseName::SlidingLegCurl),
            "split_barbell_good_morning" => Ok(LegCurlExerciseName::SplitBarbellGoodMorning),
            "split_stance_extension" => Ok(LegCurlExerciseName::SplitStanceExtension),
            "staggered_stance_good_morning" => Ok(LegCurlExerciseName::StaggeredStanceGoodMorning),
            "swiss_ball_hip_raise_and_leg_curl" => {
                Ok(LegCurlExerciseName::SwissBallHipRaiseAndLegCurl)
            }
            "zercher_good_morning" => Ok(LegCurlExerciseName::ZercherGoodMorning),
            _ => Err("No corresponding LegCurlExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LegRaiseExerciseName {
    HangingKneeRaise,
    HangingLegRaise,
    WeightedHangingLegRaise,
    HangingSingleLegRaise,
    WeightedHangingSingleLegRaise,
    KettlebellLegRaises,
    LegLoweringDrill,
    WeightedLegLoweringDrill,
    LyingStraightLegRaise,
    WeightedLyingStraightLegRaise,
    MedicineBallLegDrops,
    QuadrupedLegRaise,
    WeightedQuadrupedLegRaise,
    ReverseLegRaise,
    WeightedReverseLegRaise,
    ReverseLegRaiseOnSwissBall,
    WeightedReverseLegRaiseOnSwissBall,
    SingleLegLoweringDrill,
    WeightedSingleLegLoweringDrill,
    WeightedHangingKneeRaise,
    LateralStepover,
    WeightedLateralStepover,
}
impl fmt::Display for LegRaiseExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LegRaiseExerciseName::HangingKneeRaise => f.write_str("hanging_knee_raise"),
            LegRaiseExerciseName::HangingLegRaise => f.write_str("hanging_leg_raise"),
            LegRaiseExerciseName::WeightedHangingLegRaise => {
                f.write_str("weighted_hanging_leg_raise")
            }
            LegRaiseExerciseName::HangingSingleLegRaise => f.write_str("hanging_single_leg_raise"),
            LegRaiseExerciseName::WeightedHangingSingleLegRaise => {
                f.write_str("weighted_hanging_single_leg_raise")
            }
            LegRaiseExerciseName::KettlebellLegRaises => f.write_str("kettlebell_leg_raises"),
            LegRaiseExerciseName::LegLoweringDrill => f.write_str("leg_lowering_drill"),
            LegRaiseExerciseName::WeightedLegLoweringDrill => {
                f.write_str("weighted_leg_lowering_drill")
            }
            LegRaiseExerciseName::LyingStraightLegRaise => f.write_str("lying_straight_leg_raise"),
            LegRaiseExerciseName::WeightedLyingStraightLegRaise => {
                f.write_str("weighted_lying_straight_leg_raise")
            }
            LegRaiseExerciseName::MedicineBallLegDrops => f.write_str("medicine_ball_leg_drops"),
            LegRaiseExerciseName::QuadrupedLegRaise => f.write_str("quadruped_leg_raise"),
            LegRaiseExerciseName::WeightedQuadrupedLegRaise => {
                f.write_str("weighted_quadruped_leg_raise")
            }
            LegRaiseExerciseName::ReverseLegRaise => f.write_str("reverse_leg_raise"),
            LegRaiseExerciseName::WeightedReverseLegRaise => {
                f.write_str("weighted_reverse_leg_raise")
            }
            LegRaiseExerciseName::ReverseLegRaiseOnSwissBall => {
                f.write_str("reverse_leg_raise_on_swiss_ball")
            }
            LegRaiseExerciseName::WeightedReverseLegRaiseOnSwissBall => {
                f.write_str("weighted_reverse_leg_raise_on_swiss_ball")
            }
            LegRaiseExerciseName::SingleLegLoweringDrill => {
                f.write_str("single_leg_lowering_drill")
            }
            LegRaiseExerciseName::WeightedSingleLegLoweringDrill => {
                f.write_str("weighted_single_leg_lowering_drill")
            }
            LegRaiseExerciseName::WeightedHangingKneeRaise => {
                f.write_str("weighted_hanging_knee_raise")
            }
            LegRaiseExerciseName::LateralStepover => f.write_str("lateral_stepover"),
            LegRaiseExerciseName::WeightedLateralStepover => {
                f.write_str("weighted_lateral_stepover")
            }
        }
    }
}
impl LegRaiseExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LegRaiseExerciseName::HangingKneeRaise => fit::Value::UInt16(0),
            LegRaiseExerciseName::HangingLegRaise => fit::Value::UInt16(1),
            LegRaiseExerciseName::WeightedHangingLegRaise => fit::Value::UInt16(2),
            LegRaiseExerciseName::HangingSingleLegRaise => fit::Value::UInt16(3),
            LegRaiseExerciseName::WeightedHangingSingleLegRaise => fit::Value::UInt16(4),
            LegRaiseExerciseName::KettlebellLegRaises => fit::Value::UInt16(5),
            LegRaiseExerciseName::LegLoweringDrill => fit::Value::UInt16(6),
            LegRaiseExerciseName::WeightedLegLoweringDrill => fit::Value::UInt16(7),
            LegRaiseExerciseName::LyingStraightLegRaise => fit::Value::UInt16(8),
            LegRaiseExerciseName::WeightedLyingStraightLegRaise => fit::Value::UInt16(9),
            LegRaiseExerciseName::MedicineBallLegDrops => fit::Value::UInt16(10),
            LegRaiseExerciseName::QuadrupedLegRaise => fit::Value::UInt16(11),
            LegRaiseExerciseName::WeightedQuadrupedLegRaise => fit::Value::UInt16(12),
            LegRaiseExerciseName::ReverseLegRaise => fit::Value::UInt16(13),
            LegRaiseExerciseName::WeightedReverseLegRaise => fit::Value::UInt16(14),
            LegRaiseExerciseName::ReverseLegRaiseOnSwissBall => fit::Value::UInt16(15),
            LegRaiseExerciseName::WeightedReverseLegRaiseOnSwissBall => fit::Value::UInt16(16),
            LegRaiseExerciseName::SingleLegLoweringDrill => fit::Value::UInt16(17),
            LegRaiseExerciseName::WeightedSingleLegLoweringDrill => fit::Value::UInt16(18),
            LegRaiseExerciseName::WeightedHangingKneeRaise => fit::Value::UInt16(19),
            LegRaiseExerciseName::LateralStepover => fit::Value::UInt16(20),
            LegRaiseExerciseName::WeightedLateralStepover => fit::Value::UInt16(21),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for LegRaiseExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(LegRaiseExerciseName::HangingKneeRaise),
            fit::Value::UInt16(1) => Ok(LegRaiseExerciseName::HangingLegRaise),
            fit::Value::UInt16(2) => Ok(LegRaiseExerciseName::WeightedHangingLegRaise),
            fit::Value::UInt16(3) => Ok(LegRaiseExerciseName::HangingSingleLegRaise),
            fit::Value::UInt16(4) => Ok(LegRaiseExerciseName::WeightedHangingSingleLegRaise),
            fit::Value::UInt16(5) => Ok(LegRaiseExerciseName::KettlebellLegRaises),
            fit::Value::UInt16(6) => Ok(LegRaiseExerciseName::LegLoweringDrill),
            fit::Value::UInt16(7) => Ok(LegRaiseExerciseName::WeightedLegLoweringDrill),
            fit::Value::UInt16(8) => Ok(LegRaiseExerciseName::LyingStraightLegRaise),
            fit::Value::UInt16(9) => Ok(LegRaiseExerciseName::WeightedLyingStraightLegRaise),
            fit::Value::UInt16(10) => Ok(LegRaiseExerciseName::MedicineBallLegDrops),
            fit::Value::UInt16(11) => Ok(LegRaiseExerciseName::QuadrupedLegRaise),
            fit::Value::UInt16(12) => Ok(LegRaiseExerciseName::WeightedQuadrupedLegRaise),
            fit::Value::UInt16(13) => Ok(LegRaiseExerciseName::ReverseLegRaise),
            fit::Value::UInt16(14) => Ok(LegRaiseExerciseName::WeightedReverseLegRaise),
            fit::Value::UInt16(15) => Ok(LegRaiseExerciseName::ReverseLegRaiseOnSwissBall),
            fit::Value::UInt16(16) => Ok(LegRaiseExerciseName::WeightedReverseLegRaiseOnSwissBall),
            fit::Value::UInt16(17) => Ok(LegRaiseExerciseName::SingleLegLoweringDrill),
            fit::Value::UInt16(18) => Ok(LegRaiseExerciseName::WeightedSingleLegLoweringDrill),
            fit::Value::UInt16(19) => Ok(LegRaiseExerciseName::WeightedHangingKneeRaise),
            fit::Value::UInt16(20) => Ok(LegRaiseExerciseName::LateralStepover),
            fit::Value::UInt16(21) => Ok(LegRaiseExerciseName::WeightedLateralStepover),
            _ => Err("No corresponding LegRaiseExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for LegRaiseExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "hanging_knee_raise" => Ok(LegRaiseExerciseName::HangingKneeRaise),
            "hanging_leg_raise" => Ok(LegRaiseExerciseName::HangingLegRaise),
            "weighted_hanging_leg_raise" => Ok(LegRaiseExerciseName::WeightedHangingLegRaise),
            "hanging_single_leg_raise" => Ok(LegRaiseExerciseName::HangingSingleLegRaise),
            "weighted_hanging_single_leg_raise" => {
                Ok(LegRaiseExerciseName::WeightedHangingSingleLegRaise)
            }
            "kettlebell_leg_raises" => Ok(LegRaiseExerciseName::KettlebellLegRaises),
            "leg_lowering_drill" => Ok(LegRaiseExerciseName::LegLoweringDrill),
            "weighted_leg_lowering_drill" => Ok(LegRaiseExerciseName::WeightedLegLoweringDrill),
            "lying_straight_leg_raise" => Ok(LegRaiseExerciseName::LyingStraightLegRaise),
            "weighted_lying_straight_leg_raise" => {
                Ok(LegRaiseExerciseName::WeightedLyingStraightLegRaise)
            }
            "medicine_ball_leg_drops" => Ok(LegRaiseExerciseName::MedicineBallLegDrops),
            "quadruped_leg_raise" => Ok(LegRaiseExerciseName::QuadrupedLegRaise),
            "weighted_quadruped_leg_raise" => Ok(LegRaiseExerciseName::WeightedQuadrupedLegRaise),
            "reverse_leg_raise" => Ok(LegRaiseExerciseName::ReverseLegRaise),
            "weighted_reverse_leg_raise" => Ok(LegRaiseExerciseName::WeightedReverseLegRaise),
            "reverse_leg_raise_on_swiss_ball" => {
                Ok(LegRaiseExerciseName::ReverseLegRaiseOnSwissBall)
            }
            "weighted_reverse_leg_raise_on_swiss_ball" => {
                Ok(LegRaiseExerciseName::WeightedReverseLegRaiseOnSwissBall)
            }
            "single_leg_lowering_drill" => Ok(LegRaiseExerciseName::SingleLegLoweringDrill),
            "weighted_single_leg_lowering_drill" => {
                Ok(LegRaiseExerciseName::WeightedSingleLegLoweringDrill)
            }
            "weighted_hanging_knee_raise" => Ok(LegRaiseExerciseName::WeightedHangingKneeRaise),
            "lateral_stepover" => Ok(LegRaiseExerciseName::LateralStepover),
            "weighted_lateral_stepover" => Ok(LegRaiseExerciseName::WeightedLateralStepover),
            _ => Err("No corresponding LegRaiseExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum LungeExerciseName {
    OverheadLunge,
    LungeMatrix,
    WeightedLungeMatrix,
    AlternatingBarbellForwardLunge,
    AlternatingDumbbellLungeWithReach,
    BackFootElevatedDumbbellSplitSquat,
    BarbellBoxLunge,
    BarbellBulgarianSplitSquat,
    BarbellCrossoverLunge,
    BarbellFrontSplitSquat,
    BarbellLunge,
    BarbellReverseLunge,
    BarbellSideLunge,
    BarbellSplitSquat,
    CoreControlRearLunge,
    DiagonalLunge,
    DropLunge,
    DumbbellBoxLunge,
    DumbbellBulgarianSplitSquat,
    DumbbellCrossoverLunge,
    DumbbellDiagonalLunge,
    DumbbellLunge,
    DumbbellLungeAndRotation,
    DumbbellOverheadBulgarianSplitSquat,
    DumbbellReverseLungeToHighKneeAndPress,
    DumbbellSideLunge,
    ElevatedFrontFootBarbellSplitSquat,
    FrontFootElevatedDumbbellSplitSquat,
    GunslingerLunge,
    LawnmowerLunge,
    LowLungeWithIsometricAdduction,
    LowSideToSideLunge,
    Lunge,
    WeightedLunge,
    LungeWithArmReach,
    LungeWithDiagonalReach,
    LungeWithSideBend,
    OffsetDumbbellLunge,
    OffsetDumbbellReverseLunge,
    OverheadBulgarianSplitSquat,
    OverheadDumbbellReverseLunge,
    OverheadDumbbellSplitSquat,
    OverheadLungeWithRotation,
    ReverseBarbellBoxLunge,
    ReverseBoxLunge,
    ReverseDumbbellBoxLunge,
    ReverseDumbbellCrossoverLunge,
    ReverseDumbbellDiagonalLunge,
    ReverseLungeWithReachBack,
    WeightedReverseLungeWithReachBack,
    ReverseLungeWithTwistAndOverheadReach,
    WeightedReverseLungeWithTwistAndOverheadReach,
    ReverseSlidingBoxLunge,
    WeightedReverseSlidingBoxLunge,
    ReverseSlidingLunge,
    WeightedReverseSlidingLunge,
    RunnersLungeToBalance,
    WeightedRunnersLungeToBalance,
    ShiftingSideLunge,
    SideAndCrossoverLunge,
    WeightedSideAndCrossoverLunge,
    SideLunge,
    WeightedSideLunge,
    SideLungeAndPress,
    SideLungeJumpOff,
    SideLungeSweep,
    WeightedSideLungeSweep,
    SideLungeToCrossoverTap,
    WeightedSideLungeToCrossoverTap,
    SideToSideLungeChops,
    WeightedSideToSideLungeChops,
    SiffJumpLunge,
    WeightedSiffJumpLunge,
    SingleArmReverseLungeAndPress,
    SlidingLateralLunge,
    WeightedSlidingLateralLunge,
    WalkingBarbellLunge,
    WalkingDumbbellLunge,
    WalkingLunge,
    WeightedWalkingLunge,
    WideGripOverheadBarbellSplitSquat,
}
impl fmt::Display for LungeExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LungeExerciseName::OverheadLunge => f.write_str("overhead_lunge"),
            LungeExerciseName::LungeMatrix => f.write_str("lunge_matrix"),
            LungeExerciseName::WeightedLungeMatrix => f.write_str("weighted_lunge_matrix"),
            LungeExerciseName::AlternatingBarbellForwardLunge => {
                f.write_str("alternating_barbell_forward_lunge")
            }
            LungeExerciseName::AlternatingDumbbellLungeWithReach => {
                f.write_str("alternating_dumbbell_lunge_with_reach")
            }
            LungeExerciseName::BackFootElevatedDumbbellSplitSquat => {
                f.write_str("back_foot_elevated_dumbbell_split_squat")
            }
            LungeExerciseName::BarbellBoxLunge => f.write_str("barbell_box_lunge"),
            LungeExerciseName::BarbellBulgarianSplitSquat => {
                f.write_str("barbell_bulgarian_split_squat")
            }
            LungeExerciseName::BarbellCrossoverLunge => f.write_str("barbell_crossover_lunge"),
            LungeExerciseName::BarbellFrontSplitSquat => f.write_str("barbell_front_split_squat"),
            LungeExerciseName::BarbellLunge => f.write_str("barbell_lunge"),
            LungeExerciseName::BarbellReverseLunge => f.write_str("barbell_reverse_lunge"),
            LungeExerciseName::BarbellSideLunge => f.write_str("barbell_side_lunge"),
            LungeExerciseName::BarbellSplitSquat => f.write_str("barbell_split_squat"),
            LungeExerciseName::CoreControlRearLunge => f.write_str("core_control_rear_lunge"),
            LungeExerciseName::DiagonalLunge => f.write_str("diagonal_lunge"),
            LungeExerciseName::DropLunge => f.write_str("drop_lunge"),
            LungeExerciseName::DumbbellBoxLunge => f.write_str("dumbbell_box_lunge"),
            LungeExerciseName::DumbbellBulgarianSplitSquat => {
                f.write_str("dumbbell_bulgarian_split_squat")
            }
            LungeExerciseName::DumbbellCrossoverLunge => f.write_str("dumbbell_crossover_lunge"),
            LungeExerciseName::DumbbellDiagonalLunge => f.write_str("dumbbell_diagonal_lunge"),
            LungeExerciseName::DumbbellLunge => f.write_str("dumbbell_lunge"),
            LungeExerciseName::DumbbellLungeAndRotation => {
                f.write_str("dumbbell_lunge_and_rotation")
            }
            LungeExerciseName::DumbbellOverheadBulgarianSplitSquat => {
                f.write_str("dumbbell_overhead_bulgarian_split_squat")
            }
            LungeExerciseName::DumbbellReverseLungeToHighKneeAndPress => {
                f.write_str("dumbbell_reverse_lunge_to_high_knee_and_press")
            }
            LungeExerciseName::DumbbellSideLunge => f.write_str("dumbbell_side_lunge"),
            LungeExerciseName::ElevatedFrontFootBarbellSplitSquat => {
                f.write_str("elevated_front_foot_barbell_split_squat")
            }
            LungeExerciseName::FrontFootElevatedDumbbellSplitSquat => {
                f.write_str("front_foot_elevated_dumbbell_split_squat")
            }
            LungeExerciseName::GunslingerLunge => f.write_str("gunslinger_lunge"),
            LungeExerciseName::LawnmowerLunge => f.write_str("lawnmower_lunge"),
            LungeExerciseName::LowLungeWithIsometricAdduction => {
                f.write_str("low_lunge_with_isometric_adduction")
            }
            LungeExerciseName::LowSideToSideLunge => f.write_str("low_side_to_side_lunge"),
            LungeExerciseName::Lunge => f.write_str("lunge"),
            LungeExerciseName::WeightedLunge => f.write_str("weighted_lunge"),
            LungeExerciseName::LungeWithArmReach => f.write_str("lunge_with_arm_reach"),
            LungeExerciseName::LungeWithDiagonalReach => f.write_str("lunge_with_diagonal_reach"),
            LungeExerciseName::LungeWithSideBend => f.write_str("lunge_with_side_bend"),
            LungeExerciseName::OffsetDumbbellLunge => f.write_str("offset_dumbbell_lunge"),
            LungeExerciseName::OffsetDumbbellReverseLunge => {
                f.write_str("offset_dumbbell_reverse_lunge")
            }
            LungeExerciseName::OverheadBulgarianSplitSquat => {
                f.write_str("overhead_bulgarian_split_squat")
            }
            LungeExerciseName::OverheadDumbbellReverseLunge => {
                f.write_str("overhead_dumbbell_reverse_lunge")
            }
            LungeExerciseName::OverheadDumbbellSplitSquat => {
                f.write_str("overhead_dumbbell_split_squat")
            }
            LungeExerciseName::OverheadLungeWithRotation => {
                f.write_str("overhead_lunge_with_rotation")
            }
            LungeExerciseName::ReverseBarbellBoxLunge => f.write_str("reverse_barbell_box_lunge"),
            LungeExerciseName::ReverseBoxLunge => f.write_str("reverse_box_lunge"),
            LungeExerciseName::ReverseDumbbellBoxLunge => f.write_str("reverse_dumbbell_box_lunge"),
            LungeExerciseName::ReverseDumbbellCrossoverLunge => {
                f.write_str("reverse_dumbbell_crossover_lunge")
            }
            LungeExerciseName::ReverseDumbbellDiagonalLunge => {
                f.write_str("reverse_dumbbell_diagonal_lunge")
            }
            LungeExerciseName::ReverseLungeWithReachBack => {
                f.write_str("reverse_lunge_with_reach_back")
            }
            LungeExerciseName::WeightedReverseLungeWithReachBack => {
                f.write_str("weighted_reverse_lunge_with_reach_back")
            }
            LungeExerciseName::ReverseLungeWithTwistAndOverheadReach => {
                f.write_str("reverse_lunge_with_twist_and_overhead_reach")
            }
            LungeExerciseName::WeightedReverseLungeWithTwistAndOverheadReach => {
                f.write_str("weighted_reverse_lunge_with_twist_and_overhead_reach")
            }
            LungeExerciseName::ReverseSlidingBoxLunge => f.write_str("reverse_sliding_box_lunge"),
            LungeExerciseName::WeightedReverseSlidingBoxLunge => {
                f.write_str("weighted_reverse_sliding_box_lunge")
            }
            LungeExerciseName::ReverseSlidingLunge => f.write_str("reverse_sliding_lunge"),
            LungeExerciseName::WeightedReverseSlidingLunge => {
                f.write_str("weighted_reverse_sliding_lunge")
            }
            LungeExerciseName::RunnersLungeToBalance => f.write_str("runners_lunge_to_balance"),
            LungeExerciseName::WeightedRunnersLungeToBalance => {
                f.write_str("weighted_runners_lunge_to_balance")
            }
            LungeExerciseName::ShiftingSideLunge => f.write_str("shifting_side_lunge"),
            LungeExerciseName::SideAndCrossoverLunge => f.write_str("side_and_crossover_lunge"),
            LungeExerciseName::WeightedSideAndCrossoverLunge => {
                f.write_str("weighted_side_and_crossover_lunge")
            }
            LungeExerciseName::SideLunge => f.write_str("side_lunge"),
            LungeExerciseName::WeightedSideLunge => f.write_str("weighted_side_lunge"),
            LungeExerciseName::SideLungeAndPress => f.write_str("side_lunge_and_press"),
            LungeExerciseName::SideLungeJumpOff => f.write_str("side_lunge_jump_off"),
            LungeExerciseName::SideLungeSweep => f.write_str("side_lunge_sweep"),
            LungeExerciseName::WeightedSideLungeSweep => f.write_str("weighted_side_lunge_sweep"),
            LungeExerciseName::SideLungeToCrossoverTap => {
                f.write_str("side_lunge_to_crossover_tap")
            }
            LungeExerciseName::WeightedSideLungeToCrossoverTap => {
                f.write_str("weighted_side_lunge_to_crossover_tap")
            }
            LungeExerciseName::SideToSideLungeChops => f.write_str("side_to_side_lunge_chops"),
            LungeExerciseName::WeightedSideToSideLungeChops => {
                f.write_str("weighted_side_to_side_lunge_chops")
            }
            LungeExerciseName::SiffJumpLunge => f.write_str("siff_jump_lunge"),
            LungeExerciseName::WeightedSiffJumpLunge => f.write_str("weighted_siff_jump_lunge"),
            LungeExerciseName::SingleArmReverseLungeAndPress => {
                f.write_str("single_arm_reverse_lunge_and_press")
            }
            LungeExerciseName::SlidingLateralLunge => f.write_str("sliding_lateral_lunge"),
            LungeExerciseName::WeightedSlidingLateralLunge => {
                f.write_str("weighted_sliding_lateral_lunge")
            }
            LungeExerciseName::WalkingBarbellLunge => f.write_str("walking_barbell_lunge"),
            LungeExerciseName::WalkingDumbbellLunge => f.write_str("walking_dumbbell_lunge"),
            LungeExerciseName::WalkingLunge => f.write_str("walking_lunge"),
            LungeExerciseName::WeightedWalkingLunge => f.write_str("weighted_walking_lunge"),
            LungeExerciseName::WideGripOverheadBarbellSplitSquat => {
                f.write_str("wide_grip_overhead_barbell_split_squat")
            }
        }
    }
}
impl LungeExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            LungeExerciseName::OverheadLunge => fit::Value::UInt16(0),
            LungeExerciseName::LungeMatrix => fit::Value::UInt16(1),
            LungeExerciseName::WeightedLungeMatrix => fit::Value::UInt16(2),
            LungeExerciseName::AlternatingBarbellForwardLunge => fit::Value::UInt16(3),
            LungeExerciseName::AlternatingDumbbellLungeWithReach => fit::Value::UInt16(4),
            LungeExerciseName::BackFootElevatedDumbbellSplitSquat => fit::Value::UInt16(5),
            LungeExerciseName::BarbellBoxLunge => fit::Value::UInt16(6),
            LungeExerciseName::BarbellBulgarianSplitSquat => fit::Value::UInt16(7),
            LungeExerciseName::BarbellCrossoverLunge => fit::Value::UInt16(8),
            LungeExerciseName::BarbellFrontSplitSquat => fit::Value::UInt16(9),
            LungeExerciseName::BarbellLunge => fit::Value::UInt16(10),
            LungeExerciseName::BarbellReverseLunge => fit::Value::UInt16(11),
            LungeExerciseName::BarbellSideLunge => fit::Value::UInt16(12),
            LungeExerciseName::BarbellSplitSquat => fit::Value::UInt16(13),
            LungeExerciseName::CoreControlRearLunge => fit::Value::UInt16(14),
            LungeExerciseName::DiagonalLunge => fit::Value::UInt16(15),
            LungeExerciseName::DropLunge => fit::Value::UInt16(16),
            LungeExerciseName::DumbbellBoxLunge => fit::Value::UInt16(17),
            LungeExerciseName::DumbbellBulgarianSplitSquat => fit::Value::UInt16(18),
            LungeExerciseName::DumbbellCrossoverLunge => fit::Value::UInt16(19),
            LungeExerciseName::DumbbellDiagonalLunge => fit::Value::UInt16(20),
            LungeExerciseName::DumbbellLunge => fit::Value::UInt16(21),
            LungeExerciseName::DumbbellLungeAndRotation => fit::Value::UInt16(22),
            LungeExerciseName::DumbbellOverheadBulgarianSplitSquat => fit::Value::UInt16(23),
            LungeExerciseName::DumbbellReverseLungeToHighKneeAndPress => fit::Value::UInt16(24),
            LungeExerciseName::DumbbellSideLunge => fit::Value::UInt16(25),
            LungeExerciseName::ElevatedFrontFootBarbellSplitSquat => fit::Value::UInt16(26),
            LungeExerciseName::FrontFootElevatedDumbbellSplitSquat => fit::Value::UInt16(27),
            LungeExerciseName::GunslingerLunge => fit::Value::UInt16(28),
            LungeExerciseName::LawnmowerLunge => fit::Value::UInt16(29),
            LungeExerciseName::LowLungeWithIsometricAdduction => fit::Value::UInt16(30),
            LungeExerciseName::LowSideToSideLunge => fit::Value::UInt16(31),
            LungeExerciseName::Lunge => fit::Value::UInt16(32),
            LungeExerciseName::WeightedLunge => fit::Value::UInt16(33),
            LungeExerciseName::LungeWithArmReach => fit::Value::UInt16(34),
            LungeExerciseName::LungeWithDiagonalReach => fit::Value::UInt16(35),
            LungeExerciseName::LungeWithSideBend => fit::Value::UInt16(36),
            LungeExerciseName::OffsetDumbbellLunge => fit::Value::UInt16(37),
            LungeExerciseName::OffsetDumbbellReverseLunge => fit::Value::UInt16(38),
            LungeExerciseName::OverheadBulgarianSplitSquat => fit::Value::UInt16(39),
            LungeExerciseName::OverheadDumbbellReverseLunge => fit::Value::UInt16(40),
            LungeExerciseName::OverheadDumbbellSplitSquat => fit::Value::UInt16(41),
            LungeExerciseName::OverheadLungeWithRotation => fit::Value::UInt16(42),
            LungeExerciseName::ReverseBarbellBoxLunge => fit::Value::UInt16(43),
            LungeExerciseName::ReverseBoxLunge => fit::Value::UInt16(44),
            LungeExerciseName::ReverseDumbbellBoxLunge => fit::Value::UInt16(45),
            LungeExerciseName::ReverseDumbbellCrossoverLunge => fit::Value::UInt16(46),
            LungeExerciseName::ReverseDumbbellDiagonalLunge => fit::Value::UInt16(47),
            LungeExerciseName::ReverseLungeWithReachBack => fit::Value::UInt16(48),
            LungeExerciseName::WeightedReverseLungeWithReachBack => fit::Value::UInt16(49),
            LungeExerciseName::ReverseLungeWithTwistAndOverheadReach => fit::Value::UInt16(50),
            LungeExerciseName::WeightedReverseLungeWithTwistAndOverheadReach => {
                fit::Value::UInt16(51)
            }
            LungeExerciseName::ReverseSlidingBoxLunge => fit::Value::UInt16(52),
            LungeExerciseName::WeightedReverseSlidingBoxLunge => fit::Value::UInt16(53),
            LungeExerciseName::ReverseSlidingLunge => fit::Value::UInt16(54),
            LungeExerciseName::WeightedReverseSlidingLunge => fit::Value::UInt16(55),
            LungeExerciseName::RunnersLungeToBalance => fit::Value::UInt16(56),
            LungeExerciseName::WeightedRunnersLungeToBalance => fit::Value::UInt16(57),
            LungeExerciseName::ShiftingSideLunge => fit::Value::UInt16(58),
            LungeExerciseName::SideAndCrossoverLunge => fit::Value::UInt16(59),
            LungeExerciseName::WeightedSideAndCrossoverLunge => fit::Value::UInt16(60),
            LungeExerciseName::SideLunge => fit::Value::UInt16(61),
            LungeExerciseName::WeightedSideLunge => fit::Value::UInt16(62),
            LungeExerciseName::SideLungeAndPress => fit::Value::UInt16(63),
            LungeExerciseName::SideLungeJumpOff => fit::Value::UInt16(64),
            LungeExerciseName::SideLungeSweep => fit::Value::UInt16(65),
            LungeExerciseName::WeightedSideLungeSweep => fit::Value::UInt16(66),
            LungeExerciseName::SideLungeToCrossoverTap => fit::Value::UInt16(67),
            LungeExerciseName::WeightedSideLungeToCrossoverTap => fit::Value::UInt16(68),
            LungeExerciseName::SideToSideLungeChops => fit::Value::UInt16(69),
            LungeExerciseName::WeightedSideToSideLungeChops => fit::Value::UInt16(70),
            LungeExerciseName::SiffJumpLunge => fit::Value::UInt16(71),
            LungeExerciseName::WeightedSiffJumpLunge => fit::Value::UInt16(72),
            LungeExerciseName::SingleArmReverseLungeAndPress => fit::Value::UInt16(73),
            LungeExerciseName::SlidingLateralLunge => fit::Value::UInt16(74),
            LungeExerciseName::WeightedSlidingLateralLunge => fit::Value::UInt16(75),
            LungeExerciseName::WalkingBarbellLunge => fit::Value::UInt16(76),
            LungeExerciseName::WalkingDumbbellLunge => fit::Value::UInt16(77),
            LungeExerciseName::WalkingLunge => fit::Value::UInt16(78),
            LungeExerciseName::WeightedWalkingLunge => fit::Value::UInt16(79),
            LungeExerciseName::WideGripOverheadBarbellSplitSquat => fit::Value::UInt16(80),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for LungeExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(LungeExerciseName::OverheadLunge),
            fit::Value::UInt16(1) => Ok(LungeExerciseName::LungeMatrix),
            fit::Value::UInt16(2) => Ok(LungeExerciseName::WeightedLungeMatrix),
            fit::Value::UInt16(3) => Ok(LungeExerciseName::AlternatingBarbellForwardLunge),
            fit::Value::UInt16(4) => Ok(LungeExerciseName::AlternatingDumbbellLungeWithReach),
            fit::Value::UInt16(5) => Ok(LungeExerciseName::BackFootElevatedDumbbellSplitSquat),
            fit::Value::UInt16(6) => Ok(LungeExerciseName::BarbellBoxLunge),
            fit::Value::UInt16(7) => Ok(LungeExerciseName::BarbellBulgarianSplitSquat),
            fit::Value::UInt16(8) => Ok(LungeExerciseName::BarbellCrossoverLunge),
            fit::Value::UInt16(9) => Ok(LungeExerciseName::BarbellFrontSplitSquat),
            fit::Value::UInt16(10) => Ok(LungeExerciseName::BarbellLunge),
            fit::Value::UInt16(11) => Ok(LungeExerciseName::BarbellReverseLunge),
            fit::Value::UInt16(12) => Ok(LungeExerciseName::BarbellSideLunge),
            fit::Value::UInt16(13) => Ok(LungeExerciseName::BarbellSplitSquat),
            fit::Value::UInt16(14) => Ok(LungeExerciseName::CoreControlRearLunge),
            fit::Value::UInt16(15) => Ok(LungeExerciseName::DiagonalLunge),
            fit::Value::UInt16(16) => Ok(LungeExerciseName::DropLunge),
            fit::Value::UInt16(17) => Ok(LungeExerciseName::DumbbellBoxLunge),
            fit::Value::UInt16(18) => Ok(LungeExerciseName::DumbbellBulgarianSplitSquat),
            fit::Value::UInt16(19) => Ok(LungeExerciseName::DumbbellCrossoverLunge),
            fit::Value::UInt16(20) => Ok(LungeExerciseName::DumbbellDiagonalLunge),
            fit::Value::UInt16(21) => Ok(LungeExerciseName::DumbbellLunge),
            fit::Value::UInt16(22) => Ok(LungeExerciseName::DumbbellLungeAndRotation),
            fit::Value::UInt16(23) => Ok(LungeExerciseName::DumbbellOverheadBulgarianSplitSquat),
            fit::Value::UInt16(24) => Ok(LungeExerciseName::DumbbellReverseLungeToHighKneeAndPress),
            fit::Value::UInt16(25) => Ok(LungeExerciseName::DumbbellSideLunge),
            fit::Value::UInt16(26) => Ok(LungeExerciseName::ElevatedFrontFootBarbellSplitSquat),
            fit::Value::UInt16(27) => Ok(LungeExerciseName::FrontFootElevatedDumbbellSplitSquat),
            fit::Value::UInt16(28) => Ok(LungeExerciseName::GunslingerLunge),
            fit::Value::UInt16(29) => Ok(LungeExerciseName::LawnmowerLunge),
            fit::Value::UInt16(30) => Ok(LungeExerciseName::LowLungeWithIsometricAdduction),
            fit::Value::UInt16(31) => Ok(LungeExerciseName::LowSideToSideLunge),
            fit::Value::UInt16(32) => Ok(LungeExerciseName::Lunge),
            fit::Value::UInt16(33) => Ok(LungeExerciseName::WeightedLunge),
            fit::Value::UInt16(34) => Ok(LungeExerciseName::LungeWithArmReach),
            fit::Value::UInt16(35) => Ok(LungeExerciseName::LungeWithDiagonalReach),
            fit::Value::UInt16(36) => Ok(LungeExerciseName::LungeWithSideBend),
            fit::Value::UInt16(37) => Ok(LungeExerciseName::OffsetDumbbellLunge),
            fit::Value::UInt16(38) => Ok(LungeExerciseName::OffsetDumbbellReverseLunge),
            fit::Value::UInt16(39) => Ok(LungeExerciseName::OverheadBulgarianSplitSquat),
            fit::Value::UInt16(40) => Ok(LungeExerciseName::OverheadDumbbellReverseLunge),
            fit::Value::UInt16(41) => Ok(LungeExerciseName::OverheadDumbbellSplitSquat),
            fit::Value::UInt16(42) => Ok(LungeExerciseName::OverheadLungeWithRotation),
            fit::Value::UInt16(43) => Ok(LungeExerciseName::ReverseBarbellBoxLunge),
            fit::Value::UInt16(44) => Ok(LungeExerciseName::ReverseBoxLunge),
            fit::Value::UInt16(45) => Ok(LungeExerciseName::ReverseDumbbellBoxLunge),
            fit::Value::UInt16(46) => Ok(LungeExerciseName::ReverseDumbbellCrossoverLunge),
            fit::Value::UInt16(47) => Ok(LungeExerciseName::ReverseDumbbellDiagonalLunge),
            fit::Value::UInt16(48) => Ok(LungeExerciseName::ReverseLungeWithReachBack),
            fit::Value::UInt16(49) => Ok(LungeExerciseName::WeightedReverseLungeWithReachBack),
            fit::Value::UInt16(50) => Ok(LungeExerciseName::ReverseLungeWithTwistAndOverheadReach),
            fit::Value::UInt16(51) => {
                Ok(LungeExerciseName::WeightedReverseLungeWithTwistAndOverheadReach)
            }
            fit::Value::UInt16(52) => Ok(LungeExerciseName::ReverseSlidingBoxLunge),
            fit::Value::UInt16(53) => Ok(LungeExerciseName::WeightedReverseSlidingBoxLunge),
            fit::Value::UInt16(54) => Ok(LungeExerciseName::ReverseSlidingLunge),
            fit::Value::UInt16(55) => Ok(LungeExerciseName::WeightedReverseSlidingLunge),
            fit::Value::UInt16(56) => Ok(LungeExerciseName::RunnersLungeToBalance),
            fit::Value::UInt16(57) => Ok(LungeExerciseName::WeightedRunnersLungeToBalance),
            fit::Value::UInt16(58) => Ok(LungeExerciseName::ShiftingSideLunge),
            fit::Value::UInt16(59) => Ok(LungeExerciseName::SideAndCrossoverLunge),
            fit::Value::UInt16(60) => Ok(LungeExerciseName::WeightedSideAndCrossoverLunge),
            fit::Value::UInt16(61) => Ok(LungeExerciseName::SideLunge),
            fit::Value::UInt16(62) => Ok(LungeExerciseName::WeightedSideLunge),
            fit::Value::UInt16(63) => Ok(LungeExerciseName::SideLungeAndPress),
            fit::Value::UInt16(64) => Ok(LungeExerciseName::SideLungeJumpOff),
            fit::Value::UInt16(65) => Ok(LungeExerciseName::SideLungeSweep),
            fit::Value::UInt16(66) => Ok(LungeExerciseName::WeightedSideLungeSweep),
            fit::Value::UInt16(67) => Ok(LungeExerciseName::SideLungeToCrossoverTap),
            fit::Value::UInt16(68) => Ok(LungeExerciseName::WeightedSideLungeToCrossoverTap),
            fit::Value::UInt16(69) => Ok(LungeExerciseName::SideToSideLungeChops),
            fit::Value::UInt16(70) => Ok(LungeExerciseName::WeightedSideToSideLungeChops),
            fit::Value::UInt16(71) => Ok(LungeExerciseName::SiffJumpLunge),
            fit::Value::UInt16(72) => Ok(LungeExerciseName::WeightedSiffJumpLunge),
            fit::Value::UInt16(73) => Ok(LungeExerciseName::SingleArmReverseLungeAndPress),
            fit::Value::UInt16(74) => Ok(LungeExerciseName::SlidingLateralLunge),
            fit::Value::UInt16(75) => Ok(LungeExerciseName::WeightedSlidingLateralLunge),
            fit::Value::UInt16(76) => Ok(LungeExerciseName::WalkingBarbellLunge),
            fit::Value::UInt16(77) => Ok(LungeExerciseName::WalkingDumbbellLunge),
            fit::Value::UInt16(78) => Ok(LungeExerciseName::WalkingLunge),
            fit::Value::UInt16(79) => Ok(LungeExerciseName::WeightedWalkingLunge),
            fit::Value::UInt16(80) => Ok(LungeExerciseName::WideGripOverheadBarbellSplitSquat),
            _ => Err("No corresponding LungeExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for LungeExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "overhead_lunge" => Ok(LungeExerciseName::OverheadLunge),
            "lunge_matrix" => Ok(LungeExerciseName::LungeMatrix),
            "weighted_lunge_matrix" => Ok(LungeExerciseName::WeightedLungeMatrix),
            "alternating_barbell_forward_lunge" => {
                Ok(LungeExerciseName::AlternatingBarbellForwardLunge)
            }
            "alternating_dumbbell_lunge_with_reach" => {
                Ok(LungeExerciseName::AlternatingDumbbellLungeWithReach)
            }
            "back_foot_elevated_dumbbell_split_squat" => {
                Ok(LungeExerciseName::BackFootElevatedDumbbellSplitSquat)
            }
            "barbell_box_lunge" => Ok(LungeExerciseName::BarbellBoxLunge),
            "barbell_bulgarian_split_squat" => Ok(LungeExerciseName::BarbellBulgarianSplitSquat),
            "barbell_crossover_lunge" => Ok(LungeExerciseName::BarbellCrossoverLunge),
            "barbell_front_split_squat" => Ok(LungeExerciseName::BarbellFrontSplitSquat),
            "barbell_lunge" => Ok(LungeExerciseName::BarbellLunge),
            "barbell_reverse_lunge" => Ok(LungeExerciseName::BarbellReverseLunge),
            "barbell_side_lunge" => Ok(LungeExerciseName::BarbellSideLunge),
            "barbell_split_squat" => Ok(LungeExerciseName::BarbellSplitSquat),
            "core_control_rear_lunge" => Ok(LungeExerciseName::CoreControlRearLunge),
            "diagonal_lunge" => Ok(LungeExerciseName::DiagonalLunge),
            "drop_lunge" => Ok(LungeExerciseName::DropLunge),
            "dumbbell_box_lunge" => Ok(LungeExerciseName::DumbbellBoxLunge),
            "dumbbell_bulgarian_split_squat" => Ok(LungeExerciseName::DumbbellBulgarianSplitSquat),
            "dumbbell_crossover_lunge" => Ok(LungeExerciseName::DumbbellCrossoverLunge),
            "dumbbell_diagonal_lunge" => Ok(LungeExerciseName::DumbbellDiagonalLunge),
            "dumbbell_lunge" => Ok(LungeExerciseName::DumbbellLunge),
            "dumbbell_lunge_and_rotation" => Ok(LungeExerciseName::DumbbellLungeAndRotation),
            "dumbbell_overhead_bulgarian_split_squat" => {
                Ok(LungeExerciseName::DumbbellOverheadBulgarianSplitSquat)
            }
            "dumbbell_reverse_lunge_to_high_knee_and_press" => {
                Ok(LungeExerciseName::DumbbellReverseLungeToHighKneeAndPress)
            }
            "dumbbell_side_lunge" => Ok(LungeExerciseName::DumbbellSideLunge),
            "elevated_front_foot_barbell_split_squat" => {
                Ok(LungeExerciseName::ElevatedFrontFootBarbellSplitSquat)
            }
            "front_foot_elevated_dumbbell_split_squat" => {
                Ok(LungeExerciseName::FrontFootElevatedDumbbellSplitSquat)
            }
            "gunslinger_lunge" => Ok(LungeExerciseName::GunslingerLunge),
            "lawnmower_lunge" => Ok(LungeExerciseName::LawnmowerLunge),
            "low_lunge_with_isometric_adduction" => {
                Ok(LungeExerciseName::LowLungeWithIsometricAdduction)
            }
            "low_side_to_side_lunge" => Ok(LungeExerciseName::LowSideToSideLunge),
            "lunge" => Ok(LungeExerciseName::Lunge),
            "weighted_lunge" => Ok(LungeExerciseName::WeightedLunge),
            "lunge_with_arm_reach" => Ok(LungeExerciseName::LungeWithArmReach),
            "lunge_with_diagonal_reach" => Ok(LungeExerciseName::LungeWithDiagonalReach),
            "lunge_with_side_bend" => Ok(LungeExerciseName::LungeWithSideBend),
            "offset_dumbbell_lunge" => Ok(LungeExerciseName::OffsetDumbbellLunge),
            "offset_dumbbell_reverse_lunge" => Ok(LungeExerciseName::OffsetDumbbellReverseLunge),
            "overhead_bulgarian_split_squat" => Ok(LungeExerciseName::OverheadBulgarianSplitSquat),
            "overhead_dumbbell_reverse_lunge" => {
                Ok(LungeExerciseName::OverheadDumbbellReverseLunge)
            }
            "overhead_dumbbell_split_squat" => Ok(LungeExerciseName::OverheadDumbbellSplitSquat),
            "overhead_lunge_with_rotation" => Ok(LungeExerciseName::OverheadLungeWithRotation),
            "reverse_barbell_box_lunge" => Ok(LungeExerciseName::ReverseBarbellBoxLunge),
            "reverse_box_lunge" => Ok(LungeExerciseName::ReverseBoxLunge),
            "reverse_dumbbell_box_lunge" => Ok(LungeExerciseName::ReverseDumbbellBoxLunge),
            "reverse_dumbbell_crossover_lunge" => {
                Ok(LungeExerciseName::ReverseDumbbellCrossoverLunge)
            }
            "reverse_dumbbell_diagonal_lunge" => {
                Ok(LungeExerciseName::ReverseDumbbellDiagonalLunge)
            }
            "reverse_lunge_with_reach_back" => Ok(LungeExerciseName::ReverseLungeWithReachBack),
            "weighted_reverse_lunge_with_reach_back" => {
                Ok(LungeExerciseName::WeightedReverseLungeWithReachBack)
            }
            "reverse_lunge_with_twist_and_overhead_reach" => {
                Ok(LungeExerciseName::ReverseLungeWithTwistAndOverheadReach)
            }
            "weighted_reverse_lunge_with_twist_and_overhead_reach" => {
                Ok(LungeExerciseName::WeightedReverseLungeWithTwistAndOverheadReach)
            }
            "reverse_sliding_box_lunge" => Ok(LungeExerciseName::ReverseSlidingBoxLunge),
            "weighted_reverse_sliding_box_lunge" => {
                Ok(LungeExerciseName::WeightedReverseSlidingBoxLunge)
            }
            "reverse_sliding_lunge" => Ok(LungeExerciseName::ReverseSlidingLunge),
            "weighted_reverse_sliding_lunge" => Ok(LungeExerciseName::WeightedReverseSlidingLunge),
            "runners_lunge_to_balance" => Ok(LungeExerciseName::RunnersLungeToBalance),
            "weighted_runners_lunge_to_balance" => {
                Ok(LungeExerciseName::WeightedRunnersLungeToBalance)
            }
            "shifting_side_lunge" => Ok(LungeExerciseName::ShiftingSideLunge),
            "side_and_crossover_lunge" => Ok(LungeExerciseName::SideAndCrossoverLunge),
            "weighted_side_and_crossover_lunge" => {
                Ok(LungeExerciseName::WeightedSideAndCrossoverLunge)
            }
            "side_lunge" => Ok(LungeExerciseName::SideLunge),
            "weighted_side_lunge" => Ok(LungeExerciseName::WeightedSideLunge),
            "side_lunge_and_press" => Ok(LungeExerciseName::SideLungeAndPress),
            "side_lunge_jump_off" => Ok(LungeExerciseName::SideLungeJumpOff),
            "side_lunge_sweep" => Ok(LungeExerciseName::SideLungeSweep),
            "weighted_side_lunge_sweep" => Ok(LungeExerciseName::WeightedSideLungeSweep),
            "side_lunge_to_crossover_tap" => Ok(LungeExerciseName::SideLungeToCrossoverTap),
            "weighted_side_lunge_to_crossover_tap" => {
                Ok(LungeExerciseName::WeightedSideLungeToCrossoverTap)
            }
            "side_to_side_lunge_chops" => Ok(LungeExerciseName::SideToSideLungeChops),
            "weighted_side_to_side_lunge_chops" => {
                Ok(LungeExerciseName::WeightedSideToSideLungeChops)
            }
            "siff_jump_lunge" => Ok(LungeExerciseName::SiffJumpLunge),
            "weighted_siff_jump_lunge" => Ok(LungeExerciseName::WeightedSiffJumpLunge),
            "single_arm_reverse_lunge_and_press" => {
                Ok(LungeExerciseName::SingleArmReverseLungeAndPress)
            }
            "sliding_lateral_lunge" => Ok(LungeExerciseName::SlidingLateralLunge),
            "weighted_sliding_lateral_lunge" => Ok(LungeExerciseName::WeightedSlidingLateralLunge),
            "walking_barbell_lunge" => Ok(LungeExerciseName::WalkingBarbellLunge),
            "walking_dumbbell_lunge" => Ok(LungeExerciseName::WalkingDumbbellLunge),
            "walking_lunge" => Ok(LungeExerciseName::WalkingLunge),
            "weighted_walking_lunge" => Ok(LungeExerciseName::WeightedWalkingLunge),
            "wide_grip_overhead_barbell_split_squat" => {
                Ok(LungeExerciseName::WideGripOverheadBarbellSplitSquat)
            }
            _ => Err("No corresponding LungeExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum OlympicLiftExerciseName {
    BarbellHangPowerClean,
    BarbellHangSquatClean,
    BarbellPowerClean,
    BarbellPowerSnatch,
    BarbellSquatClean,
    CleanAndJerk,
    BarbellHangPowerSnatch,
    BarbellHangPull,
    BarbellHighPull,
    BarbellSnatch,
    BarbellSplitJerk,
    Clean,
    DumbbellClean,
    DumbbellHangPull,
    OneHandDumbbellSplitSnatch,
    PushJerk,
    SingleArmDumbbellSnatch,
    SingleArmHangSnatch,
    SingleArmKettlebellSnatch,
    SplitJerk,
    SquatCleanAndJerk,
}
impl fmt::Display for OlympicLiftExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            OlympicLiftExerciseName::BarbellHangPowerClean => {
                f.write_str("barbell_hang_power_clean")
            }
            OlympicLiftExerciseName::BarbellHangSquatClean => {
                f.write_str("barbell_hang_squat_clean")
            }
            OlympicLiftExerciseName::BarbellPowerClean => f.write_str("barbell_power_clean"),
            OlympicLiftExerciseName::BarbellPowerSnatch => f.write_str("barbell_power_snatch"),
            OlympicLiftExerciseName::BarbellSquatClean => f.write_str("barbell_squat_clean"),
            OlympicLiftExerciseName::CleanAndJerk => f.write_str("clean_and_jerk"),
            OlympicLiftExerciseName::BarbellHangPowerSnatch => {
                f.write_str("barbell_hang_power_snatch")
            }
            OlympicLiftExerciseName::BarbellHangPull => f.write_str("barbell_hang_pull"),
            OlympicLiftExerciseName::BarbellHighPull => f.write_str("barbell_high_pull"),
            OlympicLiftExerciseName::BarbellSnatch => f.write_str("barbell_snatch"),
            OlympicLiftExerciseName::BarbellSplitJerk => f.write_str("barbell_split_jerk"),
            OlympicLiftExerciseName::Clean => f.write_str("clean"),
            OlympicLiftExerciseName::DumbbellClean => f.write_str("dumbbell_clean"),
            OlympicLiftExerciseName::DumbbellHangPull => f.write_str("dumbbell_hang_pull"),
            OlympicLiftExerciseName::OneHandDumbbellSplitSnatch => {
                f.write_str("one_hand_dumbbell_split_snatch")
            }
            OlympicLiftExerciseName::PushJerk => f.write_str("push_jerk"),
            OlympicLiftExerciseName::SingleArmDumbbellSnatch => {
                f.write_str("single_arm_dumbbell_snatch")
            }
            OlympicLiftExerciseName::SingleArmHangSnatch => f.write_str("single_arm_hang_snatch"),
            OlympicLiftExerciseName::SingleArmKettlebellSnatch => {
                f.write_str("single_arm_kettlebell_snatch")
            }
            OlympicLiftExerciseName::SplitJerk => f.write_str("split_jerk"),
            OlympicLiftExerciseName::SquatCleanAndJerk => f.write_str("squat_clean_and_jerk"),
        }
    }
}
impl OlympicLiftExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            OlympicLiftExerciseName::BarbellHangPowerClean => fit::Value::UInt16(0),
            OlympicLiftExerciseName::BarbellHangSquatClean => fit::Value::UInt16(1),
            OlympicLiftExerciseName::BarbellPowerClean => fit::Value::UInt16(2),
            OlympicLiftExerciseName::BarbellPowerSnatch => fit::Value::UInt16(3),
            OlympicLiftExerciseName::BarbellSquatClean => fit::Value::UInt16(4),
            OlympicLiftExerciseName::CleanAndJerk => fit::Value::UInt16(5),
            OlympicLiftExerciseName::BarbellHangPowerSnatch => fit::Value::UInt16(6),
            OlympicLiftExerciseName::BarbellHangPull => fit::Value::UInt16(7),
            OlympicLiftExerciseName::BarbellHighPull => fit::Value::UInt16(8),
            OlympicLiftExerciseName::BarbellSnatch => fit::Value::UInt16(9),
            OlympicLiftExerciseName::BarbellSplitJerk => fit::Value::UInt16(10),
            OlympicLiftExerciseName::Clean => fit::Value::UInt16(11),
            OlympicLiftExerciseName::DumbbellClean => fit::Value::UInt16(12),
            OlympicLiftExerciseName::DumbbellHangPull => fit::Value::UInt16(13),
            OlympicLiftExerciseName::OneHandDumbbellSplitSnatch => fit::Value::UInt16(14),
            OlympicLiftExerciseName::PushJerk => fit::Value::UInt16(15),
            OlympicLiftExerciseName::SingleArmDumbbellSnatch => fit::Value::UInt16(16),
            OlympicLiftExerciseName::SingleArmHangSnatch => fit::Value::UInt16(17),
            OlympicLiftExerciseName::SingleArmKettlebellSnatch => fit::Value::UInt16(18),
            OlympicLiftExerciseName::SplitJerk => fit::Value::UInt16(19),
            OlympicLiftExerciseName::SquatCleanAndJerk => fit::Value::UInt16(20),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for OlympicLiftExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(OlympicLiftExerciseName::BarbellHangPowerClean),
            fit::Value::UInt16(1) => Ok(OlympicLiftExerciseName::BarbellHangSquatClean),
            fit::Value::UInt16(2) => Ok(OlympicLiftExerciseName::BarbellPowerClean),
            fit::Value::UInt16(3) => Ok(OlympicLiftExerciseName::BarbellPowerSnatch),
            fit::Value::UInt16(4) => Ok(OlympicLiftExerciseName::BarbellSquatClean),
            fit::Value::UInt16(5) => Ok(OlympicLiftExerciseName::CleanAndJerk),
            fit::Value::UInt16(6) => Ok(OlympicLiftExerciseName::BarbellHangPowerSnatch),
            fit::Value::UInt16(7) => Ok(OlympicLiftExerciseName::BarbellHangPull),
            fit::Value::UInt16(8) => Ok(OlympicLiftExerciseName::BarbellHighPull),
            fit::Value::UInt16(9) => Ok(OlympicLiftExerciseName::BarbellSnatch),
            fit::Value::UInt16(10) => Ok(OlympicLiftExerciseName::BarbellSplitJerk),
            fit::Value::UInt16(11) => Ok(OlympicLiftExerciseName::Clean),
            fit::Value::UInt16(12) => Ok(OlympicLiftExerciseName::DumbbellClean),
            fit::Value::UInt16(13) => Ok(OlympicLiftExerciseName::DumbbellHangPull),
            fit::Value::UInt16(14) => Ok(OlympicLiftExerciseName::OneHandDumbbellSplitSnatch),
            fit::Value::UInt16(15) => Ok(OlympicLiftExerciseName::PushJerk),
            fit::Value::UInt16(16) => Ok(OlympicLiftExerciseName::SingleArmDumbbellSnatch),
            fit::Value::UInt16(17) => Ok(OlympicLiftExerciseName::SingleArmHangSnatch),
            fit::Value::UInt16(18) => Ok(OlympicLiftExerciseName::SingleArmKettlebellSnatch),
            fit::Value::UInt16(19) => Ok(OlympicLiftExerciseName::SplitJerk),
            fit::Value::UInt16(20) => Ok(OlympicLiftExerciseName::SquatCleanAndJerk),
            _ => Err("No corresponding OlympicLiftExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for OlympicLiftExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "barbell_hang_power_clean" => Ok(OlympicLiftExerciseName::BarbellHangPowerClean),
            "barbell_hang_squat_clean" => Ok(OlympicLiftExerciseName::BarbellHangSquatClean),
            "barbell_power_clean" => Ok(OlympicLiftExerciseName::BarbellPowerClean),
            "barbell_power_snatch" => Ok(OlympicLiftExerciseName::BarbellPowerSnatch),
            "barbell_squat_clean" => Ok(OlympicLiftExerciseName::BarbellSquatClean),
            "clean_and_jerk" => Ok(OlympicLiftExerciseName::CleanAndJerk),
            "barbell_hang_power_snatch" => Ok(OlympicLiftExerciseName::BarbellHangPowerSnatch),
            "barbell_hang_pull" => Ok(OlympicLiftExerciseName::BarbellHangPull),
            "barbell_high_pull" => Ok(OlympicLiftExerciseName::BarbellHighPull),
            "barbell_snatch" => Ok(OlympicLiftExerciseName::BarbellSnatch),
            "barbell_split_jerk" => Ok(OlympicLiftExerciseName::BarbellSplitJerk),
            "clean" => Ok(OlympicLiftExerciseName::Clean),
            "dumbbell_clean" => Ok(OlympicLiftExerciseName::DumbbellClean),
            "dumbbell_hang_pull" => Ok(OlympicLiftExerciseName::DumbbellHangPull),
            "one_hand_dumbbell_split_snatch" => {
                Ok(OlympicLiftExerciseName::OneHandDumbbellSplitSnatch)
            }
            "push_jerk" => Ok(OlympicLiftExerciseName::PushJerk),
            "single_arm_dumbbell_snatch" => Ok(OlympicLiftExerciseName::SingleArmDumbbellSnatch),
            "single_arm_hang_snatch" => Ok(OlympicLiftExerciseName::SingleArmHangSnatch),
            "single_arm_kettlebell_snatch" => {
                Ok(OlympicLiftExerciseName::SingleArmKettlebellSnatch)
            }
            "split_jerk" => Ok(OlympicLiftExerciseName::SplitJerk),
            "squat_clean_and_jerk" => Ok(OlympicLiftExerciseName::SquatCleanAndJerk),
            _ => Err("No corresponding OlympicLiftExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum PlankExerciseName {
    N45DegreePlank,
    Weighted45DegreePlank,
    N90DegreeStaticHold,
    Weighted90DegreeStaticHold,
    BearCrawl,
    WeightedBearCrawl,
    CrossBodyMountainClimber,
    WeightedCrossBodyMountainClimber,
    ElbowPlankPikeJacks,
    WeightedElbowPlankPikeJacks,
    ElevatedFeetPlank,
    WeightedElevatedFeetPlank,
    ElevatorAbs,
    WeightedElevatorAbs,
    ExtendedPlank,
    WeightedExtendedPlank,
    FullPlankPasseTwist,
    WeightedFullPlankPasseTwist,
    InchingElbowPlank,
    WeightedInchingElbowPlank,
    InchwormToSidePlank,
    WeightedInchwormToSidePlank,
    KneelingPlank,
    WeightedKneelingPlank,
    KneelingSidePlankWithLegLift,
    WeightedKneelingSidePlankWithLegLift,
    LateralRoll,
    WeightedLateralRoll,
    LyingReversePlank,
    WeightedLyingReversePlank,
    MedicineBallMountainClimber,
    WeightedMedicineBallMountainClimber,
    ModifiedMountainClimberAndExtension,
    WeightedModifiedMountainClimberAndExtension,
    MountainClimber,
    WeightedMountainClimber,
    MountainClimberOnSlidingDiscs,
    WeightedMountainClimberOnSlidingDiscs,
    MountainClimberWithFeetOnBosuBall,
    WeightedMountainClimberWithFeetOnBosuBall,
    MountainClimberWithHandsOnBench,
    MountainClimberWithHandsOnSwissBall,
    WeightedMountainClimberWithHandsOnSwissBall,
    Plank,
    PlankJacksWithFeetOnSlidingDiscs,
    WeightedPlankJacksWithFeetOnSlidingDiscs,
    PlankKneeTwist,
    WeightedPlankKneeTwist,
    PlankPikeJumps,
    WeightedPlankPikeJumps,
    PlankPikes,
    WeightedPlankPikes,
    PlankToStandUp,
    WeightedPlankToStandUp,
    PlankWithArmRaise,
    WeightedPlankWithArmRaise,
    PlankWithKneeToElbow,
    WeightedPlankWithKneeToElbow,
    PlankWithObliqueCrunch,
    WeightedPlankWithObliqueCrunch,
    PlyometricSidePlank,
    WeightedPlyometricSidePlank,
    RollingSidePlank,
    WeightedRollingSidePlank,
    SideKickPlank,
    WeightedSideKickPlank,
    SidePlank,
    WeightedSidePlank,
    SidePlankAndRow,
    WeightedSidePlankAndRow,
    SidePlankLift,
    WeightedSidePlankLift,
    SidePlankWithElbowOnBosuBall,
    WeightedSidePlankWithElbowOnBosuBall,
    SidePlankWithFeetOnBench,
    WeightedSidePlankWithFeetOnBench,
    SidePlankWithKneeCircle,
    WeightedSidePlankWithKneeCircle,
    SidePlankWithKneeTuck,
    WeightedSidePlankWithKneeTuck,
    SidePlankWithLegLift,
    WeightedSidePlankWithLegLift,
    SidePlankWithReachUnder,
    WeightedSidePlankWithReachUnder,
    SingleLegElevatedFeetPlank,
    WeightedSingleLegElevatedFeetPlank,
    SingleLegFlexAndExtend,
    WeightedSingleLegFlexAndExtend,
    SingleLegSidePlank,
    WeightedSingleLegSidePlank,
    SpidermanPlank,
    WeightedSpidermanPlank,
    StraightArmPlank,
    WeightedStraightArmPlank,
    StraightArmPlankWithShoulderTouch,
    WeightedStraightArmPlankWithShoulderTouch,
    SwissBallPlank,
    WeightedSwissBallPlank,
    SwissBallPlankLegLift,
    WeightedSwissBallPlankLegLift,
    SwissBallPlankLegLiftAndHold,
    SwissBallPlankWithFeetOnBench,
    WeightedSwissBallPlankWithFeetOnBench,
    SwissBallProneJackknife,
    WeightedSwissBallProneJackknife,
    SwissBallSidePlank,
    WeightedSwissBallSidePlank,
    ThreeWayPlank,
    WeightedThreeWayPlank,
    TowelPlankAndKneeIn,
    WeightedTowelPlankAndKneeIn,
    TStabilization,
    WeightedTStabilization,
    TurkishGetUpToSidePlank,
    WeightedTurkishGetUpToSidePlank,
    TwoPointPlank,
    WeightedTwoPointPlank,
    WeightedPlank,
    WideStancePlankWithDiagonalArmLift,
    WeightedWideStancePlankWithDiagonalArmLift,
    WideStancePlankWithDiagonalLegLift,
    WeightedWideStancePlankWithDiagonalLegLift,
    WideStancePlankWithLegLift,
    WeightedWideStancePlankWithLegLift,
    WideStancePlankWithOppositeArmAndLegLift,
    WeightedMountainClimberWithHandsOnBench,
    WeightedSwissBallPlankLegLiftAndHold,
    WeightedWideStancePlankWithOppositeArmAndLegLift,
    PlankWithFeetOnSwissBall,
    SidePlankToPlankWithReachUnder,
    BridgeWithGluteLowerLift,
    BridgeOneLegBridge,
    PlankWithArmVariations,
    PlankWithLegLift,
    ReversePlankWithLegPull,
}
impl fmt::Display for PlankExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PlankExerciseName::N45DegreePlank => f.write_str("45_degree_plank"),
            PlankExerciseName::Weighted45DegreePlank => f.write_str("weighted_45_degree_plank"),
            PlankExerciseName::N90DegreeStaticHold => f.write_str("90_degree_static_hold"),
            PlankExerciseName::Weighted90DegreeStaticHold => {
                f.write_str("weighted_90_degree_static_hold")
            }
            PlankExerciseName::BearCrawl => f.write_str("bear_crawl"),
            PlankExerciseName::WeightedBearCrawl => f.write_str("weighted_bear_crawl"),
            PlankExerciseName::CrossBodyMountainClimber => {
                f.write_str("cross_body_mountain_climber")
            }
            PlankExerciseName::WeightedCrossBodyMountainClimber => {
                f.write_str("weighted_cross_body_mountain_climber")
            }
            PlankExerciseName::ElbowPlankPikeJacks => f.write_str("elbow_plank_pike_jacks"),
            PlankExerciseName::WeightedElbowPlankPikeJacks => {
                f.write_str("weighted_elbow_plank_pike_jacks")
            }
            PlankExerciseName::ElevatedFeetPlank => f.write_str("elevated_feet_plank"),
            PlankExerciseName::WeightedElevatedFeetPlank => {
                f.write_str("weighted_elevated_feet_plank")
            }
            PlankExerciseName::ElevatorAbs => f.write_str("elevator_abs"),
            PlankExerciseName::WeightedElevatorAbs => f.write_str("weighted_elevator_abs"),
            PlankExerciseName::ExtendedPlank => f.write_str("extended_plank"),
            PlankExerciseName::WeightedExtendedPlank => f.write_str("weighted_extended_plank"),
            PlankExerciseName::FullPlankPasseTwist => f.write_str("full_plank_passe_twist"),
            PlankExerciseName::WeightedFullPlankPasseTwist => {
                f.write_str("weighted_full_plank_passe_twist")
            }
            PlankExerciseName::InchingElbowPlank => f.write_str("inching_elbow_plank"),
            PlankExerciseName::WeightedInchingElbowPlank => {
                f.write_str("weighted_inching_elbow_plank")
            }
            PlankExerciseName::InchwormToSidePlank => f.write_str("inchworm_to_side_plank"),
            PlankExerciseName::WeightedInchwormToSidePlank => {
                f.write_str("weighted_inchworm_to_side_plank")
            }
            PlankExerciseName::KneelingPlank => f.write_str("kneeling_plank"),
            PlankExerciseName::WeightedKneelingPlank => f.write_str("weighted_kneeling_plank"),
            PlankExerciseName::KneelingSidePlankWithLegLift => {
                f.write_str("kneeling_side_plank_with_leg_lift")
            }
            PlankExerciseName::WeightedKneelingSidePlankWithLegLift => {
                f.write_str("weighted_kneeling_side_plank_with_leg_lift")
            }
            PlankExerciseName::LateralRoll => f.write_str("lateral_roll"),
            PlankExerciseName::WeightedLateralRoll => f.write_str("weighted_lateral_roll"),
            PlankExerciseName::LyingReversePlank => f.write_str("lying_reverse_plank"),
            PlankExerciseName::WeightedLyingReversePlank => {
                f.write_str("weighted_lying_reverse_plank")
            }
            PlankExerciseName::MedicineBallMountainClimber => {
                f.write_str("medicine_ball_mountain_climber")
            }
            PlankExerciseName::WeightedMedicineBallMountainClimber => {
                f.write_str("weighted_medicine_ball_mountain_climber")
            }
            PlankExerciseName::ModifiedMountainClimberAndExtension => {
                f.write_str("modified_mountain_climber_and_extension")
            }
            PlankExerciseName::WeightedModifiedMountainClimberAndExtension => {
                f.write_str("weighted_modified_mountain_climber_and_extension")
            }
            PlankExerciseName::MountainClimber => f.write_str("mountain_climber"),
            PlankExerciseName::WeightedMountainClimber => f.write_str("weighted_mountain_climber"),
            PlankExerciseName::MountainClimberOnSlidingDiscs => {
                f.write_str("mountain_climber_on_sliding_discs")
            }
            PlankExerciseName::WeightedMountainClimberOnSlidingDiscs => {
                f.write_str("weighted_mountain_climber_on_sliding_discs")
            }
            PlankExerciseName::MountainClimberWithFeetOnBosuBall => {
                f.write_str("mountain_climber_with_feet_on_bosu_ball")
            }
            PlankExerciseName::WeightedMountainClimberWithFeetOnBosuBall => {
                f.write_str("weighted_mountain_climber_with_feet_on_bosu_ball")
            }
            PlankExerciseName::MountainClimberWithHandsOnBench => {
                f.write_str("mountain_climber_with_hands_on_bench")
            }
            PlankExerciseName::MountainClimberWithHandsOnSwissBall => {
                f.write_str("mountain_climber_with_hands_on_swiss_ball")
            }
            PlankExerciseName::WeightedMountainClimberWithHandsOnSwissBall => {
                f.write_str("weighted_mountain_climber_with_hands_on_swiss_ball")
            }
            PlankExerciseName::Plank => f.write_str("plank"),
            PlankExerciseName::PlankJacksWithFeetOnSlidingDiscs => {
                f.write_str("plank_jacks_with_feet_on_sliding_discs")
            }
            PlankExerciseName::WeightedPlankJacksWithFeetOnSlidingDiscs => {
                f.write_str("weighted_plank_jacks_with_feet_on_sliding_discs")
            }
            PlankExerciseName::PlankKneeTwist => f.write_str("plank_knee_twist"),
            PlankExerciseName::WeightedPlankKneeTwist => f.write_str("weighted_plank_knee_twist"),
            PlankExerciseName::PlankPikeJumps => f.write_str("plank_pike_jumps"),
            PlankExerciseName::WeightedPlankPikeJumps => f.write_str("weighted_plank_pike_jumps"),
            PlankExerciseName::PlankPikes => f.write_str("plank_pikes"),
            PlankExerciseName::WeightedPlankPikes => f.write_str("weighted_plank_pikes"),
            PlankExerciseName::PlankToStandUp => f.write_str("plank_to_stand_up"),
            PlankExerciseName::WeightedPlankToStandUp => f.write_str("weighted_plank_to_stand_up"),
            PlankExerciseName::PlankWithArmRaise => f.write_str("plank_with_arm_raise"),
            PlankExerciseName::WeightedPlankWithArmRaise => {
                f.write_str("weighted_plank_with_arm_raise")
            }
            PlankExerciseName::PlankWithKneeToElbow => f.write_str("plank_with_knee_to_elbow"),
            PlankExerciseName::WeightedPlankWithKneeToElbow => {
                f.write_str("weighted_plank_with_knee_to_elbow")
            }
            PlankExerciseName::PlankWithObliqueCrunch => f.write_str("plank_with_oblique_crunch"),
            PlankExerciseName::WeightedPlankWithObliqueCrunch => {
                f.write_str("weighted_plank_with_oblique_crunch")
            }
            PlankExerciseName::PlyometricSidePlank => f.write_str("plyometric_side_plank"),
            PlankExerciseName::WeightedPlyometricSidePlank => {
                f.write_str("weighted_plyometric_side_plank")
            }
            PlankExerciseName::RollingSidePlank => f.write_str("rolling_side_plank"),
            PlankExerciseName::WeightedRollingSidePlank => {
                f.write_str("weighted_rolling_side_plank")
            }
            PlankExerciseName::SideKickPlank => f.write_str("side_kick_plank"),
            PlankExerciseName::WeightedSideKickPlank => f.write_str("weighted_side_kick_plank"),
            PlankExerciseName::SidePlank => f.write_str("side_plank"),
            PlankExerciseName::WeightedSidePlank => f.write_str("weighted_side_plank"),
            PlankExerciseName::SidePlankAndRow => f.write_str("side_plank_and_row"),
            PlankExerciseName::WeightedSidePlankAndRow => {
                f.write_str("weighted_side_plank_and_row")
            }
            PlankExerciseName::SidePlankLift => f.write_str("side_plank_lift"),
            PlankExerciseName::WeightedSidePlankLift => f.write_str("weighted_side_plank_lift"),
            PlankExerciseName::SidePlankWithElbowOnBosuBall => {
                f.write_str("side_plank_with_elbow_on_bosu_ball")
            }
            PlankExerciseName::WeightedSidePlankWithElbowOnBosuBall => {
                f.write_str("weighted_side_plank_with_elbow_on_bosu_ball")
            }
            PlankExerciseName::SidePlankWithFeetOnBench => {
                f.write_str("side_plank_with_feet_on_bench")
            }
            PlankExerciseName::WeightedSidePlankWithFeetOnBench => {
                f.write_str("weighted_side_plank_with_feet_on_bench")
            }
            PlankExerciseName::SidePlankWithKneeCircle => {
                f.write_str("side_plank_with_knee_circle")
            }
            PlankExerciseName::WeightedSidePlankWithKneeCircle => {
                f.write_str("weighted_side_plank_with_knee_circle")
            }
            PlankExerciseName::SidePlankWithKneeTuck => f.write_str("side_plank_with_knee_tuck"),
            PlankExerciseName::WeightedSidePlankWithKneeTuck => {
                f.write_str("weighted_side_plank_with_knee_tuck")
            }
            PlankExerciseName::SidePlankWithLegLift => f.write_str("side_plank_with_leg_lift"),
            PlankExerciseName::WeightedSidePlankWithLegLift => {
                f.write_str("weighted_side_plank_with_leg_lift")
            }
            PlankExerciseName::SidePlankWithReachUnder => {
                f.write_str("side_plank_with_reach_under")
            }
            PlankExerciseName::WeightedSidePlankWithReachUnder => {
                f.write_str("weighted_side_plank_with_reach_under")
            }
            PlankExerciseName::SingleLegElevatedFeetPlank => {
                f.write_str("single_leg_elevated_feet_plank")
            }
            PlankExerciseName::WeightedSingleLegElevatedFeetPlank => {
                f.write_str("weighted_single_leg_elevated_feet_plank")
            }
            PlankExerciseName::SingleLegFlexAndExtend => f.write_str("single_leg_flex_and_extend"),
            PlankExerciseName::WeightedSingleLegFlexAndExtend => {
                f.write_str("weighted_single_leg_flex_and_extend")
            }
            PlankExerciseName::SingleLegSidePlank => f.write_str("single_leg_side_plank"),
            PlankExerciseName::WeightedSingleLegSidePlank => {
                f.write_str("weighted_single_leg_side_plank")
            }
            PlankExerciseName::SpidermanPlank => f.write_str("spiderman_plank"),
            PlankExerciseName::WeightedSpidermanPlank => f.write_str("weighted_spiderman_plank"),
            PlankExerciseName::StraightArmPlank => f.write_str("straight_arm_plank"),
            PlankExerciseName::WeightedStraightArmPlank => {
                f.write_str("weighted_straight_arm_plank")
            }
            PlankExerciseName::StraightArmPlankWithShoulderTouch => {
                f.write_str("straight_arm_plank_with_shoulder_touch")
            }
            PlankExerciseName::WeightedStraightArmPlankWithShoulderTouch => {
                f.write_str("weighted_straight_arm_plank_with_shoulder_touch")
            }
            PlankExerciseName::SwissBallPlank => f.write_str("swiss_ball_plank"),
            PlankExerciseName::WeightedSwissBallPlank => f.write_str("weighted_swiss_ball_plank"),
            PlankExerciseName::SwissBallPlankLegLift => f.write_str("swiss_ball_plank_leg_lift"),
            PlankExerciseName::WeightedSwissBallPlankLegLift => {
                f.write_str("weighted_swiss_ball_plank_leg_lift")
            }
            PlankExerciseName::SwissBallPlankLegLiftAndHold => {
                f.write_str("swiss_ball_plank_leg_lift_and_hold")
            }
            PlankExerciseName::SwissBallPlankWithFeetOnBench => {
                f.write_str("swiss_ball_plank_with_feet_on_bench")
            }
            PlankExerciseName::WeightedSwissBallPlankWithFeetOnBench => {
                f.write_str("weighted_swiss_ball_plank_with_feet_on_bench")
            }
            PlankExerciseName::SwissBallProneJackknife => f.write_str("swiss_ball_prone_jackknife"),
            PlankExerciseName::WeightedSwissBallProneJackknife => {
                f.write_str("weighted_swiss_ball_prone_jackknife")
            }
            PlankExerciseName::SwissBallSidePlank => f.write_str("swiss_ball_side_plank"),
            PlankExerciseName::WeightedSwissBallSidePlank => {
                f.write_str("weighted_swiss_ball_side_plank")
            }
            PlankExerciseName::ThreeWayPlank => f.write_str("three_way_plank"),
            PlankExerciseName::WeightedThreeWayPlank => f.write_str("weighted_three_way_plank"),
            PlankExerciseName::TowelPlankAndKneeIn => f.write_str("towel_plank_and_knee_in"),
            PlankExerciseName::WeightedTowelPlankAndKneeIn => {
                f.write_str("weighted_towel_plank_and_knee_in")
            }
            PlankExerciseName::TStabilization => f.write_str("t_stabilization"),
            PlankExerciseName::WeightedTStabilization => f.write_str("weighted_t_stabilization"),
            PlankExerciseName::TurkishGetUpToSidePlank => {
                f.write_str("turkish_get_up_to_side_plank")
            }
            PlankExerciseName::WeightedTurkishGetUpToSidePlank => {
                f.write_str("weighted_turkish_get_up_to_side_plank")
            }
            PlankExerciseName::TwoPointPlank => f.write_str("two_point_plank"),
            PlankExerciseName::WeightedTwoPointPlank => f.write_str("weighted_two_point_plank"),
            PlankExerciseName::WeightedPlank => f.write_str("weighted_plank"),
            PlankExerciseName::WideStancePlankWithDiagonalArmLift => {
                f.write_str("wide_stance_plank_with_diagonal_arm_lift")
            }
            PlankExerciseName::WeightedWideStancePlankWithDiagonalArmLift => {
                f.write_str("weighted_wide_stance_plank_with_diagonal_arm_lift")
            }
            PlankExerciseName::WideStancePlankWithDiagonalLegLift => {
                f.write_str("wide_stance_plank_with_diagonal_leg_lift")
            }
            PlankExerciseName::WeightedWideStancePlankWithDiagonalLegLift => {
                f.write_str("weighted_wide_stance_plank_with_diagonal_leg_lift")
            }
            PlankExerciseName::WideStancePlankWithLegLift => {
                f.write_str("wide_stance_plank_with_leg_lift")
            }
            PlankExerciseName::WeightedWideStancePlankWithLegLift => {
                f.write_str("weighted_wide_stance_plank_with_leg_lift")
            }
            PlankExerciseName::WideStancePlankWithOppositeArmAndLegLift => {
                f.write_str("wide_stance_plank_with_opposite_arm_and_leg_lift")
            }
            PlankExerciseName::WeightedMountainClimberWithHandsOnBench => {
                f.write_str("weighted_mountain_climber_with_hands_on_bench")
            }
            PlankExerciseName::WeightedSwissBallPlankLegLiftAndHold => {
                f.write_str("weighted_swiss_ball_plank_leg_lift_and_hold")
            }
            PlankExerciseName::WeightedWideStancePlankWithOppositeArmAndLegLift => {
                f.write_str("weighted_wide_stance_plank_with_opposite_arm_and_leg_lift")
            }
            PlankExerciseName::PlankWithFeetOnSwissBall => {
                f.write_str("plank_with_feet_on_swiss_ball")
            }
            PlankExerciseName::SidePlankToPlankWithReachUnder => {
                f.write_str("side_plank_to_plank_with_reach_under")
            }
            PlankExerciseName::BridgeWithGluteLowerLift => {
                f.write_str("bridge_with_glute_lower_lift")
            }
            PlankExerciseName::BridgeOneLegBridge => f.write_str("bridge_one_leg_bridge"),
            PlankExerciseName::PlankWithArmVariations => f.write_str("plank_with_arm_variations"),
            PlankExerciseName::PlankWithLegLift => f.write_str("plank_with_leg_lift"),
            PlankExerciseName::ReversePlankWithLegPull => {
                f.write_str("reverse_plank_with_leg_pull")
            }
        }
    }
}
impl PlankExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            PlankExerciseName::N45DegreePlank => fit::Value::UInt16(0),
            PlankExerciseName::Weighted45DegreePlank => fit::Value::UInt16(1),
            PlankExerciseName::N90DegreeStaticHold => fit::Value::UInt16(2),
            PlankExerciseName::Weighted90DegreeStaticHold => fit::Value::UInt16(3),
            PlankExerciseName::BearCrawl => fit::Value::UInt16(4),
            PlankExerciseName::WeightedBearCrawl => fit::Value::UInt16(5),
            PlankExerciseName::CrossBodyMountainClimber => fit::Value::UInt16(6),
            PlankExerciseName::WeightedCrossBodyMountainClimber => fit::Value::UInt16(7),
            PlankExerciseName::ElbowPlankPikeJacks => fit::Value::UInt16(8),
            PlankExerciseName::WeightedElbowPlankPikeJacks => fit::Value::UInt16(9),
            PlankExerciseName::ElevatedFeetPlank => fit::Value::UInt16(10),
            PlankExerciseName::WeightedElevatedFeetPlank => fit::Value::UInt16(11),
            PlankExerciseName::ElevatorAbs => fit::Value::UInt16(12),
            PlankExerciseName::WeightedElevatorAbs => fit::Value::UInt16(13),
            PlankExerciseName::ExtendedPlank => fit::Value::UInt16(14),
            PlankExerciseName::WeightedExtendedPlank => fit::Value::UInt16(15),
            PlankExerciseName::FullPlankPasseTwist => fit::Value::UInt16(16),
            PlankExerciseName::WeightedFullPlankPasseTwist => fit::Value::UInt16(17),
            PlankExerciseName::InchingElbowPlank => fit::Value::UInt16(18),
            PlankExerciseName::WeightedInchingElbowPlank => fit::Value::UInt16(19),
            PlankExerciseName::InchwormToSidePlank => fit::Value::UInt16(20),
            PlankExerciseName::WeightedInchwormToSidePlank => fit::Value::UInt16(21),
            PlankExerciseName::KneelingPlank => fit::Value::UInt16(22),
            PlankExerciseName::WeightedKneelingPlank => fit::Value::UInt16(23),
            PlankExerciseName::KneelingSidePlankWithLegLift => fit::Value::UInt16(24),
            PlankExerciseName::WeightedKneelingSidePlankWithLegLift => fit::Value::UInt16(25),
            PlankExerciseName::LateralRoll => fit::Value::UInt16(26),
            PlankExerciseName::WeightedLateralRoll => fit::Value::UInt16(27),
            PlankExerciseName::LyingReversePlank => fit::Value::UInt16(28),
            PlankExerciseName::WeightedLyingReversePlank => fit::Value::UInt16(29),
            PlankExerciseName::MedicineBallMountainClimber => fit::Value::UInt16(30),
            PlankExerciseName::WeightedMedicineBallMountainClimber => fit::Value::UInt16(31),
            PlankExerciseName::ModifiedMountainClimberAndExtension => fit::Value::UInt16(32),
            PlankExerciseName::WeightedModifiedMountainClimberAndExtension => {
                fit::Value::UInt16(33)
            }
            PlankExerciseName::MountainClimber => fit::Value::UInt16(34),
            PlankExerciseName::WeightedMountainClimber => fit::Value::UInt16(35),
            PlankExerciseName::MountainClimberOnSlidingDiscs => fit::Value::UInt16(36),
            PlankExerciseName::WeightedMountainClimberOnSlidingDiscs => fit::Value::UInt16(37),
            PlankExerciseName::MountainClimberWithFeetOnBosuBall => fit::Value::UInt16(38),
            PlankExerciseName::WeightedMountainClimberWithFeetOnBosuBall => fit::Value::UInt16(39),
            PlankExerciseName::MountainClimberWithHandsOnBench => fit::Value::UInt16(40),
            PlankExerciseName::MountainClimberWithHandsOnSwissBall => fit::Value::UInt16(41),
            PlankExerciseName::WeightedMountainClimberWithHandsOnSwissBall => {
                fit::Value::UInt16(42)
            }
            PlankExerciseName::Plank => fit::Value::UInt16(43),
            PlankExerciseName::PlankJacksWithFeetOnSlidingDiscs => fit::Value::UInt16(44),
            PlankExerciseName::WeightedPlankJacksWithFeetOnSlidingDiscs => fit::Value::UInt16(45),
            PlankExerciseName::PlankKneeTwist => fit::Value::UInt16(46),
            PlankExerciseName::WeightedPlankKneeTwist => fit::Value::UInt16(47),
            PlankExerciseName::PlankPikeJumps => fit::Value::UInt16(48),
            PlankExerciseName::WeightedPlankPikeJumps => fit::Value::UInt16(49),
            PlankExerciseName::PlankPikes => fit::Value::UInt16(50),
            PlankExerciseName::WeightedPlankPikes => fit::Value::UInt16(51),
            PlankExerciseName::PlankToStandUp => fit::Value::UInt16(52),
            PlankExerciseName::WeightedPlankToStandUp => fit::Value::UInt16(53),
            PlankExerciseName::PlankWithArmRaise => fit::Value::UInt16(54),
            PlankExerciseName::WeightedPlankWithArmRaise => fit::Value::UInt16(55),
            PlankExerciseName::PlankWithKneeToElbow => fit::Value::UInt16(56),
            PlankExerciseName::WeightedPlankWithKneeToElbow => fit::Value::UInt16(57),
            PlankExerciseName::PlankWithObliqueCrunch => fit::Value::UInt16(58),
            PlankExerciseName::WeightedPlankWithObliqueCrunch => fit::Value::UInt16(59),
            PlankExerciseName::PlyometricSidePlank => fit::Value::UInt16(60),
            PlankExerciseName::WeightedPlyometricSidePlank => fit::Value::UInt16(61),
            PlankExerciseName::RollingSidePlank => fit::Value::UInt16(62),
            PlankExerciseName::WeightedRollingSidePlank => fit::Value::UInt16(63),
            PlankExerciseName::SideKickPlank => fit::Value::UInt16(64),
            PlankExerciseName::WeightedSideKickPlank => fit::Value::UInt16(65),
            PlankExerciseName::SidePlank => fit::Value::UInt16(66),
            PlankExerciseName::WeightedSidePlank => fit::Value::UInt16(67),
            PlankExerciseName::SidePlankAndRow => fit::Value::UInt16(68),
            PlankExerciseName::WeightedSidePlankAndRow => fit::Value::UInt16(69),
            PlankExerciseName::SidePlankLift => fit::Value::UInt16(70),
            PlankExerciseName::WeightedSidePlankLift => fit::Value::UInt16(71),
            PlankExerciseName::SidePlankWithElbowOnBosuBall => fit::Value::UInt16(72),
            PlankExerciseName::WeightedSidePlankWithElbowOnBosuBall => fit::Value::UInt16(73),
            PlankExerciseName::SidePlankWithFeetOnBench => fit::Value::UInt16(74),
            PlankExerciseName::WeightedSidePlankWithFeetOnBench => fit::Value::UInt16(75),
            PlankExerciseName::SidePlankWithKneeCircle => fit::Value::UInt16(76),
            PlankExerciseName::WeightedSidePlankWithKneeCircle => fit::Value::UInt16(77),
            PlankExerciseName::SidePlankWithKneeTuck => fit::Value::UInt16(78),
            PlankExerciseName::WeightedSidePlankWithKneeTuck => fit::Value::UInt16(79),
            PlankExerciseName::SidePlankWithLegLift => fit::Value::UInt16(80),
            PlankExerciseName::WeightedSidePlankWithLegLift => fit::Value::UInt16(81),
            PlankExerciseName::SidePlankWithReachUnder => fit::Value::UInt16(82),
            PlankExerciseName::WeightedSidePlankWithReachUnder => fit::Value::UInt16(83),
            PlankExerciseName::SingleLegElevatedFeetPlank => fit::Value::UInt16(84),
            PlankExerciseName::WeightedSingleLegElevatedFeetPlank => fit::Value::UInt16(85),
            PlankExerciseName::SingleLegFlexAndExtend => fit::Value::UInt16(86),
            PlankExerciseName::WeightedSingleLegFlexAndExtend => fit::Value::UInt16(87),
            PlankExerciseName::SingleLegSidePlank => fit::Value::UInt16(88),
            PlankExerciseName::WeightedSingleLegSidePlank => fit::Value::UInt16(89),
            PlankExerciseName::SpidermanPlank => fit::Value::UInt16(90),
            PlankExerciseName::WeightedSpidermanPlank => fit::Value::UInt16(91),
            PlankExerciseName::StraightArmPlank => fit::Value::UInt16(92),
            PlankExerciseName::WeightedStraightArmPlank => fit::Value::UInt16(93),
            PlankExerciseName::StraightArmPlankWithShoulderTouch => fit::Value::UInt16(94),
            PlankExerciseName::WeightedStraightArmPlankWithShoulderTouch => fit::Value::UInt16(95),
            PlankExerciseName::SwissBallPlank => fit::Value::UInt16(96),
            PlankExerciseName::WeightedSwissBallPlank => fit::Value::UInt16(97),
            PlankExerciseName::SwissBallPlankLegLift => fit::Value::UInt16(98),
            PlankExerciseName::WeightedSwissBallPlankLegLift => fit::Value::UInt16(99),
            PlankExerciseName::SwissBallPlankLegLiftAndHold => fit::Value::UInt16(100),
            PlankExerciseName::SwissBallPlankWithFeetOnBench => fit::Value::UInt16(101),
            PlankExerciseName::WeightedSwissBallPlankWithFeetOnBench => fit::Value::UInt16(102),
            PlankExerciseName::SwissBallProneJackknife => fit::Value::UInt16(103),
            PlankExerciseName::WeightedSwissBallProneJackknife => fit::Value::UInt16(104),
            PlankExerciseName::SwissBallSidePlank => fit::Value::UInt16(105),
            PlankExerciseName::WeightedSwissBallSidePlank => fit::Value::UInt16(106),
            PlankExerciseName::ThreeWayPlank => fit::Value::UInt16(107),
            PlankExerciseName::WeightedThreeWayPlank => fit::Value::UInt16(108),
            PlankExerciseName::TowelPlankAndKneeIn => fit::Value::UInt16(109),
            PlankExerciseName::WeightedTowelPlankAndKneeIn => fit::Value::UInt16(110),
            PlankExerciseName::TStabilization => fit::Value::UInt16(111),
            PlankExerciseName::WeightedTStabilization => fit::Value::UInt16(112),
            PlankExerciseName::TurkishGetUpToSidePlank => fit::Value::UInt16(113),
            PlankExerciseName::WeightedTurkishGetUpToSidePlank => fit::Value::UInt16(114),
            PlankExerciseName::TwoPointPlank => fit::Value::UInt16(115),
            PlankExerciseName::WeightedTwoPointPlank => fit::Value::UInt16(116),
            PlankExerciseName::WeightedPlank => fit::Value::UInt16(117),
            PlankExerciseName::WideStancePlankWithDiagonalArmLift => fit::Value::UInt16(118),
            PlankExerciseName::WeightedWideStancePlankWithDiagonalArmLift => {
                fit::Value::UInt16(119)
            }
            PlankExerciseName::WideStancePlankWithDiagonalLegLift => fit::Value::UInt16(120),
            PlankExerciseName::WeightedWideStancePlankWithDiagonalLegLift => {
                fit::Value::UInt16(121)
            }
            PlankExerciseName::WideStancePlankWithLegLift => fit::Value::UInt16(122),
            PlankExerciseName::WeightedWideStancePlankWithLegLift => fit::Value::UInt16(123),
            PlankExerciseName::WideStancePlankWithOppositeArmAndLegLift => fit::Value::UInt16(124),
            PlankExerciseName::WeightedMountainClimberWithHandsOnBench => fit::Value::UInt16(125),
            PlankExerciseName::WeightedSwissBallPlankLegLiftAndHold => fit::Value::UInt16(126),
            PlankExerciseName::WeightedWideStancePlankWithOppositeArmAndLegLift => {
                fit::Value::UInt16(127)
            }
            PlankExerciseName::PlankWithFeetOnSwissBall => fit::Value::UInt16(128),
            PlankExerciseName::SidePlankToPlankWithReachUnder => fit::Value::UInt16(129),
            PlankExerciseName::BridgeWithGluteLowerLift => fit::Value::UInt16(130),
            PlankExerciseName::BridgeOneLegBridge => fit::Value::UInt16(131),
            PlankExerciseName::PlankWithArmVariations => fit::Value::UInt16(132),
            PlankExerciseName::PlankWithLegLift => fit::Value::UInt16(133),
            PlankExerciseName::ReversePlankWithLegPull => fit::Value::UInt16(134),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for PlankExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(PlankExerciseName::N45DegreePlank),
            fit::Value::UInt16(1) => Ok(PlankExerciseName::Weighted45DegreePlank),
            fit::Value::UInt16(2) => Ok(PlankExerciseName::N90DegreeStaticHold),
            fit::Value::UInt16(3) => Ok(PlankExerciseName::Weighted90DegreeStaticHold),
            fit::Value::UInt16(4) => Ok(PlankExerciseName::BearCrawl),
            fit::Value::UInt16(5) => Ok(PlankExerciseName::WeightedBearCrawl),
            fit::Value::UInt16(6) => Ok(PlankExerciseName::CrossBodyMountainClimber),
            fit::Value::UInt16(7) => Ok(PlankExerciseName::WeightedCrossBodyMountainClimber),
            fit::Value::UInt16(8) => Ok(PlankExerciseName::ElbowPlankPikeJacks),
            fit::Value::UInt16(9) => Ok(PlankExerciseName::WeightedElbowPlankPikeJacks),
            fit::Value::UInt16(10) => Ok(PlankExerciseName::ElevatedFeetPlank),
            fit::Value::UInt16(11) => Ok(PlankExerciseName::WeightedElevatedFeetPlank),
            fit::Value::UInt16(12) => Ok(PlankExerciseName::ElevatorAbs),
            fit::Value::UInt16(13) => Ok(PlankExerciseName::WeightedElevatorAbs),
            fit::Value::UInt16(14) => Ok(PlankExerciseName::ExtendedPlank),
            fit::Value::UInt16(15) => Ok(PlankExerciseName::WeightedExtendedPlank),
            fit::Value::UInt16(16) => Ok(PlankExerciseName::FullPlankPasseTwist),
            fit::Value::UInt16(17) => Ok(PlankExerciseName::WeightedFullPlankPasseTwist),
            fit::Value::UInt16(18) => Ok(PlankExerciseName::InchingElbowPlank),
            fit::Value::UInt16(19) => Ok(PlankExerciseName::WeightedInchingElbowPlank),
            fit::Value::UInt16(20) => Ok(PlankExerciseName::InchwormToSidePlank),
            fit::Value::UInt16(21) => Ok(PlankExerciseName::WeightedInchwormToSidePlank),
            fit::Value::UInt16(22) => Ok(PlankExerciseName::KneelingPlank),
            fit::Value::UInt16(23) => Ok(PlankExerciseName::WeightedKneelingPlank),
            fit::Value::UInt16(24) => Ok(PlankExerciseName::KneelingSidePlankWithLegLift),
            fit::Value::UInt16(25) => Ok(PlankExerciseName::WeightedKneelingSidePlankWithLegLift),
            fit::Value::UInt16(26) => Ok(PlankExerciseName::LateralRoll),
            fit::Value::UInt16(27) => Ok(PlankExerciseName::WeightedLateralRoll),
            fit::Value::UInt16(28) => Ok(PlankExerciseName::LyingReversePlank),
            fit::Value::UInt16(29) => Ok(PlankExerciseName::WeightedLyingReversePlank),
            fit::Value::UInt16(30) => Ok(PlankExerciseName::MedicineBallMountainClimber),
            fit::Value::UInt16(31) => Ok(PlankExerciseName::WeightedMedicineBallMountainClimber),
            fit::Value::UInt16(32) => Ok(PlankExerciseName::ModifiedMountainClimberAndExtension),
            fit::Value::UInt16(33) => {
                Ok(PlankExerciseName::WeightedModifiedMountainClimberAndExtension)
            }
            fit::Value::UInt16(34) => Ok(PlankExerciseName::MountainClimber),
            fit::Value::UInt16(35) => Ok(PlankExerciseName::WeightedMountainClimber),
            fit::Value::UInt16(36) => Ok(PlankExerciseName::MountainClimberOnSlidingDiscs),
            fit::Value::UInt16(37) => Ok(PlankExerciseName::WeightedMountainClimberOnSlidingDiscs),
            fit::Value::UInt16(38) => Ok(PlankExerciseName::MountainClimberWithFeetOnBosuBall),
            fit::Value::UInt16(39) => {
                Ok(PlankExerciseName::WeightedMountainClimberWithFeetOnBosuBall)
            }
            fit::Value::UInt16(40) => Ok(PlankExerciseName::MountainClimberWithHandsOnBench),
            fit::Value::UInt16(41) => Ok(PlankExerciseName::MountainClimberWithHandsOnSwissBall),
            fit::Value::UInt16(42) => {
                Ok(PlankExerciseName::WeightedMountainClimberWithHandsOnSwissBall)
            }
            fit::Value::UInt16(43) => Ok(PlankExerciseName::Plank),
            fit::Value::UInt16(44) => Ok(PlankExerciseName::PlankJacksWithFeetOnSlidingDiscs),
            fit::Value::UInt16(45) => {
                Ok(PlankExerciseName::WeightedPlankJacksWithFeetOnSlidingDiscs)
            }
            fit::Value::UInt16(46) => Ok(PlankExerciseName::PlankKneeTwist),
            fit::Value::UInt16(47) => Ok(PlankExerciseName::WeightedPlankKneeTwist),
            fit::Value::UInt16(48) => Ok(PlankExerciseName::PlankPikeJumps),
            fit::Value::UInt16(49) => Ok(PlankExerciseName::WeightedPlankPikeJumps),
            fit::Value::UInt16(50) => Ok(PlankExerciseName::PlankPikes),
            fit::Value::UInt16(51) => Ok(PlankExerciseName::WeightedPlankPikes),
            fit::Value::UInt16(52) => Ok(PlankExerciseName::PlankToStandUp),
            fit::Value::UInt16(53) => Ok(PlankExerciseName::WeightedPlankToStandUp),
            fit::Value::UInt16(54) => Ok(PlankExerciseName::PlankWithArmRaise),
            fit::Value::UInt16(55) => Ok(PlankExerciseName::WeightedPlankWithArmRaise),
            fit::Value::UInt16(56) => Ok(PlankExerciseName::PlankWithKneeToElbow),
            fit::Value::UInt16(57) => Ok(PlankExerciseName::WeightedPlankWithKneeToElbow),
            fit::Value::UInt16(58) => Ok(PlankExerciseName::PlankWithObliqueCrunch),
            fit::Value::UInt16(59) => Ok(PlankExerciseName::WeightedPlankWithObliqueCrunch),
            fit::Value::UInt16(60) => Ok(PlankExerciseName::PlyometricSidePlank),
            fit::Value::UInt16(61) => Ok(PlankExerciseName::WeightedPlyometricSidePlank),
            fit::Value::UInt16(62) => Ok(PlankExerciseName::RollingSidePlank),
            fit::Value::UInt16(63) => Ok(PlankExerciseName::WeightedRollingSidePlank),
            fit::Value::UInt16(64) => Ok(PlankExerciseName::SideKickPlank),
            fit::Value::UInt16(65) => Ok(PlankExerciseName::WeightedSideKickPlank),
            fit::Value::UInt16(66) => Ok(PlankExerciseName::SidePlank),
            fit::Value::UInt16(67) => Ok(PlankExerciseName::WeightedSidePlank),
            fit::Value::UInt16(68) => Ok(PlankExerciseName::SidePlankAndRow),
            fit::Value::UInt16(69) => Ok(PlankExerciseName::WeightedSidePlankAndRow),
            fit::Value::UInt16(70) => Ok(PlankExerciseName::SidePlankLift),
            fit::Value::UInt16(71) => Ok(PlankExerciseName::WeightedSidePlankLift),
            fit::Value::UInt16(72) => Ok(PlankExerciseName::SidePlankWithElbowOnBosuBall),
            fit::Value::UInt16(73) => Ok(PlankExerciseName::WeightedSidePlankWithElbowOnBosuBall),
            fit::Value::UInt16(74) => Ok(PlankExerciseName::SidePlankWithFeetOnBench),
            fit::Value::UInt16(75) => Ok(PlankExerciseName::WeightedSidePlankWithFeetOnBench),
            fit::Value::UInt16(76) => Ok(PlankExerciseName::SidePlankWithKneeCircle),
            fit::Value::UInt16(77) => Ok(PlankExerciseName::WeightedSidePlankWithKneeCircle),
            fit::Value::UInt16(78) => Ok(PlankExerciseName::SidePlankWithKneeTuck),
            fit::Value::UInt16(79) => Ok(PlankExerciseName::WeightedSidePlankWithKneeTuck),
            fit::Value::UInt16(80) => Ok(PlankExerciseName::SidePlankWithLegLift),
            fit::Value::UInt16(81) => Ok(PlankExerciseName::WeightedSidePlankWithLegLift),
            fit::Value::UInt16(82) => Ok(PlankExerciseName::SidePlankWithReachUnder),
            fit::Value::UInt16(83) => Ok(PlankExerciseName::WeightedSidePlankWithReachUnder),
            fit::Value::UInt16(84) => Ok(PlankExerciseName::SingleLegElevatedFeetPlank),
            fit::Value::UInt16(85) => Ok(PlankExerciseName::WeightedSingleLegElevatedFeetPlank),
            fit::Value::UInt16(86) => Ok(PlankExerciseName::SingleLegFlexAndExtend),
            fit::Value::UInt16(87) => Ok(PlankExerciseName::WeightedSingleLegFlexAndExtend),
            fit::Value::UInt16(88) => Ok(PlankExerciseName::SingleLegSidePlank),
            fit::Value::UInt16(89) => Ok(PlankExerciseName::WeightedSingleLegSidePlank),
            fit::Value::UInt16(90) => Ok(PlankExerciseName::SpidermanPlank),
            fit::Value::UInt16(91) => Ok(PlankExerciseName::WeightedSpidermanPlank),
            fit::Value::UInt16(92) => Ok(PlankExerciseName::StraightArmPlank),
            fit::Value::UInt16(93) => Ok(PlankExerciseName::WeightedStraightArmPlank),
            fit::Value::UInt16(94) => Ok(PlankExerciseName::StraightArmPlankWithShoulderTouch),
            fit::Value::UInt16(95) => {
                Ok(PlankExerciseName::WeightedStraightArmPlankWithShoulderTouch)
            }
            fit::Value::UInt16(96) => Ok(PlankExerciseName::SwissBallPlank),
            fit::Value::UInt16(97) => Ok(PlankExerciseName::WeightedSwissBallPlank),
            fit::Value::UInt16(98) => Ok(PlankExerciseName::SwissBallPlankLegLift),
            fit::Value::UInt16(99) => Ok(PlankExerciseName::WeightedSwissBallPlankLegLift),
            fit::Value::UInt16(100) => Ok(PlankExerciseName::SwissBallPlankLegLiftAndHold),
            fit::Value::UInt16(101) => Ok(PlankExerciseName::SwissBallPlankWithFeetOnBench),
            fit::Value::UInt16(102) => Ok(PlankExerciseName::WeightedSwissBallPlankWithFeetOnBench),
            fit::Value::UInt16(103) => Ok(PlankExerciseName::SwissBallProneJackknife),
            fit::Value::UInt16(104) => Ok(PlankExerciseName::WeightedSwissBallProneJackknife),
            fit::Value::UInt16(105) => Ok(PlankExerciseName::SwissBallSidePlank),
            fit::Value::UInt16(106) => Ok(PlankExerciseName::WeightedSwissBallSidePlank),
            fit::Value::UInt16(107) => Ok(PlankExerciseName::ThreeWayPlank),
            fit::Value::UInt16(108) => Ok(PlankExerciseName::WeightedThreeWayPlank),
            fit::Value::UInt16(109) => Ok(PlankExerciseName::TowelPlankAndKneeIn),
            fit::Value::UInt16(110) => Ok(PlankExerciseName::WeightedTowelPlankAndKneeIn),
            fit::Value::UInt16(111) => Ok(PlankExerciseName::TStabilization),
            fit::Value::UInt16(112) => Ok(PlankExerciseName::WeightedTStabilization),
            fit::Value::UInt16(113) => Ok(PlankExerciseName::TurkishGetUpToSidePlank),
            fit::Value::UInt16(114) => Ok(PlankExerciseName::WeightedTurkishGetUpToSidePlank),
            fit::Value::UInt16(115) => Ok(PlankExerciseName::TwoPointPlank),
            fit::Value::UInt16(116) => Ok(PlankExerciseName::WeightedTwoPointPlank),
            fit::Value::UInt16(117) => Ok(PlankExerciseName::WeightedPlank),
            fit::Value::UInt16(118) => Ok(PlankExerciseName::WideStancePlankWithDiagonalArmLift),
            fit::Value::UInt16(119) => {
                Ok(PlankExerciseName::WeightedWideStancePlankWithDiagonalArmLift)
            }
            fit::Value::UInt16(120) => Ok(PlankExerciseName::WideStancePlankWithDiagonalLegLift),
            fit::Value::UInt16(121) => {
                Ok(PlankExerciseName::WeightedWideStancePlankWithDiagonalLegLift)
            }
            fit::Value::UInt16(122) => Ok(PlankExerciseName::WideStancePlankWithLegLift),
            fit::Value::UInt16(123) => Ok(PlankExerciseName::WeightedWideStancePlankWithLegLift),
            fit::Value::UInt16(124) => {
                Ok(PlankExerciseName::WideStancePlankWithOppositeArmAndLegLift)
            }
            fit::Value::UInt16(125) => {
                Ok(PlankExerciseName::WeightedMountainClimberWithHandsOnBench)
            }
            fit::Value::UInt16(126) => Ok(PlankExerciseName::WeightedSwissBallPlankLegLiftAndHold),
            fit::Value::UInt16(127) => {
                Ok(PlankExerciseName::WeightedWideStancePlankWithOppositeArmAndLegLift)
            }
            fit::Value::UInt16(128) => Ok(PlankExerciseName::PlankWithFeetOnSwissBall),
            fit::Value::UInt16(129) => Ok(PlankExerciseName::SidePlankToPlankWithReachUnder),
            fit::Value::UInt16(130) => Ok(PlankExerciseName::BridgeWithGluteLowerLift),
            fit::Value::UInt16(131) => Ok(PlankExerciseName::BridgeOneLegBridge),
            fit::Value::UInt16(132) => Ok(PlankExerciseName::PlankWithArmVariations),
            fit::Value::UInt16(133) => Ok(PlankExerciseName::PlankWithLegLift),
            fit::Value::UInt16(134) => Ok(PlankExerciseName::ReversePlankWithLegPull),
            _ => Err("No corresponding PlankExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for PlankExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "45_degree_plank" => Ok(PlankExerciseName::N45DegreePlank),
            "weighted_45_degree_plank" => Ok(PlankExerciseName::Weighted45DegreePlank),
            "90_degree_static_hold" => Ok(PlankExerciseName::N90DegreeStaticHold),
            "weighted_90_degree_static_hold" => Ok(PlankExerciseName::Weighted90DegreeStaticHold),
            "bear_crawl" => Ok(PlankExerciseName::BearCrawl),
            "weighted_bear_crawl" => Ok(PlankExerciseName::WeightedBearCrawl),
            "cross_body_mountain_climber" => Ok(PlankExerciseName::CrossBodyMountainClimber),
            "weighted_cross_body_mountain_climber" => {
                Ok(PlankExerciseName::WeightedCrossBodyMountainClimber)
            }
            "elbow_plank_pike_jacks" => Ok(PlankExerciseName::ElbowPlankPikeJacks),
            "weighted_elbow_plank_pike_jacks" => Ok(PlankExerciseName::WeightedElbowPlankPikeJacks),
            "elevated_feet_plank" => Ok(PlankExerciseName::ElevatedFeetPlank),
            "weighted_elevated_feet_plank" => Ok(PlankExerciseName::WeightedElevatedFeetPlank),
            "elevator_abs" => Ok(PlankExerciseName::ElevatorAbs),
            "weighted_elevator_abs" => Ok(PlankExerciseName::WeightedElevatorAbs),
            "extended_plank" => Ok(PlankExerciseName::ExtendedPlank),
            "weighted_extended_plank" => Ok(PlankExerciseName::WeightedExtendedPlank),
            "full_plank_passe_twist" => Ok(PlankExerciseName::FullPlankPasseTwist),
            "weighted_full_plank_passe_twist" => Ok(PlankExerciseName::WeightedFullPlankPasseTwist),
            "inching_elbow_plank" => Ok(PlankExerciseName::InchingElbowPlank),
            "weighted_inching_elbow_plank" => Ok(PlankExerciseName::WeightedInchingElbowPlank),
            "inchworm_to_side_plank" => Ok(PlankExerciseName::InchwormToSidePlank),
            "weighted_inchworm_to_side_plank" => Ok(PlankExerciseName::WeightedInchwormToSidePlank),
            "kneeling_plank" => Ok(PlankExerciseName::KneelingPlank),
            "weighted_kneeling_plank" => Ok(PlankExerciseName::WeightedKneelingPlank),
            "kneeling_side_plank_with_leg_lift" => {
                Ok(PlankExerciseName::KneelingSidePlankWithLegLift)
            }
            "weighted_kneeling_side_plank_with_leg_lift" => {
                Ok(PlankExerciseName::WeightedKneelingSidePlankWithLegLift)
            }
            "lateral_roll" => Ok(PlankExerciseName::LateralRoll),
            "weighted_lateral_roll" => Ok(PlankExerciseName::WeightedLateralRoll),
            "lying_reverse_plank" => Ok(PlankExerciseName::LyingReversePlank),
            "weighted_lying_reverse_plank" => Ok(PlankExerciseName::WeightedLyingReversePlank),
            "medicine_ball_mountain_climber" => Ok(PlankExerciseName::MedicineBallMountainClimber),
            "weighted_medicine_ball_mountain_climber" => {
                Ok(PlankExerciseName::WeightedMedicineBallMountainClimber)
            }
            "modified_mountain_climber_and_extension" => {
                Ok(PlankExerciseName::ModifiedMountainClimberAndExtension)
            }
            "weighted_modified_mountain_climber_and_extension" => {
                Ok(PlankExerciseName::WeightedModifiedMountainClimberAndExtension)
            }
            "mountain_climber" => Ok(PlankExerciseName::MountainClimber),
            "weighted_mountain_climber" => Ok(PlankExerciseName::WeightedMountainClimber),
            "mountain_climber_on_sliding_discs" => {
                Ok(PlankExerciseName::MountainClimberOnSlidingDiscs)
            }
            "weighted_mountain_climber_on_sliding_discs" => {
                Ok(PlankExerciseName::WeightedMountainClimberOnSlidingDiscs)
            }
            "mountain_climber_with_feet_on_bosu_ball" => {
                Ok(PlankExerciseName::MountainClimberWithFeetOnBosuBall)
            }
            "weighted_mountain_climber_with_feet_on_bosu_ball" => {
                Ok(PlankExerciseName::WeightedMountainClimberWithFeetOnBosuBall)
            }
            "mountain_climber_with_hands_on_bench" => {
                Ok(PlankExerciseName::MountainClimberWithHandsOnBench)
            }
            "mountain_climber_with_hands_on_swiss_ball" => {
                Ok(PlankExerciseName::MountainClimberWithHandsOnSwissBall)
            }
            "weighted_mountain_climber_with_hands_on_swiss_ball" => {
                Ok(PlankExerciseName::WeightedMountainClimberWithHandsOnSwissBall)
            }
            "plank" => Ok(PlankExerciseName::Plank),
            "plank_jacks_with_feet_on_sliding_discs" => {
                Ok(PlankExerciseName::PlankJacksWithFeetOnSlidingDiscs)
            }
            "weighted_plank_jacks_with_feet_on_sliding_discs" => {
                Ok(PlankExerciseName::WeightedPlankJacksWithFeetOnSlidingDiscs)
            }
            "plank_knee_twist" => Ok(PlankExerciseName::PlankKneeTwist),
            "weighted_plank_knee_twist" => Ok(PlankExerciseName::WeightedPlankKneeTwist),
            "plank_pike_jumps" => Ok(PlankExerciseName::PlankPikeJumps),
            "weighted_plank_pike_jumps" => Ok(PlankExerciseName::WeightedPlankPikeJumps),
            "plank_pikes" => Ok(PlankExerciseName::PlankPikes),
            "weighted_plank_pikes" => Ok(PlankExerciseName::WeightedPlankPikes),
            "plank_to_stand_up" => Ok(PlankExerciseName::PlankToStandUp),
            "weighted_plank_to_stand_up" => Ok(PlankExerciseName::WeightedPlankToStandUp),
            "plank_with_arm_raise" => Ok(PlankExerciseName::PlankWithArmRaise),
            "weighted_plank_with_arm_raise" => Ok(PlankExerciseName::WeightedPlankWithArmRaise),
            "plank_with_knee_to_elbow" => Ok(PlankExerciseName::PlankWithKneeToElbow),
            "weighted_plank_with_knee_to_elbow" => {
                Ok(PlankExerciseName::WeightedPlankWithKneeToElbow)
            }
            "plank_with_oblique_crunch" => Ok(PlankExerciseName::PlankWithObliqueCrunch),
            "weighted_plank_with_oblique_crunch" => {
                Ok(PlankExerciseName::WeightedPlankWithObliqueCrunch)
            }
            "plyometric_side_plank" => Ok(PlankExerciseName::PlyometricSidePlank),
            "weighted_plyometric_side_plank" => Ok(PlankExerciseName::WeightedPlyometricSidePlank),
            "rolling_side_plank" => Ok(PlankExerciseName::RollingSidePlank),
            "weighted_rolling_side_plank" => Ok(PlankExerciseName::WeightedRollingSidePlank),
            "side_kick_plank" => Ok(PlankExerciseName::SideKickPlank),
            "weighted_side_kick_plank" => Ok(PlankExerciseName::WeightedSideKickPlank),
            "side_plank" => Ok(PlankExerciseName::SidePlank),
            "weighted_side_plank" => Ok(PlankExerciseName::WeightedSidePlank),
            "side_plank_and_row" => Ok(PlankExerciseName::SidePlankAndRow),
            "weighted_side_plank_and_row" => Ok(PlankExerciseName::WeightedSidePlankAndRow),
            "side_plank_lift" => Ok(PlankExerciseName::SidePlankLift),
            "weighted_side_plank_lift" => Ok(PlankExerciseName::WeightedSidePlankLift),
            "side_plank_with_elbow_on_bosu_ball" => {
                Ok(PlankExerciseName::SidePlankWithElbowOnBosuBall)
            }
            "weighted_side_plank_with_elbow_on_bosu_ball" => {
                Ok(PlankExerciseName::WeightedSidePlankWithElbowOnBosuBall)
            }
            "side_plank_with_feet_on_bench" => Ok(PlankExerciseName::SidePlankWithFeetOnBench),
            "weighted_side_plank_with_feet_on_bench" => {
                Ok(PlankExerciseName::WeightedSidePlankWithFeetOnBench)
            }
            "side_plank_with_knee_circle" => Ok(PlankExerciseName::SidePlankWithKneeCircle),
            "weighted_side_plank_with_knee_circle" => {
                Ok(PlankExerciseName::WeightedSidePlankWithKneeCircle)
            }
            "side_plank_with_knee_tuck" => Ok(PlankExerciseName::SidePlankWithKneeTuck),
            "weighted_side_plank_with_knee_tuck" => {
                Ok(PlankExerciseName::WeightedSidePlankWithKneeTuck)
            }
            "side_plank_with_leg_lift" => Ok(PlankExerciseName::SidePlankWithLegLift),
            "weighted_side_plank_with_leg_lift" => {
                Ok(PlankExerciseName::WeightedSidePlankWithLegLift)
            }
            "side_plank_with_reach_under" => Ok(PlankExerciseName::SidePlankWithReachUnder),
            "weighted_side_plank_with_reach_under" => {
                Ok(PlankExerciseName::WeightedSidePlankWithReachUnder)
            }
            "single_leg_elevated_feet_plank" => Ok(PlankExerciseName::SingleLegElevatedFeetPlank),
            "weighted_single_leg_elevated_feet_plank" => {
                Ok(PlankExerciseName::WeightedSingleLegElevatedFeetPlank)
            }
            "single_leg_flex_and_extend" => Ok(PlankExerciseName::SingleLegFlexAndExtend),
            "weighted_single_leg_flex_and_extend" => {
                Ok(PlankExerciseName::WeightedSingleLegFlexAndExtend)
            }
            "single_leg_side_plank" => Ok(PlankExerciseName::SingleLegSidePlank),
            "weighted_single_leg_side_plank" => Ok(PlankExerciseName::WeightedSingleLegSidePlank),
            "spiderman_plank" => Ok(PlankExerciseName::SpidermanPlank),
            "weighted_spiderman_plank" => Ok(PlankExerciseName::WeightedSpidermanPlank),
            "straight_arm_plank" => Ok(PlankExerciseName::StraightArmPlank),
            "weighted_straight_arm_plank" => Ok(PlankExerciseName::WeightedStraightArmPlank),
            "straight_arm_plank_with_shoulder_touch" => {
                Ok(PlankExerciseName::StraightArmPlankWithShoulderTouch)
            }
            "weighted_straight_arm_plank_with_shoulder_touch" => {
                Ok(PlankExerciseName::WeightedStraightArmPlankWithShoulderTouch)
            }
            "swiss_ball_plank" => Ok(PlankExerciseName::SwissBallPlank),
            "weighted_swiss_ball_plank" => Ok(PlankExerciseName::WeightedSwissBallPlank),
            "swiss_ball_plank_leg_lift" => Ok(PlankExerciseName::SwissBallPlankLegLift),
            "weighted_swiss_ball_plank_leg_lift" => {
                Ok(PlankExerciseName::WeightedSwissBallPlankLegLift)
            }
            "swiss_ball_plank_leg_lift_and_hold" => {
                Ok(PlankExerciseName::SwissBallPlankLegLiftAndHold)
            }
            "swiss_ball_plank_with_feet_on_bench" => {
                Ok(PlankExerciseName::SwissBallPlankWithFeetOnBench)
            }
            "weighted_swiss_ball_plank_with_feet_on_bench" => {
                Ok(PlankExerciseName::WeightedSwissBallPlankWithFeetOnBench)
            }
            "swiss_ball_prone_jackknife" => Ok(PlankExerciseName::SwissBallProneJackknife),
            "weighted_swiss_ball_prone_jackknife" => {
                Ok(PlankExerciseName::WeightedSwissBallProneJackknife)
            }
            "swiss_ball_side_plank" => Ok(PlankExerciseName::SwissBallSidePlank),
            "weighted_swiss_ball_side_plank" => Ok(PlankExerciseName::WeightedSwissBallSidePlank),
            "three_way_plank" => Ok(PlankExerciseName::ThreeWayPlank),
            "weighted_three_way_plank" => Ok(PlankExerciseName::WeightedThreeWayPlank),
            "towel_plank_and_knee_in" => Ok(PlankExerciseName::TowelPlankAndKneeIn),
            "weighted_towel_plank_and_knee_in" => {
                Ok(PlankExerciseName::WeightedTowelPlankAndKneeIn)
            }
            "t_stabilization" => Ok(PlankExerciseName::TStabilization),
            "weighted_t_stabilization" => Ok(PlankExerciseName::WeightedTStabilization),
            "turkish_get_up_to_side_plank" => Ok(PlankExerciseName::TurkishGetUpToSidePlank),
            "weighted_turkish_get_up_to_side_plank" => {
                Ok(PlankExerciseName::WeightedTurkishGetUpToSidePlank)
            }
            "two_point_plank" => Ok(PlankExerciseName::TwoPointPlank),
            "weighted_two_point_plank" => Ok(PlankExerciseName::WeightedTwoPointPlank),
            "weighted_plank" => Ok(PlankExerciseName::WeightedPlank),
            "wide_stance_plank_with_diagonal_arm_lift" => {
                Ok(PlankExerciseName::WideStancePlankWithDiagonalArmLift)
            }
            "weighted_wide_stance_plank_with_diagonal_arm_lift" => {
                Ok(PlankExerciseName::WeightedWideStancePlankWithDiagonalArmLift)
            }
            "wide_stance_plank_with_diagonal_leg_lift" => {
                Ok(PlankExerciseName::WideStancePlankWithDiagonalLegLift)
            }
            "weighted_wide_stance_plank_with_diagonal_leg_lift" => {
                Ok(PlankExerciseName::WeightedWideStancePlankWithDiagonalLegLift)
            }
            "wide_stance_plank_with_leg_lift" => Ok(PlankExerciseName::WideStancePlankWithLegLift),
            "weighted_wide_stance_plank_with_leg_lift" => {
                Ok(PlankExerciseName::WeightedWideStancePlankWithLegLift)
            }
            "wide_stance_plank_with_opposite_arm_and_leg_lift" => {
                Ok(PlankExerciseName::WideStancePlankWithOppositeArmAndLegLift)
            }
            "weighted_mountain_climber_with_hands_on_bench" => {
                Ok(PlankExerciseName::WeightedMountainClimberWithHandsOnBench)
            }
            "weighted_swiss_ball_plank_leg_lift_and_hold" => {
                Ok(PlankExerciseName::WeightedSwissBallPlankLegLiftAndHold)
            }
            "weighted_wide_stance_plank_with_opposite_arm_and_leg_lift" => {
                Ok(PlankExerciseName::WeightedWideStancePlankWithOppositeArmAndLegLift)
            }
            "plank_with_feet_on_swiss_ball" => Ok(PlankExerciseName::PlankWithFeetOnSwissBall),
            "side_plank_to_plank_with_reach_under" => {
                Ok(PlankExerciseName::SidePlankToPlankWithReachUnder)
            }
            "bridge_with_glute_lower_lift" => Ok(PlankExerciseName::BridgeWithGluteLowerLift),
            "bridge_one_leg_bridge" => Ok(PlankExerciseName::BridgeOneLegBridge),
            "plank_with_arm_variations" => Ok(PlankExerciseName::PlankWithArmVariations),
            "plank_with_leg_lift" => Ok(PlankExerciseName::PlankWithLegLift),
            "reverse_plank_with_leg_pull" => Ok(PlankExerciseName::ReversePlankWithLegPull),
            _ => Err("No corresponding PlankExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum PlyoExerciseName {
    AlternatingJumpLunge,
    WeightedAlternatingJumpLunge,
    BarbellJumpSquat,
    BodyWeightJumpSquat,
    WeightedJumpSquat,
    CrossKneeStrike,
    WeightedCrossKneeStrike,
    DepthJump,
    WeightedDepthJump,
    DumbbellJumpSquat,
    DumbbellSplitJump,
    FrontKneeStrike,
    WeightedFrontKneeStrike,
    HighBoxJump,
    WeightedHighBoxJump,
    IsometricExplosiveBodyWeightJumpSquat,
    WeightedIsometricExplosiveJumpSquat,
    LateralLeapAndHop,
    WeightedLateralLeapAndHop,
    LateralPlyoSquats,
    WeightedLateralPlyoSquats,
    LateralSlide,
    WeightedLateralSlide,
    MedicineBallOverheadThrows,
    MedicineBallSideThrow,
    MedicineBallSlam,
    SideToSideMedicineBallThrows,
    SideToSideShuffleJump,
    WeightedSideToSideShuffleJump,
    SquatJumpOntoBox,
    WeightedSquatJumpOntoBox,
    SquatJumpsInAndOut,
    WeightedSquatJumpsInAndOut,
}
impl fmt::Display for PlyoExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PlyoExerciseName::AlternatingJumpLunge => f.write_str("alternating_jump_lunge"),
            PlyoExerciseName::WeightedAlternatingJumpLunge => {
                f.write_str("weighted_alternating_jump_lunge")
            }
            PlyoExerciseName::BarbellJumpSquat => f.write_str("barbell_jump_squat"),
            PlyoExerciseName::BodyWeightJumpSquat => f.write_str("body_weight_jump_squat"),
            PlyoExerciseName::WeightedJumpSquat => f.write_str("weighted_jump_squat"),
            PlyoExerciseName::CrossKneeStrike => f.write_str("cross_knee_strike"),
            PlyoExerciseName::WeightedCrossKneeStrike => f.write_str("weighted_cross_knee_strike"),
            PlyoExerciseName::DepthJump => f.write_str("depth_jump"),
            PlyoExerciseName::WeightedDepthJump => f.write_str("weighted_depth_jump"),
            PlyoExerciseName::DumbbellJumpSquat => f.write_str("dumbbell_jump_squat"),
            PlyoExerciseName::DumbbellSplitJump => f.write_str("dumbbell_split_jump"),
            PlyoExerciseName::FrontKneeStrike => f.write_str("front_knee_strike"),
            PlyoExerciseName::WeightedFrontKneeStrike => f.write_str("weighted_front_knee_strike"),
            PlyoExerciseName::HighBoxJump => f.write_str("high_box_jump"),
            PlyoExerciseName::WeightedHighBoxJump => f.write_str("weighted_high_box_jump"),
            PlyoExerciseName::IsometricExplosiveBodyWeightJumpSquat => {
                f.write_str("isometric_explosive_body_weight_jump_squat")
            }
            PlyoExerciseName::WeightedIsometricExplosiveJumpSquat => {
                f.write_str("weighted_isometric_explosive_jump_squat")
            }
            PlyoExerciseName::LateralLeapAndHop => f.write_str("lateral_leap_and_hop"),
            PlyoExerciseName::WeightedLateralLeapAndHop => {
                f.write_str("weighted_lateral_leap_and_hop")
            }
            PlyoExerciseName::LateralPlyoSquats => f.write_str("lateral_plyo_squats"),
            PlyoExerciseName::WeightedLateralPlyoSquats => {
                f.write_str("weighted_lateral_plyo_squats")
            }
            PlyoExerciseName::LateralSlide => f.write_str("lateral_slide"),
            PlyoExerciseName::WeightedLateralSlide => f.write_str("weighted_lateral_slide"),
            PlyoExerciseName::MedicineBallOverheadThrows => {
                f.write_str("medicine_ball_overhead_throws")
            }
            PlyoExerciseName::MedicineBallSideThrow => f.write_str("medicine_ball_side_throw"),
            PlyoExerciseName::MedicineBallSlam => f.write_str("medicine_ball_slam"),
            PlyoExerciseName::SideToSideMedicineBallThrows => {
                f.write_str("side_to_side_medicine_ball_throws")
            }
            PlyoExerciseName::SideToSideShuffleJump => f.write_str("side_to_side_shuffle_jump"),
            PlyoExerciseName::WeightedSideToSideShuffleJump => {
                f.write_str("weighted_side_to_side_shuffle_jump")
            }
            PlyoExerciseName::SquatJumpOntoBox => f.write_str("squat_jump_onto_box"),
            PlyoExerciseName::WeightedSquatJumpOntoBox => {
                f.write_str("weighted_squat_jump_onto_box")
            }
            PlyoExerciseName::SquatJumpsInAndOut => f.write_str("squat_jumps_in_and_out"),
            PlyoExerciseName::WeightedSquatJumpsInAndOut => {
                f.write_str("weighted_squat_jumps_in_and_out")
            }
        }
    }
}
impl PlyoExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            PlyoExerciseName::AlternatingJumpLunge => fit::Value::UInt16(0),
            PlyoExerciseName::WeightedAlternatingJumpLunge => fit::Value::UInt16(1),
            PlyoExerciseName::BarbellJumpSquat => fit::Value::UInt16(2),
            PlyoExerciseName::BodyWeightJumpSquat => fit::Value::UInt16(3),
            PlyoExerciseName::WeightedJumpSquat => fit::Value::UInt16(4),
            PlyoExerciseName::CrossKneeStrike => fit::Value::UInt16(5),
            PlyoExerciseName::WeightedCrossKneeStrike => fit::Value::UInt16(6),
            PlyoExerciseName::DepthJump => fit::Value::UInt16(7),
            PlyoExerciseName::WeightedDepthJump => fit::Value::UInt16(8),
            PlyoExerciseName::DumbbellJumpSquat => fit::Value::UInt16(9),
            PlyoExerciseName::DumbbellSplitJump => fit::Value::UInt16(10),
            PlyoExerciseName::FrontKneeStrike => fit::Value::UInt16(11),
            PlyoExerciseName::WeightedFrontKneeStrike => fit::Value::UInt16(12),
            PlyoExerciseName::HighBoxJump => fit::Value::UInt16(13),
            PlyoExerciseName::WeightedHighBoxJump => fit::Value::UInt16(14),
            PlyoExerciseName::IsometricExplosiveBodyWeightJumpSquat => fit::Value::UInt16(15),
            PlyoExerciseName::WeightedIsometricExplosiveJumpSquat => fit::Value::UInt16(16),
            PlyoExerciseName::LateralLeapAndHop => fit::Value::UInt16(17),
            PlyoExerciseName::WeightedLateralLeapAndHop => fit::Value::UInt16(18),
            PlyoExerciseName::LateralPlyoSquats => fit::Value::UInt16(19),
            PlyoExerciseName::WeightedLateralPlyoSquats => fit::Value::UInt16(20),
            PlyoExerciseName::LateralSlide => fit::Value::UInt16(21),
            PlyoExerciseName::WeightedLateralSlide => fit::Value::UInt16(22),
            PlyoExerciseName::MedicineBallOverheadThrows => fit::Value::UInt16(23),
            PlyoExerciseName::MedicineBallSideThrow => fit::Value::UInt16(24),
            PlyoExerciseName::MedicineBallSlam => fit::Value::UInt16(25),
            PlyoExerciseName::SideToSideMedicineBallThrows => fit::Value::UInt16(26),
            PlyoExerciseName::SideToSideShuffleJump => fit::Value::UInt16(27),
            PlyoExerciseName::WeightedSideToSideShuffleJump => fit::Value::UInt16(28),
            PlyoExerciseName::SquatJumpOntoBox => fit::Value::UInt16(29),
            PlyoExerciseName::WeightedSquatJumpOntoBox => fit::Value::UInt16(30),
            PlyoExerciseName::SquatJumpsInAndOut => fit::Value::UInt16(31),
            PlyoExerciseName::WeightedSquatJumpsInAndOut => fit::Value::UInt16(32),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for PlyoExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(PlyoExerciseName::AlternatingJumpLunge),
            fit::Value::UInt16(1) => Ok(PlyoExerciseName::WeightedAlternatingJumpLunge),
            fit::Value::UInt16(2) => Ok(PlyoExerciseName::BarbellJumpSquat),
            fit::Value::UInt16(3) => Ok(PlyoExerciseName::BodyWeightJumpSquat),
            fit::Value::UInt16(4) => Ok(PlyoExerciseName::WeightedJumpSquat),
            fit::Value::UInt16(5) => Ok(PlyoExerciseName::CrossKneeStrike),
            fit::Value::UInt16(6) => Ok(PlyoExerciseName::WeightedCrossKneeStrike),
            fit::Value::UInt16(7) => Ok(PlyoExerciseName::DepthJump),
            fit::Value::UInt16(8) => Ok(PlyoExerciseName::WeightedDepthJump),
            fit::Value::UInt16(9) => Ok(PlyoExerciseName::DumbbellJumpSquat),
            fit::Value::UInt16(10) => Ok(PlyoExerciseName::DumbbellSplitJump),
            fit::Value::UInt16(11) => Ok(PlyoExerciseName::FrontKneeStrike),
            fit::Value::UInt16(12) => Ok(PlyoExerciseName::WeightedFrontKneeStrike),
            fit::Value::UInt16(13) => Ok(PlyoExerciseName::HighBoxJump),
            fit::Value::UInt16(14) => Ok(PlyoExerciseName::WeightedHighBoxJump),
            fit::Value::UInt16(15) => Ok(PlyoExerciseName::IsometricExplosiveBodyWeightJumpSquat),
            fit::Value::UInt16(16) => Ok(PlyoExerciseName::WeightedIsometricExplosiveJumpSquat),
            fit::Value::UInt16(17) => Ok(PlyoExerciseName::LateralLeapAndHop),
            fit::Value::UInt16(18) => Ok(PlyoExerciseName::WeightedLateralLeapAndHop),
            fit::Value::UInt16(19) => Ok(PlyoExerciseName::LateralPlyoSquats),
            fit::Value::UInt16(20) => Ok(PlyoExerciseName::WeightedLateralPlyoSquats),
            fit::Value::UInt16(21) => Ok(PlyoExerciseName::LateralSlide),
            fit::Value::UInt16(22) => Ok(PlyoExerciseName::WeightedLateralSlide),
            fit::Value::UInt16(23) => Ok(PlyoExerciseName::MedicineBallOverheadThrows),
            fit::Value::UInt16(24) => Ok(PlyoExerciseName::MedicineBallSideThrow),
            fit::Value::UInt16(25) => Ok(PlyoExerciseName::MedicineBallSlam),
            fit::Value::UInt16(26) => Ok(PlyoExerciseName::SideToSideMedicineBallThrows),
            fit::Value::UInt16(27) => Ok(PlyoExerciseName::SideToSideShuffleJump),
            fit::Value::UInt16(28) => Ok(PlyoExerciseName::WeightedSideToSideShuffleJump),
            fit::Value::UInt16(29) => Ok(PlyoExerciseName::SquatJumpOntoBox),
            fit::Value::UInt16(30) => Ok(PlyoExerciseName::WeightedSquatJumpOntoBox),
            fit::Value::UInt16(31) => Ok(PlyoExerciseName::SquatJumpsInAndOut),
            fit::Value::UInt16(32) => Ok(PlyoExerciseName::WeightedSquatJumpsInAndOut),
            _ => Err("No corresponding PlyoExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for PlyoExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "alternating_jump_lunge" => Ok(PlyoExerciseName::AlternatingJumpLunge),
            "weighted_alternating_jump_lunge" => Ok(PlyoExerciseName::WeightedAlternatingJumpLunge),
            "barbell_jump_squat" => Ok(PlyoExerciseName::BarbellJumpSquat),
            "body_weight_jump_squat" => Ok(PlyoExerciseName::BodyWeightJumpSquat),
            "weighted_jump_squat" => Ok(PlyoExerciseName::WeightedJumpSquat),
            "cross_knee_strike" => Ok(PlyoExerciseName::CrossKneeStrike),
            "weighted_cross_knee_strike" => Ok(PlyoExerciseName::WeightedCrossKneeStrike),
            "depth_jump" => Ok(PlyoExerciseName::DepthJump),
            "weighted_depth_jump" => Ok(PlyoExerciseName::WeightedDepthJump),
            "dumbbell_jump_squat" => Ok(PlyoExerciseName::DumbbellJumpSquat),
            "dumbbell_split_jump" => Ok(PlyoExerciseName::DumbbellSplitJump),
            "front_knee_strike" => Ok(PlyoExerciseName::FrontKneeStrike),
            "weighted_front_knee_strike" => Ok(PlyoExerciseName::WeightedFrontKneeStrike),
            "high_box_jump" => Ok(PlyoExerciseName::HighBoxJump),
            "weighted_high_box_jump" => Ok(PlyoExerciseName::WeightedHighBoxJump),
            "isometric_explosive_body_weight_jump_squat" => {
                Ok(PlyoExerciseName::IsometricExplosiveBodyWeightJumpSquat)
            }
            "weighted_isometric_explosive_jump_squat" => {
                Ok(PlyoExerciseName::WeightedIsometricExplosiveJumpSquat)
            }
            "lateral_leap_and_hop" => Ok(PlyoExerciseName::LateralLeapAndHop),
            "weighted_lateral_leap_and_hop" => Ok(PlyoExerciseName::WeightedLateralLeapAndHop),
            "lateral_plyo_squats" => Ok(PlyoExerciseName::LateralPlyoSquats),
            "weighted_lateral_plyo_squats" => Ok(PlyoExerciseName::WeightedLateralPlyoSquats),
            "lateral_slide" => Ok(PlyoExerciseName::LateralSlide),
            "weighted_lateral_slide" => Ok(PlyoExerciseName::WeightedLateralSlide),
            "medicine_ball_overhead_throws" => Ok(PlyoExerciseName::MedicineBallOverheadThrows),
            "medicine_ball_side_throw" => Ok(PlyoExerciseName::MedicineBallSideThrow),
            "medicine_ball_slam" => Ok(PlyoExerciseName::MedicineBallSlam),
            "side_to_side_medicine_ball_throws" => {
                Ok(PlyoExerciseName::SideToSideMedicineBallThrows)
            }
            "side_to_side_shuffle_jump" => Ok(PlyoExerciseName::SideToSideShuffleJump),
            "weighted_side_to_side_shuffle_jump" => {
                Ok(PlyoExerciseName::WeightedSideToSideShuffleJump)
            }
            "squat_jump_onto_box" => Ok(PlyoExerciseName::SquatJumpOntoBox),
            "weighted_squat_jump_onto_box" => Ok(PlyoExerciseName::WeightedSquatJumpOntoBox),
            "squat_jumps_in_and_out" => Ok(PlyoExerciseName::SquatJumpsInAndOut),
            "weighted_squat_jumps_in_and_out" => Ok(PlyoExerciseName::WeightedSquatJumpsInAndOut),
            _ => Err("No corresponding PlyoExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum PullUpExerciseName {
    BandedPullUps,
    N30DegreeLatPulldown,
    BandAssistedChinUp,
    CloseGripChinUp,
    WeightedCloseGripChinUp,
    CloseGripLatPulldown,
    CrossoverChinUp,
    WeightedCrossoverChinUp,
    EzBarPullover,
    HangingHurdle,
    WeightedHangingHurdle,
    KneelingLatPulldown,
    KneelingUnderhandGripLatPulldown,
    LatPulldown,
    MixedGripChinUp,
    WeightedMixedGripChinUp,
    MixedGripPullUp,
    WeightedMixedGripPullUp,
    ReverseGripPulldown,
    StandingCablePullover,
    StraightArmPulldown,
    SwissBallEzBarPullover,
    TowelPullUp,
    WeightedTowelPullUp,
    WeightedPullUp,
    WideGripLatPulldown,
    WideGripPullUp,
    WeightedWideGripPullUp,
    BurpeePullUp,
    WeightedBurpeePullUp,
    JumpingPullUps,
    WeightedJumpingPullUps,
    KippingPullUp,
    WeightedKippingPullUp,
    LPullUp,
    WeightedLPullUp,
    SuspendedChinUp,
    WeightedSuspendedChinUp,
    PullUp,
}
impl fmt::Display for PullUpExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PullUpExerciseName::BandedPullUps => f.write_str("banded_pull_ups"),
            PullUpExerciseName::N30DegreeLatPulldown => f.write_str("30_degree_lat_pulldown"),
            PullUpExerciseName::BandAssistedChinUp => f.write_str("band_assisted_chin_up"),
            PullUpExerciseName::CloseGripChinUp => f.write_str("close_grip_chin_up"),
            PullUpExerciseName::WeightedCloseGripChinUp => {
                f.write_str("weighted_close_grip_chin_up")
            }
            PullUpExerciseName::CloseGripLatPulldown => f.write_str("close_grip_lat_pulldown"),
            PullUpExerciseName::CrossoverChinUp => f.write_str("crossover_chin_up"),
            PullUpExerciseName::WeightedCrossoverChinUp => {
                f.write_str("weighted_crossover_chin_up")
            }
            PullUpExerciseName::EzBarPullover => f.write_str("ez_bar_pullover"),
            PullUpExerciseName::HangingHurdle => f.write_str("hanging_hurdle"),
            PullUpExerciseName::WeightedHangingHurdle => f.write_str("weighted_hanging_hurdle"),
            PullUpExerciseName::KneelingLatPulldown => f.write_str("kneeling_lat_pulldown"),
            PullUpExerciseName::KneelingUnderhandGripLatPulldown => {
                f.write_str("kneeling_underhand_grip_lat_pulldown")
            }
            PullUpExerciseName::LatPulldown => f.write_str("lat_pulldown"),
            PullUpExerciseName::MixedGripChinUp => f.write_str("mixed_grip_chin_up"),
            PullUpExerciseName::WeightedMixedGripChinUp => {
                f.write_str("weighted_mixed_grip_chin_up")
            }
            PullUpExerciseName::MixedGripPullUp => f.write_str("mixed_grip_pull_up"),
            PullUpExerciseName::WeightedMixedGripPullUp => {
                f.write_str("weighted_mixed_grip_pull_up")
            }
            PullUpExerciseName::ReverseGripPulldown => f.write_str("reverse_grip_pulldown"),
            PullUpExerciseName::StandingCablePullover => f.write_str("standing_cable_pullover"),
            PullUpExerciseName::StraightArmPulldown => f.write_str("straight_arm_pulldown"),
            PullUpExerciseName::SwissBallEzBarPullover => f.write_str("swiss_ball_ez_bar_pullover"),
            PullUpExerciseName::TowelPullUp => f.write_str("towel_pull_up"),
            PullUpExerciseName::WeightedTowelPullUp => f.write_str("weighted_towel_pull_up"),
            PullUpExerciseName::WeightedPullUp => f.write_str("weighted_pull_up"),
            PullUpExerciseName::WideGripLatPulldown => f.write_str("wide_grip_lat_pulldown"),
            PullUpExerciseName::WideGripPullUp => f.write_str("wide_grip_pull_up"),
            PullUpExerciseName::WeightedWideGripPullUp => f.write_str("weighted_wide_grip_pull_up"),
            PullUpExerciseName::BurpeePullUp => f.write_str("burpee_pull_up"),
            PullUpExerciseName::WeightedBurpeePullUp => f.write_str("weighted_burpee_pull_up"),
            PullUpExerciseName::JumpingPullUps => f.write_str("jumping_pull_ups"),
            PullUpExerciseName::WeightedJumpingPullUps => f.write_str("weighted_jumping_pull_ups"),
            PullUpExerciseName::KippingPullUp => f.write_str("kipping_pull_up"),
            PullUpExerciseName::WeightedKippingPullUp => f.write_str("weighted_kipping_pull_up"),
            PullUpExerciseName::LPullUp => f.write_str("l_pull_up"),
            PullUpExerciseName::WeightedLPullUp => f.write_str("weighted_l_pull_up"),
            PullUpExerciseName::SuspendedChinUp => f.write_str("suspended_chin_up"),
            PullUpExerciseName::WeightedSuspendedChinUp => {
                f.write_str("weighted_suspended_chin_up")
            }
            PullUpExerciseName::PullUp => f.write_str("pull_up"),
        }
    }
}
impl PullUpExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            PullUpExerciseName::BandedPullUps => fit::Value::UInt16(0),
            PullUpExerciseName::N30DegreeLatPulldown => fit::Value::UInt16(1),
            PullUpExerciseName::BandAssistedChinUp => fit::Value::UInt16(2),
            PullUpExerciseName::CloseGripChinUp => fit::Value::UInt16(3),
            PullUpExerciseName::WeightedCloseGripChinUp => fit::Value::UInt16(4),
            PullUpExerciseName::CloseGripLatPulldown => fit::Value::UInt16(5),
            PullUpExerciseName::CrossoverChinUp => fit::Value::UInt16(6),
            PullUpExerciseName::WeightedCrossoverChinUp => fit::Value::UInt16(7),
            PullUpExerciseName::EzBarPullover => fit::Value::UInt16(8),
            PullUpExerciseName::HangingHurdle => fit::Value::UInt16(9),
            PullUpExerciseName::WeightedHangingHurdle => fit::Value::UInt16(10),
            PullUpExerciseName::KneelingLatPulldown => fit::Value::UInt16(11),
            PullUpExerciseName::KneelingUnderhandGripLatPulldown => fit::Value::UInt16(12),
            PullUpExerciseName::LatPulldown => fit::Value::UInt16(13),
            PullUpExerciseName::MixedGripChinUp => fit::Value::UInt16(14),
            PullUpExerciseName::WeightedMixedGripChinUp => fit::Value::UInt16(15),
            PullUpExerciseName::MixedGripPullUp => fit::Value::UInt16(16),
            PullUpExerciseName::WeightedMixedGripPullUp => fit::Value::UInt16(17),
            PullUpExerciseName::ReverseGripPulldown => fit::Value::UInt16(18),
            PullUpExerciseName::StandingCablePullover => fit::Value::UInt16(19),
            PullUpExerciseName::StraightArmPulldown => fit::Value::UInt16(20),
            PullUpExerciseName::SwissBallEzBarPullover => fit::Value::UInt16(21),
            PullUpExerciseName::TowelPullUp => fit::Value::UInt16(22),
            PullUpExerciseName::WeightedTowelPullUp => fit::Value::UInt16(23),
            PullUpExerciseName::WeightedPullUp => fit::Value::UInt16(24),
            PullUpExerciseName::WideGripLatPulldown => fit::Value::UInt16(25),
            PullUpExerciseName::WideGripPullUp => fit::Value::UInt16(26),
            PullUpExerciseName::WeightedWideGripPullUp => fit::Value::UInt16(27),
            PullUpExerciseName::BurpeePullUp => fit::Value::UInt16(28),
            PullUpExerciseName::WeightedBurpeePullUp => fit::Value::UInt16(29),
            PullUpExerciseName::JumpingPullUps => fit::Value::UInt16(30),
            PullUpExerciseName::WeightedJumpingPullUps => fit::Value::UInt16(31),
            PullUpExerciseName::KippingPullUp => fit::Value::UInt16(32),
            PullUpExerciseName::WeightedKippingPullUp => fit::Value::UInt16(33),
            PullUpExerciseName::LPullUp => fit::Value::UInt16(34),
            PullUpExerciseName::WeightedLPullUp => fit::Value::UInt16(35),
            PullUpExerciseName::SuspendedChinUp => fit::Value::UInt16(36),
            PullUpExerciseName::WeightedSuspendedChinUp => fit::Value::UInt16(37),
            PullUpExerciseName::PullUp => fit::Value::UInt16(38),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for PullUpExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(PullUpExerciseName::BandedPullUps),
            fit::Value::UInt16(1) => Ok(PullUpExerciseName::N30DegreeLatPulldown),
            fit::Value::UInt16(2) => Ok(PullUpExerciseName::BandAssistedChinUp),
            fit::Value::UInt16(3) => Ok(PullUpExerciseName::CloseGripChinUp),
            fit::Value::UInt16(4) => Ok(PullUpExerciseName::WeightedCloseGripChinUp),
            fit::Value::UInt16(5) => Ok(PullUpExerciseName::CloseGripLatPulldown),
            fit::Value::UInt16(6) => Ok(PullUpExerciseName::CrossoverChinUp),
            fit::Value::UInt16(7) => Ok(PullUpExerciseName::WeightedCrossoverChinUp),
            fit::Value::UInt16(8) => Ok(PullUpExerciseName::EzBarPullover),
            fit::Value::UInt16(9) => Ok(PullUpExerciseName::HangingHurdle),
            fit::Value::UInt16(10) => Ok(PullUpExerciseName::WeightedHangingHurdle),
            fit::Value::UInt16(11) => Ok(PullUpExerciseName::KneelingLatPulldown),
            fit::Value::UInt16(12) => Ok(PullUpExerciseName::KneelingUnderhandGripLatPulldown),
            fit::Value::UInt16(13) => Ok(PullUpExerciseName::LatPulldown),
            fit::Value::UInt16(14) => Ok(PullUpExerciseName::MixedGripChinUp),
            fit::Value::UInt16(15) => Ok(PullUpExerciseName::WeightedMixedGripChinUp),
            fit::Value::UInt16(16) => Ok(PullUpExerciseName::MixedGripPullUp),
            fit::Value::UInt16(17) => Ok(PullUpExerciseName::WeightedMixedGripPullUp),
            fit::Value::UInt16(18) => Ok(PullUpExerciseName::ReverseGripPulldown),
            fit::Value::UInt16(19) => Ok(PullUpExerciseName::StandingCablePullover),
            fit::Value::UInt16(20) => Ok(PullUpExerciseName::StraightArmPulldown),
            fit::Value::UInt16(21) => Ok(PullUpExerciseName::SwissBallEzBarPullover),
            fit::Value::UInt16(22) => Ok(PullUpExerciseName::TowelPullUp),
            fit::Value::UInt16(23) => Ok(PullUpExerciseName::WeightedTowelPullUp),
            fit::Value::UInt16(24) => Ok(PullUpExerciseName::WeightedPullUp),
            fit::Value::UInt16(25) => Ok(PullUpExerciseName::WideGripLatPulldown),
            fit::Value::UInt16(26) => Ok(PullUpExerciseName::WideGripPullUp),
            fit::Value::UInt16(27) => Ok(PullUpExerciseName::WeightedWideGripPullUp),
            fit::Value::UInt16(28) => Ok(PullUpExerciseName::BurpeePullUp),
            fit::Value::UInt16(29) => Ok(PullUpExerciseName::WeightedBurpeePullUp),
            fit::Value::UInt16(30) => Ok(PullUpExerciseName::JumpingPullUps),
            fit::Value::UInt16(31) => Ok(PullUpExerciseName::WeightedJumpingPullUps),
            fit::Value::UInt16(32) => Ok(PullUpExerciseName::KippingPullUp),
            fit::Value::UInt16(33) => Ok(PullUpExerciseName::WeightedKippingPullUp),
            fit::Value::UInt16(34) => Ok(PullUpExerciseName::LPullUp),
            fit::Value::UInt16(35) => Ok(PullUpExerciseName::WeightedLPullUp),
            fit::Value::UInt16(36) => Ok(PullUpExerciseName::SuspendedChinUp),
            fit::Value::UInt16(37) => Ok(PullUpExerciseName::WeightedSuspendedChinUp),
            fit::Value::UInt16(38) => Ok(PullUpExerciseName::PullUp),
            _ => Err("No corresponding PullUpExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for PullUpExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "banded_pull_ups" => Ok(PullUpExerciseName::BandedPullUps),
            "30_degree_lat_pulldown" => Ok(PullUpExerciseName::N30DegreeLatPulldown),
            "band_assisted_chin_up" => Ok(PullUpExerciseName::BandAssistedChinUp),
            "close_grip_chin_up" => Ok(PullUpExerciseName::CloseGripChinUp),
            "weighted_close_grip_chin_up" => Ok(PullUpExerciseName::WeightedCloseGripChinUp),
            "close_grip_lat_pulldown" => Ok(PullUpExerciseName::CloseGripLatPulldown),
            "crossover_chin_up" => Ok(PullUpExerciseName::CrossoverChinUp),
            "weighted_crossover_chin_up" => Ok(PullUpExerciseName::WeightedCrossoverChinUp),
            "ez_bar_pullover" => Ok(PullUpExerciseName::EzBarPullover),
            "hanging_hurdle" => Ok(PullUpExerciseName::HangingHurdle),
            "weighted_hanging_hurdle" => Ok(PullUpExerciseName::WeightedHangingHurdle),
            "kneeling_lat_pulldown" => Ok(PullUpExerciseName::KneelingLatPulldown),
            "kneeling_underhand_grip_lat_pulldown" => {
                Ok(PullUpExerciseName::KneelingUnderhandGripLatPulldown)
            }
            "lat_pulldown" => Ok(PullUpExerciseName::LatPulldown),
            "mixed_grip_chin_up" => Ok(PullUpExerciseName::MixedGripChinUp),
            "weighted_mixed_grip_chin_up" => Ok(PullUpExerciseName::WeightedMixedGripChinUp),
            "mixed_grip_pull_up" => Ok(PullUpExerciseName::MixedGripPullUp),
            "weighted_mixed_grip_pull_up" => Ok(PullUpExerciseName::WeightedMixedGripPullUp),
            "reverse_grip_pulldown" => Ok(PullUpExerciseName::ReverseGripPulldown),
            "standing_cable_pullover" => Ok(PullUpExerciseName::StandingCablePullover),
            "straight_arm_pulldown" => Ok(PullUpExerciseName::StraightArmPulldown),
            "swiss_ball_ez_bar_pullover" => Ok(PullUpExerciseName::SwissBallEzBarPullover),
            "towel_pull_up" => Ok(PullUpExerciseName::TowelPullUp),
            "weighted_towel_pull_up" => Ok(PullUpExerciseName::WeightedTowelPullUp),
            "weighted_pull_up" => Ok(PullUpExerciseName::WeightedPullUp),
            "wide_grip_lat_pulldown" => Ok(PullUpExerciseName::WideGripLatPulldown),
            "wide_grip_pull_up" => Ok(PullUpExerciseName::WideGripPullUp),
            "weighted_wide_grip_pull_up" => Ok(PullUpExerciseName::WeightedWideGripPullUp),
            "burpee_pull_up" => Ok(PullUpExerciseName::BurpeePullUp),
            "weighted_burpee_pull_up" => Ok(PullUpExerciseName::WeightedBurpeePullUp),
            "jumping_pull_ups" => Ok(PullUpExerciseName::JumpingPullUps),
            "weighted_jumping_pull_ups" => Ok(PullUpExerciseName::WeightedJumpingPullUps),
            "kipping_pull_up" => Ok(PullUpExerciseName::KippingPullUp),
            "weighted_kipping_pull_up" => Ok(PullUpExerciseName::WeightedKippingPullUp),
            "l_pull_up" => Ok(PullUpExerciseName::LPullUp),
            "weighted_l_pull_up" => Ok(PullUpExerciseName::WeightedLPullUp),
            "suspended_chin_up" => Ok(PullUpExerciseName::SuspendedChinUp),
            "weighted_suspended_chin_up" => Ok(PullUpExerciseName::WeightedSuspendedChinUp),
            "pull_up" => Ok(PullUpExerciseName::PullUp),
            _ => Err("No corresponding PullUpExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum PushUpExerciseName {
    ChestPressWithBand,
    AlternatingStaggeredPushUp,
    WeightedAlternatingStaggeredPushUp,
    AlternatingHandsMedicineBallPushUp,
    WeightedAlternatingHandsMedicineBallPushUp,
    BosuBallPushUp,
    WeightedBosuBallPushUp,
    ClappingPushUp,
    WeightedClappingPushUp,
    CloseGripMedicineBallPushUp,
    WeightedCloseGripMedicineBallPushUp,
    CloseHandsPushUp,
    WeightedCloseHandsPushUp,
    DeclinePushUp,
    WeightedDeclinePushUp,
    DiamondPushUp,
    WeightedDiamondPushUp,
    ExplosiveCrossoverPushUp,
    WeightedExplosiveCrossoverPushUp,
    ExplosivePushUp,
    WeightedExplosivePushUp,
    FeetElevatedSideToSidePushUp,
    WeightedFeetElevatedSideToSidePushUp,
    HandReleasePushUp,
    WeightedHandReleasePushUp,
    HandstandPushUp,
    WeightedHandstandPushUp,
    InclinePushUp,
    WeightedInclinePushUp,
    IsometricExplosivePushUp,
    WeightedIsometricExplosivePushUp,
    JudoPushUp,
    WeightedJudoPushUp,
    KneelingPushUp,
    WeightedKneelingPushUp,
    MedicineBallChestPass,
    MedicineBallPushUp,
    WeightedMedicineBallPushUp,
    OneArmPushUp,
    WeightedOneArmPushUp,
    WeightedPushUp,
    PushUpAndRow,
    WeightedPushUpAndRow,
    PushUpPlus,
    WeightedPushUpPlus,
    PushUpWithFeetOnSwissBall,
    WeightedPushUpWithFeetOnSwissBall,
    PushUpWithOneHandOnMedicineBall,
    WeightedPushUpWithOneHandOnMedicineBall,
    ShoulderPushUp,
    WeightedShoulderPushUp,
    SingleArmMedicineBallPushUp,
    WeightedSingleArmMedicineBallPushUp,
    SpidermanPushUp,
    WeightedSpidermanPushUp,
    StackedFeetPushUp,
    WeightedStackedFeetPushUp,
    StaggeredHandsPushUp,
    WeightedStaggeredHandsPushUp,
    SuspendedPushUp,
    WeightedSuspendedPushUp,
    SwissBallPushUp,
    WeightedSwissBallPushUp,
    SwissBallPushUpPlus,
    WeightedSwissBallPushUpPlus,
    TPushUp,
    WeightedTPushUp,
    TripleStopPushUp,
    WeightedTripleStopPushUp,
    WideHandsPushUp,
    WeightedWideHandsPushUp,
    ParalletteHandstandPushUp,
    WeightedParalletteHandstandPushUp,
    RingHandstandPushUp,
    WeightedRingHandstandPushUp,
    RingPushUp,
    WeightedRingPushUp,
    PushUp,
    PilatesPushup,
}
impl fmt::Display for PushUpExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            PushUpExerciseName::ChestPressWithBand => f.write_str("chest_press_with_band"),
            PushUpExerciseName::AlternatingStaggeredPushUp => {
                f.write_str("alternating_staggered_push_up")
            }
            PushUpExerciseName::WeightedAlternatingStaggeredPushUp => {
                f.write_str("weighted_alternating_staggered_push_up")
            }
            PushUpExerciseName::AlternatingHandsMedicineBallPushUp => {
                f.write_str("alternating_hands_medicine_ball_push_up")
            }
            PushUpExerciseName::WeightedAlternatingHandsMedicineBallPushUp => {
                f.write_str("weighted_alternating_hands_medicine_ball_push_up")
            }
            PushUpExerciseName::BosuBallPushUp => f.write_str("bosu_ball_push_up"),
            PushUpExerciseName::WeightedBosuBallPushUp => f.write_str("weighted_bosu_ball_push_up"),
            PushUpExerciseName::ClappingPushUp => f.write_str("clapping_push_up"),
            PushUpExerciseName::WeightedClappingPushUp => f.write_str("weighted_clapping_push_up"),
            PushUpExerciseName::CloseGripMedicineBallPushUp => {
                f.write_str("close_grip_medicine_ball_push_up")
            }
            PushUpExerciseName::WeightedCloseGripMedicineBallPushUp => {
                f.write_str("weighted_close_grip_medicine_ball_push_up")
            }
            PushUpExerciseName::CloseHandsPushUp => f.write_str("close_hands_push_up"),
            PushUpExerciseName::WeightedCloseHandsPushUp => {
                f.write_str("weighted_close_hands_push_up")
            }
            PushUpExerciseName::DeclinePushUp => f.write_str("decline_push_up"),
            PushUpExerciseName::WeightedDeclinePushUp => f.write_str("weighted_decline_push_up"),
            PushUpExerciseName::DiamondPushUp => f.write_str("diamond_push_up"),
            PushUpExerciseName::WeightedDiamondPushUp => f.write_str("weighted_diamond_push_up"),
            PushUpExerciseName::ExplosiveCrossoverPushUp => {
                f.write_str("explosive_crossover_push_up")
            }
            PushUpExerciseName::WeightedExplosiveCrossoverPushUp => {
                f.write_str("weighted_explosive_crossover_push_up")
            }
            PushUpExerciseName::ExplosivePushUp => f.write_str("explosive_push_up"),
            PushUpExerciseName::WeightedExplosivePushUp => {
                f.write_str("weighted_explosive_push_up")
            }
            PushUpExerciseName::FeetElevatedSideToSidePushUp => {
                f.write_str("feet_elevated_side_to_side_push_up")
            }
            PushUpExerciseName::WeightedFeetElevatedSideToSidePushUp => {
                f.write_str("weighted_feet_elevated_side_to_side_push_up")
            }
            PushUpExerciseName::HandReleasePushUp => f.write_str("hand_release_push_up"),
            PushUpExerciseName::WeightedHandReleasePushUp => {
                f.write_str("weighted_hand_release_push_up")
            }
            PushUpExerciseName::HandstandPushUp => f.write_str("handstand_push_up"),
            PushUpExerciseName::WeightedHandstandPushUp => {
                f.write_str("weighted_handstand_push_up")
            }
            PushUpExerciseName::InclinePushUp => f.write_str("incline_push_up"),
            PushUpExerciseName::WeightedInclinePushUp => f.write_str("weighted_incline_push_up"),
            PushUpExerciseName::IsometricExplosivePushUp => {
                f.write_str("isometric_explosive_push_up")
            }
            PushUpExerciseName::WeightedIsometricExplosivePushUp => {
                f.write_str("weighted_isometric_explosive_push_up")
            }
            PushUpExerciseName::JudoPushUp => f.write_str("judo_push_up"),
            PushUpExerciseName::WeightedJudoPushUp => f.write_str("weighted_judo_push_up"),
            PushUpExerciseName::KneelingPushUp => f.write_str("kneeling_push_up"),
            PushUpExerciseName::WeightedKneelingPushUp => f.write_str("weighted_kneeling_push_up"),
            PushUpExerciseName::MedicineBallChestPass => f.write_str("medicine_ball_chest_pass"),
            PushUpExerciseName::MedicineBallPushUp => f.write_str("medicine_ball_push_up"),
            PushUpExerciseName::WeightedMedicineBallPushUp => {
                f.write_str("weighted_medicine_ball_push_up")
            }
            PushUpExerciseName::OneArmPushUp => f.write_str("one_arm_push_up"),
            PushUpExerciseName::WeightedOneArmPushUp => f.write_str("weighted_one_arm_push_up"),
            PushUpExerciseName::WeightedPushUp => f.write_str("weighted_push_up"),
            PushUpExerciseName::PushUpAndRow => f.write_str("push_up_and_row"),
            PushUpExerciseName::WeightedPushUpAndRow => f.write_str("weighted_push_up_and_row"),
            PushUpExerciseName::PushUpPlus => f.write_str("push_up_plus"),
            PushUpExerciseName::WeightedPushUpPlus => f.write_str("weighted_push_up_plus"),
            PushUpExerciseName::PushUpWithFeetOnSwissBall => {
                f.write_str("push_up_with_feet_on_swiss_ball")
            }
            PushUpExerciseName::WeightedPushUpWithFeetOnSwissBall => {
                f.write_str("weighted_push_up_with_feet_on_swiss_ball")
            }
            PushUpExerciseName::PushUpWithOneHandOnMedicineBall => {
                f.write_str("push_up_with_one_hand_on_medicine_ball")
            }
            PushUpExerciseName::WeightedPushUpWithOneHandOnMedicineBall => {
                f.write_str("weighted_push_up_with_one_hand_on_medicine_ball")
            }
            PushUpExerciseName::ShoulderPushUp => f.write_str("shoulder_push_up"),
            PushUpExerciseName::WeightedShoulderPushUp => f.write_str("weighted_shoulder_push_up"),
            PushUpExerciseName::SingleArmMedicineBallPushUp => {
                f.write_str("single_arm_medicine_ball_push_up")
            }
            PushUpExerciseName::WeightedSingleArmMedicineBallPushUp => {
                f.write_str("weighted_single_arm_medicine_ball_push_up")
            }
            PushUpExerciseName::SpidermanPushUp => f.write_str("spiderman_push_up"),
            PushUpExerciseName::WeightedSpidermanPushUp => {
                f.write_str("weighted_spiderman_push_up")
            }
            PushUpExerciseName::StackedFeetPushUp => f.write_str("stacked_feet_push_up"),
            PushUpExerciseName::WeightedStackedFeetPushUp => {
                f.write_str("weighted_stacked_feet_push_up")
            }
            PushUpExerciseName::StaggeredHandsPushUp => f.write_str("staggered_hands_push_up"),
            PushUpExerciseName::WeightedStaggeredHandsPushUp => {
                f.write_str("weighted_staggered_hands_push_up")
            }
            PushUpExerciseName::SuspendedPushUp => f.write_str("suspended_push_up"),
            PushUpExerciseName::WeightedSuspendedPushUp => {
                f.write_str("weighted_suspended_push_up")
            }
            PushUpExerciseName::SwissBallPushUp => f.write_str("swiss_ball_push_up"),
            PushUpExerciseName::WeightedSwissBallPushUp => {
                f.write_str("weighted_swiss_ball_push_up")
            }
            PushUpExerciseName::SwissBallPushUpPlus => f.write_str("swiss_ball_push_up_plus"),
            PushUpExerciseName::WeightedSwissBallPushUpPlus => {
                f.write_str("weighted_swiss_ball_push_up_plus")
            }
            PushUpExerciseName::TPushUp => f.write_str("t_push_up"),
            PushUpExerciseName::WeightedTPushUp => f.write_str("weighted_t_push_up"),
            PushUpExerciseName::TripleStopPushUp => f.write_str("triple_stop_push_up"),
            PushUpExerciseName::WeightedTripleStopPushUp => {
                f.write_str("weighted_triple_stop_push_up")
            }
            PushUpExerciseName::WideHandsPushUp => f.write_str("wide_hands_push_up"),
            PushUpExerciseName::WeightedWideHandsPushUp => {
                f.write_str("weighted_wide_hands_push_up")
            }
            PushUpExerciseName::ParalletteHandstandPushUp => {
                f.write_str("parallette_handstand_push_up")
            }
            PushUpExerciseName::WeightedParalletteHandstandPushUp => {
                f.write_str("weighted_parallette_handstand_push_up")
            }
            PushUpExerciseName::RingHandstandPushUp => f.write_str("ring_handstand_push_up"),
            PushUpExerciseName::WeightedRingHandstandPushUp => {
                f.write_str("weighted_ring_handstand_push_up")
            }
            PushUpExerciseName::RingPushUp => f.write_str("ring_push_up"),
            PushUpExerciseName::WeightedRingPushUp => f.write_str("weighted_ring_push_up"),
            PushUpExerciseName::PushUp => f.write_str("push_up"),
            PushUpExerciseName::PilatesPushup => f.write_str("pilates_pushup"),
        }
    }
}
impl PushUpExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            PushUpExerciseName::ChestPressWithBand => fit::Value::UInt16(0),
            PushUpExerciseName::AlternatingStaggeredPushUp => fit::Value::UInt16(1),
            PushUpExerciseName::WeightedAlternatingStaggeredPushUp => fit::Value::UInt16(2),
            PushUpExerciseName::AlternatingHandsMedicineBallPushUp => fit::Value::UInt16(3),
            PushUpExerciseName::WeightedAlternatingHandsMedicineBallPushUp => fit::Value::UInt16(4),
            PushUpExerciseName::BosuBallPushUp => fit::Value::UInt16(5),
            PushUpExerciseName::WeightedBosuBallPushUp => fit::Value::UInt16(6),
            PushUpExerciseName::ClappingPushUp => fit::Value::UInt16(7),
            PushUpExerciseName::WeightedClappingPushUp => fit::Value::UInt16(8),
            PushUpExerciseName::CloseGripMedicineBallPushUp => fit::Value::UInt16(9),
            PushUpExerciseName::WeightedCloseGripMedicineBallPushUp => fit::Value::UInt16(10),
            PushUpExerciseName::CloseHandsPushUp => fit::Value::UInt16(11),
            PushUpExerciseName::WeightedCloseHandsPushUp => fit::Value::UInt16(12),
            PushUpExerciseName::DeclinePushUp => fit::Value::UInt16(13),
            PushUpExerciseName::WeightedDeclinePushUp => fit::Value::UInt16(14),
            PushUpExerciseName::DiamondPushUp => fit::Value::UInt16(15),
            PushUpExerciseName::WeightedDiamondPushUp => fit::Value::UInt16(16),
            PushUpExerciseName::ExplosiveCrossoverPushUp => fit::Value::UInt16(17),
            PushUpExerciseName::WeightedExplosiveCrossoverPushUp => fit::Value::UInt16(18),
            PushUpExerciseName::ExplosivePushUp => fit::Value::UInt16(19),
            PushUpExerciseName::WeightedExplosivePushUp => fit::Value::UInt16(20),
            PushUpExerciseName::FeetElevatedSideToSidePushUp => fit::Value::UInt16(21),
            PushUpExerciseName::WeightedFeetElevatedSideToSidePushUp => fit::Value::UInt16(22),
            PushUpExerciseName::HandReleasePushUp => fit::Value::UInt16(23),
            PushUpExerciseName::WeightedHandReleasePushUp => fit::Value::UInt16(24),
            PushUpExerciseName::HandstandPushUp => fit::Value::UInt16(25),
            PushUpExerciseName::WeightedHandstandPushUp => fit::Value::UInt16(26),
            PushUpExerciseName::InclinePushUp => fit::Value::UInt16(27),
            PushUpExerciseName::WeightedInclinePushUp => fit::Value::UInt16(28),
            PushUpExerciseName::IsometricExplosivePushUp => fit::Value::UInt16(29),
            PushUpExerciseName::WeightedIsometricExplosivePushUp => fit::Value::UInt16(30),
            PushUpExerciseName::JudoPushUp => fit::Value::UInt16(31),
            PushUpExerciseName::WeightedJudoPushUp => fit::Value::UInt16(32),
            PushUpExerciseName::KneelingPushUp => fit::Value::UInt16(33),
            PushUpExerciseName::WeightedKneelingPushUp => fit::Value::UInt16(34),
            PushUpExerciseName::MedicineBallChestPass => fit::Value::UInt16(35),
            PushUpExerciseName::MedicineBallPushUp => fit::Value::UInt16(36),
            PushUpExerciseName::WeightedMedicineBallPushUp => fit::Value::UInt16(37),
            PushUpExerciseName::OneArmPushUp => fit::Value::UInt16(38),
            PushUpExerciseName::WeightedOneArmPushUp => fit::Value::UInt16(39),
            PushUpExerciseName::WeightedPushUp => fit::Value::UInt16(40),
            PushUpExerciseName::PushUpAndRow => fit::Value::UInt16(41),
            PushUpExerciseName::WeightedPushUpAndRow => fit::Value::UInt16(42),
            PushUpExerciseName::PushUpPlus => fit::Value::UInt16(43),
            PushUpExerciseName::WeightedPushUpPlus => fit::Value::UInt16(44),
            PushUpExerciseName::PushUpWithFeetOnSwissBall => fit::Value::UInt16(45),
            PushUpExerciseName::WeightedPushUpWithFeetOnSwissBall => fit::Value::UInt16(46),
            PushUpExerciseName::PushUpWithOneHandOnMedicineBall => fit::Value::UInt16(47),
            PushUpExerciseName::WeightedPushUpWithOneHandOnMedicineBall => fit::Value::UInt16(48),
            PushUpExerciseName::ShoulderPushUp => fit::Value::UInt16(49),
            PushUpExerciseName::WeightedShoulderPushUp => fit::Value::UInt16(50),
            PushUpExerciseName::SingleArmMedicineBallPushUp => fit::Value::UInt16(51),
            PushUpExerciseName::WeightedSingleArmMedicineBallPushUp => fit::Value::UInt16(52),
            PushUpExerciseName::SpidermanPushUp => fit::Value::UInt16(53),
            PushUpExerciseName::WeightedSpidermanPushUp => fit::Value::UInt16(54),
            PushUpExerciseName::StackedFeetPushUp => fit::Value::UInt16(55),
            PushUpExerciseName::WeightedStackedFeetPushUp => fit::Value::UInt16(56),
            PushUpExerciseName::StaggeredHandsPushUp => fit::Value::UInt16(57),
            PushUpExerciseName::WeightedStaggeredHandsPushUp => fit::Value::UInt16(58),
            PushUpExerciseName::SuspendedPushUp => fit::Value::UInt16(59),
            PushUpExerciseName::WeightedSuspendedPushUp => fit::Value::UInt16(60),
            PushUpExerciseName::SwissBallPushUp => fit::Value::UInt16(61),
            PushUpExerciseName::WeightedSwissBallPushUp => fit::Value::UInt16(62),
            PushUpExerciseName::SwissBallPushUpPlus => fit::Value::UInt16(63),
            PushUpExerciseName::WeightedSwissBallPushUpPlus => fit::Value::UInt16(64),
            PushUpExerciseName::TPushUp => fit::Value::UInt16(65),
            PushUpExerciseName::WeightedTPushUp => fit::Value::UInt16(66),
            PushUpExerciseName::TripleStopPushUp => fit::Value::UInt16(67),
            PushUpExerciseName::WeightedTripleStopPushUp => fit::Value::UInt16(68),
            PushUpExerciseName::WideHandsPushUp => fit::Value::UInt16(69),
            PushUpExerciseName::WeightedWideHandsPushUp => fit::Value::UInt16(70),
            PushUpExerciseName::ParalletteHandstandPushUp => fit::Value::UInt16(71),
            PushUpExerciseName::WeightedParalletteHandstandPushUp => fit::Value::UInt16(72),
            PushUpExerciseName::RingHandstandPushUp => fit::Value::UInt16(73),
            PushUpExerciseName::WeightedRingHandstandPushUp => fit::Value::UInt16(74),
            PushUpExerciseName::RingPushUp => fit::Value::UInt16(75),
            PushUpExerciseName::WeightedRingPushUp => fit::Value::UInt16(76),
            PushUpExerciseName::PushUp => fit::Value::UInt16(77),
            PushUpExerciseName::PilatesPushup => fit::Value::UInt16(78),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for PushUpExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(PushUpExerciseName::ChestPressWithBand),
            fit::Value::UInt16(1) => Ok(PushUpExerciseName::AlternatingStaggeredPushUp),
            fit::Value::UInt16(2) => Ok(PushUpExerciseName::WeightedAlternatingStaggeredPushUp),
            fit::Value::UInt16(3) => Ok(PushUpExerciseName::AlternatingHandsMedicineBallPushUp),
            fit::Value::UInt16(4) => {
                Ok(PushUpExerciseName::WeightedAlternatingHandsMedicineBallPushUp)
            }
            fit::Value::UInt16(5) => Ok(PushUpExerciseName::BosuBallPushUp),
            fit::Value::UInt16(6) => Ok(PushUpExerciseName::WeightedBosuBallPushUp),
            fit::Value::UInt16(7) => Ok(PushUpExerciseName::ClappingPushUp),
            fit::Value::UInt16(8) => Ok(PushUpExerciseName::WeightedClappingPushUp),
            fit::Value::UInt16(9) => Ok(PushUpExerciseName::CloseGripMedicineBallPushUp),
            fit::Value::UInt16(10) => Ok(PushUpExerciseName::WeightedCloseGripMedicineBallPushUp),
            fit::Value::UInt16(11) => Ok(PushUpExerciseName::CloseHandsPushUp),
            fit::Value::UInt16(12) => Ok(PushUpExerciseName::WeightedCloseHandsPushUp),
            fit::Value::UInt16(13) => Ok(PushUpExerciseName::DeclinePushUp),
            fit::Value::UInt16(14) => Ok(PushUpExerciseName::WeightedDeclinePushUp),
            fit::Value::UInt16(15) => Ok(PushUpExerciseName::DiamondPushUp),
            fit::Value::UInt16(16) => Ok(PushUpExerciseName::WeightedDiamondPushUp),
            fit::Value::UInt16(17) => Ok(PushUpExerciseName::ExplosiveCrossoverPushUp),
            fit::Value::UInt16(18) => Ok(PushUpExerciseName::WeightedExplosiveCrossoverPushUp),
            fit::Value::UInt16(19) => Ok(PushUpExerciseName::ExplosivePushUp),
            fit::Value::UInt16(20) => Ok(PushUpExerciseName::WeightedExplosivePushUp),
            fit::Value::UInt16(21) => Ok(PushUpExerciseName::FeetElevatedSideToSidePushUp),
            fit::Value::UInt16(22) => Ok(PushUpExerciseName::WeightedFeetElevatedSideToSidePushUp),
            fit::Value::UInt16(23) => Ok(PushUpExerciseName::HandReleasePushUp),
            fit::Value::UInt16(24) => Ok(PushUpExerciseName::WeightedHandReleasePushUp),
            fit::Value::UInt16(25) => Ok(PushUpExerciseName::HandstandPushUp),
            fit::Value::UInt16(26) => Ok(PushUpExerciseName::WeightedHandstandPushUp),
            fit::Value::UInt16(27) => Ok(PushUpExerciseName::InclinePushUp),
            fit::Value::UInt16(28) => Ok(PushUpExerciseName::WeightedInclinePushUp),
            fit::Value::UInt16(29) => Ok(PushUpExerciseName::IsometricExplosivePushUp),
            fit::Value::UInt16(30) => Ok(PushUpExerciseName::WeightedIsometricExplosivePushUp),
            fit::Value::UInt16(31) => Ok(PushUpExerciseName::JudoPushUp),
            fit::Value::UInt16(32) => Ok(PushUpExerciseName::WeightedJudoPushUp),
            fit::Value::UInt16(33) => Ok(PushUpExerciseName::KneelingPushUp),
            fit::Value::UInt16(34) => Ok(PushUpExerciseName::WeightedKneelingPushUp),
            fit::Value::UInt16(35) => Ok(PushUpExerciseName::MedicineBallChestPass),
            fit::Value::UInt16(36) => Ok(PushUpExerciseName::MedicineBallPushUp),
            fit::Value::UInt16(37) => Ok(PushUpExerciseName::WeightedMedicineBallPushUp),
            fit::Value::UInt16(38) => Ok(PushUpExerciseName::OneArmPushUp),
            fit::Value::UInt16(39) => Ok(PushUpExerciseName::WeightedOneArmPushUp),
            fit::Value::UInt16(40) => Ok(PushUpExerciseName::WeightedPushUp),
            fit::Value::UInt16(41) => Ok(PushUpExerciseName::PushUpAndRow),
            fit::Value::UInt16(42) => Ok(PushUpExerciseName::WeightedPushUpAndRow),
            fit::Value::UInt16(43) => Ok(PushUpExerciseName::PushUpPlus),
            fit::Value::UInt16(44) => Ok(PushUpExerciseName::WeightedPushUpPlus),
            fit::Value::UInt16(45) => Ok(PushUpExerciseName::PushUpWithFeetOnSwissBall),
            fit::Value::UInt16(46) => Ok(PushUpExerciseName::WeightedPushUpWithFeetOnSwissBall),
            fit::Value::UInt16(47) => Ok(PushUpExerciseName::PushUpWithOneHandOnMedicineBall),
            fit::Value::UInt16(48) => {
                Ok(PushUpExerciseName::WeightedPushUpWithOneHandOnMedicineBall)
            }
            fit::Value::UInt16(49) => Ok(PushUpExerciseName::ShoulderPushUp),
            fit::Value::UInt16(50) => Ok(PushUpExerciseName::WeightedShoulderPushUp),
            fit::Value::UInt16(51) => Ok(PushUpExerciseName::SingleArmMedicineBallPushUp),
            fit::Value::UInt16(52) => Ok(PushUpExerciseName::WeightedSingleArmMedicineBallPushUp),
            fit::Value::UInt16(53) => Ok(PushUpExerciseName::SpidermanPushUp),
            fit::Value::UInt16(54) => Ok(PushUpExerciseName::WeightedSpidermanPushUp),
            fit::Value::UInt16(55) => Ok(PushUpExerciseName::StackedFeetPushUp),
            fit::Value::UInt16(56) => Ok(PushUpExerciseName::WeightedStackedFeetPushUp),
            fit::Value::UInt16(57) => Ok(PushUpExerciseName::StaggeredHandsPushUp),
            fit::Value::UInt16(58) => Ok(PushUpExerciseName::WeightedStaggeredHandsPushUp),
            fit::Value::UInt16(59) => Ok(PushUpExerciseName::SuspendedPushUp),
            fit::Value::UInt16(60) => Ok(PushUpExerciseName::WeightedSuspendedPushUp),
            fit::Value::UInt16(61) => Ok(PushUpExerciseName::SwissBallPushUp),
            fit::Value::UInt16(62) => Ok(PushUpExerciseName::WeightedSwissBallPushUp),
            fit::Value::UInt16(63) => Ok(PushUpExerciseName::SwissBallPushUpPlus),
            fit::Value::UInt16(64) => Ok(PushUpExerciseName::WeightedSwissBallPushUpPlus),
            fit::Value::UInt16(65) => Ok(PushUpExerciseName::TPushUp),
            fit::Value::UInt16(66) => Ok(PushUpExerciseName::WeightedTPushUp),
            fit::Value::UInt16(67) => Ok(PushUpExerciseName::TripleStopPushUp),
            fit::Value::UInt16(68) => Ok(PushUpExerciseName::WeightedTripleStopPushUp),
            fit::Value::UInt16(69) => Ok(PushUpExerciseName::WideHandsPushUp),
            fit::Value::UInt16(70) => Ok(PushUpExerciseName::WeightedWideHandsPushUp),
            fit::Value::UInt16(71) => Ok(PushUpExerciseName::ParalletteHandstandPushUp),
            fit::Value::UInt16(72) => Ok(PushUpExerciseName::WeightedParalletteHandstandPushUp),
            fit::Value::UInt16(73) => Ok(PushUpExerciseName::RingHandstandPushUp),
            fit::Value::UInt16(74) => Ok(PushUpExerciseName::WeightedRingHandstandPushUp),
            fit::Value::UInt16(75) => Ok(PushUpExerciseName::RingPushUp),
            fit::Value::UInt16(76) => Ok(PushUpExerciseName::WeightedRingPushUp),
            fit::Value::UInt16(77) => Ok(PushUpExerciseName::PushUp),
            fit::Value::UInt16(78) => Ok(PushUpExerciseName::PilatesPushup),
            _ => Err("No corresponding PushUpExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for PushUpExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "chest_press_with_band" => Ok(PushUpExerciseName::ChestPressWithBand),
            "alternating_staggered_push_up" => Ok(PushUpExerciseName::AlternatingStaggeredPushUp),
            "weighted_alternating_staggered_push_up" => {
                Ok(PushUpExerciseName::WeightedAlternatingStaggeredPushUp)
            }
            "alternating_hands_medicine_ball_push_up" => {
                Ok(PushUpExerciseName::AlternatingHandsMedicineBallPushUp)
            }
            "weighted_alternating_hands_medicine_ball_push_up" => {
                Ok(PushUpExerciseName::WeightedAlternatingHandsMedicineBallPushUp)
            }
            "bosu_ball_push_up" => Ok(PushUpExerciseName::BosuBallPushUp),
            "weighted_bosu_ball_push_up" => Ok(PushUpExerciseName::WeightedBosuBallPushUp),
            "clapping_push_up" => Ok(PushUpExerciseName::ClappingPushUp),
            "weighted_clapping_push_up" => Ok(PushUpExerciseName::WeightedClappingPushUp),
            "close_grip_medicine_ball_push_up" => {
                Ok(PushUpExerciseName::CloseGripMedicineBallPushUp)
            }
            "weighted_close_grip_medicine_ball_push_up" => {
                Ok(PushUpExerciseName::WeightedCloseGripMedicineBallPushUp)
            }
            "close_hands_push_up" => Ok(PushUpExerciseName::CloseHandsPushUp),
            "weighted_close_hands_push_up" => Ok(PushUpExerciseName::WeightedCloseHandsPushUp),
            "decline_push_up" => Ok(PushUpExerciseName::DeclinePushUp),
            "weighted_decline_push_up" => Ok(PushUpExerciseName::WeightedDeclinePushUp),
            "diamond_push_up" => Ok(PushUpExerciseName::DiamondPushUp),
            "weighted_diamond_push_up" => Ok(PushUpExerciseName::WeightedDiamondPushUp),
            "explosive_crossover_push_up" => Ok(PushUpExerciseName::ExplosiveCrossoverPushUp),
            "weighted_explosive_crossover_push_up" => {
                Ok(PushUpExerciseName::WeightedExplosiveCrossoverPushUp)
            }
            "explosive_push_up" => Ok(PushUpExerciseName::ExplosivePushUp),
            "weighted_explosive_push_up" => Ok(PushUpExerciseName::WeightedExplosivePushUp),
            "feet_elevated_side_to_side_push_up" => {
                Ok(PushUpExerciseName::FeetElevatedSideToSidePushUp)
            }
            "weighted_feet_elevated_side_to_side_push_up" => {
                Ok(PushUpExerciseName::WeightedFeetElevatedSideToSidePushUp)
            }
            "hand_release_push_up" => Ok(PushUpExerciseName::HandReleasePushUp),
            "weighted_hand_release_push_up" => Ok(PushUpExerciseName::WeightedHandReleasePushUp),
            "handstand_push_up" => Ok(PushUpExerciseName::HandstandPushUp),
            "weighted_handstand_push_up" => Ok(PushUpExerciseName::WeightedHandstandPushUp),
            "incline_push_up" => Ok(PushUpExerciseName::InclinePushUp),
            "weighted_incline_push_up" => Ok(PushUpExerciseName::WeightedInclinePushUp),
            "isometric_explosive_push_up" => Ok(PushUpExerciseName::IsometricExplosivePushUp),
            "weighted_isometric_explosive_push_up" => {
                Ok(PushUpExerciseName::WeightedIsometricExplosivePushUp)
            }
            "judo_push_up" => Ok(PushUpExerciseName::JudoPushUp),
            "weighted_judo_push_up" => Ok(PushUpExerciseName::WeightedJudoPushUp),
            "kneeling_push_up" => Ok(PushUpExerciseName::KneelingPushUp),
            "weighted_kneeling_push_up" => Ok(PushUpExerciseName::WeightedKneelingPushUp),
            "medicine_ball_chest_pass" => Ok(PushUpExerciseName::MedicineBallChestPass),
            "medicine_ball_push_up" => Ok(PushUpExerciseName::MedicineBallPushUp),
            "weighted_medicine_ball_push_up" => Ok(PushUpExerciseName::WeightedMedicineBallPushUp),
            "one_arm_push_up" => Ok(PushUpExerciseName::OneArmPushUp),
            "weighted_one_arm_push_up" => Ok(PushUpExerciseName::WeightedOneArmPushUp),
            "weighted_push_up" => Ok(PushUpExerciseName::WeightedPushUp),
            "push_up_and_row" => Ok(PushUpExerciseName::PushUpAndRow),
            "weighted_push_up_and_row" => Ok(PushUpExerciseName::WeightedPushUpAndRow),
            "push_up_plus" => Ok(PushUpExerciseName::PushUpPlus),
            "weighted_push_up_plus" => Ok(PushUpExerciseName::WeightedPushUpPlus),
            "push_up_with_feet_on_swiss_ball" => Ok(PushUpExerciseName::PushUpWithFeetOnSwissBall),
            "weighted_push_up_with_feet_on_swiss_ball" => {
                Ok(PushUpExerciseName::WeightedPushUpWithFeetOnSwissBall)
            }
            "push_up_with_one_hand_on_medicine_ball" => {
                Ok(PushUpExerciseName::PushUpWithOneHandOnMedicineBall)
            }
            "weighted_push_up_with_one_hand_on_medicine_ball" => {
                Ok(PushUpExerciseName::WeightedPushUpWithOneHandOnMedicineBall)
            }
            "shoulder_push_up" => Ok(PushUpExerciseName::ShoulderPushUp),
            "weighted_shoulder_push_up" => Ok(PushUpExerciseName::WeightedShoulderPushUp),
            "single_arm_medicine_ball_push_up" => {
                Ok(PushUpExerciseName::SingleArmMedicineBallPushUp)
            }
            "weighted_single_arm_medicine_ball_push_up" => {
                Ok(PushUpExerciseName::WeightedSingleArmMedicineBallPushUp)
            }
            "spiderman_push_up" => Ok(PushUpExerciseName::SpidermanPushUp),
            "weighted_spiderman_push_up" => Ok(PushUpExerciseName::WeightedSpidermanPushUp),
            "stacked_feet_push_up" => Ok(PushUpExerciseName::StackedFeetPushUp),
            "weighted_stacked_feet_push_up" => Ok(PushUpExerciseName::WeightedStackedFeetPushUp),
            "staggered_hands_push_up" => Ok(PushUpExerciseName::StaggeredHandsPushUp),
            "weighted_staggered_hands_push_up" => {
                Ok(PushUpExerciseName::WeightedStaggeredHandsPushUp)
            }
            "suspended_push_up" => Ok(PushUpExerciseName::SuspendedPushUp),
            "weighted_suspended_push_up" => Ok(PushUpExerciseName::WeightedSuspendedPushUp),
            "swiss_ball_push_up" => Ok(PushUpExerciseName::SwissBallPushUp),
            "weighted_swiss_ball_push_up" => Ok(PushUpExerciseName::WeightedSwissBallPushUp),
            "swiss_ball_push_up_plus" => Ok(PushUpExerciseName::SwissBallPushUpPlus),
            "weighted_swiss_ball_push_up_plus" => {
                Ok(PushUpExerciseName::WeightedSwissBallPushUpPlus)
            }
            "t_push_up" => Ok(PushUpExerciseName::TPushUp),
            "weighted_t_push_up" => Ok(PushUpExerciseName::WeightedTPushUp),
            "triple_stop_push_up" => Ok(PushUpExerciseName::TripleStopPushUp),
            "weighted_triple_stop_push_up" => Ok(PushUpExerciseName::WeightedTripleStopPushUp),
            "wide_hands_push_up" => Ok(PushUpExerciseName::WideHandsPushUp),
            "weighted_wide_hands_push_up" => Ok(PushUpExerciseName::WeightedWideHandsPushUp),
            "parallette_handstand_push_up" => Ok(PushUpExerciseName::ParalletteHandstandPushUp),
            "weighted_parallette_handstand_push_up" => {
                Ok(PushUpExerciseName::WeightedParalletteHandstandPushUp)
            }
            "ring_handstand_push_up" => Ok(PushUpExerciseName::RingHandstandPushUp),
            "weighted_ring_handstand_push_up" => {
                Ok(PushUpExerciseName::WeightedRingHandstandPushUp)
            }
            "ring_push_up" => Ok(PushUpExerciseName::RingPushUp),
            "weighted_ring_push_up" => Ok(PushUpExerciseName::WeightedRingPushUp),
            "push_up" => Ok(PushUpExerciseName::PushUp),
            "pilates_pushup" => Ok(PushUpExerciseName::PilatesPushup),
            _ => Err("No corresponding PushUpExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum RowExerciseName {
    BarbellStraightLegDeadliftToRow,
    CableRowStanding,
    DumbbellRow,
    ElevatedFeetInvertedRow,
    WeightedElevatedFeetInvertedRow,
    FacePull,
    FacePullWithExternalRotation,
    InvertedRowWithFeetOnSwissBall,
    WeightedInvertedRowWithFeetOnSwissBall,
    KettlebellRow,
    ModifiedInvertedRow,
    WeightedModifiedInvertedRow,
    NeutralGripAlternatingDumbbellRow,
    OneArmBentOverRow,
    OneLeggedDumbbellRow,
    RenegadeRow,
    ReverseGripBarbellRow,
    RopeHandleCableRow,
    SeatedCableRow,
    SeatedDumbbellRow,
    SingleArmCableRow,
    SingleArmCableRowAndRotation,
    SingleArmInvertedRow,
    WeightedSingleArmInvertedRow,
    SingleArmNeutralGripDumbbellRow,
    SingleArmNeutralGripDumbbellRowAndRotation,
    SuspendedInvertedRow,
    WeightedSuspendedInvertedRow,
    TBarRow,
    TowelGripInvertedRow,
    WeightedTowelGripInvertedRow,
    UnderhandGripCableRow,
    VGripCableRow,
    WideGripSeatedCableRow,
}
impl fmt::Display for RowExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RowExerciseName::BarbellStraightLegDeadliftToRow => {
                f.write_str("barbell_straight_leg_deadlift_to_row")
            }
            RowExerciseName::CableRowStanding => f.write_str("cable_row_standing"),
            RowExerciseName::DumbbellRow => f.write_str("dumbbell_row"),
            RowExerciseName::ElevatedFeetInvertedRow => f.write_str("elevated_feet_inverted_row"),
            RowExerciseName::WeightedElevatedFeetInvertedRow => {
                f.write_str("weighted_elevated_feet_inverted_row")
            }
            RowExerciseName::FacePull => f.write_str("face_pull"),
            RowExerciseName::FacePullWithExternalRotation => {
                f.write_str("face_pull_with_external_rotation")
            }
            RowExerciseName::InvertedRowWithFeetOnSwissBall => {
                f.write_str("inverted_row_with_feet_on_swiss_ball")
            }
            RowExerciseName::WeightedInvertedRowWithFeetOnSwissBall => {
                f.write_str("weighted_inverted_row_with_feet_on_swiss_ball")
            }
            RowExerciseName::KettlebellRow => f.write_str("kettlebell_row"),
            RowExerciseName::ModifiedInvertedRow => f.write_str("modified_inverted_row"),
            RowExerciseName::WeightedModifiedInvertedRow => {
                f.write_str("weighted_modified_inverted_row")
            }
            RowExerciseName::NeutralGripAlternatingDumbbellRow => {
                f.write_str("neutral_grip_alternating_dumbbell_row")
            }
            RowExerciseName::OneArmBentOverRow => f.write_str("one_arm_bent_over_row"),
            RowExerciseName::OneLeggedDumbbellRow => f.write_str("one_legged_dumbbell_row"),
            RowExerciseName::RenegadeRow => f.write_str("renegade_row"),
            RowExerciseName::ReverseGripBarbellRow => f.write_str("reverse_grip_barbell_row"),
            RowExerciseName::RopeHandleCableRow => f.write_str("rope_handle_cable_row"),
            RowExerciseName::SeatedCableRow => f.write_str("seated_cable_row"),
            RowExerciseName::SeatedDumbbellRow => f.write_str("seated_dumbbell_row"),
            RowExerciseName::SingleArmCableRow => f.write_str("single_arm_cable_row"),
            RowExerciseName::SingleArmCableRowAndRotation => {
                f.write_str("single_arm_cable_row_and_rotation")
            }
            RowExerciseName::SingleArmInvertedRow => f.write_str("single_arm_inverted_row"),
            RowExerciseName::WeightedSingleArmInvertedRow => {
                f.write_str("weighted_single_arm_inverted_row")
            }
            RowExerciseName::SingleArmNeutralGripDumbbellRow => {
                f.write_str("single_arm_neutral_grip_dumbbell_row")
            }
            RowExerciseName::SingleArmNeutralGripDumbbellRowAndRotation => {
                f.write_str("single_arm_neutral_grip_dumbbell_row_and_rotation")
            }
            RowExerciseName::SuspendedInvertedRow => f.write_str("suspended_inverted_row"),
            RowExerciseName::WeightedSuspendedInvertedRow => {
                f.write_str("weighted_suspended_inverted_row")
            }
            RowExerciseName::TBarRow => f.write_str("t_bar_row"),
            RowExerciseName::TowelGripInvertedRow => f.write_str("towel_grip_inverted_row"),
            RowExerciseName::WeightedTowelGripInvertedRow => {
                f.write_str("weighted_towel_grip_inverted_row")
            }
            RowExerciseName::UnderhandGripCableRow => f.write_str("underhand_grip_cable_row"),
            RowExerciseName::VGripCableRow => f.write_str("v_grip_cable_row"),
            RowExerciseName::WideGripSeatedCableRow => f.write_str("wide_grip_seated_cable_row"),
        }
    }
}
impl RowExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            RowExerciseName::BarbellStraightLegDeadliftToRow => fit::Value::UInt16(0),
            RowExerciseName::CableRowStanding => fit::Value::UInt16(1),
            RowExerciseName::DumbbellRow => fit::Value::UInt16(2),
            RowExerciseName::ElevatedFeetInvertedRow => fit::Value::UInt16(3),
            RowExerciseName::WeightedElevatedFeetInvertedRow => fit::Value::UInt16(4),
            RowExerciseName::FacePull => fit::Value::UInt16(5),
            RowExerciseName::FacePullWithExternalRotation => fit::Value::UInt16(6),
            RowExerciseName::InvertedRowWithFeetOnSwissBall => fit::Value::UInt16(7),
            RowExerciseName::WeightedInvertedRowWithFeetOnSwissBall => fit::Value::UInt16(8),
            RowExerciseName::KettlebellRow => fit::Value::UInt16(9),
            RowExerciseName::ModifiedInvertedRow => fit::Value::UInt16(10),
            RowExerciseName::WeightedModifiedInvertedRow => fit::Value::UInt16(11),
            RowExerciseName::NeutralGripAlternatingDumbbellRow => fit::Value::UInt16(12),
            RowExerciseName::OneArmBentOverRow => fit::Value::UInt16(13),
            RowExerciseName::OneLeggedDumbbellRow => fit::Value::UInt16(14),
            RowExerciseName::RenegadeRow => fit::Value::UInt16(15),
            RowExerciseName::ReverseGripBarbellRow => fit::Value::UInt16(16),
            RowExerciseName::RopeHandleCableRow => fit::Value::UInt16(17),
            RowExerciseName::SeatedCableRow => fit::Value::UInt16(18),
            RowExerciseName::SeatedDumbbellRow => fit::Value::UInt16(19),
            RowExerciseName::SingleArmCableRow => fit::Value::UInt16(20),
            RowExerciseName::SingleArmCableRowAndRotation => fit::Value::UInt16(21),
            RowExerciseName::SingleArmInvertedRow => fit::Value::UInt16(22),
            RowExerciseName::WeightedSingleArmInvertedRow => fit::Value::UInt16(23),
            RowExerciseName::SingleArmNeutralGripDumbbellRow => fit::Value::UInt16(24),
            RowExerciseName::SingleArmNeutralGripDumbbellRowAndRotation => fit::Value::UInt16(25),
            RowExerciseName::SuspendedInvertedRow => fit::Value::UInt16(26),
            RowExerciseName::WeightedSuspendedInvertedRow => fit::Value::UInt16(27),
            RowExerciseName::TBarRow => fit::Value::UInt16(28),
            RowExerciseName::TowelGripInvertedRow => fit::Value::UInt16(29),
            RowExerciseName::WeightedTowelGripInvertedRow => fit::Value::UInt16(30),
            RowExerciseName::UnderhandGripCableRow => fit::Value::UInt16(31),
            RowExerciseName::VGripCableRow => fit::Value::UInt16(32),
            RowExerciseName::WideGripSeatedCableRow => fit::Value::UInt16(33),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for RowExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(RowExerciseName::BarbellStraightLegDeadliftToRow),
            fit::Value::UInt16(1) => Ok(RowExerciseName::CableRowStanding),
            fit::Value::UInt16(2) => Ok(RowExerciseName::DumbbellRow),
            fit::Value::UInt16(3) => Ok(RowExerciseName::ElevatedFeetInvertedRow),
            fit::Value::UInt16(4) => Ok(RowExerciseName::WeightedElevatedFeetInvertedRow),
            fit::Value::UInt16(5) => Ok(RowExerciseName::FacePull),
            fit::Value::UInt16(6) => Ok(RowExerciseName::FacePullWithExternalRotation),
            fit::Value::UInt16(7) => Ok(RowExerciseName::InvertedRowWithFeetOnSwissBall),
            fit::Value::UInt16(8) => Ok(RowExerciseName::WeightedInvertedRowWithFeetOnSwissBall),
            fit::Value::UInt16(9) => Ok(RowExerciseName::KettlebellRow),
            fit::Value::UInt16(10) => Ok(RowExerciseName::ModifiedInvertedRow),
            fit::Value::UInt16(11) => Ok(RowExerciseName::WeightedModifiedInvertedRow),
            fit::Value::UInt16(12) => Ok(RowExerciseName::NeutralGripAlternatingDumbbellRow),
            fit::Value::UInt16(13) => Ok(RowExerciseName::OneArmBentOverRow),
            fit::Value::UInt16(14) => Ok(RowExerciseName::OneLeggedDumbbellRow),
            fit::Value::UInt16(15) => Ok(RowExerciseName::RenegadeRow),
            fit::Value::UInt16(16) => Ok(RowExerciseName::ReverseGripBarbellRow),
            fit::Value::UInt16(17) => Ok(RowExerciseName::RopeHandleCableRow),
            fit::Value::UInt16(18) => Ok(RowExerciseName::SeatedCableRow),
            fit::Value::UInt16(19) => Ok(RowExerciseName::SeatedDumbbellRow),
            fit::Value::UInt16(20) => Ok(RowExerciseName::SingleArmCableRow),
            fit::Value::UInt16(21) => Ok(RowExerciseName::SingleArmCableRowAndRotation),
            fit::Value::UInt16(22) => Ok(RowExerciseName::SingleArmInvertedRow),
            fit::Value::UInt16(23) => Ok(RowExerciseName::WeightedSingleArmInvertedRow),
            fit::Value::UInt16(24) => Ok(RowExerciseName::SingleArmNeutralGripDumbbellRow),
            fit::Value::UInt16(25) => {
                Ok(RowExerciseName::SingleArmNeutralGripDumbbellRowAndRotation)
            }
            fit::Value::UInt16(26) => Ok(RowExerciseName::SuspendedInvertedRow),
            fit::Value::UInt16(27) => Ok(RowExerciseName::WeightedSuspendedInvertedRow),
            fit::Value::UInt16(28) => Ok(RowExerciseName::TBarRow),
            fit::Value::UInt16(29) => Ok(RowExerciseName::TowelGripInvertedRow),
            fit::Value::UInt16(30) => Ok(RowExerciseName::WeightedTowelGripInvertedRow),
            fit::Value::UInt16(31) => Ok(RowExerciseName::UnderhandGripCableRow),
            fit::Value::UInt16(32) => Ok(RowExerciseName::VGripCableRow),
            fit::Value::UInt16(33) => Ok(RowExerciseName::WideGripSeatedCableRow),
            _ => Err("No corresponding RowExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for RowExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "barbell_straight_leg_deadlift_to_row" => {
                Ok(RowExerciseName::BarbellStraightLegDeadliftToRow)
            }
            "cable_row_standing" => Ok(RowExerciseName::CableRowStanding),
            "dumbbell_row" => Ok(RowExerciseName::DumbbellRow),
            "elevated_feet_inverted_row" => Ok(RowExerciseName::ElevatedFeetInvertedRow),
            "weighted_elevated_feet_inverted_row" => {
                Ok(RowExerciseName::WeightedElevatedFeetInvertedRow)
            }
            "face_pull" => Ok(RowExerciseName::FacePull),
            "face_pull_with_external_rotation" => Ok(RowExerciseName::FacePullWithExternalRotation),
            "inverted_row_with_feet_on_swiss_ball" => {
                Ok(RowExerciseName::InvertedRowWithFeetOnSwissBall)
            }
            "weighted_inverted_row_with_feet_on_swiss_ball" => {
                Ok(RowExerciseName::WeightedInvertedRowWithFeetOnSwissBall)
            }
            "kettlebell_row" => Ok(RowExerciseName::KettlebellRow),
            "modified_inverted_row" => Ok(RowExerciseName::ModifiedInvertedRow),
            "weighted_modified_inverted_row" => Ok(RowExerciseName::WeightedModifiedInvertedRow),
            "neutral_grip_alternating_dumbbell_row" => {
                Ok(RowExerciseName::NeutralGripAlternatingDumbbellRow)
            }
            "one_arm_bent_over_row" => Ok(RowExerciseName::OneArmBentOverRow),
            "one_legged_dumbbell_row" => Ok(RowExerciseName::OneLeggedDumbbellRow),
            "renegade_row" => Ok(RowExerciseName::RenegadeRow),
            "reverse_grip_barbell_row" => Ok(RowExerciseName::ReverseGripBarbellRow),
            "rope_handle_cable_row" => Ok(RowExerciseName::RopeHandleCableRow),
            "seated_cable_row" => Ok(RowExerciseName::SeatedCableRow),
            "seated_dumbbell_row" => Ok(RowExerciseName::SeatedDumbbellRow),
            "single_arm_cable_row" => Ok(RowExerciseName::SingleArmCableRow),
            "single_arm_cable_row_and_rotation" => {
                Ok(RowExerciseName::SingleArmCableRowAndRotation)
            }
            "single_arm_inverted_row" => Ok(RowExerciseName::SingleArmInvertedRow),
            "weighted_single_arm_inverted_row" => Ok(RowExerciseName::WeightedSingleArmInvertedRow),
            "single_arm_neutral_grip_dumbbell_row" => {
                Ok(RowExerciseName::SingleArmNeutralGripDumbbellRow)
            }
            "single_arm_neutral_grip_dumbbell_row_and_rotation" => {
                Ok(RowExerciseName::SingleArmNeutralGripDumbbellRowAndRotation)
            }
            "suspended_inverted_row" => Ok(RowExerciseName::SuspendedInvertedRow),
            "weighted_suspended_inverted_row" => Ok(RowExerciseName::WeightedSuspendedInvertedRow),
            "t_bar_row" => Ok(RowExerciseName::TBarRow),
            "towel_grip_inverted_row" => Ok(RowExerciseName::TowelGripInvertedRow),
            "weighted_towel_grip_inverted_row" => Ok(RowExerciseName::WeightedTowelGripInvertedRow),
            "underhand_grip_cable_row" => Ok(RowExerciseName::UnderhandGripCableRow),
            "v_grip_cable_row" => Ok(RowExerciseName::VGripCableRow),
            "wide_grip_seated_cable_row" => Ok(RowExerciseName::WideGripSeatedCableRow),
            _ => Err("No corresponding RowExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ShoulderPressExerciseName {
    AlternatingDumbbellShoulderPress,
    ArnoldPress,
    BarbellFrontSquatToPushPress,
    BarbellPushPress,
    BarbellShoulderPress,
    DeadCurlPress,
    DumbbellAlternatingShoulderPressAndTwist,
    DumbbellHammerCurlToLungeToPress,
    DumbbellPushPress,
    FloorInvertedShoulderPress,
    WeightedFloorInvertedShoulderPress,
    InvertedShoulderPress,
    WeightedInvertedShoulderPress,
    OneArmPushPress,
    OverheadBarbellPress,
    OverheadDumbbellPress,
    SeatedBarbellShoulderPress,
    SeatedDumbbellShoulderPress,
    SingleArmDumbbellShoulderPress,
    SingleArmStepUpAndPress,
    SmithMachineOverheadPress,
    SplitStanceHammerCurlToPress,
    SwissBallDumbbellShoulderPress,
    WeightPlateFrontRaise,
}
impl fmt::Display for ShoulderPressExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ShoulderPressExerciseName::AlternatingDumbbellShoulderPress => {
                f.write_str("alternating_dumbbell_shoulder_press")
            }
            ShoulderPressExerciseName::ArnoldPress => f.write_str("arnold_press"),
            ShoulderPressExerciseName::BarbellFrontSquatToPushPress => {
                f.write_str("barbell_front_squat_to_push_press")
            }
            ShoulderPressExerciseName::BarbellPushPress => f.write_str("barbell_push_press"),
            ShoulderPressExerciseName::BarbellShoulderPress => {
                f.write_str("barbell_shoulder_press")
            }
            ShoulderPressExerciseName::DeadCurlPress => f.write_str("dead_curl_press"),
            ShoulderPressExerciseName::DumbbellAlternatingShoulderPressAndTwist => {
                f.write_str("dumbbell_alternating_shoulder_press_and_twist")
            }
            ShoulderPressExerciseName::DumbbellHammerCurlToLungeToPress => {
                f.write_str("dumbbell_hammer_curl_to_lunge_to_press")
            }
            ShoulderPressExerciseName::DumbbellPushPress => f.write_str("dumbbell_push_press"),
            ShoulderPressExerciseName::FloorInvertedShoulderPress => {
                f.write_str("floor_inverted_shoulder_press")
            }
            ShoulderPressExerciseName::WeightedFloorInvertedShoulderPress => {
                f.write_str("weighted_floor_inverted_shoulder_press")
            }
            ShoulderPressExerciseName::InvertedShoulderPress => {
                f.write_str("inverted_shoulder_press")
            }
            ShoulderPressExerciseName::WeightedInvertedShoulderPress => {
                f.write_str("weighted_inverted_shoulder_press")
            }
            ShoulderPressExerciseName::OneArmPushPress => f.write_str("one_arm_push_press"),
            ShoulderPressExerciseName::OverheadBarbellPress => {
                f.write_str("overhead_barbell_press")
            }
            ShoulderPressExerciseName::OverheadDumbbellPress => {
                f.write_str("overhead_dumbbell_press")
            }
            ShoulderPressExerciseName::SeatedBarbellShoulderPress => {
                f.write_str("seated_barbell_shoulder_press")
            }
            ShoulderPressExerciseName::SeatedDumbbellShoulderPress => {
                f.write_str("seated_dumbbell_shoulder_press")
            }
            ShoulderPressExerciseName::SingleArmDumbbellShoulderPress => {
                f.write_str("single_arm_dumbbell_shoulder_press")
            }
            ShoulderPressExerciseName::SingleArmStepUpAndPress => {
                f.write_str("single_arm_step_up_and_press")
            }
            ShoulderPressExerciseName::SmithMachineOverheadPress => {
                f.write_str("smith_machine_overhead_press")
            }
            ShoulderPressExerciseName::SplitStanceHammerCurlToPress => {
                f.write_str("split_stance_hammer_curl_to_press")
            }
            ShoulderPressExerciseName::SwissBallDumbbellShoulderPress => {
                f.write_str("swiss_ball_dumbbell_shoulder_press")
            }
            ShoulderPressExerciseName::WeightPlateFrontRaise => {
                f.write_str("weight_plate_front_raise")
            }
        }
    }
}
impl ShoulderPressExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ShoulderPressExerciseName::AlternatingDumbbellShoulderPress => fit::Value::UInt16(0),
            ShoulderPressExerciseName::ArnoldPress => fit::Value::UInt16(1),
            ShoulderPressExerciseName::BarbellFrontSquatToPushPress => fit::Value::UInt16(2),
            ShoulderPressExerciseName::BarbellPushPress => fit::Value::UInt16(3),
            ShoulderPressExerciseName::BarbellShoulderPress => fit::Value::UInt16(4),
            ShoulderPressExerciseName::DeadCurlPress => fit::Value::UInt16(5),
            ShoulderPressExerciseName::DumbbellAlternatingShoulderPressAndTwist => {
                fit::Value::UInt16(6)
            }
            ShoulderPressExerciseName::DumbbellHammerCurlToLungeToPress => fit::Value::UInt16(7),
            ShoulderPressExerciseName::DumbbellPushPress => fit::Value::UInt16(8),
            ShoulderPressExerciseName::FloorInvertedShoulderPress => fit::Value::UInt16(9),
            ShoulderPressExerciseName::WeightedFloorInvertedShoulderPress => fit::Value::UInt16(10),
            ShoulderPressExerciseName::InvertedShoulderPress => fit::Value::UInt16(11),
            ShoulderPressExerciseName::WeightedInvertedShoulderPress => fit::Value::UInt16(12),
            ShoulderPressExerciseName::OneArmPushPress => fit::Value::UInt16(13),
            ShoulderPressExerciseName::OverheadBarbellPress => fit::Value::UInt16(14),
            ShoulderPressExerciseName::OverheadDumbbellPress => fit::Value::UInt16(15),
            ShoulderPressExerciseName::SeatedBarbellShoulderPress => fit::Value::UInt16(16),
            ShoulderPressExerciseName::SeatedDumbbellShoulderPress => fit::Value::UInt16(17),
            ShoulderPressExerciseName::SingleArmDumbbellShoulderPress => fit::Value::UInt16(18),
            ShoulderPressExerciseName::SingleArmStepUpAndPress => fit::Value::UInt16(19),
            ShoulderPressExerciseName::SmithMachineOverheadPress => fit::Value::UInt16(20),
            ShoulderPressExerciseName::SplitStanceHammerCurlToPress => fit::Value::UInt16(21),
            ShoulderPressExerciseName::SwissBallDumbbellShoulderPress => fit::Value::UInt16(22),
            ShoulderPressExerciseName::WeightPlateFrontRaise => fit::Value::UInt16(23),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for ShoulderPressExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => {
                Ok(ShoulderPressExerciseName::AlternatingDumbbellShoulderPress)
            }
            fit::Value::UInt16(1) => Ok(ShoulderPressExerciseName::ArnoldPress),
            fit::Value::UInt16(2) => Ok(ShoulderPressExerciseName::BarbellFrontSquatToPushPress),
            fit::Value::UInt16(3) => Ok(ShoulderPressExerciseName::BarbellPushPress),
            fit::Value::UInt16(4) => Ok(ShoulderPressExerciseName::BarbellShoulderPress),
            fit::Value::UInt16(5) => Ok(ShoulderPressExerciseName::DeadCurlPress),
            fit::Value::UInt16(6) => {
                Ok(ShoulderPressExerciseName::DumbbellAlternatingShoulderPressAndTwist)
            }
            fit::Value::UInt16(7) => {
                Ok(ShoulderPressExerciseName::DumbbellHammerCurlToLungeToPress)
            }
            fit::Value::UInt16(8) => Ok(ShoulderPressExerciseName::DumbbellPushPress),
            fit::Value::UInt16(9) => Ok(ShoulderPressExerciseName::FloorInvertedShoulderPress),
            fit::Value::UInt16(10) => {
                Ok(ShoulderPressExerciseName::WeightedFloorInvertedShoulderPress)
            }
            fit::Value::UInt16(11) => Ok(ShoulderPressExerciseName::InvertedShoulderPress),
            fit::Value::UInt16(12) => Ok(ShoulderPressExerciseName::WeightedInvertedShoulderPress),
            fit::Value::UInt16(13) => Ok(ShoulderPressExerciseName::OneArmPushPress),
            fit::Value::UInt16(14) => Ok(ShoulderPressExerciseName::OverheadBarbellPress),
            fit::Value::UInt16(15) => Ok(ShoulderPressExerciseName::OverheadDumbbellPress),
            fit::Value::UInt16(16) => Ok(ShoulderPressExerciseName::SeatedBarbellShoulderPress),
            fit::Value::UInt16(17) => Ok(ShoulderPressExerciseName::SeatedDumbbellShoulderPress),
            fit::Value::UInt16(18) => Ok(ShoulderPressExerciseName::SingleArmDumbbellShoulderPress),
            fit::Value::UInt16(19) => Ok(ShoulderPressExerciseName::SingleArmStepUpAndPress),
            fit::Value::UInt16(20) => Ok(ShoulderPressExerciseName::SmithMachineOverheadPress),
            fit::Value::UInt16(21) => Ok(ShoulderPressExerciseName::SplitStanceHammerCurlToPress),
            fit::Value::UInt16(22) => Ok(ShoulderPressExerciseName::SwissBallDumbbellShoulderPress),
            fit::Value::UInt16(23) => Ok(ShoulderPressExerciseName::WeightPlateFrontRaise),
            _ => Err("No corresponding ShoulderPressExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for ShoulderPressExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "alternating_dumbbell_shoulder_press" => {
                Ok(ShoulderPressExerciseName::AlternatingDumbbellShoulderPress)
            }
            "arnold_press" => Ok(ShoulderPressExerciseName::ArnoldPress),
            "barbell_front_squat_to_push_press" => {
                Ok(ShoulderPressExerciseName::BarbellFrontSquatToPushPress)
            }
            "barbell_push_press" => Ok(ShoulderPressExerciseName::BarbellPushPress),
            "barbell_shoulder_press" => Ok(ShoulderPressExerciseName::BarbellShoulderPress),
            "dead_curl_press" => Ok(ShoulderPressExerciseName::DeadCurlPress),
            "dumbbell_alternating_shoulder_press_and_twist" => {
                Ok(ShoulderPressExerciseName::DumbbellAlternatingShoulderPressAndTwist)
            }
            "dumbbell_hammer_curl_to_lunge_to_press" => {
                Ok(ShoulderPressExerciseName::DumbbellHammerCurlToLungeToPress)
            }
            "dumbbell_push_press" => Ok(ShoulderPressExerciseName::DumbbellPushPress),
            "floor_inverted_shoulder_press" => {
                Ok(ShoulderPressExerciseName::FloorInvertedShoulderPress)
            }
            "weighted_floor_inverted_shoulder_press" => {
                Ok(ShoulderPressExerciseName::WeightedFloorInvertedShoulderPress)
            }
            "inverted_shoulder_press" => Ok(ShoulderPressExerciseName::InvertedShoulderPress),
            "weighted_inverted_shoulder_press" => {
                Ok(ShoulderPressExerciseName::WeightedInvertedShoulderPress)
            }
            "one_arm_push_press" => Ok(ShoulderPressExerciseName::OneArmPushPress),
            "overhead_barbell_press" => Ok(ShoulderPressExerciseName::OverheadBarbellPress),
            "overhead_dumbbell_press" => Ok(ShoulderPressExerciseName::OverheadDumbbellPress),
            "seated_barbell_shoulder_press" => {
                Ok(ShoulderPressExerciseName::SeatedBarbellShoulderPress)
            }
            "seated_dumbbell_shoulder_press" => {
                Ok(ShoulderPressExerciseName::SeatedDumbbellShoulderPress)
            }
            "single_arm_dumbbell_shoulder_press" => {
                Ok(ShoulderPressExerciseName::SingleArmDumbbellShoulderPress)
            }
            "single_arm_step_up_and_press" => {
                Ok(ShoulderPressExerciseName::SingleArmStepUpAndPress)
            }
            "smith_machine_overhead_press" => {
                Ok(ShoulderPressExerciseName::SmithMachineOverheadPress)
            }
            "split_stance_hammer_curl_to_press" => {
                Ok(ShoulderPressExerciseName::SplitStanceHammerCurlToPress)
            }
            "swiss_ball_dumbbell_shoulder_press" => {
                Ok(ShoulderPressExerciseName::SwissBallDumbbellShoulderPress)
            }
            "weight_plate_front_raise" => Ok(ShoulderPressExerciseName::WeightPlateFrontRaise),
            _ => Err("No corresponding ShoulderPressExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ShoulderStabilityExerciseName {
    N90DegreeCableExternalRotation,
    BandExternalRotation,
    BandInternalRotation,
    BentArmLateralRaiseAndExternalRotation,
    CableExternalRotation,
    DumbbellFacePullWithExternalRotation,
    FloorIRaise,
    WeightedFloorIRaise,
    FloorTRaise,
    WeightedFloorTRaise,
    FloorYRaise,
    WeightedFloorYRaise,
    InclineIRaise,
    WeightedInclineIRaise,
    InclineLRaise,
    WeightedInclineLRaise,
    InclineTRaise,
    WeightedInclineTRaise,
    InclineWRaise,
    WeightedInclineWRaise,
    InclineYRaise,
    WeightedInclineYRaise,
    LyingExternalRotation,
    SeatedDumbbellExternalRotation,
    StandingLRaise,
    SwissBallIRaise,
    WeightedSwissBallIRaise,
    SwissBallTRaise,
    WeightedSwissBallTRaise,
    SwissBallWRaise,
    WeightedSwissBallWRaise,
    SwissBallYRaise,
    WeightedSwissBallYRaise,
}
impl fmt::Display for ShoulderStabilityExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ShoulderStabilityExerciseName::N90DegreeCableExternalRotation => {
                f.write_str("90_degree_cable_external_rotation")
            }
            ShoulderStabilityExerciseName::BandExternalRotation => {
                f.write_str("band_external_rotation")
            }
            ShoulderStabilityExerciseName::BandInternalRotation => {
                f.write_str("band_internal_rotation")
            }
            ShoulderStabilityExerciseName::BentArmLateralRaiseAndExternalRotation => {
                f.write_str("bent_arm_lateral_raise_and_external_rotation")
            }
            ShoulderStabilityExerciseName::CableExternalRotation => {
                f.write_str("cable_external_rotation")
            }
            ShoulderStabilityExerciseName::DumbbellFacePullWithExternalRotation => {
                f.write_str("dumbbell_face_pull_with_external_rotation")
            }
            ShoulderStabilityExerciseName::FloorIRaise => f.write_str("floor_i_raise"),
            ShoulderStabilityExerciseName::WeightedFloorIRaise => {
                f.write_str("weighted_floor_i_raise")
            }
            ShoulderStabilityExerciseName::FloorTRaise => f.write_str("floor_t_raise"),
            ShoulderStabilityExerciseName::WeightedFloorTRaise => {
                f.write_str("weighted_floor_t_raise")
            }
            ShoulderStabilityExerciseName::FloorYRaise => f.write_str("floor_y_raise"),
            ShoulderStabilityExerciseName::WeightedFloorYRaise => {
                f.write_str("weighted_floor_y_raise")
            }
            ShoulderStabilityExerciseName::InclineIRaise => f.write_str("incline_i_raise"),
            ShoulderStabilityExerciseName::WeightedInclineIRaise => {
                f.write_str("weighted_incline_i_raise")
            }
            ShoulderStabilityExerciseName::InclineLRaise => f.write_str("incline_l_raise"),
            ShoulderStabilityExerciseName::WeightedInclineLRaise => {
                f.write_str("weighted_incline_l_raise")
            }
            ShoulderStabilityExerciseName::InclineTRaise => f.write_str("incline_t_raise"),
            ShoulderStabilityExerciseName::WeightedInclineTRaise => {
                f.write_str("weighted_incline_t_raise")
            }
            ShoulderStabilityExerciseName::InclineWRaise => f.write_str("incline_w_raise"),
            ShoulderStabilityExerciseName::WeightedInclineWRaise => {
                f.write_str("weighted_incline_w_raise")
            }
            ShoulderStabilityExerciseName::InclineYRaise => f.write_str("incline_y_raise"),
            ShoulderStabilityExerciseName::WeightedInclineYRaise => {
                f.write_str("weighted_incline_y_raise")
            }
            ShoulderStabilityExerciseName::LyingExternalRotation => {
                f.write_str("lying_external_rotation")
            }
            ShoulderStabilityExerciseName::SeatedDumbbellExternalRotation => {
                f.write_str("seated_dumbbell_external_rotation")
            }
            ShoulderStabilityExerciseName::StandingLRaise => f.write_str("standing_l_raise"),
            ShoulderStabilityExerciseName::SwissBallIRaise => f.write_str("swiss_ball_i_raise"),
            ShoulderStabilityExerciseName::WeightedSwissBallIRaise => {
                f.write_str("weighted_swiss_ball_i_raise")
            }
            ShoulderStabilityExerciseName::SwissBallTRaise => f.write_str("swiss_ball_t_raise"),
            ShoulderStabilityExerciseName::WeightedSwissBallTRaise => {
                f.write_str("weighted_swiss_ball_t_raise")
            }
            ShoulderStabilityExerciseName::SwissBallWRaise => f.write_str("swiss_ball_w_raise"),
            ShoulderStabilityExerciseName::WeightedSwissBallWRaise => {
                f.write_str("weighted_swiss_ball_w_raise")
            }
            ShoulderStabilityExerciseName::SwissBallYRaise => f.write_str("swiss_ball_y_raise"),
            ShoulderStabilityExerciseName::WeightedSwissBallYRaise => {
                f.write_str("weighted_swiss_ball_y_raise")
            }
        }
    }
}
impl ShoulderStabilityExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ShoulderStabilityExerciseName::N90DegreeCableExternalRotation => fit::Value::UInt16(0),
            ShoulderStabilityExerciseName::BandExternalRotation => fit::Value::UInt16(1),
            ShoulderStabilityExerciseName::BandInternalRotation => fit::Value::UInt16(2),
            ShoulderStabilityExerciseName::BentArmLateralRaiseAndExternalRotation => {
                fit::Value::UInt16(3)
            }
            ShoulderStabilityExerciseName::CableExternalRotation => fit::Value::UInt16(4),
            ShoulderStabilityExerciseName::DumbbellFacePullWithExternalRotation => {
                fit::Value::UInt16(5)
            }
            ShoulderStabilityExerciseName::FloorIRaise => fit::Value::UInt16(6),
            ShoulderStabilityExerciseName::WeightedFloorIRaise => fit::Value::UInt16(7),
            ShoulderStabilityExerciseName::FloorTRaise => fit::Value::UInt16(8),
            ShoulderStabilityExerciseName::WeightedFloorTRaise => fit::Value::UInt16(9),
            ShoulderStabilityExerciseName::FloorYRaise => fit::Value::UInt16(10),
            ShoulderStabilityExerciseName::WeightedFloorYRaise => fit::Value::UInt16(11),
            ShoulderStabilityExerciseName::InclineIRaise => fit::Value::UInt16(12),
            ShoulderStabilityExerciseName::WeightedInclineIRaise => fit::Value::UInt16(13),
            ShoulderStabilityExerciseName::InclineLRaise => fit::Value::UInt16(14),
            ShoulderStabilityExerciseName::WeightedInclineLRaise => fit::Value::UInt16(15),
            ShoulderStabilityExerciseName::InclineTRaise => fit::Value::UInt16(16),
            ShoulderStabilityExerciseName::WeightedInclineTRaise => fit::Value::UInt16(17),
            ShoulderStabilityExerciseName::InclineWRaise => fit::Value::UInt16(18),
            ShoulderStabilityExerciseName::WeightedInclineWRaise => fit::Value::UInt16(19),
            ShoulderStabilityExerciseName::InclineYRaise => fit::Value::UInt16(20),
            ShoulderStabilityExerciseName::WeightedInclineYRaise => fit::Value::UInt16(21),
            ShoulderStabilityExerciseName::LyingExternalRotation => fit::Value::UInt16(22),
            ShoulderStabilityExerciseName::SeatedDumbbellExternalRotation => fit::Value::UInt16(23),
            ShoulderStabilityExerciseName::StandingLRaise => fit::Value::UInt16(24),
            ShoulderStabilityExerciseName::SwissBallIRaise => fit::Value::UInt16(25),
            ShoulderStabilityExerciseName::WeightedSwissBallIRaise => fit::Value::UInt16(26),
            ShoulderStabilityExerciseName::SwissBallTRaise => fit::Value::UInt16(27),
            ShoulderStabilityExerciseName::WeightedSwissBallTRaise => fit::Value::UInt16(28),
            ShoulderStabilityExerciseName::SwissBallWRaise => fit::Value::UInt16(29),
            ShoulderStabilityExerciseName::WeightedSwissBallWRaise => fit::Value::UInt16(30),
            ShoulderStabilityExerciseName::SwissBallYRaise => fit::Value::UInt16(31),
            ShoulderStabilityExerciseName::WeightedSwissBallYRaise => fit::Value::UInt16(32),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for ShoulderStabilityExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => {
                Ok(ShoulderStabilityExerciseName::N90DegreeCableExternalRotation)
            }
            fit::Value::UInt16(1) => Ok(ShoulderStabilityExerciseName::BandExternalRotation),
            fit::Value::UInt16(2) => Ok(ShoulderStabilityExerciseName::BandInternalRotation),
            fit::Value::UInt16(3) => {
                Ok(ShoulderStabilityExerciseName::BentArmLateralRaiseAndExternalRotation)
            }
            fit::Value::UInt16(4) => Ok(ShoulderStabilityExerciseName::CableExternalRotation),
            fit::Value::UInt16(5) => {
                Ok(ShoulderStabilityExerciseName::DumbbellFacePullWithExternalRotation)
            }
            fit::Value::UInt16(6) => Ok(ShoulderStabilityExerciseName::FloorIRaise),
            fit::Value::UInt16(7) => Ok(ShoulderStabilityExerciseName::WeightedFloorIRaise),
            fit::Value::UInt16(8) => Ok(ShoulderStabilityExerciseName::FloorTRaise),
            fit::Value::UInt16(9) => Ok(ShoulderStabilityExerciseName::WeightedFloorTRaise),
            fit::Value::UInt16(10) => Ok(ShoulderStabilityExerciseName::FloorYRaise),
            fit::Value::UInt16(11) => Ok(ShoulderStabilityExerciseName::WeightedFloorYRaise),
            fit::Value::UInt16(12) => Ok(ShoulderStabilityExerciseName::InclineIRaise),
            fit::Value::UInt16(13) => Ok(ShoulderStabilityExerciseName::WeightedInclineIRaise),
            fit::Value::UInt16(14) => Ok(ShoulderStabilityExerciseName::InclineLRaise),
            fit::Value::UInt16(15) => Ok(ShoulderStabilityExerciseName::WeightedInclineLRaise),
            fit::Value::UInt16(16) => Ok(ShoulderStabilityExerciseName::InclineTRaise),
            fit::Value::UInt16(17) => Ok(ShoulderStabilityExerciseName::WeightedInclineTRaise),
            fit::Value::UInt16(18) => Ok(ShoulderStabilityExerciseName::InclineWRaise),
            fit::Value::UInt16(19) => Ok(ShoulderStabilityExerciseName::WeightedInclineWRaise),
            fit::Value::UInt16(20) => Ok(ShoulderStabilityExerciseName::InclineYRaise),
            fit::Value::UInt16(21) => Ok(ShoulderStabilityExerciseName::WeightedInclineYRaise),
            fit::Value::UInt16(22) => Ok(ShoulderStabilityExerciseName::LyingExternalRotation),
            fit::Value::UInt16(23) => {
                Ok(ShoulderStabilityExerciseName::SeatedDumbbellExternalRotation)
            }
            fit::Value::UInt16(24) => Ok(ShoulderStabilityExerciseName::StandingLRaise),
            fit::Value::UInt16(25) => Ok(ShoulderStabilityExerciseName::SwissBallIRaise),
            fit::Value::UInt16(26) => Ok(ShoulderStabilityExerciseName::WeightedSwissBallIRaise),
            fit::Value::UInt16(27) => Ok(ShoulderStabilityExerciseName::SwissBallTRaise),
            fit::Value::UInt16(28) => Ok(ShoulderStabilityExerciseName::WeightedSwissBallTRaise),
            fit::Value::UInt16(29) => Ok(ShoulderStabilityExerciseName::SwissBallWRaise),
            fit::Value::UInt16(30) => Ok(ShoulderStabilityExerciseName::WeightedSwissBallWRaise),
            fit::Value::UInt16(31) => Ok(ShoulderStabilityExerciseName::SwissBallYRaise),
            fit::Value::UInt16(32) => Ok(ShoulderStabilityExerciseName::WeightedSwissBallYRaise),
            _ => Err("No corresponding ShoulderStabilityExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for ShoulderStabilityExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "90_degree_cable_external_rotation" => {
                Ok(ShoulderStabilityExerciseName::N90DegreeCableExternalRotation)
            }
            "band_external_rotation" => Ok(ShoulderStabilityExerciseName::BandExternalRotation),
            "band_internal_rotation" => Ok(ShoulderStabilityExerciseName::BandInternalRotation),
            "bent_arm_lateral_raise_and_external_rotation" => {
                Ok(ShoulderStabilityExerciseName::BentArmLateralRaiseAndExternalRotation)
            }
            "cable_external_rotation" => Ok(ShoulderStabilityExerciseName::CableExternalRotation),
            "dumbbell_face_pull_with_external_rotation" => {
                Ok(ShoulderStabilityExerciseName::DumbbellFacePullWithExternalRotation)
            }
            "floor_i_raise" => Ok(ShoulderStabilityExerciseName::FloorIRaise),
            "weighted_floor_i_raise" => Ok(ShoulderStabilityExerciseName::WeightedFloorIRaise),
            "floor_t_raise" => Ok(ShoulderStabilityExerciseName::FloorTRaise),
            "weighted_floor_t_raise" => Ok(ShoulderStabilityExerciseName::WeightedFloorTRaise),
            "floor_y_raise" => Ok(ShoulderStabilityExerciseName::FloorYRaise),
            "weighted_floor_y_raise" => Ok(ShoulderStabilityExerciseName::WeightedFloorYRaise),
            "incline_i_raise" => Ok(ShoulderStabilityExerciseName::InclineIRaise),
            "weighted_incline_i_raise" => Ok(ShoulderStabilityExerciseName::WeightedInclineIRaise),
            "incline_l_raise" => Ok(ShoulderStabilityExerciseName::InclineLRaise),
            "weighted_incline_l_raise" => Ok(ShoulderStabilityExerciseName::WeightedInclineLRaise),
            "incline_t_raise" => Ok(ShoulderStabilityExerciseName::InclineTRaise),
            "weighted_incline_t_raise" => Ok(ShoulderStabilityExerciseName::WeightedInclineTRaise),
            "incline_w_raise" => Ok(ShoulderStabilityExerciseName::InclineWRaise),
            "weighted_incline_w_raise" => Ok(ShoulderStabilityExerciseName::WeightedInclineWRaise),
            "incline_y_raise" => Ok(ShoulderStabilityExerciseName::InclineYRaise),
            "weighted_incline_y_raise" => Ok(ShoulderStabilityExerciseName::WeightedInclineYRaise),
            "lying_external_rotation" => Ok(ShoulderStabilityExerciseName::LyingExternalRotation),
            "seated_dumbbell_external_rotation" => {
                Ok(ShoulderStabilityExerciseName::SeatedDumbbellExternalRotation)
            }
            "standing_l_raise" => Ok(ShoulderStabilityExerciseName::StandingLRaise),
            "swiss_ball_i_raise" => Ok(ShoulderStabilityExerciseName::SwissBallIRaise),
            "weighted_swiss_ball_i_raise" => {
                Ok(ShoulderStabilityExerciseName::WeightedSwissBallIRaise)
            }
            "swiss_ball_t_raise" => Ok(ShoulderStabilityExerciseName::SwissBallTRaise),
            "weighted_swiss_ball_t_raise" => {
                Ok(ShoulderStabilityExerciseName::WeightedSwissBallTRaise)
            }
            "swiss_ball_w_raise" => Ok(ShoulderStabilityExerciseName::SwissBallWRaise),
            "weighted_swiss_ball_w_raise" => {
                Ok(ShoulderStabilityExerciseName::WeightedSwissBallWRaise)
            }
            "swiss_ball_y_raise" => Ok(ShoulderStabilityExerciseName::SwissBallYRaise),
            "weighted_swiss_ball_y_raise" => {
                Ok(ShoulderStabilityExerciseName::WeightedSwissBallYRaise)
            }
            _ => Err("No corresponding ShoulderStabilityExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ShrugExerciseName {
    BarbellJumpShrug,
    BarbellShrug,
    BarbellUprightRow,
    BehindTheBackSmithMachineShrug,
    DumbbellJumpShrug,
    DumbbellShrug,
    DumbbellUprightRow,
    InclineDumbbellShrug,
    OverheadBarbellShrug,
    OverheadDumbbellShrug,
    ScaptionAndShrug,
    ScapularRetraction,
    SerratusChairShrug,
    WeightedSerratusChairShrug,
    SerratusShrug,
    WeightedSerratusShrug,
    WideGripJumpShrug,
}
impl fmt::Display for ShrugExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ShrugExerciseName::BarbellJumpShrug => f.write_str("barbell_jump_shrug"),
            ShrugExerciseName::BarbellShrug => f.write_str("barbell_shrug"),
            ShrugExerciseName::BarbellUprightRow => f.write_str("barbell_upright_row"),
            ShrugExerciseName::BehindTheBackSmithMachineShrug => {
                f.write_str("behind_the_back_smith_machine_shrug")
            }
            ShrugExerciseName::DumbbellJumpShrug => f.write_str("dumbbell_jump_shrug"),
            ShrugExerciseName::DumbbellShrug => f.write_str("dumbbell_shrug"),
            ShrugExerciseName::DumbbellUprightRow => f.write_str("dumbbell_upright_row"),
            ShrugExerciseName::InclineDumbbellShrug => f.write_str("incline_dumbbell_shrug"),
            ShrugExerciseName::OverheadBarbellShrug => f.write_str("overhead_barbell_shrug"),
            ShrugExerciseName::OverheadDumbbellShrug => f.write_str("overhead_dumbbell_shrug"),
            ShrugExerciseName::ScaptionAndShrug => f.write_str("scaption_and_shrug"),
            ShrugExerciseName::ScapularRetraction => f.write_str("scapular_retraction"),
            ShrugExerciseName::SerratusChairShrug => f.write_str("serratus_chair_shrug"),
            ShrugExerciseName::WeightedSerratusChairShrug => {
                f.write_str("weighted_serratus_chair_shrug")
            }
            ShrugExerciseName::SerratusShrug => f.write_str("serratus_shrug"),
            ShrugExerciseName::WeightedSerratusShrug => f.write_str("weighted_serratus_shrug"),
            ShrugExerciseName::WideGripJumpShrug => f.write_str("wide_grip_jump_shrug"),
        }
    }
}
impl ShrugExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ShrugExerciseName::BarbellJumpShrug => fit::Value::UInt16(0),
            ShrugExerciseName::BarbellShrug => fit::Value::UInt16(1),
            ShrugExerciseName::BarbellUprightRow => fit::Value::UInt16(2),
            ShrugExerciseName::BehindTheBackSmithMachineShrug => fit::Value::UInt16(3),
            ShrugExerciseName::DumbbellJumpShrug => fit::Value::UInt16(4),
            ShrugExerciseName::DumbbellShrug => fit::Value::UInt16(5),
            ShrugExerciseName::DumbbellUprightRow => fit::Value::UInt16(6),
            ShrugExerciseName::InclineDumbbellShrug => fit::Value::UInt16(7),
            ShrugExerciseName::OverheadBarbellShrug => fit::Value::UInt16(8),
            ShrugExerciseName::OverheadDumbbellShrug => fit::Value::UInt16(9),
            ShrugExerciseName::ScaptionAndShrug => fit::Value::UInt16(10),
            ShrugExerciseName::ScapularRetraction => fit::Value::UInt16(11),
            ShrugExerciseName::SerratusChairShrug => fit::Value::UInt16(12),
            ShrugExerciseName::WeightedSerratusChairShrug => fit::Value::UInt16(13),
            ShrugExerciseName::SerratusShrug => fit::Value::UInt16(14),
            ShrugExerciseName::WeightedSerratusShrug => fit::Value::UInt16(15),
            ShrugExerciseName::WideGripJumpShrug => fit::Value::UInt16(16),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for ShrugExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(ShrugExerciseName::BarbellJumpShrug),
            fit::Value::UInt16(1) => Ok(ShrugExerciseName::BarbellShrug),
            fit::Value::UInt16(2) => Ok(ShrugExerciseName::BarbellUprightRow),
            fit::Value::UInt16(3) => Ok(ShrugExerciseName::BehindTheBackSmithMachineShrug),
            fit::Value::UInt16(4) => Ok(ShrugExerciseName::DumbbellJumpShrug),
            fit::Value::UInt16(5) => Ok(ShrugExerciseName::DumbbellShrug),
            fit::Value::UInt16(6) => Ok(ShrugExerciseName::DumbbellUprightRow),
            fit::Value::UInt16(7) => Ok(ShrugExerciseName::InclineDumbbellShrug),
            fit::Value::UInt16(8) => Ok(ShrugExerciseName::OverheadBarbellShrug),
            fit::Value::UInt16(9) => Ok(ShrugExerciseName::OverheadDumbbellShrug),
            fit::Value::UInt16(10) => Ok(ShrugExerciseName::ScaptionAndShrug),
            fit::Value::UInt16(11) => Ok(ShrugExerciseName::ScapularRetraction),
            fit::Value::UInt16(12) => Ok(ShrugExerciseName::SerratusChairShrug),
            fit::Value::UInt16(13) => Ok(ShrugExerciseName::WeightedSerratusChairShrug),
            fit::Value::UInt16(14) => Ok(ShrugExerciseName::SerratusShrug),
            fit::Value::UInt16(15) => Ok(ShrugExerciseName::WeightedSerratusShrug),
            fit::Value::UInt16(16) => Ok(ShrugExerciseName::WideGripJumpShrug),
            _ => Err("No corresponding ShrugExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for ShrugExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "barbell_jump_shrug" => Ok(ShrugExerciseName::BarbellJumpShrug),
            "barbell_shrug" => Ok(ShrugExerciseName::BarbellShrug),
            "barbell_upright_row" => Ok(ShrugExerciseName::BarbellUprightRow),
            "behind_the_back_smith_machine_shrug" => {
                Ok(ShrugExerciseName::BehindTheBackSmithMachineShrug)
            }
            "dumbbell_jump_shrug" => Ok(ShrugExerciseName::DumbbellJumpShrug),
            "dumbbell_shrug" => Ok(ShrugExerciseName::DumbbellShrug),
            "dumbbell_upright_row" => Ok(ShrugExerciseName::DumbbellUprightRow),
            "incline_dumbbell_shrug" => Ok(ShrugExerciseName::InclineDumbbellShrug),
            "overhead_barbell_shrug" => Ok(ShrugExerciseName::OverheadBarbellShrug),
            "overhead_dumbbell_shrug" => Ok(ShrugExerciseName::OverheadDumbbellShrug),
            "scaption_and_shrug" => Ok(ShrugExerciseName::ScaptionAndShrug),
            "scapular_retraction" => Ok(ShrugExerciseName::ScapularRetraction),
            "serratus_chair_shrug" => Ok(ShrugExerciseName::SerratusChairShrug),
            "weighted_serratus_chair_shrug" => Ok(ShrugExerciseName::WeightedSerratusChairShrug),
            "serratus_shrug" => Ok(ShrugExerciseName::SerratusShrug),
            "weighted_serratus_shrug" => Ok(ShrugExerciseName::WeightedSerratusShrug),
            "wide_grip_jump_shrug" => Ok(ShrugExerciseName::WideGripJumpShrug),
            _ => Err("No corresponding ShrugExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SitUpExerciseName {
    AlternatingSitUp,
    WeightedAlternatingSitUp,
    BentKneeVUp,
    WeightedBentKneeVUp,
    ButterflySitUp,
    WeightedButterflySitup,
    CrossPunchRollUp,
    WeightedCrossPunchRollUp,
    CrossedArmsSitUp,
    WeightedCrossedArmsSitUp,
    GetUpSitUp,
    WeightedGetUpSitUp,
    HoveringSitUp,
    WeightedHoveringSitUp,
    KettlebellSitUp,
    MedicineBallAlternatingVUp,
    MedicineBallSitUp,
    MedicineBallVUp,
    ModifiedSitUp,
    NegativeSitUp,
    OneArmFullSitUp,
    RecliningCircle,
    WeightedRecliningCircle,
    ReverseCurlUp,
    WeightedReverseCurlUp,
    SingleLegSwissBallJackknife,
    WeightedSingleLegSwissBallJackknife,
    TheTeaser,
    TheTeaserWeighted,
    ThreePartRollDown,
    WeightedThreePartRollDown,
    VUp,
    WeightedVUp,
    WeightedRussianTwistOnSwissBall,
    WeightedSitUp,
    XAbs,
    WeightedXAbs,
    SitUp,
}
impl fmt::Display for SitUpExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SitUpExerciseName::AlternatingSitUp => f.write_str("alternating_sit_up"),
            SitUpExerciseName::WeightedAlternatingSitUp => {
                f.write_str("weighted_alternating_sit_up")
            }
            SitUpExerciseName::BentKneeVUp => f.write_str("bent_knee_v_up"),
            SitUpExerciseName::WeightedBentKneeVUp => f.write_str("weighted_bent_knee_v_up"),
            SitUpExerciseName::ButterflySitUp => f.write_str("butterfly_sit_up"),
            SitUpExerciseName::WeightedButterflySitup => f.write_str("weighted_butterfly_situp"),
            SitUpExerciseName::CrossPunchRollUp => f.write_str("cross_punch_roll_up"),
            SitUpExerciseName::WeightedCrossPunchRollUp => {
                f.write_str("weighted_cross_punch_roll_up")
            }
            SitUpExerciseName::CrossedArmsSitUp => f.write_str("crossed_arms_sit_up"),
            SitUpExerciseName::WeightedCrossedArmsSitUp => {
                f.write_str("weighted_crossed_arms_sit_up")
            }
            SitUpExerciseName::GetUpSitUp => f.write_str("get_up_sit_up"),
            SitUpExerciseName::WeightedGetUpSitUp => f.write_str("weighted_get_up_sit_up"),
            SitUpExerciseName::HoveringSitUp => f.write_str("hovering_sit_up"),
            SitUpExerciseName::WeightedHoveringSitUp => f.write_str("weighted_hovering_sit_up"),
            SitUpExerciseName::KettlebellSitUp => f.write_str("kettlebell_sit_up"),
            SitUpExerciseName::MedicineBallAlternatingVUp => {
                f.write_str("medicine_ball_alternating_v_up")
            }
            SitUpExerciseName::MedicineBallSitUp => f.write_str("medicine_ball_sit_up"),
            SitUpExerciseName::MedicineBallVUp => f.write_str("medicine_ball_v_up"),
            SitUpExerciseName::ModifiedSitUp => f.write_str("modified_sit_up"),
            SitUpExerciseName::NegativeSitUp => f.write_str("negative_sit_up"),
            SitUpExerciseName::OneArmFullSitUp => f.write_str("one_arm_full_sit_up"),
            SitUpExerciseName::RecliningCircle => f.write_str("reclining_circle"),
            SitUpExerciseName::WeightedRecliningCircle => f.write_str("weighted_reclining_circle"),
            SitUpExerciseName::ReverseCurlUp => f.write_str("reverse_curl_up"),
            SitUpExerciseName::WeightedReverseCurlUp => f.write_str("weighted_reverse_curl_up"),
            SitUpExerciseName::SingleLegSwissBallJackknife => {
                f.write_str("single_leg_swiss_ball_jackknife")
            }
            SitUpExerciseName::WeightedSingleLegSwissBallJackknife => {
                f.write_str("weighted_single_leg_swiss_ball_jackknife")
            }
            SitUpExerciseName::TheTeaser => f.write_str("the_teaser"),
            SitUpExerciseName::TheTeaserWeighted => f.write_str("the_teaser_weighted"),
            SitUpExerciseName::ThreePartRollDown => f.write_str("three_part_roll_down"),
            SitUpExerciseName::WeightedThreePartRollDown => {
                f.write_str("weighted_three_part_roll_down")
            }
            SitUpExerciseName::VUp => f.write_str("v_up"),
            SitUpExerciseName::WeightedVUp => f.write_str("weighted_v_up"),
            SitUpExerciseName::WeightedRussianTwistOnSwissBall => {
                f.write_str("weighted_russian_twist_on_swiss_ball")
            }
            SitUpExerciseName::WeightedSitUp => f.write_str("weighted_sit_up"),
            SitUpExerciseName::XAbs => f.write_str("x_abs"),
            SitUpExerciseName::WeightedXAbs => f.write_str("weighted_x_abs"),
            SitUpExerciseName::SitUp => f.write_str("sit_up"),
        }
    }
}
impl SitUpExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SitUpExerciseName::AlternatingSitUp => fit::Value::UInt16(0),
            SitUpExerciseName::WeightedAlternatingSitUp => fit::Value::UInt16(1),
            SitUpExerciseName::BentKneeVUp => fit::Value::UInt16(2),
            SitUpExerciseName::WeightedBentKneeVUp => fit::Value::UInt16(3),
            SitUpExerciseName::ButterflySitUp => fit::Value::UInt16(4),
            SitUpExerciseName::WeightedButterflySitup => fit::Value::UInt16(5),
            SitUpExerciseName::CrossPunchRollUp => fit::Value::UInt16(6),
            SitUpExerciseName::WeightedCrossPunchRollUp => fit::Value::UInt16(7),
            SitUpExerciseName::CrossedArmsSitUp => fit::Value::UInt16(8),
            SitUpExerciseName::WeightedCrossedArmsSitUp => fit::Value::UInt16(9),
            SitUpExerciseName::GetUpSitUp => fit::Value::UInt16(10),
            SitUpExerciseName::WeightedGetUpSitUp => fit::Value::UInt16(11),
            SitUpExerciseName::HoveringSitUp => fit::Value::UInt16(12),
            SitUpExerciseName::WeightedHoveringSitUp => fit::Value::UInt16(13),
            SitUpExerciseName::KettlebellSitUp => fit::Value::UInt16(14),
            SitUpExerciseName::MedicineBallAlternatingVUp => fit::Value::UInt16(15),
            SitUpExerciseName::MedicineBallSitUp => fit::Value::UInt16(16),
            SitUpExerciseName::MedicineBallVUp => fit::Value::UInt16(17),
            SitUpExerciseName::ModifiedSitUp => fit::Value::UInt16(18),
            SitUpExerciseName::NegativeSitUp => fit::Value::UInt16(19),
            SitUpExerciseName::OneArmFullSitUp => fit::Value::UInt16(20),
            SitUpExerciseName::RecliningCircle => fit::Value::UInt16(21),
            SitUpExerciseName::WeightedRecliningCircle => fit::Value::UInt16(22),
            SitUpExerciseName::ReverseCurlUp => fit::Value::UInt16(23),
            SitUpExerciseName::WeightedReverseCurlUp => fit::Value::UInt16(24),
            SitUpExerciseName::SingleLegSwissBallJackknife => fit::Value::UInt16(25),
            SitUpExerciseName::WeightedSingleLegSwissBallJackknife => fit::Value::UInt16(26),
            SitUpExerciseName::TheTeaser => fit::Value::UInt16(27),
            SitUpExerciseName::TheTeaserWeighted => fit::Value::UInt16(28),
            SitUpExerciseName::ThreePartRollDown => fit::Value::UInt16(29),
            SitUpExerciseName::WeightedThreePartRollDown => fit::Value::UInt16(30),
            SitUpExerciseName::VUp => fit::Value::UInt16(31),
            SitUpExerciseName::WeightedVUp => fit::Value::UInt16(32),
            SitUpExerciseName::WeightedRussianTwistOnSwissBall => fit::Value::UInt16(33),
            SitUpExerciseName::WeightedSitUp => fit::Value::UInt16(34),
            SitUpExerciseName::XAbs => fit::Value::UInt16(35),
            SitUpExerciseName::WeightedXAbs => fit::Value::UInt16(36),
            SitUpExerciseName::SitUp => fit::Value::UInt16(37),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for SitUpExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(SitUpExerciseName::AlternatingSitUp),
            fit::Value::UInt16(1) => Ok(SitUpExerciseName::WeightedAlternatingSitUp),
            fit::Value::UInt16(2) => Ok(SitUpExerciseName::BentKneeVUp),
            fit::Value::UInt16(3) => Ok(SitUpExerciseName::WeightedBentKneeVUp),
            fit::Value::UInt16(4) => Ok(SitUpExerciseName::ButterflySitUp),
            fit::Value::UInt16(5) => Ok(SitUpExerciseName::WeightedButterflySitup),
            fit::Value::UInt16(6) => Ok(SitUpExerciseName::CrossPunchRollUp),
            fit::Value::UInt16(7) => Ok(SitUpExerciseName::WeightedCrossPunchRollUp),
            fit::Value::UInt16(8) => Ok(SitUpExerciseName::CrossedArmsSitUp),
            fit::Value::UInt16(9) => Ok(SitUpExerciseName::WeightedCrossedArmsSitUp),
            fit::Value::UInt16(10) => Ok(SitUpExerciseName::GetUpSitUp),
            fit::Value::UInt16(11) => Ok(SitUpExerciseName::WeightedGetUpSitUp),
            fit::Value::UInt16(12) => Ok(SitUpExerciseName::HoveringSitUp),
            fit::Value::UInt16(13) => Ok(SitUpExerciseName::WeightedHoveringSitUp),
            fit::Value::UInt16(14) => Ok(SitUpExerciseName::KettlebellSitUp),
            fit::Value::UInt16(15) => Ok(SitUpExerciseName::MedicineBallAlternatingVUp),
            fit::Value::UInt16(16) => Ok(SitUpExerciseName::MedicineBallSitUp),
            fit::Value::UInt16(17) => Ok(SitUpExerciseName::MedicineBallVUp),
            fit::Value::UInt16(18) => Ok(SitUpExerciseName::ModifiedSitUp),
            fit::Value::UInt16(19) => Ok(SitUpExerciseName::NegativeSitUp),
            fit::Value::UInt16(20) => Ok(SitUpExerciseName::OneArmFullSitUp),
            fit::Value::UInt16(21) => Ok(SitUpExerciseName::RecliningCircle),
            fit::Value::UInt16(22) => Ok(SitUpExerciseName::WeightedRecliningCircle),
            fit::Value::UInt16(23) => Ok(SitUpExerciseName::ReverseCurlUp),
            fit::Value::UInt16(24) => Ok(SitUpExerciseName::WeightedReverseCurlUp),
            fit::Value::UInt16(25) => Ok(SitUpExerciseName::SingleLegSwissBallJackknife),
            fit::Value::UInt16(26) => Ok(SitUpExerciseName::WeightedSingleLegSwissBallJackknife),
            fit::Value::UInt16(27) => Ok(SitUpExerciseName::TheTeaser),
            fit::Value::UInt16(28) => Ok(SitUpExerciseName::TheTeaserWeighted),
            fit::Value::UInt16(29) => Ok(SitUpExerciseName::ThreePartRollDown),
            fit::Value::UInt16(30) => Ok(SitUpExerciseName::WeightedThreePartRollDown),
            fit::Value::UInt16(31) => Ok(SitUpExerciseName::VUp),
            fit::Value::UInt16(32) => Ok(SitUpExerciseName::WeightedVUp),
            fit::Value::UInt16(33) => Ok(SitUpExerciseName::WeightedRussianTwistOnSwissBall),
            fit::Value::UInt16(34) => Ok(SitUpExerciseName::WeightedSitUp),
            fit::Value::UInt16(35) => Ok(SitUpExerciseName::XAbs),
            fit::Value::UInt16(36) => Ok(SitUpExerciseName::WeightedXAbs),
            fit::Value::UInt16(37) => Ok(SitUpExerciseName::SitUp),
            _ => Err("No corresponding SitUpExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for SitUpExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "alternating_sit_up" => Ok(SitUpExerciseName::AlternatingSitUp),
            "weighted_alternating_sit_up" => Ok(SitUpExerciseName::WeightedAlternatingSitUp),
            "bent_knee_v_up" => Ok(SitUpExerciseName::BentKneeVUp),
            "weighted_bent_knee_v_up" => Ok(SitUpExerciseName::WeightedBentKneeVUp),
            "butterfly_sit_up" => Ok(SitUpExerciseName::ButterflySitUp),
            "weighted_butterfly_situp" => Ok(SitUpExerciseName::WeightedButterflySitup),
            "cross_punch_roll_up" => Ok(SitUpExerciseName::CrossPunchRollUp),
            "weighted_cross_punch_roll_up" => Ok(SitUpExerciseName::WeightedCrossPunchRollUp),
            "crossed_arms_sit_up" => Ok(SitUpExerciseName::CrossedArmsSitUp),
            "weighted_crossed_arms_sit_up" => Ok(SitUpExerciseName::WeightedCrossedArmsSitUp),
            "get_up_sit_up" => Ok(SitUpExerciseName::GetUpSitUp),
            "weighted_get_up_sit_up" => Ok(SitUpExerciseName::WeightedGetUpSitUp),
            "hovering_sit_up" => Ok(SitUpExerciseName::HoveringSitUp),
            "weighted_hovering_sit_up" => Ok(SitUpExerciseName::WeightedHoveringSitUp),
            "kettlebell_sit_up" => Ok(SitUpExerciseName::KettlebellSitUp),
            "medicine_ball_alternating_v_up" => Ok(SitUpExerciseName::MedicineBallAlternatingVUp),
            "medicine_ball_sit_up" => Ok(SitUpExerciseName::MedicineBallSitUp),
            "medicine_ball_v_up" => Ok(SitUpExerciseName::MedicineBallVUp),
            "modified_sit_up" => Ok(SitUpExerciseName::ModifiedSitUp),
            "negative_sit_up" => Ok(SitUpExerciseName::NegativeSitUp),
            "one_arm_full_sit_up" => Ok(SitUpExerciseName::OneArmFullSitUp),
            "reclining_circle" => Ok(SitUpExerciseName::RecliningCircle),
            "weighted_reclining_circle" => Ok(SitUpExerciseName::WeightedRecliningCircle),
            "reverse_curl_up" => Ok(SitUpExerciseName::ReverseCurlUp),
            "weighted_reverse_curl_up" => Ok(SitUpExerciseName::WeightedReverseCurlUp),
            "single_leg_swiss_ball_jackknife" => Ok(SitUpExerciseName::SingleLegSwissBallJackknife),
            "weighted_single_leg_swiss_ball_jackknife" => {
                Ok(SitUpExerciseName::WeightedSingleLegSwissBallJackknife)
            }
            "the_teaser" => Ok(SitUpExerciseName::TheTeaser),
            "the_teaser_weighted" => Ok(SitUpExerciseName::TheTeaserWeighted),
            "three_part_roll_down" => Ok(SitUpExerciseName::ThreePartRollDown),
            "weighted_three_part_roll_down" => Ok(SitUpExerciseName::WeightedThreePartRollDown),
            "v_up" => Ok(SitUpExerciseName::VUp),
            "weighted_v_up" => Ok(SitUpExerciseName::WeightedVUp),
            "weighted_russian_twist_on_swiss_ball" => {
                Ok(SitUpExerciseName::WeightedRussianTwistOnSwissBall)
            }
            "weighted_sit_up" => Ok(SitUpExerciseName::WeightedSitUp),
            "x_abs" => Ok(SitUpExerciseName::XAbs),
            "weighted_x_abs" => Ok(SitUpExerciseName::WeightedXAbs),
            "sit_up" => Ok(SitUpExerciseName::SitUp),
            _ => Err("No corresponding SitUpExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SquatExerciseName {
    LegPress,
    BackSquatWithBodyBar,
    BackSquats,
    WeightedBackSquats,
    BalancingSquat,
    WeightedBalancingSquat,
    BarbellBackSquat,
    BarbellBoxSquat,
    BarbellFrontSquat,
    BarbellHackSquat,
    BarbellHangSquatSnatch,
    BarbellLateralStepUp,
    BarbellQuarterSquat,
    BarbellSiffSquat,
    BarbellSquatSnatch,
    BarbellSquatWithHeelsRaised,
    BarbellStepover,
    BarbellStepUp,
    BenchSquatWithRotationalChop,
    WeightedBenchSquatWithRotationalChop,
    BodyWeightWallSquat,
    WeightedWallSquat,
    BoxStepSquat,
    WeightedBoxStepSquat,
    BracedSquat,
    CrossedArmBarbellFrontSquat,
    CrossoverDumbbellStepUp,
    DumbbellFrontSquat,
    DumbbellSplitSquat,
    DumbbellSquat,
    DumbbellSquatClean,
    DumbbellStepover,
    DumbbellStepUp,
    ElevatedSingleLegSquat,
    WeightedElevatedSingleLegSquat,
    FigureFourSquats,
    WeightedFigureFourSquats,
    GobletSquat,
    KettlebellSquat,
    KettlebellSwingOverhead,
    KettlebellSwingWithFlipToSquat,
    LateralDumbbellStepUp,
    OneLeggedSquat,
    OverheadDumbbellSquat,
    OverheadSquat,
    PartialSingleLegSquat,
    WeightedPartialSingleLegSquat,
    PistolSquat,
    WeightedPistolSquat,
    PlieSlides,
    WeightedPlieSlides,
    PlieSquat,
    WeightedPlieSquat,
    PrisonerSquat,
    WeightedPrisonerSquat,
    SingleLegBenchGetUp,
    WeightedSingleLegBenchGetUp,
    SingleLegBenchSquat,
    WeightedSingleLegBenchSquat,
    SingleLegSquatOnSwissBall,
    WeightedSingleLegSquatOnSwissBall,
    Squat,
    WeightedSquat,
    SquatsWithBand,
    StaggeredSquat,
    WeightedStaggeredSquat,
    StepUp,
    WeightedStepUp,
    SuitcaseSquats,
    SumoSquat,
    SumoSquatSlideIn,
    WeightedSumoSquatSlideIn,
    SumoSquatToHighPull,
    SumoSquatToStand,
    WeightedSumoSquatToStand,
    SumoSquatWithRotation,
    WeightedSumoSquatWithRotation,
    SwissBallBodyWeightWallSquat,
    WeightedSwissBallWallSquat,
    Thrusters,
    UnevenSquat,
    WeightedUnevenSquat,
    WaistSlimmingSquat,
    WallBall,
    WideStanceBarbellSquat,
    WideStanceGobletSquat,
    ZercherSquat,
    /// Deprecated do not use
    KbsOverhead,
    SquatAndSideKick,
    SquatJumpsInNOut,
    PilatesPlieSquatsParallelTurnedOutFlatAndHeels,
    ReleveStraightLegAndKneeBentWithOneLegVariation,
}
impl fmt::Display for SquatExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SquatExerciseName::LegPress => f.write_str("leg_press"),
            SquatExerciseName::BackSquatWithBodyBar => f.write_str("back_squat_with_body_bar"),
            SquatExerciseName::BackSquats => f.write_str("back_squats"),
            SquatExerciseName::WeightedBackSquats => f.write_str("weighted_back_squats"),
            SquatExerciseName::BalancingSquat => f.write_str("balancing_squat"),
            SquatExerciseName::WeightedBalancingSquat => f.write_str("weighted_balancing_squat"),
            SquatExerciseName::BarbellBackSquat => f.write_str("barbell_back_squat"),
            SquatExerciseName::BarbellBoxSquat => f.write_str("barbell_box_squat"),
            SquatExerciseName::BarbellFrontSquat => f.write_str("barbell_front_squat"),
            SquatExerciseName::BarbellHackSquat => f.write_str("barbell_hack_squat"),
            SquatExerciseName::BarbellHangSquatSnatch => f.write_str("barbell_hang_squat_snatch"),
            SquatExerciseName::BarbellLateralStepUp => f.write_str("barbell_lateral_step_up"),
            SquatExerciseName::BarbellQuarterSquat => f.write_str("barbell_quarter_squat"),
            SquatExerciseName::BarbellSiffSquat => f.write_str("barbell_siff_squat"),
            SquatExerciseName::BarbellSquatSnatch => f.write_str("barbell_squat_snatch"),
            SquatExerciseName::BarbellSquatWithHeelsRaised => {
                f.write_str("barbell_squat_with_heels_raised")
            }
            SquatExerciseName::BarbellStepover => f.write_str("barbell_stepover"),
            SquatExerciseName::BarbellStepUp => f.write_str("barbell_step_up"),
            SquatExerciseName::BenchSquatWithRotationalChop => {
                f.write_str("bench_squat_with_rotational_chop")
            }
            SquatExerciseName::WeightedBenchSquatWithRotationalChop => {
                f.write_str("weighted_bench_squat_with_rotational_chop")
            }
            SquatExerciseName::BodyWeightWallSquat => f.write_str("body_weight_wall_squat"),
            SquatExerciseName::WeightedWallSquat => f.write_str("weighted_wall_squat"),
            SquatExerciseName::BoxStepSquat => f.write_str("box_step_squat"),
            SquatExerciseName::WeightedBoxStepSquat => f.write_str("weighted_box_step_squat"),
            SquatExerciseName::BracedSquat => f.write_str("braced_squat"),
            SquatExerciseName::CrossedArmBarbellFrontSquat => {
                f.write_str("crossed_arm_barbell_front_squat")
            }
            SquatExerciseName::CrossoverDumbbellStepUp => f.write_str("crossover_dumbbell_step_up"),
            SquatExerciseName::DumbbellFrontSquat => f.write_str("dumbbell_front_squat"),
            SquatExerciseName::DumbbellSplitSquat => f.write_str("dumbbell_split_squat"),
            SquatExerciseName::DumbbellSquat => f.write_str("dumbbell_squat"),
            SquatExerciseName::DumbbellSquatClean => f.write_str("dumbbell_squat_clean"),
            SquatExerciseName::DumbbellStepover => f.write_str("dumbbell_stepover"),
            SquatExerciseName::DumbbellStepUp => f.write_str("dumbbell_step_up"),
            SquatExerciseName::ElevatedSingleLegSquat => f.write_str("elevated_single_leg_squat"),
            SquatExerciseName::WeightedElevatedSingleLegSquat => {
                f.write_str("weighted_elevated_single_leg_squat")
            }
            SquatExerciseName::FigureFourSquats => f.write_str("figure_four_squats"),
            SquatExerciseName::WeightedFigureFourSquats => {
                f.write_str("weighted_figure_four_squats")
            }
            SquatExerciseName::GobletSquat => f.write_str("goblet_squat"),
            SquatExerciseName::KettlebellSquat => f.write_str("kettlebell_squat"),
            SquatExerciseName::KettlebellSwingOverhead => f.write_str("kettlebell_swing_overhead"),
            SquatExerciseName::KettlebellSwingWithFlipToSquat => {
                f.write_str("kettlebell_swing_with_flip_to_squat")
            }
            SquatExerciseName::LateralDumbbellStepUp => f.write_str("lateral_dumbbell_step_up"),
            SquatExerciseName::OneLeggedSquat => f.write_str("one_legged_squat"),
            SquatExerciseName::OverheadDumbbellSquat => f.write_str("overhead_dumbbell_squat"),
            SquatExerciseName::OverheadSquat => f.write_str("overhead_squat"),
            SquatExerciseName::PartialSingleLegSquat => f.write_str("partial_single_leg_squat"),
            SquatExerciseName::WeightedPartialSingleLegSquat => {
                f.write_str("weighted_partial_single_leg_squat")
            }
            SquatExerciseName::PistolSquat => f.write_str("pistol_squat"),
            SquatExerciseName::WeightedPistolSquat => f.write_str("weighted_pistol_squat"),
            SquatExerciseName::PlieSlides => f.write_str("plie_slides"),
            SquatExerciseName::WeightedPlieSlides => f.write_str("weighted_plie_slides"),
            SquatExerciseName::PlieSquat => f.write_str("plie_squat"),
            SquatExerciseName::WeightedPlieSquat => f.write_str("weighted_plie_squat"),
            SquatExerciseName::PrisonerSquat => f.write_str("prisoner_squat"),
            SquatExerciseName::WeightedPrisonerSquat => f.write_str("weighted_prisoner_squat"),
            SquatExerciseName::SingleLegBenchGetUp => f.write_str("single_leg_bench_get_up"),
            SquatExerciseName::WeightedSingleLegBenchGetUp => {
                f.write_str("weighted_single_leg_bench_get_up")
            }
            SquatExerciseName::SingleLegBenchSquat => f.write_str("single_leg_bench_squat"),
            SquatExerciseName::WeightedSingleLegBenchSquat => {
                f.write_str("weighted_single_leg_bench_squat")
            }
            SquatExerciseName::SingleLegSquatOnSwissBall => {
                f.write_str("single_leg_squat_on_swiss_ball")
            }
            SquatExerciseName::WeightedSingleLegSquatOnSwissBall => {
                f.write_str("weighted_single_leg_squat_on_swiss_ball")
            }
            SquatExerciseName::Squat => f.write_str("squat"),
            SquatExerciseName::WeightedSquat => f.write_str("weighted_squat"),
            SquatExerciseName::SquatsWithBand => f.write_str("squats_with_band"),
            SquatExerciseName::StaggeredSquat => f.write_str("staggered_squat"),
            SquatExerciseName::WeightedStaggeredSquat => f.write_str("weighted_staggered_squat"),
            SquatExerciseName::StepUp => f.write_str("step_up"),
            SquatExerciseName::WeightedStepUp => f.write_str("weighted_step_up"),
            SquatExerciseName::SuitcaseSquats => f.write_str("suitcase_squats"),
            SquatExerciseName::SumoSquat => f.write_str("sumo_squat"),
            SquatExerciseName::SumoSquatSlideIn => f.write_str("sumo_squat_slide_in"),
            SquatExerciseName::WeightedSumoSquatSlideIn => {
                f.write_str("weighted_sumo_squat_slide_in")
            }
            SquatExerciseName::SumoSquatToHighPull => f.write_str("sumo_squat_to_high_pull"),
            SquatExerciseName::SumoSquatToStand => f.write_str("sumo_squat_to_stand"),
            SquatExerciseName::WeightedSumoSquatToStand => {
                f.write_str("weighted_sumo_squat_to_stand")
            }
            SquatExerciseName::SumoSquatWithRotation => f.write_str("sumo_squat_with_rotation"),
            SquatExerciseName::WeightedSumoSquatWithRotation => {
                f.write_str("weighted_sumo_squat_with_rotation")
            }
            SquatExerciseName::SwissBallBodyWeightWallSquat => {
                f.write_str("swiss_ball_body_weight_wall_squat")
            }
            SquatExerciseName::WeightedSwissBallWallSquat => {
                f.write_str("weighted_swiss_ball_wall_squat")
            }
            SquatExerciseName::Thrusters => f.write_str("thrusters"),
            SquatExerciseName::UnevenSquat => f.write_str("uneven_squat"),
            SquatExerciseName::WeightedUnevenSquat => f.write_str("weighted_uneven_squat"),
            SquatExerciseName::WaistSlimmingSquat => f.write_str("waist_slimming_squat"),
            SquatExerciseName::WallBall => f.write_str("wall_ball"),
            SquatExerciseName::WideStanceBarbellSquat => f.write_str("wide_stance_barbell_squat"),
            SquatExerciseName::WideStanceGobletSquat => f.write_str("wide_stance_goblet_squat"),
            SquatExerciseName::ZercherSquat => f.write_str("zercher_squat"),
            SquatExerciseName::KbsOverhead => f.write_str("kbs_overhead"),
            SquatExerciseName::SquatAndSideKick => f.write_str("squat_and_side_kick"),
            SquatExerciseName::SquatJumpsInNOut => f.write_str("squat_jumps_in_n_out"),
            SquatExerciseName::PilatesPlieSquatsParallelTurnedOutFlatAndHeels => {
                f.write_str("pilates_plie_squats_parallel_turned_out_flat_and_heels")
            }
            SquatExerciseName::ReleveStraightLegAndKneeBentWithOneLegVariation => {
                f.write_str("releve_straight_leg_and_knee_bent_with_one_leg_variation")
            }
        }
    }
}
impl SquatExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SquatExerciseName::LegPress => fit::Value::UInt16(0),
            SquatExerciseName::BackSquatWithBodyBar => fit::Value::UInt16(1),
            SquatExerciseName::BackSquats => fit::Value::UInt16(2),
            SquatExerciseName::WeightedBackSquats => fit::Value::UInt16(3),
            SquatExerciseName::BalancingSquat => fit::Value::UInt16(4),
            SquatExerciseName::WeightedBalancingSquat => fit::Value::UInt16(5),
            SquatExerciseName::BarbellBackSquat => fit::Value::UInt16(6),
            SquatExerciseName::BarbellBoxSquat => fit::Value::UInt16(7),
            SquatExerciseName::BarbellFrontSquat => fit::Value::UInt16(8),
            SquatExerciseName::BarbellHackSquat => fit::Value::UInt16(9),
            SquatExerciseName::BarbellHangSquatSnatch => fit::Value::UInt16(10),
            SquatExerciseName::BarbellLateralStepUp => fit::Value::UInt16(11),
            SquatExerciseName::BarbellQuarterSquat => fit::Value::UInt16(12),
            SquatExerciseName::BarbellSiffSquat => fit::Value::UInt16(13),
            SquatExerciseName::BarbellSquatSnatch => fit::Value::UInt16(14),
            SquatExerciseName::BarbellSquatWithHeelsRaised => fit::Value::UInt16(15),
            SquatExerciseName::BarbellStepover => fit::Value::UInt16(16),
            SquatExerciseName::BarbellStepUp => fit::Value::UInt16(17),
            SquatExerciseName::BenchSquatWithRotationalChop => fit::Value::UInt16(18),
            SquatExerciseName::WeightedBenchSquatWithRotationalChop => fit::Value::UInt16(19),
            SquatExerciseName::BodyWeightWallSquat => fit::Value::UInt16(20),
            SquatExerciseName::WeightedWallSquat => fit::Value::UInt16(21),
            SquatExerciseName::BoxStepSquat => fit::Value::UInt16(22),
            SquatExerciseName::WeightedBoxStepSquat => fit::Value::UInt16(23),
            SquatExerciseName::BracedSquat => fit::Value::UInt16(24),
            SquatExerciseName::CrossedArmBarbellFrontSquat => fit::Value::UInt16(25),
            SquatExerciseName::CrossoverDumbbellStepUp => fit::Value::UInt16(26),
            SquatExerciseName::DumbbellFrontSquat => fit::Value::UInt16(27),
            SquatExerciseName::DumbbellSplitSquat => fit::Value::UInt16(28),
            SquatExerciseName::DumbbellSquat => fit::Value::UInt16(29),
            SquatExerciseName::DumbbellSquatClean => fit::Value::UInt16(30),
            SquatExerciseName::DumbbellStepover => fit::Value::UInt16(31),
            SquatExerciseName::DumbbellStepUp => fit::Value::UInt16(32),
            SquatExerciseName::ElevatedSingleLegSquat => fit::Value::UInt16(33),
            SquatExerciseName::WeightedElevatedSingleLegSquat => fit::Value::UInt16(34),
            SquatExerciseName::FigureFourSquats => fit::Value::UInt16(35),
            SquatExerciseName::WeightedFigureFourSquats => fit::Value::UInt16(36),
            SquatExerciseName::GobletSquat => fit::Value::UInt16(37),
            SquatExerciseName::KettlebellSquat => fit::Value::UInt16(38),
            SquatExerciseName::KettlebellSwingOverhead => fit::Value::UInt16(39),
            SquatExerciseName::KettlebellSwingWithFlipToSquat => fit::Value::UInt16(40),
            SquatExerciseName::LateralDumbbellStepUp => fit::Value::UInt16(41),
            SquatExerciseName::OneLeggedSquat => fit::Value::UInt16(42),
            SquatExerciseName::OverheadDumbbellSquat => fit::Value::UInt16(43),
            SquatExerciseName::OverheadSquat => fit::Value::UInt16(44),
            SquatExerciseName::PartialSingleLegSquat => fit::Value::UInt16(45),
            SquatExerciseName::WeightedPartialSingleLegSquat => fit::Value::UInt16(46),
            SquatExerciseName::PistolSquat => fit::Value::UInt16(47),
            SquatExerciseName::WeightedPistolSquat => fit::Value::UInt16(48),
            SquatExerciseName::PlieSlides => fit::Value::UInt16(49),
            SquatExerciseName::WeightedPlieSlides => fit::Value::UInt16(50),
            SquatExerciseName::PlieSquat => fit::Value::UInt16(51),
            SquatExerciseName::WeightedPlieSquat => fit::Value::UInt16(52),
            SquatExerciseName::PrisonerSquat => fit::Value::UInt16(53),
            SquatExerciseName::WeightedPrisonerSquat => fit::Value::UInt16(54),
            SquatExerciseName::SingleLegBenchGetUp => fit::Value::UInt16(55),
            SquatExerciseName::WeightedSingleLegBenchGetUp => fit::Value::UInt16(56),
            SquatExerciseName::SingleLegBenchSquat => fit::Value::UInt16(57),
            SquatExerciseName::WeightedSingleLegBenchSquat => fit::Value::UInt16(58),
            SquatExerciseName::SingleLegSquatOnSwissBall => fit::Value::UInt16(59),
            SquatExerciseName::WeightedSingleLegSquatOnSwissBall => fit::Value::UInt16(60),
            SquatExerciseName::Squat => fit::Value::UInt16(61),
            SquatExerciseName::WeightedSquat => fit::Value::UInt16(62),
            SquatExerciseName::SquatsWithBand => fit::Value::UInt16(63),
            SquatExerciseName::StaggeredSquat => fit::Value::UInt16(64),
            SquatExerciseName::WeightedStaggeredSquat => fit::Value::UInt16(65),
            SquatExerciseName::StepUp => fit::Value::UInt16(66),
            SquatExerciseName::WeightedStepUp => fit::Value::UInt16(67),
            SquatExerciseName::SuitcaseSquats => fit::Value::UInt16(68),
            SquatExerciseName::SumoSquat => fit::Value::UInt16(69),
            SquatExerciseName::SumoSquatSlideIn => fit::Value::UInt16(70),
            SquatExerciseName::WeightedSumoSquatSlideIn => fit::Value::UInt16(71),
            SquatExerciseName::SumoSquatToHighPull => fit::Value::UInt16(72),
            SquatExerciseName::SumoSquatToStand => fit::Value::UInt16(73),
            SquatExerciseName::WeightedSumoSquatToStand => fit::Value::UInt16(74),
            SquatExerciseName::SumoSquatWithRotation => fit::Value::UInt16(75),
            SquatExerciseName::WeightedSumoSquatWithRotation => fit::Value::UInt16(76),
            SquatExerciseName::SwissBallBodyWeightWallSquat => fit::Value::UInt16(77),
            SquatExerciseName::WeightedSwissBallWallSquat => fit::Value::UInt16(78),
            SquatExerciseName::Thrusters => fit::Value::UInt16(79),
            SquatExerciseName::UnevenSquat => fit::Value::UInt16(80),
            SquatExerciseName::WeightedUnevenSquat => fit::Value::UInt16(81),
            SquatExerciseName::WaistSlimmingSquat => fit::Value::UInt16(82),
            SquatExerciseName::WallBall => fit::Value::UInt16(83),
            SquatExerciseName::WideStanceBarbellSquat => fit::Value::UInt16(84),
            SquatExerciseName::WideStanceGobletSquat => fit::Value::UInt16(85),
            SquatExerciseName::ZercherSquat => fit::Value::UInt16(86),
            SquatExerciseName::KbsOverhead => fit::Value::UInt16(87),
            SquatExerciseName::SquatAndSideKick => fit::Value::UInt16(88),
            SquatExerciseName::SquatJumpsInNOut => fit::Value::UInt16(89),
            SquatExerciseName::PilatesPlieSquatsParallelTurnedOutFlatAndHeels => {
                fit::Value::UInt16(90)
            }
            SquatExerciseName::ReleveStraightLegAndKneeBentWithOneLegVariation => {
                fit::Value::UInt16(91)
            }
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for SquatExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(SquatExerciseName::LegPress),
            fit::Value::UInt16(1) => Ok(SquatExerciseName::BackSquatWithBodyBar),
            fit::Value::UInt16(2) => Ok(SquatExerciseName::BackSquats),
            fit::Value::UInt16(3) => Ok(SquatExerciseName::WeightedBackSquats),
            fit::Value::UInt16(4) => Ok(SquatExerciseName::BalancingSquat),
            fit::Value::UInt16(5) => Ok(SquatExerciseName::WeightedBalancingSquat),
            fit::Value::UInt16(6) => Ok(SquatExerciseName::BarbellBackSquat),
            fit::Value::UInt16(7) => Ok(SquatExerciseName::BarbellBoxSquat),
            fit::Value::UInt16(8) => Ok(SquatExerciseName::BarbellFrontSquat),
            fit::Value::UInt16(9) => Ok(SquatExerciseName::BarbellHackSquat),
            fit::Value::UInt16(10) => Ok(SquatExerciseName::BarbellHangSquatSnatch),
            fit::Value::UInt16(11) => Ok(SquatExerciseName::BarbellLateralStepUp),
            fit::Value::UInt16(12) => Ok(SquatExerciseName::BarbellQuarterSquat),
            fit::Value::UInt16(13) => Ok(SquatExerciseName::BarbellSiffSquat),
            fit::Value::UInt16(14) => Ok(SquatExerciseName::BarbellSquatSnatch),
            fit::Value::UInt16(15) => Ok(SquatExerciseName::BarbellSquatWithHeelsRaised),
            fit::Value::UInt16(16) => Ok(SquatExerciseName::BarbellStepover),
            fit::Value::UInt16(17) => Ok(SquatExerciseName::BarbellStepUp),
            fit::Value::UInt16(18) => Ok(SquatExerciseName::BenchSquatWithRotationalChop),
            fit::Value::UInt16(19) => Ok(SquatExerciseName::WeightedBenchSquatWithRotationalChop),
            fit::Value::UInt16(20) => Ok(SquatExerciseName::BodyWeightWallSquat),
            fit::Value::UInt16(21) => Ok(SquatExerciseName::WeightedWallSquat),
            fit::Value::UInt16(22) => Ok(SquatExerciseName::BoxStepSquat),
            fit::Value::UInt16(23) => Ok(SquatExerciseName::WeightedBoxStepSquat),
            fit::Value::UInt16(24) => Ok(SquatExerciseName::BracedSquat),
            fit::Value::UInt16(25) => Ok(SquatExerciseName::CrossedArmBarbellFrontSquat),
            fit::Value::UInt16(26) => Ok(SquatExerciseName::CrossoverDumbbellStepUp),
            fit::Value::UInt16(27) => Ok(SquatExerciseName::DumbbellFrontSquat),
            fit::Value::UInt16(28) => Ok(SquatExerciseName::DumbbellSplitSquat),
            fit::Value::UInt16(29) => Ok(SquatExerciseName::DumbbellSquat),
            fit::Value::UInt16(30) => Ok(SquatExerciseName::DumbbellSquatClean),
            fit::Value::UInt16(31) => Ok(SquatExerciseName::DumbbellStepover),
            fit::Value::UInt16(32) => Ok(SquatExerciseName::DumbbellStepUp),
            fit::Value::UInt16(33) => Ok(SquatExerciseName::ElevatedSingleLegSquat),
            fit::Value::UInt16(34) => Ok(SquatExerciseName::WeightedElevatedSingleLegSquat),
            fit::Value::UInt16(35) => Ok(SquatExerciseName::FigureFourSquats),
            fit::Value::UInt16(36) => Ok(SquatExerciseName::WeightedFigureFourSquats),
            fit::Value::UInt16(37) => Ok(SquatExerciseName::GobletSquat),
            fit::Value::UInt16(38) => Ok(SquatExerciseName::KettlebellSquat),
            fit::Value::UInt16(39) => Ok(SquatExerciseName::KettlebellSwingOverhead),
            fit::Value::UInt16(40) => Ok(SquatExerciseName::KettlebellSwingWithFlipToSquat),
            fit::Value::UInt16(41) => Ok(SquatExerciseName::LateralDumbbellStepUp),
            fit::Value::UInt16(42) => Ok(SquatExerciseName::OneLeggedSquat),
            fit::Value::UInt16(43) => Ok(SquatExerciseName::OverheadDumbbellSquat),
            fit::Value::UInt16(44) => Ok(SquatExerciseName::OverheadSquat),
            fit::Value::UInt16(45) => Ok(SquatExerciseName::PartialSingleLegSquat),
            fit::Value::UInt16(46) => Ok(SquatExerciseName::WeightedPartialSingleLegSquat),
            fit::Value::UInt16(47) => Ok(SquatExerciseName::PistolSquat),
            fit::Value::UInt16(48) => Ok(SquatExerciseName::WeightedPistolSquat),
            fit::Value::UInt16(49) => Ok(SquatExerciseName::PlieSlides),
            fit::Value::UInt16(50) => Ok(SquatExerciseName::WeightedPlieSlides),
            fit::Value::UInt16(51) => Ok(SquatExerciseName::PlieSquat),
            fit::Value::UInt16(52) => Ok(SquatExerciseName::WeightedPlieSquat),
            fit::Value::UInt16(53) => Ok(SquatExerciseName::PrisonerSquat),
            fit::Value::UInt16(54) => Ok(SquatExerciseName::WeightedPrisonerSquat),
            fit::Value::UInt16(55) => Ok(SquatExerciseName::SingleLegBenchGetUp),
            fit::Value::UInt16(56) => Ok(SquatExerciseName::WeightedSingleLegBenchGetUp),
            fit::Value::UInt16(57) => Ok(SquatExerciseName::SingleLegBenchSquat),
            fit::Value::UInt16(58) => Ok(SquatExerciseName::WeightedSingleLegBenchSquat),
            fit::Value::UInt16(59) => Ok(SquatExerciseName::SingleLegSquatOnSwissBall),
            fit::Value::UInt16(60) => Ok(SquatExerciseName::WeightedSingleLegSquatOnSwissBall),
            fit::Value::UInt16(61) => Ok(SquatExerciseName::Squat),
            fit::Value::UInt16(62) => Ok(SquatExerciseName::WeightedSquat),
            fit::Value::UInt16(63) => Ok(SquatExerciseName::SquatsWithBand),
            fit::Value::UInt16(64) => Ok(SquatExerciseName::StaggeredSquat),
            fit::Value::UInt16(65) => Ok(SquatExerciseName::WeightedStaggeredSquat),
            fit::Value::UInt16(66) => Ok(SquatExerciseName::StepUp),
            fit::Value::UInt16(67) => Ok(SquatExerciseName::WeightedStepUp),
            fit::Value::UInt16(68) => Ok(SquatExerciseName::SuitcaseSquats),
            fit::Value::UInt16(69) => Ok(SquatExerciseName::SumoSquat),
            fit::Value::UInt16(70) => Ok(SquatExerciseName::SumoSquatSlideIn),
            fit::Value::UInt16(71) => Ok(SquatExerciseName::WeightedSumoSquatSlideIn),
            fit::Value::UInt16(72) => Ok(SquatExerciseName::SumoSquatToHighPull),
            fit::Value::UInt16(73) => Ok(SquatExerciseName::SumoSquatToStand),
            fit::Value::UInt16(74) => Ok(SquatExerciseName::WeightedSumoSquatToStand),
            fit::Value::UInt16(75) => Ok(SquatExerciseName::SumoSquatWithRotation),
            fit::Value::UInt16(76) => Ok(SquatExerciseName::WeightedSumoSquatWithRotation),
            fit::Value::UInt16(77) => Ok(SquatExerciseName::SwissBallBodyWeightWallSquat),
            fit::Value::UInt16(78) => Ok(SquatExerciseName::WeightedSwissBallWallSquat),
            fit::Value::UInt16(79) => Ok(SquatExerciseName::Thrusters),
            fit::Value::UInt16(80) => Ok(SquatExerciseName::UnevenSquat),
            fit::Value::UInt16(81) => Ok(SquatExerciseName::WeightedUnevenSquat),
            fit::Value::UInt16(82) => Ok(SquatExerciseName::WaistSlimmingSquat),
            fit::Value::UInt16(83) => Ok(SquatExerciseName::WallBall),
            fit::Value::UInt16(84) => Ok(SquatExerciseName::WideStanceBarbellSquat),
            fit::Value::UInt16(85) => Ok(SquatExerciseName::WideStanceGobletSquat),
            fit::Value::UInt16(86) => Ok(SquatExerciseName::ZercherSquat),
            fit::Value::UInt16(87) => Ok(SquatExerciseName::KbsOverhead),
            fit::Value::UInt16(88) => Ok(SquatExerciseName::SquatAndSideKick),
            fit::Value::UInt16(89) => Ok(SquatExerciseName::SquatJumpsInNOut),
            fit::Value::UInt16(90) => {
                Ok(SquatExerciseName::PilatesPlieSquatsParallelTurnedOutFlatAndHeels)
            }
            fit::Value::UInt16(91) => {
                Ok(SquatExerciseName::ReleveStraightLegAndKneeBentWithOneLegVariation)
            }
            _ => Err("No corresponding SquatExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for SquatExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "leg_press" => Ok(SquatExerciseName::LegPress),
            "back_squat_with_body_bar" => Ok(SquatExerciseName::BackSquatWithBodyBar),
            "back_squats" => Ok(SquatExerciseName::BackSquats),
            "weighted_back_squats" => Ok(SquatExerciseName::WeightedBackSquats),
            "balancing_squat" => Ok(SquatExerciseName::BalancingSquat),
            "weighted_balancing_squat" => Ok(SquatExerciseName::WeightedBalancingSquat),
            "barbell_back_squat" => Ok(SquatExerciseName::BarbellBackSquat),
            "barbell_box_squat" => Ok(SquatExerciseName::BarbellBoxSquat),
            "barbell_front_squat" => Ok(SquatExerciseName::BarbellFrontSquat),
            "barbell_hack_squat" => Ok(SquatExerciseName::BarbellHackSquat),
            "barbell_hang_squat_snatch" => Ok(SquatExerciseName::BarbellHangSquatSnatch),
            "barbell_lateral_step_up" => Ok(SquatExerciseName::BarbellLateralStepUp),
            "barbell_quarter_squat" => Ok(SquatExerciseName::BarbellQuarterSquat),
            "barbell_siff_squat" => Ok(SquatExerciseName::BarbellSiffSquat),
            "barbell_squat_snatch" => Ok(SquatExerciseName::BarbellSquatSnatch),
            "barbell_squat_with_heels_raised" => Ok(SquatExerciseName::BarbellSquatWithHeelsRaised),
            "barbell_stepover" => Ok(SquatExerciseName::BarbellStepover),
            "barbell_step_up" => Ok(SquatExerciseName::BarbellStepUp),
            "bench_squat_with_rotational_chop" => {
                Ok(SquatExerciseName::BenchSquatWithRotationalChop)
            }
            "weighted_bench_squat_with_rotational_chop" => {
                Ok(SquatExerciseName::WeightedBenchSquatWithRotationalChop)
            }
            "body_weight_wall_squat" => Ok(SquatExerciseName::BodyWeightWallSquat),
            "weighted_wall_squat" => Ok(SquatExerciseName::WeightedWallSquat),
            "box_step_squat" => Ok(SquatExerciseName::BoxStepSquat),
            "weighted_box_step_squat" => Ok(SquatExerciseName::WeightedBoxStepSquat),
            "braced_squat" => Ok(SquatExerciseName::BracedSquat),
            "crossed_arm_barbell_front_squat" => Ok(SquatExerciseName::CrossedArmBarbellFrontSquat),
            "crossover_dumbbell_step_up" => Ok(SquatExerciseName::CrossoverDumbbellStepUp),
            "dumbbell_front_squat" => Ok(SquatExerciseName::DumbbellFrontSquat),
            "dumbbell_split_squat" => Ok(SquatExerciseName::DumbbellSplitSquat),
            "dumbbell_squat" => Ok(SquatExerciseName::DumbbellSquat),
            "dumbbell_squat_clean" => Ok(SquatExerciseName::DumbbellSquatClean),
            "dumbbell_stepover" => Ok(SquatExerciseName::DumbbellStepover),
            "dumbbell_step_up" => Ok(SquatExerciseName::DumbbellStepUp),
            "elevated_single_leg_squat" => Ok(SquatExerciseName::ElevatedSingleLegSquat),
            "weighted_elevated_single_leg_squat" => {
                Ok(SquatExerciseName::WeightedElevatedSingleLegSquat)
            }
            "figure_four_squats" => Ok(SquatExerciseName::FigureFourSquats),
            "weighted_figure_four_squats" => Ok(SquatExerciseName::WeightedFigureFourSquats),
            "goblet_squat" => Ok(SquatExerciseName::GobletSquat),
            "kettlebell_squat" => Ok(SquatExerciseName::KettlebellSquat),
            "kettlebell_swing_overhead" => Ok(SquatExerciseName::KettlebellSwingOverhead),
            "kettlebell_swing_with_flip_to_squat" => {
                Ok(SquatExerciseName::KettlebellSwingWithFlipToSquat)
            }
            "lateral_dumbbell_step_up" => Ok(SquatExerciseName::LateralDumbbellStepUp),
            "one_legged_squat" => Ok(SquatExerciseName::OneLeggedSquat),
            "overhead_dumbbell_squat" => Ok(SquatExerciseName::OverheadDumbbellSquat),
            "overhead_squat" => Ok(SquatExerciseName::OverheadSquat),
            "partial_single_leg_squat" => Ok(SquatExerciseName::PartialSingleLegSquat),
            "weighted_partial_single_leg_squat" => {
                Ok(SquatExerciseName::WeightedPartialSingleLegSquat)
            }
            "pistol_squat" => Ok(SquatExerciseName::PistolSquat),
            "weighted_pistol_squat" => Ok(SquatExerciseName::WeightedPistolSquat),
            "plie_slides" => Ok(SquatExerciseName::PlieSlides),
            "weighted_plie_slides" => Ok(SquatExerciseName::WeightedPlieSlides),
            "plie_squat" => Ok(SquatExerciseName::PlieSquat),
            "weighted_plie_squat" => Ok(SquatExerciseName::WeightedPlieSquat),
            "prisoner_squat" => Ok(SquatExerciseName::PrisonerSquat),
            "weighted_prisoner_squat" => Ok(SquatExerciseName::WeightedPrisonerSquat),
            "single_leg_bench_get_up" => Ok(SquatExerciseName::SingleLegBenchGetUp),
            "weighted_single_leg_bench_get_up" => {
                Ok(SquatExerciseName::WeightedSingleLegBenchGetUp)
            }
            "single_leg_bench_squat" => Ok(SquatExerciseName::SingleLegBenchSquat),
            "weighted_single_leg_bench_squat" => Ok(SquatExerciseName::WeightedSingleLegBenchSquat),
            "single_leg_squat_on_swiss_ball" => Ok(SquatExerciseName::SingleLegSquatOnSwissBall),
            "weighted_single_leg_squat_on_swiss_ball" => {
                Ok(SquatExerciseName::WeightedSingleLegSquatOnSwissBall)
            }
            "squat" => Ok(SquatExerciseName::Squat),
            "weighted_squat" => Ok(SquatExerciseName::WeightedSquat),
            "squats_with_band" => Ok(SquatExerciseName::SquatsWithBand),
            "staggered_squat" => Ok(SquatExerciseName::StaggeredSquat),
            "weighted_staggered_squat" => Ok(SquatExerciseName::WeightedStaggeredSquat),
            "step_up" => Ok(SquatExerciseName::StepUp),
            "weighted_step_up" => Ok(SquatExerciseName::WeightedStepUp),
            "suitcase_squats" => Ok(SquatExerciseName::SuitcaseSquats),
            "sumo_squat" => Ok(SquatExerciseName::SumoSquat),
            "sumo_squat_slide_in" => Ok(SquatExerciseName::SumoSquatSlideIn),
            "weighted_sumo_squat_slide_in" => Ok(SquatExerciseName::WeightedSumoSquatSlideIn),
            "sumo_squat_to_high_pull" => Ok(SquatExerciseName::SumoSquatToHighPull),
            "sumo_squat_to_stand" => Ok(SquatExerciseName::SumoSquatToStand),
            "weighted_sumo_squat_to_stand" => Ok(SquatExerciseName::WeightedSumoSquatToStand),
            "sumo_squat_with_rotation" => Ok(SquatExerciseName::SumoSquatWithRotation),
            "weighted_sumo_squat_with_rotation" => {
                Ok(SquatExerciseName::WeightedSumoSquatWithRotation)
            }
            "swiss_ball_body_weight_wall_squat" => {
                Ok(SquatExerciseName::SwissBallBodyWeightWallSquat)
            }
            "weighted_swiss_ball_wall_squat" => Ok(SquatExerciseName::WeightedSwissBallWallSquat),
            "thrusters" => Ok(SquatExerciseName::Thrusters),
            "uneven_squat" => Ok(SquatExerciseName::UnevenSquat),
            "weighted_uneven_squat" => Ok(SquatExerciseName::WeightedUnevenSquat),
            "waist_slimming_squat" => Ok(SquatExerciseName::WaistSlimmingSquat),
            "wall_ball" => Ok(SquatExerciseName::WallBall),
            "wide_stance_barbell_squat" => Ok(SquatExerciseName::WideStanceBarbellSquat),
            "wide_stance_goblet_squat" => Ok(SquatExerciseName::WideStanceGobletSquat),
            "zercher_squat" => Ok(SquatExerciseName::ZercherSquat),
            "kbs_overhead" => Ok(SquatExerciseName::KbsOverhead),
            "squat_and_side_kick" => Ok(SquatExerciseName::SquatAndSideKick),
            "squat_jumps_in_n_out" => Ok(SquatExerciseName::SquatJumpsInNOut),
            "pilates_plie_squats_parallel_turned_out_flat_and_heels" => {
                Ok(SquatExerciseName::PilatesPlieSquatsParallelTurnedOutFlatAndHeels)
            }
            "releve_straight_leg_and_knee_bent_with_one_leg_variation" => {
                Ok(SquatExerciseName::ReleveStraightLegAndKneeBentWithOneLegVariation)
            }
            _ => Err("No corresponding SquatExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum TotalBodyExerciseName {
    Burpee,
    WeightedBurpee,
    BurpeeBoxJump,
    WeightedBurpeeBoxJump,
    HighPullBurpee,
    ManMakers,
    OneArmBurpee,
    SquatThrusts,
    WeightedSquatThrusts,
    SquatPlankPushUp,
    WeightedSquatPlankPushUp,
    StandingTRotationBalance,
    WeightedStandingTRotationBalance,
}
impl fmt::Display for TotalBodyExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TotalBodyExerciseName::Burpee => f.write_str("burpee"),
            TotalBodyExerciseName::WeightedBurpee => f.write_str("weighted_burpee"),
            TotalBodyExerciseName::BurpeeBoxJump => f.write_str("burpee_box_jump"),
            TotalBodyExerciseName::WeightedBurpeeBoxJump => f.write_str("weighted_burpee_box_jump"),
            TotalBodyExerciseName::HighPullBurpee => f.write_str("high_pull_burpee"),
            TotalBodyExerciseName::ManMakers => f.write_str("man_makers"),
            TotalBodyExerciseName::OneArmBurpee => f.write_str("one_arm_burpee"),
            TotalBodyExerciseName::SquatThrusts => f.write_str("squat_thrusts"),
            TotalBodyExerciseName::WeightedSquatThrusts => f.write_str("weighted_squat_thrusts"),
            TotalBodyExerciseName::SquatPlankPushUp => f.write_str("squat_plank_push_up"),
            TotalBodyExerciseName::WeightedSquatPlankPushUp => {
                f.write_str("weighted_squat_plank_push_up")
            }
            TotalBodyExerciseName::StandingTRotationBalance => {
                f.write_str("standing_t_rotation_balance")
            }
            TotalBodyExerciseName::WeightedStandingTRotationBalance => {
                f.write_str("weighted_standing_t_rotation_balance")
            }
        }
    }
}
impl TotalBodyExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            TotalBodyExerciseName::Burpee => fit::Value::UInt16(0),
            TotalBodyExerciseName::WeightedBurpee => fit::Value::UInt16(1),
            TotalBodyExerciseName::BurpeeBoxJump => fit::Value::UInt16(2),
            TotalBodyExerciseName::WeightedBurpeeBoxJump => fit::Value::UInt16(3),
            TotalBodyExerciseName::HighPullBurpee => fit::Value::UInt16(4),
            TotalBodyExerciseName::ManMakers => fit::Value::UInt16(5),
            TotalBodyExerciseName::OneArmBurpee => fit::Value::UInt16(6),
            TotalBodyExerciseName::SquatThrusts => fit::Value::UInt16(7),
            TotalBodyExerciseName::WeightedSquatThrusts => fit::Value::UInt16(8),
            TotalBodyExerciseName::SquatPlankPushUp => fit::Value::UInt16(9),
            TotalBodyExerciseName::WeightedSquatPlankPushUp => fit::Value::UInt16(10),
            TotalBodyExerciseName::StandingTRotationBalance => fit::Value::UInt16(11),
            TotalBodyExerciseName::WeightedStandingTRotationBalance => fit::Value::UInt16(12),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for TotalBodyExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(TotalBodyExerciseName::Burpee),
            fit::Value::UInt16(1) => Ok(TotalBodyExerciseName::WeightedBurpee),
            fit::Value::UInt16(2) => Ok(TotalBodyExerciseName::BurpeeBoxJump),
            fit::Value::UInt16(3) => Ok(TotalBodyExerciseName::WeightedBurpeeBoxJump),
            fit::Value::UInt16(4) => Ok(TotalBodyExerciseName::HighPullBurpee),
            fit::Value::UInt16(5) => Ok(TotalBodyExerciseName::ManMakers),
            fit::Value::UInt16(6) => Ok(TotalBodyExerciseName::OneArmBurpee),
            fit::Value::UInt16(7) => Ok(TotalBodyExerciseName::SquatThrusts),
            fit::Value::UInt16(8) => Ok(TotalBodyExerciseName::WeightedSquatThrusts),
            fit::Value::UInt16(9) => Ok(TotalBodyExerciseName::SquatPlankPushUp),
            fit::Value::UInt16(10) => Ok(TotalBodyExerciseName::WeightedSquatPlankPushUp),
            fit::Value::UInt16(11) => Ok(TotalBodyExerciseName::StandingTRotationBalance),
            fit::Value::UInt16(12) => Ok(TotalBodyExerciseName::WeightedStandingTRotationBalance),
            _ => Err("No corresponding TotalBodyExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for TotalBodyExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "burpee" => Ok(TotalBodyExerciseName::Burpee),
            "weighted_burpee" => Ok(TotalBodyExerciseName::WeightedBurpee),
            "burpee_box_jump" => Ok(TotalBodyExerciseName::BurpeeBoxJump),
            "weighted_burpee_box_jump" => Ok(TotalBodyExerciseName::WeightedBurpeeBoxJump),
            "high_pull_burpee" => Ok(TotalBodyExerciseName::HighPullBurpee),
            "man_makers" => Ok(TotalBodyExerciseName::ManMakers),
            "one_arm_burpee" => Ok(TotalBodyExerciseName::OneArmBurpee),
            "squat_thrusts" => Ok(TotalBodyExerciseName::SquatThrusts),
            "weighted_squat_thrusts" => Ok(TotalBodyExerciseName::WeightedSquatThrusts),
            "squat_plank_push_up" => Ok(TotalBodyExerciseName::SquatPlankPushUp),
            "weighted_squat_plank_push_up" => Ok(TotalBodyExerciseName::WeightedSquatPlankPushUp),
            "standing_t_rotation_balance" => Ok(TotalBodyExerciseName::StandingTRotationBalance),
            "weighted_standing_t_rotation_balance" => {
                Ok(TotalBodyExerciseName::WeightedStandingTRotationBalance)
            }
            _ => Err("No corresponding TotalBodyExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum TricepsExtensionExerciseName {
    BenchDip,
    WeightedBenchDip,
    BodyWeightDip,
    CableKickback,
    CableLyingTricepsExtension,
    CableOverheadTricepsExtension,
    DumbbellKickback,
    DumbbellLyingTricepsExtension,
    EzBarOverheadTricepsExtension,
    InclineDip,
    WeightedInclineDip,
    InclineEzBarLyingTricepsExtension,
    LyingDumbbellPulloverToExtension,
    LyingEzBarTricepsExtension,
    LyingTricepsExtensionToCloseGripBenchPress,
    OverheadDumbbellTricepsExtension,
    RecliningTricepsPress,
    ReverseGripPressdown,
    ReverseGripTricepsPressdown,
    RopePressdown,
    SeatedBarbellOverheadTricepsExtension,
    SeatedDumbbellOverheadTricepsExtension,
    SeatedEzBarOverheadTricepsExtension,
    SeatedSingleArmOverheadDumbbellExtension,
    SingleArmDumbbellOverheadTricepsExtension,
    SingleDumbbellSeatedOverheadTricepsExtension,
    SingleLegBenchDipAndKick,
    WeightedSingleLegBenchDipAndKick,
    SingleLegDip,
    WeightedSingleLegDip,
    StaticLyingTricepsExtension,
    SuspendedDip,
    WeightedSuspendedDip,
    SwissBallDumbbellLyingTricepsExtension,
    SwissBallEzBarLyingTricepsExtension,
    SwissBallEzBarOverheadTricepsExtension,
    TabletopDip,
    WeightedTabletopDip,
    TricepsExtensionOnFloor,
    TricepsPressdown,
    WeightedDip,
}
impl fmt::Display for TricepsExtensionExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TricepsExtensionExerciseName::BenchDip => f.write_str("bench_dip"),
            TricepsExtensionExerciseName::WeightedBenchDip => f.write_str("weighted_bench_dip"),
            TricepsExtensionExerciseName::BodyWeightDip => f.write_str("body_weight_dip"),
            TricepsExtensionExerciseName::CableKickback => f.write_str("cable_kickback"),
            TricepsExtensionExerciseName::CableLyingTricepsExtension => {
                f.write_str("cable_lying_triceps_extension")
            }
            TricepsExtensionExerciseName::CableOverheadTricepsExtension => {
                f.write_str("cable_overhead_triceps_extension")
            }
            TricepsExtensionExerciseName::DumbbellKickback => f.write_str("dumbbell_kickback"),
            TricepsExtensionExerciseName::DumbbellLyingTricepsExtension => {
                f.write_str("dumbbell_lying_triceps_extension")
            }
            TricepsExtensionExerciseName::EzBarOverheadTricepsExtension => {
                f.write_str("ez_bar_overhead_triceps_extension")
            }
            TricepsExtensionExerciseName::InclineDip => f.write_str("incline_dip"),
            TricepsExtensionExerciseName::WeightedInclineDip => f.write_str("weighted_incline_dip"),
            TricepsExtensionExerciseName::InclineEzBarLyingTricepsExtension => {
                f.write_str("incline_ez_bar_lying_triceps_extension")
            }
            TricepsExtensionExerciseName::LyingDumbbellPulloverToExtension => {
                f.write_str("lying_dumbbell_pullover_to_extension")
            }
            TricepsExtensionExerciseName::LyingEzBarTricepsExtension => {
                f.write_str("lying_ez_bar_triceps_extension")
            }
            TricepsExtensionExerciseName::LyingTricepsExtensionToCloseGripBenchPress => {
                f.write_str("lying_triceps_extension_to_close_grip_bench_press")
            }
            TricepsExtensionExerciseName::OverheadDumbbellTricepsExtension => {
                f.write_str("overhead_dumbbell_triceps_extension")
            }
            TricepsExtensionExerciseName::RecliningTricepsPress => {
                f.write_str("reclining_triceps_press")
            }
            TricepsExtensionExerciseName::ReverseGripPressdown => {
                f.write_str("reverse_grip_pressdown")
            }
            TricepsExtensionExerciseName::ReverseGripTricepsPressdown => {
                f.write_str("reverse_grip_triceps_pressdown")
            }
            TricepsExtensionExerciseName::RopePressdown => f.write_str("rope_pressdown"),
            TricepsExtensionExerciseName::SeatedBarbellOverheadTricepsExtension => {
                f.write_str("seated_barbell_overhead_triceps_extension")
            }
            TricepsExtensionExerciseName::SeatedDumbbellOverheadTricepsExtension => {
                f.write_str("seated_dumbbell_overhead_triceps_extension")
            }
            TricepsExtensionExerciseName::SeatedEzBarOverheadTricepsExtension => {
                f.write_str("seated_ez_bar_overhead_triceps_extension")
            }
            TricepsExtensionExerciseName::SeatedSingleArmOverheadDumbbellExtension => {
                f.write_str("seated_single_arm_overhead_dumbbell_extension")
            }
            TricepsExtensionExerciseName::SingleArmDumbbellOverheadTricepsExtension => {
                f.write_str("single_arm_dumbbell_overhead_triceps_extension")
            }
            TricepsExtensionExerciseName::SingleDumbbellSeatedOverheadTricepsExtension => {
                f.write_str("single_dumbbell_seated_overhead_triceps_extension")
            }
            TricepsExtensionExerciseName::SingleLegBenchDipAndKick => {
                f.write_str("single_leg_bench_dip_and_kick")
            }
            TricepsExtensionExerciseName::WeightedSingleLegBenchDipAndKick => {
                f.write_str("weighted_single_leg_bench_dip_and_kick")
            }
            TricepsExtensionExerciseName::SingleLegDip => f.write_str("single_leg_dip"),
            TricepsExtensionExerciseName::WeightedSingleLegDip => {
                f.write_str("weighted_single_leg_dip")
            }
            TricepsExtensionExerciseName::StaticLyingTricepsExtension => {
                f.write_str("static_lying_triceps_extension")
            }
            TricepsExtensionExerciseName::SuspendedDip => f.write_str("suspended_dip"),
            TricepsExtensionExerciseName::WeightedSuspendedDip => {
                f.write_str("weighted_suspended_dip")
            }
            TricepsExtensionExerciseName::SwissBallDumbbellLyingTricepsExtension => {
                f.write_str("swiss_ball_dumbbell_lying_triceps_extension")
            }
            TricepsExtensionExerciseName::SwissBallEzBarLyingTricepsExtension => {
                f.write_str("swiss_ball_ez_bar_lying_triceps_extension")
            }
            TricepsExtensionExerciseName::SwissBallEzBarOverheadTricepsExtension => {
                f.write_str("swiss_ball_ez_bar_overhead_triceps_extension")
            }
            TricepsExtensionExerciseName::TabletopDip => f.write_str("tabletop_dip"),
            TricepsExtensionExerciseName::WeightedTabletopDip => {
                f.write_str("weighted_tabletop_dip")
            }
            TricepsExtensionExerciseName::TricepsExtensionOnFloor => {
                f.write_str("triceps_extension_on_floor")
            }
            TricepsExtensionExerciseName::TricepsPressdown => f.write_str("triceps_pressdown"),
            TricepsExtensionExerciseName::WeightedDip => f.write_str("weighted_dip"),
        }
    }
}
impl TricepsExtensionExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            TricepsExtensionExerciseName::BenchDip => fit::Value::UInt16(0),
            TricepsExtensionExerciseName::WeightedBenchDip => fit::Value::UInt16(1),
            TricepsExtensionExerciseName::BodyWeightDip => fit::Value::UInt16(2),
            TricepsExtensionExerciseName::CableKickback => fit::Value::UInt16(3),
            TricepsExtensionExerciseName::CableLyingTricepsExtension => fit::Value::UInt16(4),
            TricepsExtensionExerciseName::CableOverheadTricepsExtension => fit::Value::UInt16(5),
            TricepsExtensionExerciseName::DumbbellKickback => fit::Value::UInt16(6),
            TricepsExtensionExerciseName::DumbbellLyingTricepsExtension => fit::Value::UInt16(7),
            TricepsExtensionExerciseName::EzBarOverheadTricepsExtension => fit::Value::UInt16(8),
            TricepsExtensionExerciseName::InclineDip => fit::Value::UInt16(9),
            TricepsExtensionExerciseName::WeightedInclineDip => fit::Value::UInt16(10),
            TricepsExtensionExerciseName::InclineEzBarLyingTricepsExtension => {
                fit::Value::UInt16(11)
            }
            TricepsExtensionExerciseName::LyingDumbbellPulloverToExtension => {
                fit::Value::UInt16(12)
            }
            TricepsExtensionExerciseName::LyingEzBarTricepsExtension => fit::Value::UInt16(13),
            TricepsExtensionExerciseName::LyingTricepsExtensionToCloseGripBenchPress => {
                fit::Value::UInt16(14)
            }
            TricepsExtensionExerciseName::OverheadDumbbellTricepsExtension => {
                fit::Value::UInt16(15)
            }
            TricepsExtensionExerciseName::RecliningTricepsPress => fit::Value::UInt16(16),
            TricepsExtensionExerciseName::ReverseGripPressdown => fit::Value::UInt16(17),
            TricepsExtensionExerciseName::ReverseGripTricepsPressdown => fit::Value::UInt16(18),
            TricepsExtensionExerciseName::RopePressdown => fit::Value::UInt16(19),
            TricepsExtensionExerciseName::SeatedBarbellOverheadTricepsExtension => {
                fit::Value::UInt16(20)
            }
            TricepsExtensionExerciseName::SeatedDumbbellOverheadTricepsExtension => {
                fit::Value::UInt16(21)
            }
            TricepsExtensionExerciseName::SeatedEzBarOverheadTricepsExtension => {
                fit::Value::UInt16(22)
            }
            TricepsExtensionExerciseName::SeatedSingleArmOverheadDumbbellExtension => {
                fit::Value::UInt16(23)
            }
            TricepsExtensionExerciseName::SingleArmDumbbellOverheadTricepsExtension => {
                fit::Value::UInt16(24)
            }
            TricepsExtensionExerciseName::SingleDumbbellSeatedOverheadTricepsExtension => {
                fit::Value::UInt16(25)
            }
            TricepsExtensionExerciseName::SingleLegBenchDipAndKick => fit::Value::UInt16(26),
            TricepsExtensionExerciseName::WeightedSingleLegBenchDipAndKick => {
                fit::Value::UInt16(27)
            }
            TricepsExtensionExerciseName::SingleLegDip => fit::Value::UInt16(28),
            TricepsExtensionExerciseName::WeightedSingleLegDip => fit::Value::UInt16(29),
            TricepsExtensionExerciseName::StaticLyingTricepsExtension => fit::Value::UInt16(30),
            TricepsExtensionExerciseName::SuspendedDip => fit::Value::UInt16(31),
            TricepsExtensionExerciseName::WeightedSuspendedDip => fit::Value::UInt16(32),
            TricepsExtensionExerciseName::SwissBallDumbbellLyingTricepsExtension => {
                fit::Value::UInt16(33)
            }
            TricepsExtensionExerciseName::SwissBallEzBarLyingTricepsExtension => {
                fit::Value::UInt16(34)
            }
            TricepsExtensionExerciseName::SwissBallEzBarOverheadTricepsExtension => {
                fit::Value::UInt16(35)
            }
            TricepsExtensionExerciseName::TabletopDip => fit::Value::UInt16(36),
            TricepsExtensionExerciseName::WeightedTabletopDip => fit::Value::UInt16(37),
            TricepsExtensionExerciseName::TricepsExtensionOnFloor => fit::Value::UInt16(38),
            TricepsExtensionExerciseName::TricepsPressdown => fit::Value::UInt16(39),
            TricepsExtensionExerciseName::WeightedDip => fit::Value::UInt16(40),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for TricepsExtensionExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(TricepsExtensionExerciseName::BenchDip),
            fit::Value::UInt16(1) => Ok(TricepsExtensionExerciseName::WeightedBenchDip),
            fit::Value::UInt16(2) => Ok(TricepsExtensionExerciseName::BodyWeightDip),
            fit::Value::UInt16(3) => Ok(TricepsExtensionExerciseName::CableKickback),
            fit::Value::UInt16(4) => Ok(TricepsExtensionExerciseName::CableLyingTricepsExtension),
            fit::Value::UInt16(5) => {
                Ok(TricepsExtensionExerciseName::CableOverheadTricepsExtension)
            }
            fit::Value::UInt16(6) => Ok(TricepsExtensionExerciseName::DumbbellKickback),
            fit::Value::UInt16(7) => {
                Ok(TricepsExtensionExerciseName::DumbbellLyingTricepsExtension)
            }
            fit::Value::UInt16(8) => {
                Ok(TricepsExtensionExerciseName::EzBarOverheadTricepsExtension)
            }
            fit::Value::UInt16(9) => Ok(TricepsExtensionExerciseName::InclineDip),
            fit::Value::UInt16(10) => Ok(TricepsExtensionExerciseName::WeightedInclineDip),
            fit::Value::UInt16(11) => {
                Ok(TricepsExtensionExerciseName::InclineEzBarLyingTricepsExtension)
            }
            fit::Value::UInt16(12) => {
                Ok(TricepsExtensionExerciseName::LyingDumbbellPulloverToExtension)
            }
            fit::Value::UInt16(13) => Ok(TricepsExtensionExerciseName::LyingEzBarTricepsExtension),
            fit::Value::UInt16(14) => {
                Ok(TricepsExtensionExerciseName::LyingTricepsExtensionToCloseGripBenchPress)
            }
            fit::Value::UInt16(15) => {
                Ok(TricepsExtensionExerciseName::OverheadDumbbellTricepsExtension)
            }
            fit::Value::UInt16(16) => Ok(TricepsExtensionExerciseName::RecliningTricepsPress),
            fit::Value::UInt16(17) => Ok(TricepsExtensionExerciseName::ReverseGripPressdown),
            fit::Value::UInt16(18) => Ok(TricepsExtensionExerciseName::ReverseGripTricepsPressdown),
            fit::Value::UInt16(19) => Ok(TricepsExtensionExerciseName::RopePressdown),
            fit::Value::UInt16(20) => {
                Ok(TricepsExtensionExerciseName::SeatedBarbellOverheadTricepsExtension)
            }
            fit::Value::UInt16(21) => {
                Ok(TricepsExtensionExerciseName::SeatedDumbbellOverheadTricepsExtension)
            }
            fit::Value::UInt16(22) => {
                Ok(TricepsExtensionExerciseName::SeatedEzBarOverheadTricepsExtension)
            }
            fit::Value::UInt16(23) => {
                Ok(TricepsExtensionExerciseName::SeatedSingleArmOverheadDumbbellExtension)
            }
            fit::Value::UInt16(24) => {
                Ok(TricepsExtensionExerciseName::SingleArmDumbbellOverheadTricepsExtension)
            }
            fit::Value::UInt16(25) => {
                Ok(TricepsExtensionExerciseName::SingleDumbbellSeatedOverheadTricepsExtension)
            }
            fit::Value::UInt16(26) => Ok(TricepsExtensionExerciseName::SingleLegBenchDipAndKick),
            fit::Value::UInt16(27) => {
                Ok(TricepsExtensionExerciseName::WeightedSingleLegBenchDipAndKick)
            }
            fit::Value::UInt16(28) => Ok(TricepsExtensionExerciseName::SingleLegDip),
            fit::Value::UInt16(29) => Ok(TricepsExtensionExerciseName::WeightedSingleLegDip),
            fit::Value::UInt16(30) => Ok(TricepsExtensionExerciseName::StaticLyingTricepsExtension),
            fit::Value::UInt16(31) => Ok(TricepsExtensionExerciseName::SuspendedDip),
            fit::Value::UInt16(32) => Ok(TricepsExtensionExerciseName::WeightedSuspendedDip),
            fit::Value::UInt16(33) => {
                Ok(TricepsExtensionExerciseName::SwissBallDumbbellLyingTricepsExtension)
            }
            fit::Value::UInt16(34) => {
                Ok(TricepsExtensionExerciseName::SwissBallEzBarLyingTricepsExtension)
            }
            fit::Value::UInt16(35) => {
                Ok(TricepsExtensionExerciseName::SwissBallEzBarOverheadTricepsExtension)
            }
            fit::Value::UInt16(36) => Ok(TricepsExtensionExerciseName::TabletopDip),
            fit::Value::UInt16(37) => Ok(TricepsExtensionExerciseName::WeightedTabletopDip),
            fit::Value::UInt16(38) => Ok(TricepsExtensionExerciseName::TricepsExtensionOnFloor),
            fit::Value::UInt16(39) => Ok(TricepsExtensionExerciseName::TricepsPressdown),
            fit::Value::UInt16(40) => Ok(TricepsExtensionExerciseName::WeightedDip),
            _ => Err("No corresponding TricepsExtensionExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for TricepsExtensionExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "bench_dip" => Ok(TricepsExtensionExerciseName::BenchDip),
            "weighted_bench_dip" => Ok(TricepsExtensionExerciseName::WeightedBenchDip),
            "body_weight_dip" => Ok(TricepsExtensionExerciseName::BodyWeightDip),
            "cable_kickback" => Ok(TricepsExtensionExerciseName::CableKickback),
            "cable_lying_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::CableLyingTricepsExtension)
            }
            "cable_overhead_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::CableOverheadTricepsExtension)
            }
            "dumbbell_kickback" => Ok(TricepsExtensionExerciseName::DumbbellKickback),
            "dumbbell_lying_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::DumbbellLyingTricepsExtension)
            }
            "ez_bar_overhead_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::EzBarOverheadTricepsExtension)
            }
            "incline_dip" => Ok(TricepsExtensionExerciseName::InclineDip),
            "weighted_incline_dip" => Ok(TricepsExtensionExerciseName::WeightedInclineDip),
            "incline_ez_bar_lying_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::InclineEzBarLyingTricepsExtension)
            }
            "lying_dumbbell_pullover_to_extension" => {
                Ok(TricepsExtensionExerciseName::LyingDumbbellPulloverToExtension)
            }
            "lying_ez_bar_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::LyingEzBarTricepsExtension)
            }
            "lying_triceps_extension_to_close_grip_bench_press" => {
                Ok(TricepsExtensionExerciseName::LyingTricepsExtensionToCloseGripBenchPress)
            }
            "overhead_dumbbell_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::OverheadDumbbellTricepsExtension)
            }
            "reclining_triceps_press" => Ok(TricepsExtensionExerciseName::RecliningTricepsPress),
            "reverse_grip_pressdown" => Ok(TricepsExtensionExerciseName::ReverseGripPressdown),
            "reverse_grip_triceps_pressdown" => {
                Ok(TricepsExtensionExerciseName::ReverseGripTricepsPressdown)
            }
            "rope_pressdown" => Ok(TricepsExtensionExerciseName::RopePressdown),
            "seated_barbell_overhead_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::SeatedBarbellOverheadTricepsExtension)
            }
            "seated_dumbbell_overhead_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::SeatedDumbbellOverheadTricepsExtension)
            }
            "seated_ez_bar_overhead_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::SeatedEzBarOverheadTricepsExtension)
            }
            "seated_single_arm_overhead_dumbbell_extension" => {
                Ok(TricepsExtensionExerciseName::SeatedSingleArmOverheadDumbbellExtension)
            }
            "single_arm_dumbbell_overhead_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::SingleArmDumbbellOverheadTricepsExtension)
            }
            "single_dumbbell_seated_overhead_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::SingleDumbbellSeatedOverheadTricepsExtension)
            }
            "single_leg_bench_dip_and_kick" => {
                Ok(TricepsExtensionExerciseName::SingleLegBenchDipAndKick)
            }
            "weighted_single_leg_bench_dip_and_kick" => {
                Ok(TricepsExtensionExerciseName::WeightedSingleLegBenchDipAndKick)
            }
            "single_leg_dip" => Ok(TricepsExtensionExerciseName::SingleLegDip),
            "weighted_single_leg_dip" => Ok(TricepsExtensionExerciseName::WeightedSingleLegDip),
            "static_lying_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::StaticLyingTricepsExtension)
            }
            "suspended_dip" => Ok(TricepsExtensionExerciseName::SuspendedDip),
            "weighted_suspended_dip" => Ok(TricepsExtensionExerciseName::WeightedSuspendedDip),
            "swiss_ball_dumbbell_lying_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::SwissBallDumbbellLyingTricepsExtension)
            }
            "swiss_ball_ez_bar_lying_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::SwissBallEzBarLyingTricepsExtension)
            }
            "swiss_ball_ez_bar_overhead_triceps_extension" => {
                Ok(TricepsExtensionExerciseName::SwissBallEzBarOverheadTricepsExtension)
            }
            "tabletop_dip" => Ok(TricepsExtensionExerciseName::TabletopDip),
            "weighted_tabletop_dip" => Ok(TricepsExtensionExerciseName::WeightedTabletopDip),
            "triceps_extension_on_floor" => {
                Ok(TricepsExtensionExerciseName::TricepsExtensionOnFloor)
            }
            "triceps_pressdown" => Ok(TricepsExtensionExerciseName::TricepsPressdown),
            "weighted_dip" => Ok(TricepsExtensionExerciseName::WeightedDip),
            _ => Err("No corresponding TricepsExtensionExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WarmUpExerciseName {
    QuadrupedRocking,
    NeckTilts,
    AnkleCircles,
    AnkleDorsiflexionWithBand,
    AnkleInternalRotation,
    ArmCircles,
    BentOverReachToSky,
    CatCamel,
    ElbowToFootLunge,
    ForwardAndBackwardLegSwings,
    Groiners,
    InvertedHamstringStretch,
    LateralDuckUnder,
    NeckRotations,
    OppositeArmAndLegBalance,
    ReachRollAndLift,
    /// Deprecated do not use
    Scorpion,
    ShoulderCircles,
    SideToSideLegSwings,
    SleeperStretch,
    SlideOut,
    SwissBallHipCrossover,
    SwissBallReachRollAndLift,
    SwissBallWindshieldWipers,
    ThoracicRotation,
    WalkingHighKicks,
    WalkingHighKnees,
    WalkingKneeHugs,
    WalkingLegCradles,
    Walkout,
    WalkoutFromPushUpPosition,
}
impl fmt::Display for WarmUpExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WarmUpExerciseName::QuadrupedRocking => f.write_str("quadruped_rocking"),
            WarmUpExerciseName::NeckTilts => f.write_str("neck_tilts"),
            WarmUpExerciseName::AnkleCircles => f.write_str("ankle_circles"),
            WarmUpExerciseName::AnkleDorsiflexionWithBand => {
                f.write_str("ankle_dorsiflexion_with_band")
            }
            WarmUpExerciseName::AnkleInternalRotation => f.write_str("ankle_internal_rotation"),
            WarmUpExerciseName::ArmCircles => f.write_str("arm_circles"),
            WarmUpExerciseName::BentOverReachToSky => f.write_str("bent_over_reach_to_sky"),
            WarmUpExerciseName::CatCamel => f.write_str("cat_camel"),
            WarmUpExerciseName::ElbowToFootLunge => f.write_str("elbow_to_foot_lunge"),
            WarmUpExerciseName::ForwardAndBackwardLegSwings => {
                f.write_str("forward_and_backward_leg_swings")
            }
            WarmUpExerciseName::Groiners => f.write_str("groiners"),
            WarmUpExerciseName::InvertedHamstringStretch => {
                f.write_str("inverted_hamstring_stretch")
            }
            WarmUpExerciseName::LateralDuckUnder => f.write_str("lateral_duck_under"),
            WarmUpExerciseName::NeckRotations => f.write_str("neck_rotations"),
            WarmUpExerciseName::OppositeArmAndLegBalance => {
                f.write_str("opposite_arm_and_leg_balance")
            }
            WarmUpExerciseName::ReachRollAndLift => f.write_str("reach_roll_and_lift"),
            WarmUpExerciseName::Scorpion => f.write_str("scorpion"),
            WarmUpExerciseName::ShoulderCircles => f.write_str("shoulder_circles"),
            WarmUpExerciseName::SideToSideLegSwings => f.write_str("side_to_side_leg_swings"),
            WarmUpExerciseName::SleeperStretch => f.write_str("sleeper_stretch"),
            WarmUpExerciseName::SlideOut => f.write_str("slide_out"),
            WarmUpExerciseName::SwissBallHipCrossover => f.write_str("swiss_ball_hip_crossover"),
            WarmUpExerciseName::SwissBallReachRollAndLift => {
                f.write_str("swiss_ball_reach_roll_and_lift")
            }
            WarmUpExerciseName::SwissBallWindshieldWipers => {
                f.write_str("swiss_ball_windshield_wipers")
            }
            WarmUpExerciseName::ThoracicRotation => f.write_str("thoracic_rotation"),
            WarmUpExerciseName::WalkingHighKicks => f.write_str("walking_high_kicks"),
            WarmUpExerciseName::WalkingHighKnees => f.write_str("walking_high_knees"),
            WarmUpExerciseName::WalkingKneeHugs => f.write_str("walking_knee_hugs"),
            WarmUpExerciseName::WalkingLegCradles => f.write_str("walking_leg_cradles"),
            WarmUpExerciseName::Walkout => f.write_str("walkout"),
            WarmUpExerciseName::WalkoutFromPushUpPosition => {
                f.write_str("walkout_from_push_up_position")
            }
        }
    }
}
impl WarmUpExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WarmUpExerciseName::QuadrupedRocking => fit::Value::UInt16(0),
            WarmUpExerciseName::NeckTilts => fit::Value::UInt16(1),
            WarmUpExerciseName::AnkleCircles => fit::Value::UInt16(2),
            WarmUpExerciseName::AnkleDorsiflexionWithBand => fit::Value::UInt16(3),
            WarmUpExerciseName::AnkleInternalRotation => fit::Value::UInt16(4),
            WarmUpExerciseName::ArmCircles => fit::Value::UInt16(5),
            WarmUpExerciseName::BentOverReachToSky => fit::Value::UInt16(6),
            WarmUpExerciseName::CatCamel => fit::Value::UInt16(7),
            WarmUpExerciseName::ElbowToFootLunge => fit::Value::UInt16(8),
            WarmUpExerciseName::ForwardAndBackwardLegSwings => fit::Value::UInt16(9),
            WarmUpExerciseName::Groiners => fit::Value::UInt16(10),
            WarmUpExerciseName::InvertedHamstringStretch => fit::Value::UInt16(11),
            WarmUpExerciseName::LateralDuckUnder => fit::Value::UInt16(12),
            WarmUpExerciseName::NeckRotations => fit::Value::UInt16(13),
            WarmUpExerciseName::OppositeArmAndLegBalance => fit::Value::UInt16(14),
            WarmUpExerciseName::ReachRollAndLift => fit::Value::UInt16(15),
            WarmUpExerciseName::Scorpion => fit::Value::UInt16(16),
            WarmUpExerciseName::ShoulderCircles => fit::Value::UInt16(17),
            WarmUpExerciseName::SideToSideLegSwings => fit::Value::UInt16(18),
            WarmUpExerciseName::SleeperStretch => fit::Value::UInt16(19),
            WarmUpExerciseName::SlideOut => fit::Value::UInt16(20),
            WarmUpExerciseName::SwissBallHipCrossover => fit::Value::UInt16(21),
            WarmUpExerciseName::SwissBallReachRollAndLift => fit::Value::UInt16(22),
            WarmUpExerciseName::SwissBallWindshieldWipers => fit::Value::UInt16(23),
            WarmUpExerciseName::ThoracicRotation => fit::Value::UInt16(24),
            WarmUpExerciseName::WalkingHighKicks => fit::Value::UInt16(25),
            WarmUpExerciseName::WalkingHighKnees => fit::Value::UInt16(26),
            WarmUpExerciseName::WalkingKneeHugs => fit::Value::UInt16(27),
            WarmUpExerciseName::WalkingLegCradles => fit::Value::UInt16(28),
            WarmUpExerciseName::Walkout => fit::Value::UInt16(29),
            WarmUpExerciseName::WalkoutFromPushUpPosition => fit::Value::UInt16(30),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for WarmUpExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(WarmUpExerciseName::QuadrupedRocking),
            fit::Value::UInt16(1) => Ok(WarmUpExerciseName::NeckTilts),
            fit::Value::UInt16(2) => Ok(WarmUpExerciseName::AnkleCircles),
            fit::Value::UInt16(3) => Ok(WarmUpExerciseName::AnkleDorsiflexionWithBand),
            fit::Value::UInt16(4) => Ok(WarmUpExerciseName::AnkleInternalRotation),
            fit::Value::UInt16(5) => Ok(WarmUpExerciseName::ArmCircles),
            fit::Value::UInt16(6) => Ok(WarmUpExerciseName::BentOverReachToSky),
            fit::Value::UInt16(7) => Ok(WarmUpExerciseName::CatCamel),
            fit::Value::UInt16(8) => Ok(WarmUpExerciseName::ElbowToFootLunge),
            fit::Value::UInt16(9) => Ok(WarmUpExerciseName::ForwardAndBackwardLegSwings),
            fit::Value::UInt16(10) => Ok(WarmUpExerciseName::Groiners),
            fit::Value::UInt16(11) => Ok(WarmUpExerciseName::InvertedHamstringStretch),
            fit::Value::UInt16(12) => Ok(WarmUpExerciseName::LateralDuckUnder),
            fit::Value::UInt16(13) => Ok(WarmUpExerciseName::NeckRotations),
            fit::Value::UInt16(14) => Ok(WarmUpExerciseName::OppositeArmAndLegBalance),
            fit::Value::UInt16(15) => Ok(WarmUpExerciseName::ReachRollAndLift),
            fit::Value::UInt16(16) => Ok(WarmUpExerciseName::Scorpion),
            fit::Value::UInt16(17) => Ok(WarmUpExerciseName::ShoulderCircles),
            fit::Value::UInt16(18) => Ok(WarmUpExerciseName::SideToSideLegSwings),
            fit::Value::UInt16(19) => Ok(WarmUpExerciseName::SleeperStretch),
            fit::Value::UInt16(20) => Ok(WarmUpExerciseName::SlideOut),
            fit::Value::UInt16(21) => Ok(WarmUpExerciseName::SwissBallHipCrossover),
            fit::Value::UInt16(22) => Ok(WarmUpExerciseName::SwissBallReachRollAndLift),
            fit::Value::UInt16(23) => Ok(WarmUpExerciseName::SwissBallWindshieldWipers),
            fit::Value::UInt16(24) => Ok(WarmUpExerciseName::ThoracicRotation),
            fit::Value::UInt16(25) => Ok(WarmUpExerciseName::WalkingHighKicks),
            fit::Value::UInt16(26) => Ok(WarmUpExerciseName::WalkingHighKnees),
            fit::Value::UInt16(27) => Ok(WarmUpExerciseName::WalkingKneeHugs),
            fit::Value::UInt16(28) => Ok(WarmUpExerciseName::WalkingLegCradles),
            fit::Value::UInt16(29) => Ok(WarmUpExerciseName::Walkout),
            fit::Value::UInt16(30) => Ok(WarmUpExerciseName::WalkoutFromPushUpPosition),
            _ => Err("No corresponding WarmUpExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for WarmUpExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "quadruped_rocking" => Ok(WarmUpExerciseName::QuadrupedRocking),
            "neck_tilts" => Ok(WarmUpExerciseName::NeckTilts),
            "ankle_circles" => Ok(WarmUpExerciseName::AnkleCircles),
            "ankle_dorsiflexion_with_band" => Ok(WarmUpExerciseName::AnkleDorsiflexionWithBand),
            "ankle_internal_rotation" => Ok(WarmUpExerciseName::AnkleInternalRotation),
            "arm_circles" => Ok(WarmUpExerciseName::ArmCircles),
            "bent_over_reach_to_sky" => Ok(WarmUpExerciseName::BentOverReachToSky),
            "cat_camel" => Ok(WarmUpExerciseName::CatCamel),
            "elbow_to_foot_lunge" => Ok(WarmUpExerciseName::ElbowToFootLunge),
            "forward_and_backward_leg_swings" => {
                Ok(WarmUpExerciseName::ForwardAndBackwardLegSwings)
            }
            "groiners" => Ok(WarmUpExerciseName::Groiners),
            "inverted_hamstring_stretch" => Ok(WarmUpExerciseName::InvertedHamstringStretch),
            "lateral_duck_under" => Ok(WarmUpExerciseName::LateralDuckUnder),
            "neck_rotations" => Ok(WarmUpExerciseName::NeckRotations),
            "opposite_arm_and_leg_balance" => Ok(WarmUpExerciseName::OppositeArmAndLegBalance),
            "reach_roll_and_lift" => Ok(WarmUpExerciseName::ReachRollAndLift),
            "scorpion" => Ok(WarmUpExerciseName::Scorpion),
            "shoulder_circles" => Ok(WarmUpExerciseName::ShoulderCircles),
            "side_to_side_leg_swings" => Ok(WarmUpExerciseName::SideToSideLegSwings),
            "sleeper_stretch" => Ok(WarmUpExerciseName::SleeperStretch),
            "slide_out" => Ok(WarmUpExerciseName::SlideOut),
            "swiss_ball_hip_crossover" => Ok(WarmUpExerciseName::SwissBallHipCrossover),
            "swiss_ball_reach_roll_and_lift" => Ok(WarmUpExerciseName::SwissBallReachRollAndLift),
            "swiss_ball_windshield_wipers" => Ok(WarmUpExerciseName::SwissBallWindshieldWipers),
            "thoracic_rotation" => Ok(WarmUpExerciseName::ThoracicRotation),
            "walking_high_kicks" => Ok(WarmUpExerciseName::WalkingHighKicks),
            "walking_high_knees" => Ok(WarmUpExerciseName::WalkingHighKnees),
            "walking_knee_hugs" => Ok(WarmUpExerciseName::WalkingKneeHugs),
            "walking_leg_cradles" => Ok(WarmUpExerciseName::WalkingLegCradles),
            "walkout" => Ok(WarmUpExerciseName::Walkout),
            "walkout_from_push_up_position" => Ok(WarmUpExerciseName::WalkoutFromPushUpPosition),
            _ => Err("No corresponding WarmUpExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum RunExerciseName {
    Run,
    Walk,
    Jog,
    Sprint,
}
impl fmt::Display for RunExerciseName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RunExerciseName::Run => f.write_str("run"),
            RunExerciseName::Walk => f.write_str("walk"),
            RunExerciseName::Jog => f.write_str("jog"),
            RunExerciseName::Sprint => f.write_str("sprint"),
        }
    }
}
impl RunExerciseName {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            RunExerciseName::Run => fit::Value::UInt16(0),
            RunExerciseName::Walk => fit::Value::UInt16(1),
            RunExerciseName::Jog => fit::Value::UInt16(2),
            RunExerciseName::Sprint => fit::Value::UInt16(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for RunExerciseName {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(0) => Ok(RunExerciseName::Run),
            fit::Value::UInt16(1) => Ok(RunExerciseName::Walk),
            fit::Value::UInt16(2) => Ok(RunExerciseName::Jog),
            fit::Value::UInt16(3) => Ok(RunExerciseName::Sprint),
            _ => Err("No corresponding RunExerciseName exists"),
        }
    }
}
impl TryFrom<&str> for RunExerciseName {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "run" => Ok(RunExerciseName::Run),
            "walk" => Ok(RunExerciseName::Walk),
            "jog" => Ok(RunExerciseName::Jog),
            "sprint" => Ok(RunExerciseName::Sprint),
            _ => Err("No corresponding RunExerciseName exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum WaterType {
    Fresh,
    Salt,
    En13319,
    Custom,
}
impl fmt::Display for WaterType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            WaterType::Fresh => f.write_str("fresh"),
            WaterType::Salt => f.write_str("salt"),
            WaterType::En13319 => f.write_str("en13319"),
            WaterType::Custom => f.write_str("custom"),
        }
    }
}
impl WaterType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            WaterType::Fresh => fit::Value::Enum(0),
            WaterType::Salt => fit::Value::Enum(1),
            WaterType::En13319 => fit::Value::Enum(2),
            WaterType::Custom => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for WaterType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(WaterType::Fresh),
            fit::Value::Enum(1) => Ok(WaterType::Salt),
            fit::Value::Enum(2) => Ok(WaterType::En13319),
            fit::Value::Enum(3) => Ok(WaterType::Custom),
            _ => Err("No corresponding WaterType exists"),
        }
    }
}
impl TryFrom<&str> for WaterType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "fresh" => Ok(WaterType::Fresh),
            "salt" => Ok(WaterType::Salt),
            "en13319" => Ok(WaterType::En13319),
            "custom" => Ok(WaterType::Custom),
            _ => Err("No corresponding WaterType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum TissueModelType {
    /// Buhlmann's decompression algorithm, version C
    Zhl16c,
}
impl fmt::Display for TissueModelType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TissueModelType::Zhl16c => f.write_str("zhl_16c"),
        }
    }
}
impl TissueModelType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            TissueModelType::Zhl16c => fit::Value::Enum(0),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for TissueModelType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(TissueModelType::Zhl16c),
            _ => Err("No corresponding TissueModelType exists"),
        }
    }
}
impl TryFrom<&str> for TissueModelType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "zhl_16c" => Ok(TissueModelType::Zhl16c),
            _ => Err("No corresponding TissueModelType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DiveGasStatus {
    Disabled,
    Enabled,
    BackupOnly,
}
impl fmt::Display for DiveGasStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DiveGasStatus::Disabled => f.write_str("disabled"),
            DiveGasStatus::Enabled => f.write_str("enabled"),
            DiveGasStatus::BackupOnly => f.write_str("backup_only"),
        }
    }
}
impl DiveGasStatus {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DiveGasStatus::Disabled => fit::Value::Enum(0),
            DiveGasStatus::Enabled => fit::Value::Enum(1),
            DiveGasStatus::BackupOnly => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DiveGasStatus {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DiveGasStatus::Disabled),
            fit::Value::Enum(1) => Ok(DiveGasStatus::Enabled),
            fit::Value::Enum(2) => Ok(DiveGasStatus::BackupOnly),
            _ => Err("No corresponding DiveGasStatus exists"),
        }
    }
}
impl TryFrom<&str> for DiveGasStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "disabled" => Ok(DiveGasStatus::Disabled),
            "enabled" => Ok(DiveGasStatus::Enabled),
            "backup_only" => Ok(DiveGasStatus::BackupOnly),
            _ => Err("No corresponding DiveGasStatus exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DiveAlert {
    NdlReached,
    GasSwitchPrompted,
    NearSurface,
    ApproachingNdl,
    Po2Warn,
    Po2CritHigh,
    Po2CritLow,
    TimeAlert,
    DepthAlert,
    DecoCeilingBroken,
    DecoComplete,
    SafetyStopBroken,
    SafetyStopComplete,
    CnsWarning,
    CnsCritical,
    OtuWarning,
    OtuCritical,
    AscentCritical,
    AlertDismissedByKey,
    AlertDismissedByTimeout,
    BatteryLow,
    BatteryCritical,
    SafetyStopStarted,
    ApproachingFirstDecoStop,
    SetpointSwitchAutoLow,
    SetpointSwitchAutoHigh,
    SetpointSwitchManualLow,
    SetpointSwitchManualHigh,
    AutoSetpointSwitchIgnored,
    SwitchedToOpenCircuit,
    SwitchedToClosedCircuit,
    TankBatteryLow,
    /// ccr diluent has low po2
    Po2CcrDilLow,
    /// a deco stop has been cleared
    DecoStopCleared,
    /// Target Depth Apnea Alarm triggered
    ApneaNeutralBuoyancy,
    /// Neutral Buoyance Apnea Alarm triggered
    ApneaTargetDepth,
    /// Surface Apnea Alarm triggered
    ApneaSurface,
    /// High Speed Apnea Alarm triggered
    ApneaHighSpeed,
    /// Low Speed Apnea Alarm triggered
    ApneaLowSpeed,
}
impl fmt::Display for DiveAlert {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DiveAlert::NdlReached => f.write_str("ndl_reached"),
            DiveAlert::GasSwitchPrompted => f.write_str("gas_switch_prompted"),
            DiveAlert::NearSurface => f.write_str("near_surface"),
            DiveAlert::ApproachingNdl => f.write_str("approaching_ndl"),
            DiveAlert::Po2Warn => f.write_str("po2_warn"),
            DiveAlert::Po2CritHigh => f.write_str("po2_crit_high"),
            DiveAlert::Po2CritLow => f.write_str("po2_crit_low"),
            DiveAlert::TimeAlert => f.write_str("time_alert"),
            DiveAlert::DepthAlert => f.write_str("depth_alert"),
            DiveAlert::DecoCeilingBroken => f.write_str("deco_ceiling_broken"),
            DiveAlert::DecoComplete => f.write_str("deco_complete"),
            DiveAlert::SafetyStopBroken => f.write_str("safety_stop_broken"),
            DiveAlert::SafetyStopComplete => f.write_str("safety_stop_complete"),
            DiveAlert::CnsWarning => f.write_str("cns_warning"),
            DiveAlert::CnsCritical => f.write_str("cns_critical"),
            DiveAlert::OtuWarning => f.write_str("otu_warning"),
            DiveAlert::OtuCritical => f.write_str("otu_critical"),
            DiveAlert::AscentCritical => f.write_str("ascent_critical"),
            DiveAlert::AlertDismissedByKey => f.write_str("alert_dismissed_by_key"),
            DiveAlert::AlertDismissedByTimeout => f.write_str("alert_dismissed_by_timeout"),
            DiveAlert::BatteryLow => f.write_str("battery_low"),
            DiveAlert::BatteryCritical => f.write_str("battery_critical"),
            DiveAlert::SafetyStopStarted => f.write_str("safety_stop_started"),
            DiveAlert::ApproachingFirstDecoStop => f.write_str("approaching_first_deco_stop"),
            DiveAlert::SetpointSwitchAutoLow => f.write_str("setpoint_switch_auto_low"),
            DiveAlert::SetpointSwitchAutoHigh => f.write_str("setpoint_switch_auto_high"),
            DiveAlert::SetpointSwitchManualLow => f.write_str("setpoint_switch_manual_low"),
            DiveAlert::SetpointSwitchManualHigh => f.write_str("setpoint_switch_manual_high"),
            DiveAlert::AutoSetpointSwitchIgnored => f.write_str("auto_setpoint_switch_ignored"),
            DiveAlert::SwitchedToOpenCircuit => f.write_str("switched_to_open_circuit"),
            DiveAlert::SwitchedToClosedCircuit => f.write_str("switched_to_closed_circuit"),
            DiveAlert::TankBatteryLow => f.write_str("tank_battery_low"),
            DiveAlert::Po2CcrDilLow => f.write_str("po2_ccr_dil_low"),
            DiveAlert::DecoStopCleared => f.write_str("deco_stop_cleared"),
            DiveAlert::ApneaNeutralBuoyancy => f.write_str("apnea_neutral_buoyancy"),
            DiveAlert::ApneaTargetDepth => f.write_str("apnea_target_depth"),
            DiveAlert::ApneaSurface => f.write_str("apnea_surface"),
            DiveAlert::ApneaHighSpeed => f.write_str("apnea_high_speed"),
            DiveAlert::ApneaLowSpeed => f.write_str("apnea_low_speed"),
        }
    }
}
impl DiveAlert {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DiveAlert::NdlReached => fit::Value::Enum(0),
            DiveAlert::GasSwitchPrompted => fit::Value::Enum(1),
            DiveAlert::NearSurface => fit::Value::Enum(2),
            DiveAlert::ApproachingNdl => fit::Value::Enum(3),
            DiveAlert::Po2Warn => fit::Value::Enum(4),
            DiveAlert::Po2CritHigh => fit::Value::Enum(5),
            DiveAlert::Po2CritLow => fit::Value::Enum(6),
            DiveAlert::TimeAlert => fit::Value::Enum(7),
            DiveAlert::DepthAlert => fit::Value::Enum(8),
            DiveAlert::DecoCeilingBroken => fit::Value::Enum(9),
            DiveAlert::DecoComplete => fit::Value::Enum(10),
            DiveAlert::SafetyStopBroken => fit::Value::Enum(11),
            DiveAlert::SafetyStopComplete => fit::Value::Enum(12),
            DiveAlert::CnsWarning => fit::Value::Enum(13),
            DiveAlert::CnsCritical => fit::Value::Enum(14),
            DiveAlert::OtuWarning => fit::Value::Enum(15),
            DiveAlert::OtuCritical => fit::Value::Enum(16),
            DiveAlert::AscentCritical => fit::Value::Enum(17),
            DiveAlert::AlertDismissedByKey => fit::Value::Enum(18),
            DiveAlert::AlertDismissedByTimeout => fit::Value::Enum(19),
            DiveAlert::BatteryLow => fit::Value::Enum(20),
            DiveAlert::BatteryCritical => fit::Value::Enum(21),
            DiveAlert::SafetyStopStarted => fit::Value::Enum(22),
            DiveAlert::ApproachingFirstDecoStop => fit::Value::Enum(23),
            DiveAlert::SetpointSwitchAutoLow => fit::Value::Enum(24),
            DiveAlert::SetpointSwitchAutoHigh => fit::Value::Enum(25),
            DiveAlert::SetpointSwitchManualLow => fit::Value::Enum(26),
            DiveAlert::SetpointSwitchManualHigh => fit::Value::Enum(27),
            DiveAlert::AutoSetpointSwitchIgnored => fit::Value::Enum(28),
            DiveAlert::SwitchedToOpenCircuit => fit::Value::Enum(29),
            DiveAlert::SwitchedToClosedCircuit => fit::Value::Enum(30),
            DiveAlert::TankBatteryLow => fit::Value::Enum(32),
            DiveAlert::Po2CcrDilLow => fit::Value::Enum(33),
            DiveAlert::DecoStopCleared => fit::Value::Enum(34),
            DiveAlert::ApneaNeutralBuoyancy => fit::Value::Enum(35),
            DiveAlert::ApneaTargetDepth => fit::Value::Enum(36),
            DiveAlert::ApneaSurface => fit::Value::Enum(37),
            DiveAlert::ApneaHighSpeed => fit::Value::Enum(38),
            DiveAlert::ApneaLowSpeed => fit::Value::Enum(39),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DiveAlert {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DiveAlert::NdlReached),
            fit::Value::Enum(1) => Ok(DiveAlert::GasSwitchPrompted),
            fit::Value::Enum(2) => Ok(DiveAlert::NearSurface),
            fit::Value::Enum(3) => Ok(DiveAlert::ApproachingNdl),
            fit::Value::Enum(4) => Ok(DiveAlert::Po2Warn),
            fit::Value::Enum(5) => Ok(DiveAlert::Po2CritHigh),
            fit::Value::Enum(6) => Ok(DiveAlert::Po2CritLow),
            fit::Value::Enum(7) => Ok(DiveAlert::TimeAlert),
            fit::Value::Enum(8) => Ok(DiveAlert::DepthAlert),
            fit::Value::Enum(9) => Ok(DiveAlert::DecoCeilingBroken),
            fit::Value::Enum(10) => Ok(DiveAlert::DecoComplete),
            fit::Value::Enum(11) => Ok(DiveAlert::SafetyStopBroken),
            fit::Value::Enum(12) => Ok(DiveAlert::SafetyStopComplete),
            fit::Value::Enum(13) => Ok(DiveAlert::CnsWarning),
            fit::Value::Enum(14) => Ok(DiveAlert::CnsCritical),
            fit::Value::Enum(15) => Ok(DiveAlert::OtuWarning),
            fit::Value::Enum(16) => Ok(DiveAlert::OtuCritical),
            fit::Value::Enum(17) => Ok(DiveAlert::AscentCritical),
            fit::Value::Enum(18) => Ok(DiveAlert::AlertDismissedByKey),
            fit::Value::Enum(19) => Ok(DiveAlert::AlertDismissedByTimeout),
            fit::Value::Enum(20) => Ok(DiveAlert::BatteryLow),
            fit::Value::Enum(21) => Ok(DiveAlert::BatteryCritical),
            fit::Value::Enum(22) => Ok(DiveAlert::SafetyStopStarted),
            fit::Value::Enum(23) => Ok(DiveAlert::ApproachingFirstDecoStop),
            fit::Value::Enum(24) => Ok(DiveAlert::SetpointSwitchAutoLow),
            fit::Value::Enum(25) => Ok(DiveAlert::SetpointSwitchAutoHigh),
            fit::Value::Enum(26) => Ok(DiveAlert::SetpointSwitchManualLow),
            fit::Value::Enum(27) => Ok(DiveAlert::SetpointSwitchManualHigh),
            fit::Value::Enum(28) => Ok(DiveAlert::AutoSetpointSwitchIgnored),
            fit::Value::Enum(29) => Ok(DiveAlert::SwitchedToOpenCircuit),
            fit::Value::Enum(30) => Ok(DiveAlert::SwitchedToClosedCircuit),
            fit::Value::Enum(32) => Ok(DiveAlert::TankBatteryLow),
            fit::Value::Enum(33) => Ok(DiveAlert::Po2CcrDilLow),
            fit::Value::Enum(34) => Ok(DiveAlert::DecoStopCleared),
            fit::Value::Enum(35) => Ok(DiveAlert::ApneaNeutralBuoyancy),
            fit::Value::Enum(36) => Ok(DiveAlert::ApneaTargetDepth),
            fit::Value::Enum(37) => Ok(DiveAlert::ApneaSurface),
            fit::Value::Enum(38) => Ok(DiveAlert::ApneaHighSpeed),
            fit::Value::Enum(39) => Ok(DiveAlert::ApneaLowSpeed),
            _ => Err("No corresponding DiveAlert exists"),
        }
    }
}
impl TryFrom<&str> for DiveAlert {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "ndl_reached" => Ok(DiveAlert::NdlReached),
            "gas_switch_prompted" => Ok(DiveAlert::GasSwitchPrompted),
            "near_surface" => Ok(DiveAlert::NearSurface),
            "approaching_ndl" => Ok(DiveAlert::ApproachingNdl),
            "po2_warn" => Ok(DiveAlert::Po2Warn),
            "po2_crit_high" => Ok(DiveAlert::Po2CritHigh),
            "po2_crit_low" => Ok(DiveAlert::Po2CritLow),
            "time_alert" => Ok(DiveAlert::TimeAlert),
            "depth_alert" => Ok(DiveAlert::DepthAlert),
            "deco_ceiling_broken" => Ok(DiveAlert::DecoCeilingBroken),
            "deco_complete" => Ok(DiveAlert::DecoComplete),
            "safety_stop_broken" => Ok(DiveAlert::SafetyStopBroken),
            "safety_stop_complete" => Ok(DiveAlert::SafetyStopComplete),
            "cns_warning" => Ok(DiveAlert::CnsWarning),
            "cns_critical" => Ok(DiveAlert::CnsCritical),
            "otu_warning" => Ok(DiveAlert::OtuWarning),
            "otu_critical" => Ok(DiveAlert::OtuCritical),
            "ascent_critical" => Ok(DiveAlert::AscentCritical),
            "alert_dismissed_by_key" => Ok(DiveAlert::AlertDismissedByKey),
            "alert_dismissed_by_timeout" => Ok(DiveAlert::AlertDismissedByTimeout),
            "battery_low" => Ok(DiveAlert::BatteryLow),
            "battery_critical" => Ok(DiveAlert::BatteryCritical),
            "safety_stop_started" => Ok(DiveAlert::SafetyStopStarted),
            "approaching_first_deco_stop" => Ok(DiveAlert::ApproachingFirstDecoStop),
            "setpoint_switch_auto_low" => Ok(DiveAlert::SetpointSwitchAutoLow),
            "setpoint_switch_auto_high" => Ok(DiveAlert::SetpointSwitchAutoHigh),
            "setpoint_switch_manual_low" => Ok(DiveAlert::SetpointSwitchManualLow),
            "setpoint_switch_manual_high" => Ok(DiveAlert::SetpointSwitchManualHigh),
            "auto_setpoint_switch_ignored" => Ok(DiveAlert::AutoSetpointSwitchIgnored),
            "switched_to_open_circuit" => Ok(DiveAlert::SwitchedToOpenCircuit),
            "switched_to_closed_circuit" => Ok(DiveAlert::SwitchedToClosedCircuit),
            "tank_battery_low" => Ok(DiveAlert::TankBatteryLow),
            "po2_ccr_dil_low" => Ok(DiveAlert::Po2CcrDilLow),
            "deco_stop_cleared" => Ok(DiveAlert::DecoStopCleared),
            "apnea_neutral_buoyancy" => Ok(DiveAlert::ApneaNeutralBuoyancy),
            "apnea_target_depth" => Ok(DiveAlert::ApneaTargetDepth),
            "apnea_surface" => Ok(DiveAlert::ApneaSurface),
            "apnea_high_speed" => Ok(DiveAlert::ApneaHighSpeed),
            "apnea_low_speed" => Ok(DiveAlert::ApneaLowSpeed),
            _ => Err("No corresponding DiveAlert exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DiveAlarmType {
    /// Alarm when a certain depth is crossed
    Depth,
    /// Alarm when a certain time has transpired
    Time,
    /// Alarm when a certain ascent or descent rate is exceeded
    Speed,
}
impl fmt::Display for DiveAlarmType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DiveAlarmType::Depth => f.write_str("depth"),
            DiveAlarmType::Time => f.write_str("time"),
            DiveAlarmType::Speed => f.write_str("speed"),
        }
    }
}
impl DiveAlarmType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DiveAlarmType::Depth => fit::Value::Enum(0),
            DiveAlarmType::Time => fit::Value::Enum(1),
            DiveAlarmType::Speed => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DiveAlarmType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DiveAlarmType::Depth),
            fit::Value::Enum(1) => Ok(DiveAlarmType::Time),
            fit::Value::Enum(2) => Ok(DiveAlarmType::Speed),
            _ => Err("No corresponding DiveAlarmType exists"),
        }
    }
}
impl TryFrom<&str> for DiveAlarmType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "depth" => Ok(DiveAlarmType::Depth),
            "time" => Ok(DiveAlarmType::Time),
            "speed" => Ok(DiveAlarmType::Speed),
            _ => Err("No corresponding DiveAlarmType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DiveBacklightMode {
    AtDepth,
    AlwaysOn,
}
impl fmt::Display for DiveBacklightMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DiveBacklightMode::AtDepth => f.write_str("at_depth"),
            DiveBacklightMode::AlwaysOn => f.write_str("always_on"),
        }
    }
}
impl DiveBacklightMode {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DiveBacklightMode::AtDepth => fit::Value::Enum(0),
            DiveBacklightMode::AlwaysOn => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DiveBacklightMode {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DiveBacklightMode::AtDepth),
            fit::Value::Enum(1) => Ok(DiveBacklightMode::AlwaysOn),
            _ => Err("No corresponding DiveBacklightMode exists"),
        }
    }
}
impl TryFrom<&str> for DiveBacklightMode {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "at_depth" => Ok(DiveBacklightMode::AtDepth),
            "always_on" => Ok(DiveBacklightMode::AlwaysOn),
            _ => Err("No corresponding DiveBacklightMode exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SleepLevel {
    Unmeasurable,
    Awake,
    Light,
    Deep,
    Rem,
}
impl fmt::Display for SleepLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SleepLevel::Unmeasurable => f.write_str("unmeasurable"),
            SleepLevel::Awake => f.write_str("awake"),
            SleepLevel::Light => f.write_str("light"),
            SleepLevel::Deep => f.write_str("deep"),
            SleepLevel::Rem => f.write_str("rem"),
        }
    }
}
impl SleepLevel {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SleepLevel::Unmeasurable => fit::Value::Enum(0),
            SleepLevel::Awake => fit::Value::Enum(1),
            SleepLevel::Light => fit::Value::Enum(2),
            SleepLevel::Deep => fit::Value::Enum(3),
            SleepLevel::Rem => fit::Value::Enum(4),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SleepLevel {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(SleepLevel::Unmeasurable),
            fit::Value::Enum(1) => Ok(SleepLevel::Awake),
            fit::Value::Enum(2) => Ok(SleepLevel::Light),
            fit::Value::Enum(3) => Ok(SleepLevel::Deep),
            fit::Value::Enum(4) => Ok(SleepLevel::Rem),
            _ => Err("No corresponding SleepLevel exists"),
        }
    }
}
impl TryFrom<&str> for SleepLevel {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "unmeasurable" => Ok(SleepLevel::Unmeasurable),
            "awake" => Ok(SleepLevel::Awake),
            "light" => Ok(SleepLevel::Light),
            "deep" => Ok(SleepLevel::Deep),
            "rem" => Ok(SleepLevel::Rem),
            _ => Err("No corresponding SleepLevel exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum Spo2MeasurementType {
    OffWrist,
    SpotCheck,
    ContinuousCheck,
    Periodic,
}
impl fmt::Display for Spo2MeasurementType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Spo2MeasurementType::OffWrist => f.write_str("off_wrist"),
            Spo2MeasurementType::SpotCheck => f.write_str("spot_check"),
            Spo2MeasurementType::ContinuousCheck => f.write_str("continuous_check"),
            Spo2MeasurementType::Periodic => f.write_str("periodic"),
        }
    }
}
impl Spo2MeasurementType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            Spo2MeasurementType::OffWrist => fit::Value::Enum(0),
            Spo2MeasurementType::SpotCheck => fit::Value::Enum(1),
            Spo2MeasurementType::ContinuousCheck => fit::Value::Enum(2),
            Spo2MeasurementType::Periodic => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for Spo2MeasurementType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(Spo2MeasurementType::OffWrist),
            fit::Value::Enum(1) => Ok(Spo2MeasurementType::SpotCheck),
            fit::Value::Enum(2) => Ok(Spo2MeasurementType::ContinuousCheck),
            fit::Value::Enum(3) => Ok(Spo2MeasurementType::Periodic),
            _ => Err("No corresponding Spo2MeasurementType exists"),
        }
    }
}
impl TryFrom<&str> for Spo2MeasurementType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "off_wrist" => Ok(Spo2MeasurementType::OffWrist),
            "spot_check" => Ok(Spo2MeasurementType::SpotCheck),
            "continuous_check" => Ok(Spo2MeasurementType::ContinuousCheck),
            "periodic" => Ok(Spo2MeasurementType::Periodic),
            _ => Err("No corresponding Spo2MeasurementType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum CcrSetpointSwitchMode {
    /// User switches setpoints manually
    Manual,
    /// Switch automatically based on depth
    Automatic,
}
impl fmt::Display for CcrSetpointSwitchMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            CcrSetpointSwitchMode::Manual => f.write_str("manual"),
            CcrSetpointSwitchMode::Automatic => f.write_str("automatic"),
        }
    }
}
impl CcrSetpointSwitchMode {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            CcrSetpointSwitchMode::Manual => fit::Value::Enum(0),
            CcrSetpointSwitchMode::Automatic => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for CcrSetpointSwitchMode {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(CcrSetpointSwitchMode::Manual),
            fit::Value::Enum(1) => Ok(CcrSetpointSwitchMode::Automatic),
            _ => Err("No corresponding CcrSetpointSwitchMode exists"),
        }
    }
}
impl TryFrom<&str> for CcrSetpointSwitchMode {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "manual" => Ok(CcrSetpointSwitchMode::Manual),
            "automatic" => Ok(CcrSetpointSwitchMode::Automatic),
            _ => Err("No corresponding CcrSetpointSwitchMode exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum DiveGasMode {
    OpenCircuit,
    ClosedCircuitDiluent,
}
impl fmt::Display for DiveGasMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            DiveGasMode::OpenCircuit => f.write_str("open_circuit"),
            DiveGasMode::ClosedCircuitDiluent => f.write_str("closed_circuit_diluent"),
        }
    }
}
impl DiveGasMode {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            DiveGasMode::OpenCircuit => fit::Value::Enum(0),
            DiveGasMode::ClosedCircuitDiluent => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for DiveGasMode {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(DiveGasMode::OpenCircuit),
            fit::Value::Enum(1) => Ok(DiveGasMode::ClosedCircuitDiluent),
            _ => Err("No corresponding DiveGasMode exists"),
        }
    }
}
impl TryFrom<&str> for DiveGasMode {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "open_circuit" => Ok(DiveGasMode::OpenCircuit),
            "closed_circuit_diluent" => Ok(DiveGasMode::ClosedCircuitDiluent),
            _ => Err("No corresponding DiveGasMode exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum FaveroProduct {
    AssiomaUno,
    AssiomaDuo,
}
impl fmt::Display for FaveroProduct {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            FaveroProduct::AssiomaUno => f.write_str("assioma_uno"),
            FaveroProduct::AssiomaDuo => f.write_str("assioma_duo"),
        }
    }
}
impl FaveroProduct {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            FaveroProduct::AssiomaUno => fit::Value::UInt16(10),
            FaveroProduct::AssiomaDuo => fit::Value::UInt16(12),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "uint16"
    }
}
impl TryFrom<&fit::Value> for FaveroProduct {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::UInt16(10) => Ok(FaveroProduct::AssiomaUno),
            fit::Value::UInt16(12) => Ok(FaveroProduct::AssiomaDuo),
            _ => Err("No corresponding FaveroProduct exists"),
        }
    }
}
impl TryFrom<&str> for FaveroProduct {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "assioma_uno" => Ok(FaveroProduct::AssiomaUno),
            "assioma_duo" => Ok(FaveroProduct::AssiomaDuo),
            _ => Err("No corresponding FaveroProduct exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum SplitType {
    AscentSplit,
    DescentSplit,
    IntervalActive,
    IntervalRest,
    IntervalWarmup,
    IntervalCooldown,
    IntervalRecovery,
    IntervalOther,
    ClimbActive,
    ClimbRest,
    SurfActive,
    RunActive,
    RunRest,
    WorkoutRound,
    /// run/walk detection running
    RwdRun,
    /// run/walk detection walking
    RwdWalk,
    WindsurfActive,
    /// run/walk detection standing
    RwdStand,
    /// Marks the time going from ascent_split to descent_split/used in backcountry ski
    Transition,
    SkiLiftSplit,
    SkiRunSplit,
}
impl fmt::Display for SplitType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SplitType::AscentSplit => f.write_str("ascent_split"),
            SplitType::DescentSplit => f.write_str("descent_split"),
            SplitType::IntervalActive => f.write_str("interval_active"),
            SplitType::IntervalRest => f.write_str("interval_rest"),
            SplitType::IntervalWarmup => f.write_str("interval_warmup"),
            SplitType::IntervalCooldown => f.write_str("interval_cooldown"),
            SplitType::IntervalRecovery => f.write_str("interval_recovery"),
            SplitType::IntervalOther => f.write_str("interval_other"),
            SplitType::ClimbActive => f.write_str("climb_active"),
            SplitType::ClimbRest => f.write_str("climb_rest"),
            SplitType::SurfActive => f.write_str("surf_active"),
            SplitType::RunActive => f.write_str("run_active"),
            SplitType::RunRest => f.write_str("run_rest"),
            SplitType::WorkoutRound => f.write_str("workout_round"),
            SplitType::RwdRun => f.write_str("rwd_run"),
            SplitType::RwdWalk => f.write_str("rwd_walk"),
            SplitType::WindsurfActive => f.write_str("windsurf_active"),
            SplitType::RwdStand => f.write_str("rwd_stand"),
            SplitType::Transition => f.write_str("transition"),
            SplitType::SkiLiftSplit => f.write_str("ski_lift_split"),
            SplitType::SkiRunSplit => f.write_str("ski_run_split"),
        }
    }
}
impl SplitType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            SplitType::AscentSplit => fit::Value::Enum(1),
            SplitType::DescentSplit => fit::Value::Enum(2),
            SplitType::IntervalActive => fit::Value::Enum(3),
            SplitType::IntervalRest => fit::Value::Enum(4),
            SplitType::IntervalWarmup => fit::Value::Enum(5),
            SplitType::IntervalCooldown => fit::Value::Enum(6),
            SplitType::IntervalRecovery => fit::Value::Enum(7),
            SplitType::IntervalOther => fit::Value::Enum(8),
            SplitType::ClimbActive => fit::Value::Enum(9),
            SplitType::ClimbRest => fit::Value::Enum(10),
            SplitType::SurfActive => fit::Value::Enum(11),
            SplitType::RunActive => fit::Value::Enum(12),
            SplitType::RunRest => fit::Value::Enum(13),
            SplitType::WorkoutRound => fit::Value::Enum(14),
            SplitType::RwdRun => fit::Value::Enum(17),
            SplitType::RwdWalk => fit::Value::Enum(18),
            SplitType::WindsurfActive => fit::Value::Enum(21),
            SplitType::RwdStand => fit::Value::Enum(22),
            SplitType::Transition => fit::Value::Enum(23),
            SplitType::SkiLiftSplit => fit::Value::Enum(28),
            SplitType::SkiRunSplit => fit::Value::Enum(29),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for SplitType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(1) => Ok(SplitType::AscentSplit),
            fit::Value::Enum(2) => Ok(SplitType::DescentSplit),
            fit::Value::Enum(3) => Ok(SplitType::IntervalActive),
            fit::Value::Enum(4) => Ok(SplitType::IntervalRest),
            fit::Value::Enum(5) => Ok(SplitType::IntervalWarmup),
            fit::Value::Enum(6) => Ok(SplitType::IntervalCooldown),
            fit::Value::Enum(7) => Ok(SplitType::IntervalRecovery),
            fit::Value::Enum(8) => Ok(SplitType::IntervalOther),
            fit::Value::Enum(9) => Ok(SplitType::ClimbActive),
            fit::Value::Enum(10) => Ok(SplitType::ClimbRest),
            fit::Value::Enum(11) => Ok(SplitType::SurfActive),
            fit::Value::Enum(12) => Ok(SplitType::RunActive),
            fit::Value::Enum(13) => Ok(SplitType::RunRest),
            fit::Value::Enum(14) => Ok(SplitType::WorkoutRound),
            fit::Value::Enum(17) => Ok(SplitType::RwdRun),
            fit::Value::Enum(18) => Ok(SplitType::RwdWalk),
            fit::Value::Enum(21) => Ok(SplitType::WindsurfActive),
            fit::Value::Enum(22) => Ok(SplitType::RwdStand),
            fit::Value::Enum(23) => Ok(SplitType::Transition),
            fit::Value::Enum(28) => Ok(SplitType::SkiLiftSplit),
            fit::Value::Enum(29) => Ok(SplitType::SkiRunSplit),
            _ => Err("No corresponding SplitType exists"),
        }
    }
}
impl TryFrom<&str> for SplitType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "ascent_split" => Ok(SplitType::AscentSplit),
            "descent_split" => Ok(SplitType::DescentSplit),
            "interval_active" => Ok(SplitType::IntervalActive),
            "interval_rest" => Ok(SplitType::IntervalRest),
            "interval_warmup" => Ok(SplitType::IntervalWarmup),
            "interval_cooldown" => Ok(SplitType::IntervalCooldown),
            "interval_recovery" => Ok(SplitType::IntervalRecovery),
            "interval_other" => Ok(SplitType::IntervalOther),
            "climb_active" => Ok(SplitType::ClimbActive),
            "climb_rest" => Ok(SplitType::ClimbRest),
            "surf_active" => Ok(SplitType::SurfActive),
            "run_active" => Ok(SplitType::RunActive),
            "run_rest" => Ok(SplitType::RunRest),
            "workout_round" => Ok(SplitType::WorkoutRound),
            "rwd_run" => Ok(SplitType::RwdRun),
            "rwd_walk" => Ok(SplitType::RwdWalk),
            "windsurf_active" => Ok(SplitType::WindsurfActive),
            "rwd_stand" => Ok(SplitType::RwdStand),
            "transition" => Ok(SplitType::Transition),
            "ski_lift_split" => Ok(SplitType::SkiLiftSplit),
            "ski_run_split" => Ok(SplitType::SkiRunSplit),
            _ => Err("No corresponding SplitType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum ClimbProEvent {
    Approach,
    Start,
    Complete,
}
impl fmt::Display for ClimbProEvent {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ClimbProEvent::Approach => f.write_str("approach"),
            ClimbProEvent::Start => f.write_str("start"),
            ClimbProEvent::Complete => f.write_str("complete"),
        }
    }
}
impl ClimbProEvent {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            ClimbProEvent::Approach => fit::Value::Enum(0),
            ClimbProEvent::Start => fit::Value::Enum(1),
            ClimbProEvent::Complete => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for ClimbProEvent {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(ClimbProEvent::Approach),
            fit::Value::Enum(1) => Ok(ClimbProEvent::Start),
            fit::Value::Enum(2) => Ok(ClimbProEvent::Complete),
            _ => Err("No corresponding ClimbProEvent exists"),
        }
    }
}
impl TryFrom<&str> for ClimbProEvent {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "approach" => Ok(ClimbProEvent::Approach),
            "start" => Ok(ClimbProEvent::Start),
            "complete" => Ok(ClimbProEvent::Complete),
            _ => Err("No corresponding ClimbProEvent exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum GasConsumptionRateType {
    /// Pressure-based Surface Air Consumption
    PressureSac,
    /// Volumetric Surface Air Consumption
    VolumeSac,
    /// Respiratory Minute Volume
    Rmv,
}
impl fmt::Display for GasConsumptionRateType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            GasConsumptionRateType::PressureSac => f.write_str("pressure_sac"),
            GasConsumptionRateType::VolumeSac => f.write_str("volume_sac"),
            GasConsumptionRateType::Rmv => f.write_str("rmv"),
        }
    }
}
impl GasConsumptionRateType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            GasConsumptionRateType::PressureSac => fit::Value::Enum(0),
            GasConsumptionRateType::VolumeSac => fit::Value::Enum(1),
            GasConsumptionRateType::Rmv => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for GasConsumptionRateType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(GasConsumptionRateType::PressureSac),
            fit::Value::Enum(1) => Ok(GasConsumptionRateType::VolumeSac),
            fit::Value::Enum(2) => Ok(GasConsumptionRateType::Rmv),
            _ => Err("No corresponding GasConsumptionRateType exists"),
        }
    }
}
impl TryFrom<&str> for GasConsumptionRateType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "pressure_sac" => Ok(GasConsumptionRateType::PressureSac),
            "volume_sac" => Ok(GasConsumptionRateType::VolumeSac),
            "rmv" => Ok(GasConsumptionRateType::Rmv),
            _ => Err("No corresponding GasConsumptionRateType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum TapSensitivity {
    High,
    Medium,
    Low,
}
impl fmt::Display for TapSensitivity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TapSensitivity::High => f.write_str("high"),
            TapSensitivity::Medium => f.write_str("medium"),
            TapSensitivity::Low => f.write_str("low"),
        }
    }
}
impl TapSensitivity {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            TapSensitivity::High => fit::Value::Enum(0),
            TapSensitivity::Medium => fit::Value::Enum(1),
            TapSensitivity::Low => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for TapSensitivity {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(TapSensitivity::High),
            fit::Value::Enum(1) => Ok(TapSensitivity::Medium),
            fit::Value::Enum(2) => Ok(TapSensitivity::Low),
            _ => Err("No corresponding TapSensitivity exists"),
        }
    }
}
impl TryFrom<&str> for TapSensitivity {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "high" => Ok(TapSensitivity::High),
            "medium" => Ok(TapSensitivity::Medium),
            "low" => Ok(TapSensitivity::Low),
            _ => Err("No corresponding TapSensitivity exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum RadarThreatLevelType {
    ThreatUnknown,
    ThreatNone,
    ThreatApproaching,
    ThreatApproachingFast,
}
impl fmt::Display for RadarThreatLevelType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            RadarThreatLevelType::ThreatUnknown => f.write_str("threat_unknown"),
            RadarThreatLevelType::ThreatNone => f.write_str("threat_none"),
            RadarThreatLevelType::ThreatApproaching => f.write_str("threat_approaching"),
            RadarThreatLevelType::ThreatApproachingFast => f.write_str("threat_approaching_fast"),
        }
    }
}
impl RadarThreatLevelType {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            RadarThreatLevelType::ThreatUnknown => fit::Value::Enum(0),
            RadarThreatLevelType::ThreatNone => fit::Value::Enum(1),
            RadarThreatLevelType::ThreatApproaching => fit::Value::Enum(2),
            RadarThreatLevelType::ThreatApproachingFast => fit::Value::Enum(3),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for RadarThreatLevelType {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(RadarThreatLevelType::ThreatUnknown),
            fit::Value::Enum(1) => Ok(RadarThreatLevelType::ThreatNone),
            fit::Value::Enum(2) => Ok(RadarThreatLevelType::ThreatApproaching),
            fit::Value::Enum(3) => Ok(RadarThreatLevelType::ThreatApproachingFast),
            _ => Err("No corresponding RadarThreatLevelType exists"),
        }
    }
}
impl TryFrom<&str> for RadarThreatLevelType {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "threat_unknown" => Ok(RadarThreatLevelType::ThreatUnknown),
            "threat_none" => Ok(RadarThreatLevelType::ThreatNone),
            "threat_approaching" => Ok(RadarThreatLevelType::ThreatApproaching),
            "threat_approaching_fast" => Ok(RadarThreatLevelType::ThreatApproachingFast),
            _ => Err("No corresponding RadarThreatLevelType exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum MaxMetSpeedSource {
    OnboardGps,
    ConnectedGps,
    Cadence,
}
impl fmt::Display for MaxMetSpeedSource {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            MaxMetSpeedSource::OnboardGps => f.write_str("onboard_gps"),
            MaxMetSpeedSource::ConnectedGps => f.write_str("connected_gps"),
            MaxMetSpeedSource::Cadence => f.write_str("cadence"),
        }
    }
}
impl MaxMetSpeedSource {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            MaxMetSpeedSource::OnboardGps => fit::Value::Enum(0),
            MaxMetSpeedSource::ConnectedGps => fit::Value::Enum(1),
            MaxMetSpeedSource::Cadence => fit::Value::Enum(2),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for MaxMetSpeedSource {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(MaxMetSpeedSource::OnboardGps),
            fit::Value::Enum(1) => Ok(MaxMetSpeedSource::ConnectedGps),
            fit::Value::Enum(2) => Ok(MaxMetSpeedSource::Cadence),
            _ => Err("No corresponding MaxMetSpeedSource exists"),
        }
    }
}
impl TryFrom<&str> for MaxMetSpeedSource {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "onboard_gps" => Ok(MaxMetSpeedSource::OnboardGps),
            "connected_gps" => Ok(MaxMetSpeedSource::ConnectedGps),
            "cadence" => Ok(MaxMetSpeedSource::Cadence),
            _ => Err("No corresponding MaxMetSpeedSource exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum MaxMetHeartRateSource {
    /// Wrist Heart Rate Monitor
    Whr,
    /// Chest Strap Heart Rate Monitor
    Hrm,
}
impl fmt::Display for MaxMetHeartRateSource {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            MaxMetHeartRateSource::Whr => f.write_str("whr"),
            MaxMetHeartRateSource::Hrm => f.write_str("hrm"),
        }
    }
}
impl MaxMetHeartRateSource {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            MaxMetHeartRateSource::Whr => fit::Value::Enum(0),
            MaxMetHeartRateSource::Hrm => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for MaxMetHeartRateSource {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(MaxMetHeartRateSource::Whr),
            fit::Value::Enum(1) => Ok(MaxMetHeartRateSource::Hrm),
            _ => Err("No corresponding MaxMetHeartRateSource exists"),
        }
    }
}
impl TryFrom<&str> for MaxMetHeartRateSource {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "whr" => Ok(MaxMetHeartRateSource::Whr),
            "hrm" => Ok(MaxMetHeartRateSource::Hrm),
            _ => Err("No corresponding MaxMetHeartRateSource exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum HrvStatus {
    None,
    Poor,
    Low,
    Unbalanced,
    Balanced,
}
impl fmt::Display for HrvStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            HrvStatus::None => f.write_str("none"),
            HrvStatus::Poor => f.write_str("poor"),
            HrvStatus::Low => f.write_str("low"),
            HrvStatus::Unbalanced => f.write_str("unbalanced"),
            HrvStatus::Balanced => f.write_str("balanced"),
        }
    }
}
impl HrvStatus {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            HrvStatus::None => fit::Value::Enum(0),
            HrvStatus::Poor => fit::Value::Enum(1),
            HrvStatus::Low => fit::Value::Enum(2),
            HrvStatus::Unbalanced => fit::Value::Enum(3),
            HrvStatus::Balanced => fit::Value::Enum(4),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for HrvStatus {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(HrvStatus::None),
            fit::Value::Enum(1) => Ok(HrvStatus::Poor),
            fit::Value::Enum(2) => Ok(HrvStatus::Low),
            fit::Value::Enum(3) => Ok(HrvStatus::Unbalanced),
            fit::Value::Enum(4) => Ok(HrvStatus::Balanced),
            _ => Err("No corresponding HrvStatus exists"),
        }
    }
}
impl TryFrom<&str> for HrvStatus {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "none" => Ok(HrvStatus::None),
            "poor" => Ok(HrvStatus::Poor),
            "low" => Ok(HrvStatus::Low),
            "unbalanced" => Ok(HrvStatus::Unbalanced),
            "balanced" => Ok(HrvStatus::Balanced),
            _ => Err("No corresponding HrvStatus exists"),
        }
    }
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd, Eq, Ord, Hash)]
pub(crate) enum NoFlyTimeMode {
    /// Standard Diver Alert Network no-fly guidance
    Standard,
    /// Flat 24 hour no-fly guidance
    Flat24Hours,
}
impl fmt::Display for NoFlyTimeMode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            NoFlyTimeMode::Standard => f.write_str("standard"),
            NoFlyTimeMode::Flat24Hours => f.write_str("flat_24_hours"),
        }
    }
}
impl NoFlyTimeMode {
    pub(crate) fn value(&self) -> fit::Value {
        match self {
            NoFlyTimeMode::Standard => fit::Value::Enum(0),
            NoFlyTimeMode::Flat24Hours => fit::Value::Enum(1),
        }
    }
    pub(crate) fn base_type() -> &'static str {
        "enum"
    }
}
impl TryFrom<&fit::Value> for NoFlyTimeMode {
    type Error = &'static str;
    fn try_from(value: &fit::Value) -> Result<Self, Self::Error> {
        match value {
            fit::Value::Enum(0) => Ok(NoFlyTimeMode::Standard),
            fit::Value::Enum(1) => Ok(NoFlyTimeMode::Flat24Hours),
            _ => Err("No corresponding NoFlyTimeMode exists"),
        }
    }
}
impl TryFrom<&str> for NoFlyTimeMode {
    type Error = &'static str;
    fn try_from(value: &str) -> Result<Self, Self::Error> {
        match value {
            "standard" => Ok(NoFlyTimeMode::Standard),
            "flat_24_hours" => Ok(NoFlyTimeMode::Flat24Hours),
            _ => Err("No corresponding NoFlyTimeMode exists"),
        }
    }
}
